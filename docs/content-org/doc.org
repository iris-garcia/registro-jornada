#+STARTUP: content
#+AUTHOR: Iris Garcia
#+HUGO_BASE_DIR: ../
#+HUGO_AUTO_SET_LASTMOD: t
#+OPTIONS: toc:nil

* Homepage
:PROPERTIES:
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :nocomment true :nodate true :nopaging true :noread true :chapter true
:EXPORT_HUGO_SECTION:
:EXPORT_HUGO_BUNDLE: /
:EXPORT_HUGO_WEIGHT: 1
:EXPORT_FILE_NAME: _index
:END:
<h1>Workday</h1>
[[/images/workday.png]]

{{% notice note %}}
This site hosts the documentation of Workday.
{{% /notice %}}

* Sections
** Description
:PROPERTIES:
:EXPORT_HUGO_SECTION: description
:EXPORT_HUGO_WEIGHT: 1
:END:
*** Description
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :chapter true :pre "<b>1. </b>"
:END:
<h3> Chapter 1 </h3>
<h1>Description</h1>

Get a general idea of what is Workday and the motivation to start its
development.

*** What is Workday?
:PROPERTIES:
:EXPORT_FILE_NAME: description/what
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :asciinema true
:END:
Workday is a RESTful API project that allows the management of
workers' day registration, for this purpose it makes use of a
relational database where such data persists.

It allows the creation of different types of users (roles), initially
there are two main roles:
1. ~employee~: The employee has permissions to:
   - Register checks in and checks out.
   - Update their own password.
   - Update their own schedule.
2. ~HR~: The Human Resources role is the one with almost full control,
   it has the permissions of a regular employee plus:
   - Retrieve every employee's schedule.
   - Register employees.
   - Remove employees.
   - Reset employees' password.

The final goal is to build clients consuming this API to improve the
user experience, for example:

An Android/iOS app which automatically registers the checks in when the
GPS location is near the Office's location and the checks out when it
gets away from the Office's location.

*** Why?
:PROPERTIES:
:EXPORT_FILE_NAME: description/why
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :asciinema true
:END:
Since last May 12, 2019 every Spanish company is required to provide
their employees a process to record their working hours.

This process can be as simple as signing in a paper the checks in and
checks out for every single workday; but any other process can be used
and this is the reason for which I decided to develop this project.

** Development
:PROPERTIES:
:EXPORT_HUGO_SECTION: dev
:EXPORT_HUGO_WEIGHT: 2
:END:
*** Development
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :chapter true :pre "<b>2. </b>"
:END:
<h3> Chapter 2 </h3>
<h1>Development</h1>

This chapter shows which tools are used in the development of the
project and how to set up a working dev environment.

{{% notice info %}}
Work in progress...
{{% /notice %}}

*** Toolchain
:PROPERTIES:
:EXPORT_FILE_NAME: dev/tools
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :asciinema true
:END:
**** [[https://golang.org/][Go]]
The open source programming language Go will be used to develop the
whole project, mainly because I want to try a new language and this
one is becoming quite popular nowadays.

**** [[https://github.com/gin-gonic/gin][Gin]]
Gin is a HTTP web framework written in Go (Golang). It features a
Martini-like API with much better performance -- up to 40 times
faster.

It is very well documented and provides many handy features like
authentication, data validation and a configurable logger out of the
box.

**** [[https://magefile.org/][Mage]]
Mage is a make/rake-like build tool using Go. You write plain-old go
functions, and Mage automatically uses them as Makefile-like runnable
targets.

Mage has no dependencies outside the Go standard library; in this
project it is going to be used to automate every possible process
like:
1. ~mage test~: run tests and its code coverage.
2. ~mage build~: build a binary of the project.
3. ~mage install~: installs the built binary under /usr/local/bin.
4. ~mage start~: starts the API HTTP server.
5. ~mage startdev~: bootstraps a dev environment.


**** [[https://mariadb.com/][MariaDB]]
The relational database engine MariaDB has been choosen to persist the
data, it is OpenSource and fulfills the requirements.

**** Test-driven development (TDD & BDD)
Go has support for testing built in to its toolchain which will be used to cover
unit and integration tests with the help of [[https://github.com/stretchr/testify][testify]] for the
assertions.

[[https://github.com/onsi/ginkgo][Ginkgo]] will be used as a BDD testing framework and [[https://github.com/onsi/gomega][Gomega]] as a
matcher library.

**** [[https://github.com/OAI/OpenAPI-Specification/][OpenAPI]]
This project will follow the OpenAPI Specification to document its API
endpoints, probably using swagger to parse the specifications and
generate a static site.

** Continuous Integration
:PROPERTIES:
:EXPORT_HUGO_SECTION: ci
:EXPORT_HUGO_WEIGHT: 3
:END:
*** Continuous Integration
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :chapter true :pre "<b>3. </b>"
:END:
<h3> Chapter 3 </h3>
<h1>Continuous Integration</h1>

This chapter describes the systems used to continuously integrate
changes into the project.
*** Travis CI
:PROPERTIES:
:EXPORT_FILE_NAME: ci/travis
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :asciinema true
:END:
**** Description
Travis is a hosted continuous integration service used to build and
test software projects hosted at GitHub.

It provides a free plan for open source projects which is very
convinient for our use case.

The whole configuration is set up in a single file ~.travis.yml~ which
must be placed in the root directory of the project.
**** Configuration
To avoid replicating exactly the same workflows in GitHub Actions and
Travis, there are some little changes like testing two different Go
versions: ~v1.13.x~ and ~master~ (which is the latest available at any
given time).

It also releases artifacts when a new *tag* is pushed to the
repository.

#+INCLUDE: "../../.travis.yml" src yaml

The following lines tell travis to run the tests against two different
versions of Go (1.13.x and master)

#+begin_src yaml
  go:
  - 1.13.x
  - master
#+end_src

Travis is smart enough to setup all the required dependencies before
it start running the tests, basically it runs:
1. *go get* which fetches all the dependencies defined in the file ~go.mod~
2. *go test* which runs the tests.

The ~tests coverage~ stage is exactly the same as the above but adds
the code coverage percentage which is useful to know if we are missing
some code from beign tested.

#+begin_src yaml
  - stage: tests coverage
    script: go test -cover -v
    go: 1.13.x

#+end_src

And the last stage ~Release artifact to GitHub~ runs only when there
is a tag push, it creates a compressed artifact with the source code
and place it in GitHub's releases.

#+begin_src yaml
  - stage: Release artifact to GitHub
    deploy:
      provider: releases
      api_key: $WORKDAY_RELEASE
      file: "workday"
      skip_cleanup: true
      on:
        tags: true

#+end_src
*** GitHub Actions
:PROPERTIES:
:EXPORT_FILE_NAME: ci/github
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :asciinema true
:END:
**** Description
GitHub Actions is the new continuous integration and deployment system
built and maintained by the community.

**** Configuration
Currently there are two workflows configured:

***** Test and coverage
This workflow takes care of the Unit tests and shows the total
coverage of the project.

#+INCLUDE: "../../.github/workflows/unittests.yaml" src yaml


***** Hugo documentation site
This workflow is not really a typical continuous integration one, but
I think it makes sense to mention it here as it is taking care of
automatically update the documentation site.

#+INCLUDE: "../../.github/workflows/hugo.yml" src yaml

To get this one working there are some requisites explained in a howto
[[/howto/gh-pages][document]].


** Deployment
:PROPERTIES:
:EXPORT_HUGO_SECTION: deployment
:EXPORT_HUGO_WEIGHT: 4
:END:
*** Deployment
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :chapter true :pre "<b>4. </b>"
:END:
<h3> Chapter 4 </h3>
<h1>Deployment</h1>

This chapter describes where and how is this project deployed.

{{% notice info %}}
Work in progress...
{{% /notice %}}


** How-to
:PROPERTIES:
:EXPORT_HUGO_SECTION: howto
:EXPORT_HUGO_WEIGHT: 5
:END:
*** How-to
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :chapter true :pre "<b>5. </b>"
:END:
<h3> Chapter 5 </h3>
<h1>How to's</h1>

This chapter hosts all the step by step guides which I find useful to
share.

*** GitHub Pages                                              :ci:hugo:doc:
:PROPERTIES:
:EXPORT_HUGO_SECTION: howto/gh-pages
:EXPORT_HUGO_WEIGHT: 1
:END:
**** GitHub Pages
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :asciinema true
:END:
This document ilustrates how to setup [[https://pages.github.com/][GitHub Pages]] using [[https://gohugo.io/][Hugo]] as
website generator and [[https://github.com/features/actions][GitHub's Actions]] to automate the deployment
process.

There are different alternatives to setup GitHub pages, the one used
in here is a project pages using ~gh-pages~ branch, the advantages
are:
- It keeps your source and generated website in different branches and
  therefore maintains version control history for both.
- It uses the default Hugo's *public* folder.

So basically this project's repository has the following branches:
- *master*: Hosts the source code of the project under the ~docs/~ folder.
- *gh-pages*: Hosts the static assets generated by hugo.

***** Step 1: Structure
#+begin_src bash
# Docs folder
mkdir docs && cd docs
hugo new site .
git add .
git commit -m "Adds initial hugo site"
git push origin master

# gh-pages branch
git checkout --orphan gh-pages
git reset --hard
git commit --allow-empty -m "Initializing gh-pages branch"
git push origin gh-pages
#+end_src

***** Step 2: Generate a SSH key.
#+begin_src bash
ssh-keygen -t rsa -f hugo -q -N ""
#+end_src

{{% notice note %}}
This will generate the files: ~hugo~ and ~hugo.pub~ which will be
needed for the next steps.
{{% /notice %}}

***** Step 3: Add a deployment key
Navigate to your GitHub's repository settings and under *Deploy keys*
add a new one using the content of the ~hugo.pub~ SSH key generated in
the previous step.

[[/images/deploy_key.png]]

{{% notice warning %}}
Make sure the *Allow write access* is checked, otherwise the GitHub's
Action won't be able to push changes.
{{% /notice %}}

***** Step 4: Create a secret
Navigate to you GitHub's repository settings and under *Secrets* add a
new one using the content of the ~hugo~ SSH private key generated in
the [[Step%202%3A%20Generate%20a%20SSH%20key.][step 2]].

[[/images/gh_secret.png]]

***** Step 5: Add the GitHub's Action.
Create the needed directory in the *hugo* branch:
#+begin_src bash
mkdir -p .github/workflows
#+end_src

Add a new file in the path ~.github/workflows/gh_pages.yml~ with the
following content:
#+INCLUDE: "../../.github/workflows/hugo.yml" src yaml


{{% notice note %}}
Replace the origin's remote with your repository.
{{% /notice %}}

Finally commit and push the changes (which should trigger already the
Action).

#+begin_src bash
git add .github/workflows/gh_pages.yml
git commit -m "Adds GitHub's Action to build hugo site."
git push origin master
#+end_src

***** Step 5: Verify the Action
If everything went well you should already have your site updated and a
new commit to the ~gh-pages~ branch.

You can also see the output of the Action navigating to the *Actions*
section of your repository.

[[/images/gh_action.png]]


* Footnotes
[fn:1] Footnote example

* COMMENT Local Variables                                           :ARCHIVE:
# Local Variables:
# eval: (auto-fill-mode 1)
# End
