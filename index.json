[
{
	"uri": "https://iris-garcia.github.io/workday/docker/dockerfile/",
	"title": "Dockerfile",
	"tags": ["docker"],
	"description": "",
	"content": "To create a Docker image, we have added two new files to our project:\n Dockerfile: Contains the needed commands to create the image. .dockerignore: It works like .gitignore for git, it allows to define which file/s should not be included in the Docker image when the command ADD or COPY is/are invoked.   # Use a golang image as base builder imageFROMgolang:1.13 as builder# Create the project\u0026#39;s directory under the default GOPATHRUN mkdir -p /go/src/github.com/iris-garcia/workday# Use this directory as working directoryWORKDIR/go/src/github.com/iris-garcia/workday# Copy the needed files to build the binaryCOPY . /go/src/github.com/iris-garcia/workday/# Install our build tool MageRUN go get github.com/magefile/mage# Run the build stageRUN mage build# Use a small image to run the binaryFROMbusybox:latest# Use /root as working directoryWORKDIR/root# Copy the built binary and its default config fileCOPY --from=builder /go/src/github.com/iris-garcia/workday/api_server .COPY --from=builder /go/src/github.com/iris-garcia/workday/db_config.toml .# Run the API serverCMD[\u0026#34;./api_server\u0026#34;] Code Snippet 1: Dockerfile  The Dockerfile has comments for every command but it is worth to mention that we are using a multi stage build which allows to use different FROM instructions, each of them begins a new stage of the build.\nThen we can copy artifacts from one stage to another, leaving behind everything we don\u0026rsquo;t want in the final image.\ndocs deployment .git .github internal api_server .idea coverage.html workday.coverprofile .travis.yml LICENSE Dockerfile README.org Code Snippet 2: .dockerignore  "
},
{
	"uri": "https://iris-garcia.github.io/workday/howto/gh-pages/",
	"title": "GitHub Pages",
	"tags": ["ci", "hugo", "doc"],
	"description": "",
	"content": " This document ilustrates how to setup GitHub Pages using Hugo as website generator and GitHub\u0026rsquo;s Actions to automate the deployment process.\nThere are different alternatives to setup GitHub pages, the one used in here is a project pages using gh-pages branch, the advantages are:\n It keeps your source and generated website in different branches and therefore maintains version control history for both. It uses the default Hugo\u0026rsquo;s public folder.  So basically this project\u0026rsquo;s repository has the following branches:\n master: Hosts the source code of the project under the docs/ folder. gh-pages: Hosts the static assets generated by hugo.  Step 1: Structure # Docs folder mkdir docs \u0026amp;\u0026amp; cd docs hugo new site . git add . git commit -m \u0026#34;Adds initial hugo site\u0026#34; git push origin master # gh-pages branch git checkout --orphan gh-pages git reset --hard git commit --allow-empty -m \u0026#34;Initializing gh-pages branch\u0026#34; git push origin gh-pages Step 2: Generate a SSH key. ssh-keygen -t rsa -f hugo -q -N \u0026#34;\u0026#34; This will generate the files: hugo and hugo.pub which will be needed for the next steps.\n Step 3: Add a deployment key Navigate to your GitHub\u0026rsquo;s repository settings and under Deploy keys add a new one using the content of the hugo.pub SSH key generated in the previous step.\n  Make sure the Allow write access is checked, otherwise the GitHub\u0026rsquo;s Action won\u0026rsquo;t be able to push changes.\n Step 4: Create a secret Navigate to you GitHub\u0026rsquo;s repository settings and under Secrets add a new one using the content of the hugo SSH private key generated in the step 2.\n  Step 5: Add the GitHub\u0026rsquo;s Action. Create the needed directory in the hugo branch:\nmkdir -p .github/workflows Add a new file in the path .github/workflows/gh_pages.yml with the following content:\non:push:paths:-\u0026#39;docs/**\u0026#39;-\u0026#39;.github/workflows/hugo.yml\u0026#39;name:Hugojobs:build:runs-on:ubuntu-lateststeps:-uses:actions/checkout@v1-name:Installshugorun:| cd /tmpwgethttps://github.com/gohugoio/hugo/releases/download/v0.57.0/hugo_0.57.0_Linux-64bit.debsudodpkg-ihugo_0.57.0_Linux-64bit.debhugoversion-name:Buildhugositerun:| cd docsrm-rfpublicgitworktreeadd-bgh-pagespublicorigin/gh-pageshugo-name:Configuregitanddeploymentkeyenv:GITHUB_TOKEN:${{secrets.GITHUB_TOKEN}}GITHUB_DEPLOY_KEY:${{secrets.WORKDAY_GH}}run:| mkdir /home/runner/.sshssh-keyscan-trsagithub.com\u0026gt;/home/runner/.ssh/known_hostsecho\u0026#34;${GITHUB_DEPLOY_KEY}\u0026#34;\u0026gt;/home/runner/.ssh/id_rsa\u0026amp;\u0026amp;\\chmod400/home/runner/.ssh/id_rsagitremoteset-urlorigingit@github.com:iris-garcia/workday.gitgitconfig--globaluser.name\u0026#34;GitHub Action\u0026#34;gitconfig--globaluser.email\u0026#34;action@github.com\u0026#34;-name:Commitandpushchangestogh-pagesrun:| cd docs/publicgitadd.gitcommit-m\u0026#34;Publishing to gh-pages branch\u0026#34;gitpushorigingh-pages Replace the origin\u0026rsquo;s remote with your repository.\n Finally commit and push the changes (which should trigger already the Action).\ngit add .github/workflows/gh_pages.yml git commit -m \u0026#34;Adds GitHub\u0026#39;s Action to build hugo site.\u0026#34; git push origin master Step 5: Verify the Action If everything went well you should already have your site updated and a new commit to the gh-pages branch.\nYou can also see the output of the Action navigating to the Actions section of your repository.\n  "
},
{
	"uri": "https://iris-garcia.github.io/workday/deployment/openshit/",
	"title": "OpenShift",
	"tags": ["cd"],
	"description": "",
	"content": " Requirements Create account in RedHat  Create a new account using the Sign up form. Sign in into OpenShift.  Install the OpenShift client wget https://mirror.openshift.com/pub/openshift-v4/clients/oc/4.1/linux/oc.tar.gz tar xvzf oc.tar.gz sudo cp oc /usr/local/bin/ The binary can be copied to any place as long as it is included in the $PATH.\n Get the Login command   Create a Dockerfile OpenShift can create a docker image given a source git repository, but it needs a Dockerfile definition which is shown here.\nQuickStart This is a summary of the needed commands to get the project working:\n# Login oc login --token={REDACTED} --server=https://api.us-east-2.starter.openshift-online.com:6443 # New project oc new-project workday # Not needed: mariadb service oc new-app \\  -e MYSQL_USER=workday \\  -e MYSQL_PASSWORD=workday \\  -e MYSQL_DATABASE=workday \\  mariadb # Our API service oc new-app deployment/openshift.yml # Manually trigger a new build oc start-build api For further explanation keep reading the step by step guide.\n Step 1: Login using the CLI Use the login command from the previous step:\noc login --token={REDACTED} --server=https://api.us-east-2.starter.openshift-online.com:6443 Step 2: Create a new project oc new-project workday Step 3: Create a new MariaDB app oc new-app \\  -e MYSQL_USER=workday \\  -e MYSQL_PASSWORD=workday \\  -e MYSQL_DATABASE=workday \\  mariadb This step is not needed yet, but it will be in a near future to get the service fully working.\n Step 4: Create a template for our service kind:TemplateapiVersion:v1metadata:name:apiannotations:description:\u0026#34;Workday Api app\u0026#34;tags:\u0026#34;workday,api,golang\u0026#34;iconClass:\u0026#34;icon-go-gopher\u0026#34;labels:template:\u0026#34;api\u0026#34;app:\u0026#34;api\u0026#34;objects:-kind:ServiceapiVersion:v1metadata:name:apiannotations:description:\u0026#34;Exposes and load balances the application pods\u0026#34;spec:ports:-name:webport:8080targetPort:8080selector:name:api-kind:RouteapiVersion:v1metadata:name:apispec:to:kind:Servicename:api-kind:ImageStreamapiVersion:v1metadata:name:apiannotations:description:\u0026#34;Keeps track of changes in the application image\u0026#34;-kind:SecretapiVersion:v1metadata:name:gh-secretcreationTimestamp:data:WebHookSecretKey:\u0026#34;${GITHUB_SECRET}\u0026#34;-kind:BuildConfigapiVersion:v1metadata:name:apiannotations:description:\u0026#34;Defines how to build the application\u0026#34;spec:source:type:Gitgit:uri:\u0026#34;${SOURCE_REPOSITORY_URL}\u0026#34;ref:\u0026#34;${SOURCE_REPOSITORY_REF}\u0026#34;contextDir:\u0026#34;${CONTEXT_DIR}\u0026#34;strategy:type:DockerdockerStrategy:{}output:to:kind:ImageStreamTagname:api:latestpostCommit:script:\u0026#34;GIN_MODE=release go test -v ./...\u0026#34;resources:limits:cpu:100mmemory:1Gitriggers:-type:\u0026#34;GitHub\u0026#34;github:secretReference:name:\u0026#34;gh-secret\u0026#34;-kind:DeploymentConfigapiVersion:v1metadata:name:apiannotations:description:\u0026#34;Defines how to deploy the application server\u0026#34;spec:strategy:type:Recreatetriggers:-type:ImageChangeimageChangeParams:automatic:truecontainerNames:-apifrom:kind:ImageStreamTagname:\u0026#34;api:latest\u0026#34;-type:ConfigChangereplicas:1selector:name:apitemplate:metadata:name:apilabels:name:apispec:containers:-name:apiimage:apiports:-containerPort:8080env:-name:GIN_MODEvalue:\u0026#34;release\u0026#34;-name:WORKDAY_DB_NAMEvalue:\u0026#34;workday\u0026#34;-name:WORKDAY_DB_USERvalue:\u0026#34;workday\u0026#34;-name:WORKDAY_DB_PASSWORDvalue:\u0026#34;workday\u0026#34;parameters:-name:SOURCE_REPOSITORY_URLdescription:\u0026#34;The URL of the repository with your application source code\u0026#34;value:\u0026#34;https://github.com/iris-garcia/workday.git\u0026#34;-name:SOURCE_REPOSITORY_REFdescription:\u0026#34;Set this to a branch name, tag or other ref of your repository if you are not using the default branch\u0026#34;-name:CONTEXT_DIRdescription:\u0026#34;Set this to the relative path to your project if it is not in the root of your repository\u0026#34;-name:GITHUB_SECRETdescription:\u0026#34;Github webhook secret\u0026#34; Code Snippet 1: openshift.yml  The template defines 5 main resources to be created in OpenShift:\n Service: exposes connectivity to the API container in a port. Route: Creates and endpoint which points to the Service resource. ImageStream: Keeps track of of changes in the application image. BuildConfig: This resource as it is configured basically fetches the source code from the git repository then builds and tags a docker image and finally runs the tests to make sure it is a working image. DeploymentConfig: This resource is the one spawning a new container/s with the built image, it has many parameters such as the ability to recreate the container automatically when the specified image has been changed or the number of replicas, it also allows to setup environment variables to the container/s.  Step 5: Create a new app using the above template oc new-app deployment/openshift.yml -p GITHUB_SECRET=supersecret Step 6: Trigger the build The build can be triggered manually with the following command:\noc start-build api But we don\u0026rsquo;t want to be triggering a new build everytime we integrate a new change in our service, therefore we have also set up a continuous delivery processes which deploys a new version of the app whenever there are new changes in the repository.\n Using Travis CI (how-to documentation). Using GitHub (how-to documentation).  Demo   "
},
{
	"uri": "https://iris-garcia.github.io/workday/dev/tools/",
	"title": "Toolchain",
	"tags": [],
	"description": "",
	"content": " Go The open source programming language Go will be used to develop the whole project, mainly because I want to try a new language and this one is becoming quite popular nowadays.\nGin Gin is a HTTP web framework written in Go (Golang). It features a Martini-like API with much better performance \u0026ndash; up to 40 times faster.\nIt is very well documented and provides many handy features like authentication, data validation and a configurable logger out of the box.\nMage Mage is a make/rake-like build tool using Go. You write plain-old go functions, and Mage automatically uses them as Makefile-like runnable targets.\nMage has no dependencies outside the Go standard library; in this project it is going to be used to automate every possible process like:\n mage test: runs the test suite. mage testverbose: runs the test suite with verbosity. mage testandcoverage: runs the test suite generating its code coverage. mage build: builds a binary of the project. mage install: installs the built binary under /usr/local/bin. mage start: Starts the HTTP Server using pm2 as process manager. mage startdev: Starts a dev environment, [WIP]. mage stop: Stops the HTTP Server using pm2 as process manager.  MariaDB The relational database engine MariaDB has been choosen to persist the data, it is OpenSource and fulfills the requirements.\nTest-driven development (TDD \u0026amp; BDD) Go has support for testing built in to its toolchain which will be used to cover unit and integration tests with the help of testify for the assertions.\nGinkgo will be used as a BDD testing framework and Gomega as a matcher library.\nOpenAPI This project will follow the OpenAPI Specification to document its API endpoints, probably using swagger to parse the specifications and generate a static site.\nPM2 As a process manager the tool PM2 is currently used, because it allows the usage with any language as long as it has a way to build/run it.\nIdeally this tool will be replace in favor of a Go tool, some of them has been already tested but none of them provide the same features as PM2.\n"
},
{
	"uri": "https://iris-garcia.github.io/workday/ci/travis/",
	"title": "Travis CI",
	"tags": ["ci"],
	"description": "",
	"content": " Description Travis is a hosted continuous integration service used to build and test software projects hosted at GitHub.\nIt provides a free plan for open source projects which is very convinient for our use case.\nThe whole configuration is set up in a single file .travis.yml which must be placed in the root directory of the project.\nConfiguration To avoid replicating exactly the same workflows in GitHub Actions and Travis, there are some little changes like testing two different Go versions: v1.13.x and master (which is the latest available at any given time).\nIt also releases artifacts when a new tag is pushed to the repository.\nlanguage:godist:bionicsudo:requiredstages:-test-deployjobs:include:-stage:testname:Testgo1.13.xgo:1.13.xbefore_install:-sudoapt-get-yinstallnodejs-devnode-gyplibssl1.0-devnpm-npminstallpm2@latest-ginstall:-gogetgithub.com/magefile/mage-magebuildscript:-magestart-magetest-magestop-stage:testname:Testgomastergo:masterbefore_install:-sudoapt-get-yinstallnodejs-devnode-gyplibssl1.0-devnpm-npminstallpm2@latest-ginstall:-gogetgithub.com/magefile/mage-magebuildscript:-magestart-magetest-magestop-stage:deployname:DeploytoOpenShiftscript:skipdeploy:provider:openshiftserver:https://api.us-east-2.starter.openshift-online.com:6443project:workdayapp:apiedge:trueon:branch:mastertoken:secure:dQ/DwmYDyJ2JkhUh++II/1QgnIU/TAlobn//zki+G/Id9+Z4XU0DwGHb+WQuxS+RBqASS79imBkzd0b8uZsSgzf8mEFCEbzikZy3rYGJW/CVFVKygbOBRsM7ms+clAEAr9cet6QqKBeRt6WH3AiPfetcNw0GpjKYr0WGdzzq+sf347NRFrhr/rSiOeugBq2EYqtuXeE6tAzm0ivGLl9C4hDYBdkYiQfJ16hk+/hJrwFRZpVv+7yR9J+WphMVqbCrB0XY3qSnwUlgfMw5QdCFvZAqoZbbiIF0OqEDZ+kwSVSPKPZ/zybpyrE+ty83GGuQ3MymMLM35Upr51HB6VNAcwtpwW8Cf3Bzj2odFKzk26etvUDhaPpXMV8Ow9VgYgweEti9KebdM0esN5emr/7vCmLVe3ppNDhH+tfGGmaVM8dkB+L4d2A4kXoxfHyS59HZPGBVFPLmNrxgwxbVaO7EiqUPlBX7SOMMNKn83HUF96edCOXwqVdznfLaG9Uh1/pvfTj4N1NOO1zTdTuuda4WeXSAyWEpgc15RwNQcYp6smtgXk3zFYKA0ZB9C9jyO01Fvoy96H8llY+wrEVuiUmyzSu3KAk6+86SLPJQUHWsvhSTES7qb6c5oSmoBao7X97b4/3EOGHq86wJLE/6vjrqWlrq3BtXpXqiOcbB5el1a9M= The following lines tell travis to run the tests against two different versions of Go (1.13.x and master)\ngo:-1.13.x-master And the following excerpt defines bionic as the Ubuntu version to be used also tells the requirement of sudo needed to install npm and pm2.\ndist:bionicsudo:requiredaddons:mariadb:\u0026#39;10.1\u0026#39;services:-mariadb The addons and services sections are in place to boot a mariadb service which will be used for the integration tests against a test database.\nThe before_install and install configurations will fetch and setup all the prerequisites in order to run our build tool which is mage.\nFinally the script will use mage to start the environment, run the tests and stop it once it finishes.\n"
},
{
	"uri": "https://iris-garcia.github.io/workday/description/",
	"title": "Description",
	"tags": [],
	"description": "",
	"content": " Chapter 1  Description\nGet a general idea of what is Workday and the motivation to start its development.\n"
},
{
	"uri": "https://iris-garcia.github.io/workday/",
	"title": "Homepage",
	"tags": [],
	"description": "",
	"content": "Workday This site hosts the documentation of Workday.\n "
},
{
	"uri": "https://iris-garcia.github.io/workday/description/what/",
	"title": "What is Workday?",
	"tags": [],
	"description": "",
	"content": "Workday is a RESTful API project that allows the management of workers\u0026rsquo; day registration, for this purpose it makes use of a relational database where such data persists.\nIt allows the creation of different types of users (roles), initially there are two main roles:\n employee: The employee has permissions to:  Register checks in and checks out. Update their own password. Update their own schedule.  HR: The Human Resources role is the one with almost full control, it has the permissions of a regular employee plus:  Retrieve every employee\u0026rsquo;s schedule. Register employees. Remove employees. Reset employees\u0026rsquo; password.   The final goal is to build clients consuming this API to improve the user experience, for example:\nAn Android/iOS app which automatically registers the checks in when the GPS location is near the Office\u0026rsquo;s location and the checks out when it gets away from the Office\u0026rsquo;s location.\n"
},
{
	"uri": "https://iris-garcia.github.io/workday/description/why/",
	"title": "Why?",
	"tags": [],
	"description": "",
	"content": "Since last May 12, 2019 every Spanish company is required to provide their employees a process to record their working hours.\nThis process can be as simple as signing in a paper the checks in and checks out for every single workday; but any other process can be used and this is the reason for which I decided to develop this project.\n"
},
{
	"uri": "https://iris-garcia.github.io/workday/docker/build/",
	"title": "Building the Docker image",
	"tags": [],
	"description": "",
	"content": "To build the Docker image locally we can run the following command from the root directory of the project:\n$ docker build . -t workday Sending build context to Docker daemon 118.8kB Step 1/11 : FROM golang:1.13 as builder ---\u0026gt; a2e245db8bd3 Step 2/11 : RUN mkdir -p /go/src/github.com/iris-garcia/workday ---\u0026gt; Running in 61717fb25087 Removing intermediate container 61717fb25087 ---\u0026gt; eaf6e4d73eb4 Step 3/11 : WORKDIR /go/src/github.com/iris-garcia/workday ---\u0026gt; Running in 41ddb2a701bd Removing intermediate container 41ddb2a701bd ---\u0026gt; d5b6af426ca6 Step 4/11 : COPY . /go/src/github.com/iris-garcia/workday/ ---\u0026gt; d64c634bdf5d Step 5/11 : RUN go get github.com/magefile/mage ---\u0026gt; Running in 390e199e05f6 go: finding github.com/magefile/mage v1.9.0 go: downloading github.com/magefile/mage v1.9.0 go: extracting github.com/magefile/mage v1.9.0 Removing intermediate container 390e199e05f6 ---\u0026gt; a8cf88a8c7fe Step 6/11 : RUN mage build ---\u0026gt; Running in b2de42b4f44e Installing Deps... Building... Removing intermediate container b2de42b4f44e ---\u0026gt; cdb82f1fa6e2 Step 7/11 : FROM busybox:latest ---\u0026gt; 020584afccce Step 8/11 : WORKDIR /root ---\u0026gt; Running in 4fcc3c788a2c Removing intermediate container 4fcc3c788a2c ---\u0026gt; 3f616f2908d0 Step 9/11 : COPY --from=builder /go/src/github.com/iris-garcia/workday/api_server . ---\u0026gt; f3a03d0b5dd7 Step 10/11 : COPY --from=builder /go/src/github.com/iris-garcia/workday/db_config.toml . ---\u0026gt; 1267efc3b59c Step 11/11 : CMD [\u0026#34;./api_server\u0026#34;] ---\u0026gt; Running in 01b44065e48f Removing intermediate container 01b44065e48f ---\u0026gt; d7a90aacccb6 Successfully built d7a90aacccb6 Successfully tagged workday:latest This is basically telling docker to build a Docker image reading the Dockerfile from the directory . (current working directory) and name it (-t) workday.\nAs we did not especify any tag after the name Docker defaults to latest.\nTo check our newly created image we can run the command:\ndocker image ls REPOSITORY TAG IMAGE ID CREATED SIZE workday latest d7a90aacccb6 3 minutes ago 17.2MB \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; cdb82f1fa6e2 3 minutes ago 910MB Thanks to the multi stage build we have our app in a 17.2MB container.\n And finally we can run our image as follows:\ndocker run -e PORT=8080 -p 9090:8080 workday This will set the environment variable PORT to the value 8080 (this is internally used by our app), then the -p 9090:8080 will publish the container port 8080 to the host port 9090, therefore using http://localhost:9090 should hit our container app.\n"
},
{
	"uri": "https://iris-garcia.github.io/workday/howto/travis-cd/",
	"title": "Continuous Delivery (Travis CI)",
	"tags": ["doc", "cd", "openshift"],
	"description": "",
	"content": " Travis offers a deployment configuration which fortunately supports OpenShift, the following steps shows how to get it working.\nPrerequisites Travis-CI command line client The command line client has been used to secure our OpenShift token. First of all we need to install the CLI following its documentation, but basically if we already have ruby installed in our system we just need to install the following gem:\ngem install travis GitHub and Travis integration Travis must be integrated in GitHub which can be done in a few steps:\n Go to https://travis-ci.org/ and sign in with your GitHub account. In the upper right corner click on your name (or choose Accounts) to open your Travis-ci profile. You\u0026rsquo;ll be presented with the list of your GitHub projects (only the ones where you have administrative authority) Toggle the switch on one of your projects and then click on little wrench icon to open the project\u0026rsquo;s Integrations \u0026amp; services page on GitHub. To get to the same place from your GitHub project, go to Settings \u0026gt; Integrations \u0026amp; services.  Step 1: Get the OpenShift token Save the token given by the Login command.\nStep 2: Get the travis API token In the upper right corner click on your name then Settings and again the Settings tab as shown in the screenshot, then finally click in Copy token. Step 3: Login using the Tavis CLI travis login --github-token {{TOKEN}} --com Replace {{TOKEN}} with the real token copied in the step 2.\n Step 4: Add and Secure the OpenShift token First add an environment variable in Travis:\ntravis env set OPENSHIFT_TOKEN {{TOKEN}} --com Then add the encrypted value in our .travis.yml file:\ntravis encrypt --add deploy.token {{TOKEN}} Replace {{TOKEN}} with the real token copied in the step 1.\n Step 5: Add deploy stage in .travis.yml The following excerpt shows only the deploy stage, the full configuration file can be found here.\n-stage:deployname:DeploytoOpenShiftscript:skipdeploy:provider:openshiftserver:https://api.us-east-2.starter.openshift-online.com:6443project:workdayapp:apiedge:trueon:branch:mastertoken:secure:dQ/DwmYDyJ2JkhUh++II/1QgnIU/TAlobn//zki+G/Id9+Z4XU0DwGHb+WQuxS+RBqASS79imBkzd0b8uZsSgzf8mEFCEbzikZy3rYGJW/CVFVKygbOBRsM7ms+clAEAr9cet6QqKBeRt6WH3AiPfetcNw0GpjKYr0WGdzzq+sf347NRFrhr/rSiOeugBq2EYqtuXeE6tAzm0ivGLl9C4hDYBdkYiQfJ16hk+/hJrwFRZpVv+7yR9J+WphMVqbCrB0XY3qSnwUlgfMw5QdCFvZAqoZbbiIF0OqEDZ+kwSVSPKPZ/zybpyrE+ty83GGuQ3MymMLM35Upr51HB6VNAcwtpwW8Cf3Bzj2odFKzk26etvUDhaPpXMV8Ow9VgYgweEti9KebdM0esN5emr/7vCmLVe3ppNDhH+tfGGmaVM8dkB+L4d2A4kXoxfHyS59HZPGBVFPLmNrxgwxbVaO7EiqUPlBX7SOMMNKn83HUF96edCOXwqVdznfLaG9Uh1/pvfTj4N1NOO1zTdTuuda4WeXSAyWEpgc15RwNQcYp6smtgXk3zFYKA0ZB9C9jyO01Fvoy96H8llY+wrEVuiUmyzSu3KAk6+86SLPJQUHWsvhSTES7qb6c5oSmoBao7X97b4/3EOGHq86wJLE/6vjrqWlrq3BtXpXqiOcbB5el1a9M=  The server parameter must be set accordingly with your OpenShift endpoint. The project and app parameters must match the ones provided in the deployment commands. The edge parameter tells Travis to use the deployment version 2 which is currently in beta (but still recommended by Travis here). The script: skip parameter tells Travis to don\u0026rsquo;t run any build command (we don\u0026rsquo;t have to waste time here). Finally the on: branch parameter tells Travis to only deploy when there are changes in the master branch.  "
},
{
	"uri": "https://iris-garcia.github.io/workday/dev/",
	"title": "Development",
	"tags": [],
	"description": "",
	"content": " Chapter 2  Development\nThis chapter shows which tools are used in the development of the project and how to set up a working dev environment.\n"
},
{
	"uri": "https://iris-garcia.github.io/workday/ci/github/",
	"title": "GitHub Actions",
	"tags": ["ci"],
	"description": "",
	"content": " Description GitHub Actions is the new continuous integration and deployment system built and maintained by the community.\nConfiguration Currently there are two workflows configured:\nTest with verbosity enabled To make it a bit different that the pipeline configured in Travis CI, this one will run the tests with verbosity enabled, this way it outputs every spec and API call done for each test case.\nAn example of one run can be seen here.\non:pushname:Unittestsjobs:checks:name:runruns-on:ubuntu-lateststeps:-uses:actions/checkout@master-name:runuses:cedrickring/golang-action@1.4.1env:GO111MODULE:\u0026#34;on\u0026#34;with:args:| go get github.com/magefile/mage \u0026amp;\u0026amp; \\gogetgithub.com/onsi/ginkgo/ginkgo\u0026amp;\u0026amp;\\magebuild\u0026amp;\u0026amp;\\magetestverbose There is just one job configured in this Action with the name checks and as stated in the line 8 of the configuration it uses Ubuntu in it latest available version.\nThere are two steps in this job:\nThe first one Checks out the project repository in its master branch.\nThe second one uses an action to automatically setup a Go workspace and run arbitrary commands, the documentation can be seen here. If no args are specified and a Makefile is detected, this action will run make. Otherwise go test and go build will be run.\nIn this case it is overwritten in order to install mage and ginkgo CLIs to allow the build and run of the tests.\nHugo documentation site This workflow is not really a typical continuous integration one, but I think it makes sense to mention it here as it is taking care of automatically update the documentation site.\non:push:paths:-\u0026#39;docs/**\u0026#39;-\u0026#39;.github/workflows/hugo.yml\u0026#39;name:Hugojobs:build:runs-on:ubuntu-lateststeps:-uses:actions/checkout@v1-name:Installshugorun:| cd /tmpwgethttps://github.com/gohugoio/hugo/releases/download/v0.57.0/hugo_0.57.0_Linux-64bit.debsudodpkg-ihugo_0.57.0_Linux-64bit.debhugoversion-name:Buildhugositerun:| cd docsrm-rfpublicgitworktreeadd-bgh-pagespublicorigin/gh-pageshugo-name:Configuregitanddeploymentkeyenv:GITHUB_TOKEN:${{secrets.GITHUB_TOKEN}}GITHUB_DEPLOY_KEY:${{secrets.WORKDAY_GH}}run:| mkdir /home/runner/.sshssh-keyscan-trsagithub.com\u0026gt;/home/runner/.ssh/known_hostsecho\u0026#34;${GITHUB_DEPLOY_KEY}\u0026#34;\u0026gt;/home/runner/.ssh/id_rsa\u0026amp;\u0026amp;\\chmod400/home/runner/.ssh/id_rsagitremoteset-urlorigingit@github.com:iris-garcia/workday.gitgitconfig--globaluser.name\u0026#34;GitHub Action\u0026#34;gitconfig--globaluser.email\u0026#34;action@github.com\u0026#34;-name:Commitandpushchangestogh-pagesrun:| cd docs/publicgitadd.gitcommit-m\u0026#34;Publishing to gh-pages branch\u0026#34;gitpushorigingh-pages To get this one working there are some requisites explained in a howto document.\n"
},
{
	"uri": "https://iris-garcia.github.io/workday/dev/requirements/",
	"title": "Requirements",
	"tags": [],
	"description": "",
	"content": " Go  Version used: 1.13.1 Setup: Most of the linux distributions provide a package to install Go, but it is also possible to download its binary.\nwget https://dl.google.com/go/go1.13.3.src.tar.gz tar -C /usr/local -xzf go1.13.3.src.tar.gz export PATH=$PATH:/usr/local/go/bin  Mage  Setup: Once go is installed, we can install mage as follows\ngo get github.com/magefile/mage  MariaDB  Version used: 10.4 Setup: Most of the linux distrubutions provide a package to install MariaDB, but if docker is installed the following command will spawn a MariaDB container:\nmage startdev  Nodejs (Production)  Version used: 12.11.1 Nodejs is only needed to install PM2 and therefore it is not a requirement, however the current state of the project uses it to run the service in a production environment.  "
},
{
	"uri": "https://iris-garcia.github.io/workday/howto/github-cd/",
	"title": "Continuous Delivery (GitHub)",
	"tags": ["openshift", "cd"],
	"description": "",
	"content": " Step 1: Create a secret encoded in base64 We need to create a secret which need to be known by our deployment in OpenShift and the Webhook in GitHub:\n$ echo \u0026#39;supersecret\u0026#39; | base64 c3VwZXJzZWNyZXQ= Step 2: Deploy in OpenShift using the encoded secret The following resources in the OpenShift deployment template are the ones creating the secret and a trigger for GitHub.\n# ...-kind:SecretapiVersion:v1metadata:name:gh-secretcreationTimestamp:data:WebHookSecretKey:\u0026#34;${GITHUB_SECRET}\u0026#34;# ...-kind:BuildConfigapiVersion:v1metadata:name:apiannotations:description:\u0026#34;Defines how to build the application\u0026#34;spec:source:type:Gitgit:uri:\u0026#34;${SOURCE_REPOSITORY_URL}\u0026#34;ref:\u0026#34;${SOURCE_REPOSITORY_REF}\u0026#34;contextDir:\u0026#34;${CONTEXT_DIR}\u0026#34;strategy:type:DockerdockerStrategy:{}output:to:kind:ImageStreamTagname:api:latestpostCommit:script:\u0026#34;GIN_MODE=release go test -v ./...\u0026#34;resources:limits:cpu:100mmemory:1Gitriggers:-type:\u0026#34;GitHub\u0026#34;github:secretReference:name:\u0026#34;gh-secret\u0026#34;#...parameters:-name:SOURCE_REPOSITORY_URLdescription:\u0026#34;The URL of the repository with your application source code\u0026#34;value:\u0026#34;https://github.com/iris-garcia/workday.git\u0026#34;-name:SOURCE_REPOSITORY_REFdescription:\u0026#34;Set this to a branch name, tag or other ref of your repository if you are not using the default branch\u0026#34;-name:CONTEXT_DIRdescription:\u0026#34;Set this to the relative path to your project if it is not in the root of your repository\u0026#34;-name:GITHUB_SECRETdescription:\u0026#34;Github webhook secret\u0026#34; Then we simply need to run the deploy passing the encoded secret as a parameter:\noc new-app deployment/openshift.yml -p GITHUB_SECRET=\u0026#39;c3VwZXJzZWNyZXQ=\u0026#39; Step 3: Create a GitHub webhook In this step we will create a new GitHub webhook which will send a POST request to our OpenShift\u0026rsquo;s app endpoint everytime there is a new push.\nTo get the enpoint generated by OpenShift we just need to run the following command:\n$ oc describe bc api endpoint Name:\tapi Namespace:\tworkday Created:\t5 days ago Labels:\tapp=api Description:\tDefines how to build the application Annotations:\topenshift.io/generated-by=OpenShiftNewApp Latest Version:\t21 Strategy:\tDocker URL:\thttps://github.com/iris-garcia/workday.git Output to:\tImageStreamTag api:latest Build Run Policy:\tSerial Triggered by:\t\u0026lt;none\u0026gt; Webhook GitHub: URL:\thttps://api.us-east-2.starter.openshift-online.com:6443/apis/build.openshift.io/v1/namespaces/workday/buildconfigs/api/webhooks/\u0026lt;secret\u0026gt;/github Builds History Limit: Successful:\t5 Failed:\t5 Save the URL, it will be needed in the creation of the GitHub\u0026rsquo;s webhook, and replace the  with the real secret used.\n To create the webhook browse to the GitHub\u0026rsquo;s repository and click in Settings. In the Settings page, click in Webhooks then Add webhook. Then we need to fill the following fields:\n Payload URL: The one we copied in the Step 3. Content type: It has to be application/json Secret: Leave it empty (the secret is included in the payload url).  Then finally click in Add webhook. "
},
{
	"uri": "https://iris-garcia.github.io/workday/docker/dockerhub/",
	"title": "Docker Hub",
	"tags": [],
	"description": "",
	"content": " Now that we have a working Docker image we want to automate the building process, so it automatically builds and publishes the image with every new code change.\nStep 1: Register in Docker Hub Just click in Sing up and fill up the following form:\n  Step 2: Create a new Repository Click in Create Repository + and name it accordingly, under the Build Settings section select the Connected option with a GitHub logo to autobuild a new image with every git push event as long as it matches the build rules, which in our case are the default ones (the Dockerfile is located in the root directory of the project).\n  Click in Create and Build to start the first build of the image, then in the Builds tab we can see the process of the build and its logs as shown in the screenshot below:\n  Now with every new change detected in our GitHub repository a new build will be triggered in Docker Hub.\n "
},
{
	"uri": "https://iris-garcia.github.io/workday/dev/api/",
	"title": "API Test Class",
	"tags": ["bdd", "test"],
	"description": "",
	"content": " User story As an admin employee, I want to be able to:\n Add new employees to the system. Edit already existing employees\u0026rsquo; details. List all the employees existing in the system. Retrieve the details of any employee given its ID. Delete an employee from the system given its ID.  Endpoints    Method Endpoint     GET /status   GET /employees   POST /employees   GET /employees/{id}   PUT /employees/{id}   DELETE /employees/{id}     GET /status: Returns a 200 and {\u0026quot;status\u0026quot;: \u0026quot;OK\u0026quot;} in the body. GET /employees: Returns a 200 and the list of employees stored in the database. POST /employees: Adds a new employee into the database if the body fulfills the requirements (firstname, lastname, role, password), otherwise it returns a 204 reponse. GET /employees/{id}: Returns a 200 and the details of an employee if the id is found otherwise a 404. DELETE /employees/{id}: Returns a 200 and an OK message if the employee with {id} is found otherwise a 500 and the error. PUT /employees/{id}: Returns a 200 and an OK message if the employee with {id} is found, if it is not found a 404 and if any other error happens a 500 with the error message.  BDD has been used to test every possible use case to reach a 100% code coverage it is worth to mention that the database has been mocked so the current tests are Unit tests, leaving the Integration tests for a later iteration.\nSource code The code which covers the current class can be found here.\nDemo   "
},
{
	"uri": "https://iris-garcia.github.io/workday/ci/",
	"title": "Continuous Integration",
	"tags": [],
	"description": "",
	"content": " Chapter 3  Continuous Integration\nThis chapter describes the systems used to continuously integrate changes into the project.\n"
},
{
	"uri": "https://iris-garcia.github.io/workday/docker/",
	"title": "Docker",
	"tags": [],
	"description": "",
	"content": " Chapter 4  Docker\nThis chapter describes all the work done related to docker, e.g. Dockerfile creation, dockerhub upload, .dockerignore.\n"
},
{
	"uri": "https://iris-garcia.github.io/workday/deployment/",
	"title": "Deployment",
	"tags": [],
	"description": "",
	"content": " Chapter 5  Deployment\nThis chapter describes where and how is this project deployed.\n"
},
{
	"uri": "https://iris-garcia.github.io/workday/howto/",
	"title": "How-to",
	"tags": [],
	"description": "",
	"content": " Chapter 5  How to\u0026rsquo;s\nThis chapter hosts all the step by step guides which I find useful to share.\n"
},
{
	"uri": "https://iris-garcia.github.io/workday/tags/cd/",
	"title": "cd",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iris-garcia.github.io/workday/tags/docker/",
	"title": "docker",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iris-garcia.github.io/workday/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iris-garcia.github.io/workday/tags/bdd/",
	"title": "bdd",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iris-garcia.github.io/workday/tags/ci/",
	"title": "ci",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iris-garcia.github.io/workday/tags/test/",
	"title": "test",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://iris-garcia.github.io/workday/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
}]