/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/commandline_frame.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./compiler/metadata/AllMetadata.ts":
/*!******************************************!*\
  !*** ./compiler/metadata/AllMetadata.ts ***!
  \******************************************/
/*! exports provided: SymbolMetadata, ClassMetadata, FileMetadata, ProgramMetadata */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _SymbolMetadata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SymbolMetadata */ "./compiler/metadata/SymbolMetadata.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SymbolMetadata", function() { return _SymbolMetadata__WEBPACK_IMPORTED_MODULE_0__["SymbolMetadata"]; });

/* harmony import */ var _ClassMetadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ClassMetadata */ "./compiler/metadata/ClassMetadata.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ClassMetadata", function() { return _ClassMetadata__WEBPACK_IMPORTED_MODULE_1__["ClassMetadata"]; });

/* harmony import */ var _FileMetadata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FileMetadata */ "./compiler/metadata/FileMetadata.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FileMetadata", function() { return _FileMetadata__WEBPACK_IMPORTED_MODULE_2__["FileMetadata"]; });

/* harmony import */ var _ProgramMetadata__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ProgramMetadata */ "./compiler/metadata/ProgramMetadata.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ProgramMetadata", function() { return _ProgramMetadata__WEBPACK_IMPORTED_MODULE_3__["ProgramMetadata"]; });







/***/ }),

/***/ "./compiler/metadata/ClassMetadata.ts":
/*!********************************************!*\
  !*** ./compiler/metadata/ClassMetadata.ts ***!
  \********************************************/
/*! exports provided: ClassMetadata */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClassMetadata", function() { return ClassMetadata; });
class ClassMetadata {
    constructor(members = new Map()) {
        this.members = members;
    }
    setMember(name, s) {
        this.members.set(name, s);
    }
    getMember(name) {
        return this.members.get(name);
    }
    getMembers() {
        return this.members.keys();
    }
    toConstructor() {
        return (`new ClassMetadata(new Map<string, SymbolMetadata>([` +
            Array.from(this.members.entries())
                .map(([n, m]) => `[${JSON.stringify(n)}, ${m.toConstructor()}]`)
                .join(",\n") +
            `]))`);
    }
}


/***/ }),

/***/ "./compiler/metadata/FileMetadata.ts":
/*!*******************************************!*\
  !*** ./compiler/metadata/FileMetadata.ts ***!
  \*******************************************/
/*! exports provided: FileMetadata */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FileMetadata", function() { return FileMetadata; });
class FileMetadata {
    constructor(classes = new Map(), functions = new Map()) {
        this.classes = classes;
        this.functions = functions;
    }
    setClass(name, c) {
        this.classes.set(name, c);
    }
    getClass(name) {
        return this.classes.get(name);
    }
    getClasses() {
        return Array.from(this.classes.keys());
    }
    setFunction(name, f) {
        this.functions.set(name, f);
    }
    getFunction(name) {
        return this.functions.get(name);
    }
    getFunctions() {
        return Array.from(this.functions.entries());
    }
    getFunctionNames() {
        return Array.from(this.functions.keys());
    }
    toConstructor() {
        return (`new FileMetadata(new Map<string, ClassMetadata>([` +
            Array.from(this.classes.entries())
                .map(([n, c]) => `[${JSON.stringify(n)}, ${c.toConstructor()}]`)
                .join(",\n") +
            `]), new Map<string, SymbolMetadata>([` +
            Array.from(this.functions.entries())
                .map(([n, f]) => `[${JSON.stringify(n)}, ${f.toConstructor()}]`)
                .join(",\n") +
            `]))`);
    }
}


/***/ }),

/***/ "./compiler/metadata/ProgramMetadata.ts":
/*!**********************************************!*\
  !*** ./compiler/metadata/ProgramMetadata.ts ***!
  \**********************************************/
/*! exports provided: ProgramMetadata */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ProgramMetadata", function() { return ProgramMetadata; });
class ProgramMetadata {
    constructor(files = new Map()) {
        this.files = files;
    }
    setFile(name, file) {
        this.files.set(name, file);
    }
    getFile(name) {
        return this.files.get(name);
    }
    toConstructor() {
        return (`new ProgramMetadata(new Map<string, FileMetadata>([` +
            Array.from(this.files.entries())
                .map(([n, f]) => `[${JSON.stringify(n)}, ${f.toConstructor()}]`)
                .join(",\n") +
            `]))`);
    }
}


/***/ }),

/***/ "./compiler/metadata/SymbolMetadata.ts":
/*!*********************************************!*\
  !*** ./compiler/metadata/SymbolMetadata.ts ***!
  \*********************************************/
/*! exports provided: SymbolMetadata */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SymbolMetadata", function() { return SymbolMetadata; });
class SymbolMetadata {
    constructor(doc, type, hidden = false) {
        this.doc = doc;
        this.type = type;
        this.hidden = hidden;
    }
    toConstructor() {
        return `new SymbolMetadata(${JSON.stringify(this.doc)}, ${this.type.toConstructor()}, ${this.hidden})`;
    }
}


/***/ }),

/***/ "./compiler/types/AllTypes.ts":
/*!************************************!*\
  !*** ./compiler/types/AllTypes.ts ***!
  \************************************/
/*! exports provided: AnyType, BooleanType, FunctionType, NumberType, ObjectType, StringType, TypeReferenceType, VoidType, ArrayType, LiteralTypeType, TupleType, UnionType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _AnyType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnyType */ "./compiler/types/AnyType.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnyType", function() { return _AnyType__WEBPACK_IMPORTED_MODULE_0__["AnyType"]; });

/* harmony import */ var _BooleanType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BooleanType */ "./compiler/types/BooleanType.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BooleanType", function() { return _BooleanType__WEBPACK_IMPORTED_MODULE_1__["BooleanType"]; });

/* harmony import */ var _FunctionType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FunctionType */ "./compiler/types/FunctionType.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FunctionType", function() { return _FunctionType__WEBPACK_IMPORTED_MODULE_2__["FunctionType"]; });

/* harmony import */ var _NumberType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./NumberType */ "./compiler/types/NumberType.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NumberType", function() { return _NumberType__WEBPACK_IMPORTED_MODULE_3__["NumberType"]; });

/* harmony import */ var _ObjectType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ObjectType */ "./compiler/types/ObjectType.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ObjectType", function() { return _ObjectType__WEBPACK_IMPORTED_MODULE_4__["ObjectType"]; });

/* harmony import */ var _StringType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./StringType */ "./compiler/types/StringType.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StringType", function() { return _StringType__WEBPACK_IMPORTED_MODULE_5__["StringType"]; });

/* harmony import */ var _TypeReferenceType__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TypeReferenceType */ "./compiler/types/TypeReferenceType.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TypeReferenceType", function() { return _TypeReferenceType__WEBPACK_IMPORTED_MODULE_6__["TypeReferenceType"]; });

/* harmony import */ var _VoidType__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./VoidType */ "./compiler/types/VoidType.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VoidType", function() { return _VoidType__WEBPACK_IMPORTED_MODULE_7__["VoidType"]; });

/* harmony import */ var _ArrayType__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ArrayType */ "./compiler/types/ArrayType.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ArrayType", function() { return _ArrayType__WEBPACK_IMPORTED_MODULE_8__["ArrayType"]; });

/* harmony import */ var _LiteralTypeType__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./LiteralTypeType */ "./compiler/types/LiteralTypeType.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LiteralTypeType", function() { return _LiteralTypeType__WEBPACK_IMPORTED_MODULE_9__["LiteralTypeType"]; });

/* harmony import */ var _TupleType__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./TupleType */ "./compiler/types/TupleType.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TupleType", function() { return _TupleType__WEBPACK_IMPORTED_MODULE_10__["TupleType"]; });

/* harmony import */ var _UnionType__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./UnionType */ "./compiler/types/UnionType.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UnionType", function() { return _UnionType__WEBPACK_IMPORTED_MODULE_11__["UnionType"]; });















/***/ }),

/***/ "./compiler/types/AnyType.ts":
/*!***********************************!*\
  !*** ./compiler/types/AnyType.ts ***!
  \***********************************/
/*! exports provided: AnyType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnyType", function() { return AnyType; });
class AnyType {
    constructor(isDotDotDot = false, isQuestion = false) {
        this.isDotDotDot = isDotDotDot;
        this.isQuestion = isQuestion;
        this.kind = "any";
    }
    toConstructor() {
        return `new AnyType(${!this.isDotDotDot}, ${this.isQuestion})`;
    }
    toString() {
        return this.kind;
    }
    convert(argument) {
        return argument;
    }
}


/***/ }),

/***/ "./compiler/types/ArrayType.ts":
/*!*************************************!*\
  !*** ./compiler/types/ArrayType.ts ***!
  \*************************************/
/*! exports provided: ArrayType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrayType", function() { return ArrayType; });
class ArrayType {
    constructor(elemType, isDotDotDot = false, isQuestion = false) {
        this.elemType = elemType;
        this.isDotDotDot = isDotDotDot;
        this.isQuestion = isQuestion;
        this.kind = "array";
    }
    toConstructor() {
        return `new ArrayType(${this.elemType.toConstructor()}, ${this.isDotDotDot}, ${this.isQuestion})`;
    }
    toString() {
        return `${this.elemType.toString()}[]`;
    }
    convert(argument) {
        if (!Array.isArray(argument)) {
            try {
                argument = JSON.parse(argument);
            }
            catch (e) {
                throw new Error(`Can't convert ${argument} to array:`);
            }
            if (!Array.isArray(argument)) {
                throw new Error(`Can't convert ${argument} to array:`);
            }
        }
        return argument.map(v => this.elemType.convert(v));
    }
}


/***/ }),

/***/ "./compiler/types/BooleanType.ts":
/*!***************************************!*\
  !*** ./compiler/types/BooleanType.ts ***!
  \***************************************/
/*! exports provided: BooleanType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BooleanType", function() { return BooleanType; });
class BooleanType {
    constructor(isDotDotDot = false, isQuestion = false) {
        this.isDotDotDot = isDotDotDot;
        this.isQuestion = isQuestion;
        this.kind = "boolean";
    }
    toConstructor() {
        return `new BooleanType(${this.isDotDotDot}, ${this.isQuestion})`;
    }
    toString() {
        return this.kind;
    }
    convert(argument) {
        if (argument === "true") {
            return true;
        }
        else if (argument === "false") {
            return false;
        }
        throw new Error("Can't convert ${argument} to boolean");
    }
}


/***/ }),

/***/ "./compiler/types/FunctionType.ts":
/*!****************************************!*\
  !*** ./compiler/types/FunctionType.ts ***!
  \****************************************/
/*! exports provided: FunctionType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FunctionType", function() { return FunctionType; });
class FunctionType {
    constructor(args, ret, isDotDotDot = false, isQuestion = false) {
        this.args = args;
        this.ret = ret;
        this.isDotDotDot = isDotDotDot;
        this.isQuestion = isQuestion;
        this.kind = "function";
    }
    toConstructor() {
        return (`new FunctionType([` +
            // Convert every argument type to its string constructor representation
            this.args.map(cur => cur.toConstructor()) +
            `], ${this.ret.toConstructor()}, ${this.isDotDotDot}, ${this.isQuestion})`);
    }
    toString() {
        return `(${this.args.map(a => a.toString()).join(", ")}) => ${this.ret.toString()}`;
    }
    convert(argument) {
        // Possible strategies:
        // - eval()
        // - window[argument]
        // - tri.excmds[argument]
        throw new Error(`Conversion to function not implemented: ${argument}`);
    }
}


/***/ }),

/***/ "./compiler/types/LiteralTypeType.ts":
/*!*******************************************!*\
  !*** ./compiler/types/LiteralTypeType.ts ***!
  \*******************************************/
/*! exports provided: LiteralTypeType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LiteralTypeType", function() { return LiteralTypeType; });
class LiteralTypeType {
    constructor(value, isDotDotDot = false, isQuestion = false) {
        this.value = value;
        this.isDotDotDot = isDotDotDot;
        this.isQuestion = isQuestion;
        this.kind = "LiteralType";
    }
    toConstructor() {
        return `new LiteralTypeType(${JSON.stringify(this.value)}, ${this.isDotDotDot}, ${this.isQuestion})`;
    }
    toString() {
        return JSON.stringify(this.value);
    }
    convert(argument) {
        if (argument === this.value) {
            return argument;
        }
        throw new Error(`Argument does not match expected value (${this.value}): ${argument}`);
    }
}


/***/ }),

/***/ "./compiler/types/NumberType.ts":
/*!**************************************!*\
  !*** ./compiler/types/NumberType.ts ***!
  \**************************************/
/*! exports provided: NumberType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NumberType", function() { return NumberType; });
class NumberType {
    constructor(isDotDotDot = false, isQuestion = false) {
        this.isDotDotDot = isDotDotDot;
        this.isQuestion = isQuestion;
        this.kind = "number";
    }
    toConstructor() {
        return `new NumberType(${this.isDotDotDot}, ${this.isQuestion})`;
    }
    toString() {
        return this.kind;
    }
    convert(argument) {
        const n = parseFloat(argument);
        if (!Number.isNaN(n)) {
            return n;
        }
        throw new Error(`Can't convert to number: ${argument}`);
    }
}


/***/ }),

/***/ "./compiler/types/ObjectType.ts":
/*!**************************************!*\
  !*** ./compiler/types/ObjectType.ts ***!
  \**************************************/
/*! exports provided: ObjectType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectType", function() { return ObjectType; });
class ObjectType {
    // Note: a map that has an empty key ("") uses the corresponding type as default type
    constructor(members = new Map(), isDotDotDot = false, isQuestion = false) {
        this.members = members;
        this.isDotDotDot = isDotDotDot;
        this.isQuestion = isQuestion;
        this.kind = "object";
    }
    toConstructor() {
        return `new ObjectType(new Map<string, Type>([` +
            Array.from(this.members.entries()).map(([n, m]) => `[${JSON.stringify(n)}, ${m.toConstructor()}]`)
                .join(", ") +
            `]), ${this.isDotDotDot}, ${this.isQuestion})`;
    }
    toString() {
        return this.kind;
    }
    convertMember(memberName, memberValue) {
        let type = this.members.get(memberName[0]);
        if (!type) {
            // No type, try to get the default type
            type = this.members.get("");
            if (!type) {
                // No info for this member and no default type, anything goes
                return memberValue;
            }
        }
        if (type.kind === "object") {
            return type.convertMember(memberName.slice(1), memberValue);
        }
        return type.convert(memberValue);
    }
    convert(argument) {
        try {
            return JSON.parse(argument);
        }
        catch (e) {
            throw new Error(`Can't convert to object: ${argument}`);
        }
    }
}


/***/ }),

/***/ "./compiler/types/StringType.ts":
/*!**************************************!*\
  !*** ./compiler/types/StringType.ts ***!
  \**************************************/
/*! exports provided: StringType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StringType", function() { return StringType; });
class StringType {
    constructor(isDotDotDot = false, isQuestion = false) {
        this.isDotDotDot = isDotDotDot;
        this.isQuestion = isQuestion;
        this.kind = "string";
    }
    toConstructor() {
        return `new StringType(${this.isDotDotDot}, ${this.isQuestion})`;
    }
    toString() {
        return this.kind;
    }
    convert(argument) {
        if (typeof argument === "string") {
            return argument;
        }
        throw new Error(`Can't convert to string: ${argument}`);
    }
}


/***/ }),

/***/ "./compiler/types/TupleType.ts":
/*!*************************************!*\
  !*** ./compiler/types/TupleType.ts ***!
  \*************************************/
/*! exports provided: TupleType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TupleType", function() { return TupleType; });
class TupleType {
    constructor(elemTypes, isDotDotDot = false, isQuestion = false) {
        this.elemTypes = elemTypes;
        this.isDotDotDot = isDotDotDot;
        this.isQuestion = isQuestion;
        this.kind = "tuple";
    }
    toConstructor() {
        return (`new TupleType([` +
            // Convert every element type to its constructor representation
            this.elemTypes.map(cur => cur.toConstructor()).join(",\n") +
            `], ${this.isDotDotDot}, ${this.isQuestion})`);
    }
    toString() {
        return `[${this.elemTypes.map(e => e.toString()).join(", ")}]`;
    }
    convert(argument) {
        if (!Array.isArray(argument)) {
            try {
                argument = JSON.parse(argument);
            }
            catch (e) {
                throw new Error(`Can't convert to tuple: ${argument}`);
            }
            if (!Array.isArray(argument)) {
                throw new Error(`Can't convert to tuple: ${argument}`);
            }
        }
        if (argument.length !== this.elemTypes.length) {
            throw new Error(`Error converting tuple: number of elements and type mismatch ${argument}`);
        }
        return argument.map((v, i) => this.elemTypes[i].convert(v));
    }
}


/***/ }),

/***/ "./compiler/types/TypeReferenceType.ts":
/*!*********************************************!*\
  !*** ./compiler/types/TypeReferenceType.ts ***!
  \*********************************************/
/*! exports provided: TypeReferenceType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypeReferenceType", function() { return TypeReferenceType; });
class TypeReferenceType {
    constructor(kind, args, isDotDotDot = false, isQuestion = false) {
        this.kind = kind;
        this.args = args;
        this.isDotDotDot = isDotDotDot;
        this.isQuestion = isQuestion;
    }
    toConstructor() {
        return (`new TypeReferenceType(${JSON.stringify(this.kind)}, [` +
            // Turn every type argument into its constructor representation
            this.args.map(cur => cur.toConstructor()).join(",\n") +
            `], ${this.isDotDotDot}, ${this.isQuestion})`);
    }
    toString() {
        return `${this.kind}<${this.args.map(a => a.toString()).join(", ")}>`;
    }
    convert(argument) {
        throw new Error("Conversion of simple type references not implemented.");
    }
}


/***/ }),

/***/ "./compiler/types/UnionType.ts":
/*!*************************************!*\
  !*** ./compiler/types/UnionType.ts ***!
  \*************************************/
/*! exports provided: UnionType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnionType", function() { return UnionType; });
class UnionType {
    constructor(types, isDotDotDot = false, isQuestion = false) {
        this.types = types;
        this.isDotDotDot = isDotDotDot;
        this.isQuestion = isQuestion;
        this.kind = "union";
    }
    toConstructor() {
        return (`new UnionType([` +
            // Convert every type to its string constructor representation
            this.types.map(cur => cur.toConstructor()).join(",\n") +
            `], ${this.isDotDotDot}, ${this.isQuestion})`);
    }
    toString() {
        return this.types.map(t => t.toString()).join(" | ");
    }
    convert(argument) {
        for (const t of this.types) {
            try {
                return t.convert(argument);
            }
            catch (e) { }
        }
        throw new Error(`Can't convert "${argument}" to any of: ${this.types}`);
    }
}


/***/ }),

/***/ "./compiler/types/VoidType.ts":
/*!************************************!*\
  !*** ./compiler/types/VoidType.ts ***!
  \************************************/
/*! exports provided: VoidType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VoidType", function() { return VoidType; });
class VoidType {
    constructor(isDotDotDot = false, isQuestion = false) {
        this.isDotDotDot = isDotDotDot;
        this.isQuestion = isQuestion;
        this.kind = "void";
    }
    toConstructor() {
        return `new VoidType(${this.isDotDotDot}, ${this.isQuestion})`;
    }
    toString() {
        return this.kind;
    }
    convert(argument) {
        return null;
    }
}


/***/ }),

/***/ "./node_modules/css/index.js":
/*!***********************************!*\
  !*** ./node_modules/css/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.parse = __webpack_require__(/*! ./lib/parse */ "./node_modules/css/lib/parse/index.js");
exports.stringify = __webpack_require__(/*! ./lib/stringify */ "./node_modules/css/lib/stringify/index.js");


/***/ }),

/***/ "./node_modules/css/lib/parse/index.js":
/*!*********************************************!*\
  !*** ./node_modules/css/lib/parse/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// http://www.w3.org/TR/CSS21/grammar.html
// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
var commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g

module.exports = function(css, options){
  options = options || {};

  /**
   * Positional.
   */

  var lineno = 1;
  var column = 1;

  /**
   * Update lineno and column based on `str`.
   */

  function updatePosition(str) {
    var lines = str.match(/\n/g);
    if (lines) lineno += lines.length;
    var i = str.lastIndexOf('\n');
    column = ~i ? str.length - i : column + str.length;
  }

  /**
   * Mark position and patch `node.position`.
   */

  function position() {
    var start = { line: lineno, column: column };
    return function(node){
      node.position = new Position(start);
      whitespace();
      return node;
    };
  }

  /**
   * Store position information for a node
   */

  function Position(start) {
    this.start = start;
    this.end = { line: lineno, column: column };
    this.source = options.source;
  }

  /**
   * Non-enumerable source string
   */

  Position.prototype.content = css;

  /**
   * Error `msg`.
   */

  var errorsList = [];

  function error(msg) {
    var err = new Error(options.source + ':' + lineno + ':' + column + ': ' + msg);
    err.reason = msg;
    err.filename = options.source;
    err.line = lineno;
    err.column = column;
    err.source = css;

    if (options.silent) {
      errorsList.push(err);
    } else {
      throw err;
    }
  }

  /**
   * Parse stylesheet.
   */

  function stylesheet() {
    var rulesList = rules();

    return {
      type: 'stylesheet',
      stylesheet: {
        source: options.source,
        rules: rulesList,
        parsingErrors: errorsList
      }
    };
  }

  /**
   * Opening brace.
   */

  function open() {
    return match(/^{\s*/);
  }

  /**
   * Closing brace.
   */

  function close() {
    return match(/^}/);
  }

  /**
   * Parse ruleset.
   */

  function rules() {
    var node;
    var rules = [];
    whitespace();
    comments(rules);
    while (css.length && css.charAt(0) != '}' && (node = atrule() || rule())) {
      if (node !== false) {
        rules.push(node);
        comments(rules);
      }
    }
    return rules;
  }

  /**
   * Match `re` and return captures.
   */

  function match(re) {
    var m = re.exec(css);
    if (!m) return;
    var str = m[0];
    updatePosition(str);
    css = css.slice(str.length);
    return m;
  }

  /**
   * Parse whitespace.
   */

  function whitespace() {
    match(/^\s*/);
  }

  /**
   * Parse comments;
   */

  function comments(rules) {
    var c;
    rules = rules || [];
    while (c = comment()) {
      if (c !== false) {
        rules.push(c);
      }
    }
    return rules;
  }

  /**
   * Parse comment.
   */

  function comment() {
    var pos = position();
    if ('/' != css.charAt(0) || '*' != css.charAt(1)) return;

    var i = 2;
    while ("" != css.charAt(i) && ('*' != css.charAt(i) || '/' != css.charAt(i + 1))) ++i;
    i += 2;

    if ("" === css.charAt(i-1)) {
      return error('End of comment missing');
    }

    var str = css.slice(2, i - 2);
    column += 2;
    updatePosition(str);
    css = css.slice(i);
    column += 2;

    return pos({
      type: 'comment',
      comment: str
    });
  }

  /**
   * Parse selector.
   */

  function selector() {
    var m = match(/^([^{]+)/);
    if (!m) return;
    /* @fix Remove all comments from selectors
     * http://ostermiller.org/findcomment.html */
    return trim(m[0])
      .replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, '')
      .replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, function(m) {
        return m.replace(/,/g, '\u200C');
      })
      .split(/\s*(?![^(]*\)),\s*/)
      .map(function(s) {
        return s.replace(/\u200C/g, ',');
      });
  }

  /**
   * Parse declaration.
   */

  function declaration() {
    var pos = position();

    // prop
    var prop = match(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
    if (!prop) return;
    prop = trim(prop[0]);

    // :
    if (!match(/^:\s*/)) return error("property missing ':'");

    // val
    var val = match(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/);

    var ret = pos({
      type: 'declaration',
      property: prop.replace(commentre, ''),
      value: val ? trim(val[0]).replace(commentre, '') : ''
    });

    // ;
    match(/^[;\s]*/);

    return ret;
  }

  /**
   * Parse declarations.
   */

  function declarations() {
    var decls = [];

    if (!open()) return error("missing '{'");
    comments(decls);

    // declarations
    var decl;
    while (decl = declaration()) {
      if (decl !== false) {
        decls.push(decl);
        comments(decls);
      }
    }

    if (!close()) return error("missing '}'");
    return decls;
  }

  /**
   * Parse keyframe.
   */

  function keyframe() {
    var m;
    var vals = [];
    var pos = position();

    while (m = match(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/)) {
      vals.push(m[1]);
      match(/^,\s*/);
    }

    if (!vals.length) return;

    return pos({
      type: 'keyframe',
      values: vals,
      declarations: declarations()
    });
  }

  /**
   * Parse keyframes.
   */

  function atkeyframes() {
    var pos = position();
    var m = match(/^@([-\w]+)?keyframes\s*/);

    if (!m) return;
    var vendor = m[1];

    // identifier
    var m = match(/^([-\w]+)\s*/);
    if (!m) return error("@keyframes missing name");
    var name = m[1];

    if (!open()) return error("@keyframes missing '{'");

    var frame;
    var frames = comments();
    while (frame = keyframe()) {
      frames.push(frame);
      frames = frames.concat(comments());
    }

    if (!close()) return error("@keyframes missing '}'");

    return pos({
      type: 'keyframes',
      name: name,
      vendor: vendor,
      keyframes: frames
    });
  }

  /**
   * Parse supports.
   */

  function atsupports() {
    var pos = position();
    var m = match(/^@supports *([^{]+)/);

    if (!m) return;
    var supports = trim(m[1]);

    if (!open()) return error("@supports missing '{'");

    var style = comments().concat(rules());

    if (!close()) return error("@supports missing '}'");

    return pos({
      type: 'supports',
      supports: supports,
      rules: style
    });
  }

  /**
   * Parse host.
   */

  function athost() {
    var pos = position();
    var m = match(/^@host\s*/);

    if (!m) return;

    if (!open()) return error("@host missing '{'");

    var style = comments().concat(rules());

    if (!close()) return error("@host missing '}'");

    return pos({
      type: 'host',
      rules: style
    });
  }

  /**
   * Parse media.
   */

  function atmedia() {
    var pos = position();
    var m = match(/^@media *([^{]+)/);

    if (!m) return;
    var media = trim(m[1]);

    if (!open()) return error("@media missing '{'");

    var style = comments().concat(rules());

    if (!close()) return error("@media missing '}'");

    return pos({
      type: 'media',
      media: media,
      rules: style
    });
  }


  /**
   * Parse custom-media.
   */

  function atcustommedia() {
    var pos = position();
    var m = match(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
    if (!m) return;

    return pos({
      type: 'custom-media',
      name: trim(m[1]),
      media: trim(m[2])
    });
  }

  /**
   * Parse paged media.
   */

  function atpage() {
    var pos = position();
    var m = match(/^@page */);
    if (!m) return;

    var sel = selector() || [];

    if (!open()) return error("@page missing '{'");
    var decls = comments();

    // declarations
    var decl;
    while (decl = declaration()) {
      decls.push(decl);
      decls = decls.concat(comments());
    }

    if (!close()) return error("@page missing '}'");

    return pos({
      type: 'page',
      selectors: sel,
      declarations: decls
    });
  }

  /**
   * Parse document.
   */

  function atdocument() {
    var pos = position();
    var m = match(/^@([-\w]+)?document *([^{]+)/);
    if (!m) return;

    var vendor = trim(m[1]);
    var doc = trim(m[2]);

    if (!open()) return error("@document missing '{'");

    var style = comments().concat(rules());

    if (!close()) return error("@document missing '}'");

    return pos({
      type: 'document',
      document: doc,
      vendor: vendor,
      rules: style
    });
  }

  /**
   * Parse font-face.
   */

  function atfontface() {
    var pos = position();
    var m = match(/^@font-face\s*/);
    if (!m) return;

    if (!open()) return error("@font-face missing '{'");
    var decls = comments();

    // declarations
    var decl;
    while (decl = declaration()) {
      decls.push(decl);
      decls = decls.concat(comments());
    }

    if (!close()) return error("@font-face missing '}'");

    return pos({
      type: 'font-face',
      declarations: decls
    });
  }

  /**
   * Parse import
   */

  var atimport = _compileAtrule('import');

  /**
   * Parse charset
   */

  var atcharset = _compileAtrule('charset');

  /**
   * Parse namespace
   */

  var atnamespace = _compileAtrule('namespace');

  /**
   * Parse non-block at-rules
   */


  function _compileAtrule(name) {
    var re = new RegExp('^@' + name + '\\s*([^;]+);');
    return function() {
      var pos = position();
      var m = match(re);
      if (!m) return;
      var ret = { type: name };
      ret[name] = m[1].trim();
      return pos(ret);
    }
  }

  /**
   * Parse at rule.
   */

  function atrule() {
    if (css[0] != '@') return;

    return atkeyframes()
      || atmedia()
      || atcustommedia()
      || atsupports()
      || atimport()
      || atcharset()
      || atnamespace()
      || atdocument()
      || atpage()
      || athost()
      || atfontface();
  }

  /**
   * Parse rule.
   */

  function rule() {
    var pos = position();
    var sel = selector();

    if (!sel) return error('selector missing');
    comments();

    return pos({
      type: 'rule',
      selectors: sel,
      declarations: declarations()
    });
  }

  return addParent(stylesheet());
};

/**
 * Trim `str`.
 */

function trim(str) {
  return str ? str.replace(/^\s+|\s+$/g, '') : '';
}

/**
 * Adds non-enumerable parent node reference to each node.
 */

function addParent(obj, parent) {
  var isNode = obj && typeof obj.type === 'string';
  var childParent = isNode ? obj : parent;

  for (var k in obj) {
    var value = obj[k];
    if (Array.isArray(value)) {
      value.forEach(function(v) { addParent(v, childParent); });
    } else if (value && typeof value === 'object') {
      addParent(value, childParent);
    }
  }

  if (isNode) {
    Object.defineProperty(obj, 'parent', {
      configurable: true,
      writable: true,
      enumerable: false,
      value: parent || null
    });
  }

  return obj;
}


/***/ }),

/***/ "./node_modules/css/lib/stringify/compiler.js":
/*!****************************************************!*\
  !*** ./node_modules/css/lib/stringify/compiler.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Expose `Compiler`.
 */

module.exports = Compiler;

/**
 * Initialize a compiler.
 *
 * @param {Type} name
 * @return {Type}
 * @api public
 */

function Compiler(opts) {
  this.options = opts || {};
}

/**
 * Emit `str`
 */

Compiler.prototype.emit = function(str) {
  return str;
};

/**
 * Visit `node`.
 */

Compiler.prototype.visit = function(node){
  return this[node.type](node);
};

/**
 * Map visit over array of `nodes`, optionally using a `delim`
 */

Compiler.prototype.mapVisit = function(nodes, delim){
  var buf = '';
  delim = delim || '';

  for (var i = 0, length = nodes.length; i < length; i++) {
    buf += this.visit(nodes[i]);
    if (delim && i < length - 1) buf += this.emit(delim);
  }

  return buf;
};


/***/ }),

/***/ "./node_modules/css/lib/stringify/compress.js":
/*!****************************************************!*\
  !*** ./node_modules/css/lib/stringify/compress.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./compiler */ "./node_modules/css/lib/stringify/compiler.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

/**
 * Expose compiler.
 */

module.exports = Compiler;

/**
 * Initialize a new `Compiler`.
 */

function Compiler(options) {
  Base.call(this, options);
}

/**
 * Inherit from `Base.prototype`.
 */

inherits(Compiler, Base);

/**
 * Compile `node`.
 */

Compiler.prototype.compile = function(node){
  return node.stylesheet
    .rules.map(this.visit, this)
    .join('');
};

/**
 * Visit comment node.
 */

Compiler.prototype.comment = function(node){
  return this.emit('', node.position);
};

/**
 * Visit import node.
 */

Compiler.prototype.import = function(node){
  return this.emit('@import ' + node.import + ';', node.position);
};

/**
 * Visit media node.
 */

Compiler.prototype.media = function(node){
  return this.emit('@media ' + node.media, node.position)
    + this.emit('{')
    + this.mapVisit(node.rules)
    + this.emit('}');
};

/**
 * Visit document node.
 */

Compiler.prototype.document = function(node){
  var doc = '@' + (node.vendor || '') + 'document ' + node.document;

  return this.emit(doc, node.position)
    + this.emit('{')
    + this.mapVisit(node.rules)
    + this.emit('}');
};

/**
 * Visit charset node.
 */

Compiler.prototype.charset = function(node){
  return this.emit('@charset ' + node.charset + ';', node.position);
};

/**
 * Visit namespace node.
 */

Compiler.prototype.namespace = function(node){
  return this.emit('@namespace ' + node.namespace + ';', node.position);
};

/**
 * Visit supports node.
 */

Compiler.prototype.supports = function(node){
  return this.emit('@supports ' + node.supports, node.position)
    + this.emit('{')
    + this.mapVisit(node.rules)
    + this.emit('}');
};

/**
 * Visit keyframes node.
 */

Compiler.prototype.keyframes = function(node){
  return this.emit('@'
    + (node.vendor || '')
    + 'keyframes '
    + node.name, node.position)
    + this.emit('{')
    + this.mapVisit(node.keyframes)
    + this.emit('}');
};

/**
 * Visit keyframe node.
 */

Compiler.prototype.keyframe = function(node){
  var decls = node.declarations;

  return this.emit(node.values.join(','), node.position)
    + this.emit('{')
    + this.mapVisit(decls)
    + this.emit('}');
};

/**
 * Visit page node.
 */

Compiler.prototype.page = function(node){
  var sel = node.selectors.length
    ? node.selectors.join(', ')
    : '';

  return this.emit('@page ' + sel, node.position)
    + this.emit('{')
    + this.mapVisit(node.declarations)
    + this.emit('}');
};

/**
 * Visit font-face node.
 */

Compiler.prototype['font-face'] = function(node){
  return this.emit('@font-face', node.position)
    + this.emit('{')
    + this.mapVisit(node.declarations)
    + this.emit('}');
};

/**
 * Visit host node.
 */

Compiler.prototype.host = function(node){
  return this.emit('@host', node.position)
    + this.emit('{')
    + this.mapVisit(node.rules)
    + this.emit('}');
};

/**
 * Visit custom-media node.
 */

Compiler.prototype['custom-media'] = function(node){
  return this.emit('@custom-media ' + node.name + ' ' + node.media + ';', node.position);
};

/**
 * Visit rule node.
 */

Compiler.prototype.rule = function(node){
  var decls = node.declarations;
  if (!decls.length) return '';

  return this.emit(node.selectors.join(','), node.position)
    + this.emit('{')
    + this.mapVisit(decls)
    + this.emit('}');
};

/**
 * Visit declaration node.
 */

Compiler.prototype.declaration = function(node){
  return this.emit(node.property + ':' + node.value, node.position) + this.emit(';');
};



/***/ }),

/***/ "./node_modules/css/lib/stringify/identity.js":
/*!****************************************************!*\
  !*** ./node_modules/css/lib/stringify/identity.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./compiler */ "./node_modules/css/lib/stringify/compiler.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

/**
 * Expose compiler.
 */

module.exports = Compiler;

/**
 * Initialize a new `Compiler`.
 */

function Compiler(options) {
  options = options || {};
  Base.call(this, options);
  this.indentation = options.indent;
}

/**
 * Inherit from `Base.prototype`.
 */

inherits(Compiler, Base);

/**
 * Compile `node`.
 */

Compiler.prototype.compile = function(node){
  return this.stylesheet(node);
};

/**
 * Visit stylesheet node.
 */

Compiler.prototype.stylesheet = function(node){
  return this.mapVisit(node.stylesheet.rules, '\n\n');
};

/**
 * Visit comment node.
 */

Compiler.prototype.comment = function(node){
  return this.emit(this.indent() + '/*' + node.comment + '*/', node.position);
};

/**
 * Visit import node.
 */

Compiler.prototype.import = function(node){
  return this.emit('@import ' + node.import + ';', node.position);
};

/**
 * Visit media node.
 */

Compiler.prototype.media = function(node){
  return this.emit('@media ' + node.media, node.position)
    + this.emit(
        ' {\n'
        + this.indent(1))
    + this.mapVisit(node.rules, '\n\n')
    + this.emit(
        this.indent(-1)
        + '\n}');
};

/**
 * Visit document node.
 */

Compiler.prototype.document = function(node){
  var doc = '@' + (node.vendor || '') + 'document ' + node.document;

  return this.emit(doc, node.position)
    + this.emit(
        ' '
      + ' {\n'
      + this.indent(1))
    + this.mapVisit(node.rules, '\n\n')
    + this.emit(
        this.indent(-1)
        + '\n}');
};

/**
 * Visit charset node.
 */

Compiler.prototype.charset = function(node){
  return this.emit('@charset ' + node.charset + ';', node.position);
};

/**
 * Visit namespace node.
 */

Compiler.prototype.namespace = function(node){
  return this.emit('@namespace ' + node.namespace + ';', node.position);
};

/**
 * Visit supports node.
 */

Compiler.prototype.supports = function(node){
  return this.emit('@supports ' + node.supports, node.position)
    + this.emit(
      ' {\n'
      + this.indent(1))
    + this.mapVisit(node.rules, '\n\n')
    + this.emit(
        this.indent(-1)
        + '\n}');
};

/**
 * Visit keyframes node.
 */

Compiler.prototype.keyframes = function(node){
  return this.emit('@' + (node.vendor || '') + 'keyframes ' + node.name, node.position)
    + this.emit(
      ' {\n'
      + this.indent(1))
    + this.mapVisit(node.keyframes, '\n')
    + this.emit(
        this.indent(-1)
        + '}');
};

/**
 * Visit keyframe node.
 */

Compiler.prototype.keyframe = function(node){
  var decls = node.declarations;

  return this.emit(this.indent())
    + this.emit(node.values.join(', '), node.position)
    + this.emit(
      ' {\n'
      + this.indent(1))
    + this.mapVisit(decls, '\n')
    + this.emit(
      this.indent(-1)
      + '\n'
      + this.indent() + '}\n');
};

/**
 * Visit page node.
 */

Compiler.prototype.page = function(node){
  var sel = node.selectors.length
    ? node.selectors.join(', ') + ' '
    : '';

  return this.emit('@page ' + sel, node.position)
    + this.emit('{\n')
    + this.emit(this.indent(1))
    + this.mapVisit(node.declarations, '\n')
    + this.emit(this.indent(-1))
    + this.emit('\n}');
};

/**
 * Visit font-face node.
 */

Compiler.prototype['font-face'] = function(node){
  return this.emit('@font-face ', node.position)
    + this.emit('{\n')
    + this.emit(this.indent(1))
    + this.mapVisit(node.declarations, '\n')
    + this.emit(this.indent(-1))
    + this.emit('\n}');
};

/**
 * Visit host node.
 */

Compiler.prototype.host = function(node){
  return this.emit('@host', node.position)
    + this.emit(
        ' {\n'
        + this.indent(1))
    + this.mapVisit(node.rules, '\n\n')
    + this.emit(
        this.indent(-1)
        + '\n}');
};

/**
 * Visit custom-media node.
 */

Compiler.prototype['custom-media'] = function(node){
  return this.emit('@custom-media ' + node.name + ' ' + node.media + ';', node.position);
};

/**
 * Visit rule node.
 */

Compiler.prototype.rule = function(node){
  var indent = this.indent();
  var decls = node.declarations;
  if (!decls.length) return '';

  return this.emit(node.selectors.map(function(s){ return indent + s }).join(',\n'), node.position)
    + this.emit(' {\n')
    + this.emit(this.indent(1))
    + this.mapVisit(decls, '\n')
    + this.emit(this.indent(-1))
    + this.emit('\n' + this.indent() + '}');
};

/**
 * Visit declaration node.
 */

Compiler.prototype.declaration = function(node){
  return this.emit(this.indent())
    + this.emit(node.property + ': ' + node.value, node.position)
    + this.emit(';');
};

/**
 * Increase, decrease or return current indentation.
 */

Compiler.prototype.indent = function(level) {
  this.level = this.level || 1;

  if (null != level) {
    this.level += level;
    return '';
  }

  return Array(this.level).join(this.indentation || '  ');
};


/***/ }),

/***/ "./node_modules/css/lib/stringify/index.js":
/*!*************************************************!*\
  !*** ./node_modules/css/lib/stringify/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var Compressed = __webpack_require__(/*! ./compress */ "./node_modules/css/lib/stringify/compress.js");
var Identity = __webpack_require__(/*! ./identity */ "./node_modules/css/lib/stringify/identity.js");

/**
 * Stringfy the given AST `node`.
 *
 * Options:
 *
 *  - `compress` space-optimized output
 *  - `sourcemap` return an object with `.code` and `.map`
 *
 * @param {Object} node
 * @param {Object} [options]
 * @return {String}
 * @api public
 */

module.exports = function(node, options){
  options = options || {};

  var compiler = options.compress
    ? new Compressed(options)
    : new Identity(options);

  // source maps
  if (options.sourcemap) {
    var sourcemaps = __webpack_require__(/*! ./source-map-support */ "./node_modules/css/lib/stringify/source-map-support.js");
    sourcemaps(compiler);

    var code = compiler.compile(node);
    compiler.applySourceMaps();

    var map = options.sourcemap === 'generator'
      ? compiler.map
      : compiler.map.toJSON();

    return { code: code, map: map };
  }

  var code = compiler.compile(node);
  return code;
};


/***/ }),

/***/ "./node_modules/css/lib/stringify/source-map-support.js":
/*!**************************************************************!*\
  !*** ./node_modules/css/lib/stringify/source-map-support.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var SourceMap = __webpack_require__(/*! source-map */ "./node_modules/source-map/source-map.js").SourceMapGenerator;
var SourceMapConsumer = __webpack_require__(/*! source-map */ "./node_modules/source-map/source-map.js").SourceMapConsumer;
var sourceMapResolve = __webpack_require__(/*! source-map-resolve */ "./node_modules/source-map-resolve/source-map-resolve.js");
var urix = __webpack_require__(/*! urix */ "./node_modules/urix/index.js");
var fs = __webpack_require__(/*! fs */ "./node_modules/node-libs-browser/mock/empty.js");
var path = __webpack_require__(/*! path */ "./node_modules/path-browserify/index.js");

/**
 * Expose `mixin()`.
 */

module.exports = mixin;

/**
 * Mixin source map support into `compiler`.
 *
 * @param {Compiler} compiler
 * @api public
 */

function mixin(compiler) {
  compiler._comment = compiler.comment;
  compiler.map = new SourceMap();
  compiler.position = { line: 1, column: 1 };
  compiler.files = {};
  for (var k in exports) compiler[k] = exports[k];
}

/**
 * Update position.
 *
 * @param {String} str
 * @api private
 */

exports.updatePosition = function(str) {
  var lines = str.match(/\n/g);
  if (lines) this.position.line += lines.length;
  var i = str.lastIndexOf('\n');
  this.position.column = ~i ? str.length - i : this.position.column + str.length;
};

/**
 * Emit `str`.
 *
 * @param {String} str
 * @param {Object} [pos]
 * @return {String}
 * @api private
 */

exports.emit = function(str, pos) {
  if (pos) {
    var sourceFile = urix(pos.source || 'source.css');

    this.map.addMapping({
      source: sourceFile,
      generated: {
        line: this.position.line,
        column: Math.max(this.position.column - 1, 0)
      },
      original: {
        line: pos.start.line,
        column: pos.start.column - 1
      }
    });

    this.addFile(sourceFile, pos);
  }

  this.updatePosition(str);

  return str;
};

/**
 * Adds a file to the source map output if it has not already been added
 * @param {String} file
 * @param {Object} pos
 */

exports.addFile = function(file, pos) {
  if (typeof pos.content !== 'string') return;
  if (Object.prototype.hasOwnProperty.call(this.files, file)) return;

  this.files[file] = pos.content;
};

/**
 * Applies any original source maps to the output and embeds the source file
 * contents in the source map.
 */

exports.applySourceMaps = function() {
  Object.keys(this.files).forEach(function(file) {
    var content = this.files[file];
    this.map.setSourceContent(file, content);

    if (this.options.inputSourcemaps !== false) {
      var originalMap = sourceMapResolve.resolveSync(
        content, file, fs.readFileSync);
      if (originalMap) {
        var map = new SourceMapConsumer(originalMap.map);
        var relativeTo = originalMap.sourcesRelativeTo;
        this.map.applySourceMap(map, file, urix(path.dirname(relativeTo)));
      }
    }
  }, this);
};

/**
 * Process comments, drops sourceMap comments.
 * @param {Object} node
 */

exports.comment = function(node) {
  if (/^# sourceMappingURL=/.test(node.comment))
    return this.emit('', node.position);
  else
    return this._comment(node);
};


/***/ }),

/***/ "./node_modules/fuse.js/dist/fuse.js":
/*!*******************************************!*\
  !*** ./node_modules/fuse.js/dist/fuse.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * Fuse.js v3.4.5 - Lightweight fuzzy-search (http://fusejs.io)
 * 
 * Copyright (c) 2012-2017 Kirollos Risk (http://kiro.me)
 * All Rights Reserved. Apache Software License 2.0
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 */
!function(e,t){ true?module.exports=t():undefined}(this,function(){return function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=1)}([function(e,t){e.exports=function(e){return Array.isArray?Array.isArray(e):"[object Array]"===Object.prototype.toString.call(e)}},function(e,t,n){function r(e){return(r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function o(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var i=n(2),a=n(8),s=n(0),c=function(){function e(t,n){var r=n.location,o=void 0===r?0:r,i=n.distance,s=void 0===i?100:i,c=n.threshold,h=void 0===c?.6:c,l=n.maxPatternLength,u=void 0===l?32:l,f=n.caseSensitive,d=void 0!==f&&f,v=n.tokenSeparator,p=void 0===v?/ +/g:v,g=n.findAllMatches,y=void 0!==g&&g,m=n.minMatchCharLength,k=void 0===m?1:m,S=n.id,x=void 0===S?null:S,b=n.keys,M=void 0===b?[]:b,_=n.shouldSort,L=void 0===_||_,w=n.getFn,A=void 0===w?a:w,C=n.sortFn,I=void 0===C?function(e,t){return e.score-t.score}:C,O=n.tokenize,j=void 0!==O&&O,P=n.matchAllTokens,F=void 0!==P&&P,T=n.includeMatches,z=void 0!==T&&T,E=n.includeScore,K=void 0!==E&&E,$=n.verbose,J=void 0!==$&&$;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.options={location:o,distance:s,threshold:h,maxPatternLength:u,isCaseSensitive:d,tokenSeparator:p,findAllMatches:y,minMatchCharLength:k,id:x,keys:M,includeMatches:z,includeScore:K,shouldSort:L,getFn:A,sortFn:I,verbose:J,tokenize:j,matchAllTokens:F},this.setCollection(t)}var t,n,c;return t=e,(n=[{key:"setCollection",value:function(e){return this.list=e,e}},{key:"search",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{limit:!1};this._log('---------\nSearch pattern: "'.concat(e,'"'));var n=this._prepareSearchers(e),r=n.tokenSearchers,o=n.fullSearcher,i=this._search(r,o),a=i.weights,s=i.results;return this._computeScore(a,s),this.options.shouldSort&&this._sort(s),t.limit&&"number"==typeof t.limit&&(s=s.slice(0,t.limit)),this._format(s)}},{key:"_prepareSearchers",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",t=[];if(this.options.tokenize)for(var n=e.split(this.options.tokenSeparator),r=0,o=n.length;r<o;r+=1)t.push(new i(n[r],this.options));return{tokenSearchers:t,fullSearcher:new i(e,this.options)}}},{key:"_search",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1?arguments[1]:void 0,n=this.list,r={},o=[];if("string"==typeof n[0]){for(var i=0,a=n.length;i<a;i+=1)this._analyze({key:"",value:n[i],record:i,index:i},{resultMap:r,results:o,tokenSearchers:e,fullSearcher:t});return{weights:null,results:o}}for(var s={},c=0,h=n.length;c<h;c+=1)for(var l=n[c],u=0,f=this.options.keys.length;u<f;u+=1){var d=this.options.keys[u];if("string"!=typeof d){if(s[d.name]={weight:1-d.weight||1},d.weight<=0||d.weight>1)throw new Error("Key weight has to be > 0 and <= 1");d=d.name}else s[d]={weight:1};this._analyze({key:d,value:this.options.getFn(l,d),record:l,index:c},{resultMap:r,results:o,tokenSearchers:e,fullSearcher:t})}return{weights:s,results:o}}},{key:"_analyze",value:function(e,t){var n=e.key,r=e.arrayIndex,o=void 0===r?-1:r,i=e.value,a=e.record,c=e.index,h=t.tokenSearchers,l=void 0===h?[]:h,u=t.fullSearcher,f=void 0===u?[]:u,d=t.resultMap,v=void 0===d?{}:d,p=t.results,g=void 0===p?[]:p;if(null!=i){var y=!1,m=-1,k=0;if("string"==typeof i){this._log("\nKey: ".concat(""===n?"-":n));var S=f.search(i);if(this._log('Full text: "'.concat(i,'", score: ').concat(S.score)),this.options.tokenize){for(var x=i.split(this.options.tokenSeparator),b=[],M=0;M<l.length;M+=1){var _=l[M];this._log('\nPattern: "'.concat(_.pattern,'"'));for(var L=!1,w=0;w<x.length;w+=1){var A=x[w],C=_.search(A),I={};C.isMatch?(I[A]=C.score,y=!0,L=!0,b.push(C.score)):(I[A]=1,this.options.matchAllTokens||b.push(1)),this._log('Token: "'.concat(A,'", score: ').concat(I[A]))}L&&(k+=1)}m=b[0];for(var O=b.length,j=1;j<O;j+=1)m+=b[j];m/=O,this._log("Token score average:",m)}var P=S.score;m>-1&&(P=(P+m)/2),this._log("Score average:",P);var F=!this.options.tokenize||!this.options.matchAllTokens||k>=l.length;if(this._log("\nCheck Matches: ".concat(F)),(y||S.isMatch)&&F){var T=v[c];T?T.output.push({key:n,arrayIndex:o,value:i,score:P,matchedIndices:S.matchedIndices}):(v[c]={item:a,output:[{key:n,arrayIndex:o,value:i,score:P,matchedIndices:S.matchedIndices}]},g.push(v[c]))}}else if(s(i))for(var z=0,E=i.length;z<E;z+=1)this._analyze({key:n,arrayIndex:z,value:i[z],record:a,index:c},{resultMap:v,results:g,tokenSearchers:l,fullSearcher:f})}}},{key:"_computeScore",value:function(e,t){this._log("\n\nComputing score:\n");for(var n=0,r=t.length;n<r;n+=1){for(var o=t[n].output,i=o.length,a=1,s=1,c=0;c<i;c+=1){var h=e?e[o[c].key].weight:1,l=(1===h?o[c].score:o[c].score||.001)*h;1!==h?s=Math.min(s,l):(o[c].nScore=l,a*=l)}t[n].score=1===s?a:s,this._log(t[n])}}},{key:"_sort",value:function(e){this._log("\n\nSorting...."),e.sort(this.options.sortFn)}},{key:"_format",value:function(e){var t=[];if(this.options.verbose){var n=[];this._log("\n\nOutput:\n\n",JSON.stringify(e,function(e,t){if("object"===r(t)&&null!==t){if(-1!==n.indexOf(t))return;n.push(t)}return t})),n=null}var o=[];this.options.includeMatches&&o.push(function(e,t){var n=e.output;t.matches=[];for(var r=0,o=n.length;r<o;r+=1){var i=n[r];if(0!==i.matchedIndices.length){var a={indices:i.matchedIndices,value:i.value};i.key&&(a.key=i.key),i.hasOwnProperty("arrayIndex")&&i.arrayIndex>-1&&(a.arrayIndex=i.arrayIndex),t.matches.push(a)}}}),this.options.includeScore&&o.push(function(e,t){t.score=e.score});for(var i=0,a=e.length;i<a;i+=1){var s=e[i];if(this.options.id&&(s.item=this.options.getFn(s.item,this.options.id)[0]),o.length){for(var c={item:s.item},h=0,l=o.length;h<l;h+=1)o[h](s,c);t.push(c)}else t.push(s.item)}return t}},{key:"_log",value:function(){var e;this.options.verbose&&(e=console).log.apply(e,arguments)}}])&&o(t.prototype,n),c&&o(t,c),e}();e.exports=c},function(e,t,n){function r(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var o=n(3),i=n(4),a=n(7),s=function(){function e(t,n){var r=n.location,o=void 0===r?0:r,i=n.distance,s=void 0===i?100:i,c=n.threshold,h=void 0===c?.6:c,l=n.maxPatternLength,u=void 0===l?32:l,f=n.isCaseSensitive,d=void 0!==f&&f,v=n.tokenSeparator,p=void 0===v?/ +/g:v,g=n.findAllMatches,y=void 0!==g&&g,m=n.minMatchCharLength,k=void 0===m?1:m;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.options={location:o,distance:s,threshold:h,maxPatternLength:u,isCaseSensitive:d,tokenSeparator:p,findAllMatches:y,minMatchCharLength:k},this.pattern=this.options.isCaseSensitive?t:t.toLowerCase(),this.pattern.length<=u&&(this.patternAlphabet=a(this.pattern))}var t,n,s;return t=e,(n=[{key:"search",value:function(e){if(this.options.isCaseSensitive||(e=e.toLowerCase()),this.pattern===e)return{isMatch:!0,score:0,matchedIndices:[[0,e.length-1]]};var t=this.options,n=t.maxPatternLength,r=t.tokenSeparator;if(this.pattern.length>n)return o(e,this.pattern,r);var a=this.options,s=a.location,c=a.distance,h=a.threshold,l=a.findAllMatches,u=a.minMatchCharLength;return i(e,this.pattern,this.patternAlphabet,{location:s,distance:c,threshold:h,findAllMatches:l,minMatchCharLength:u})}}])&&r(t.prototype,n),s&&r(t,s),e}();e.exports=s},function(e,t){var n=/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g;e.exports=function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:/ +/g,o=new RegExp(t.replace(n,"\\$&").replace(r,"|")),i=e.match(o),a=!!i,s=[];if(a)for(var c=0,h=i.length;c<h;c+=1){var l=i[c];s.push([e.indexOf(l),l.length-1])}return{score:a?.5:1,isMatch:a,matchedIndices:s}}},function(e,t,n){var r=n(5),o=n(6);e.exports=function(e,t,n,i){for(var a=i.location,s=void 0===a?0:a,c=i.distance,h=void 0===c?100:c,l=i.threshold,u=void 0===l?.6:l,f=i.findAllMatches,d=void 0!==f&&f,v=i.minMatchCharLength,p=void 0===v?1:v,g=s,y=e.length,m=u,k=e.indexOf(t,g),S=t.length,x=[],b=0;b<y;b+=1)x[b]=0;if(-1!==k){var M=r(t,{errors:0,currentLocation:k,expectedLocation:g,distance:h});if(m=Math.min(M,m),-1!==(k=e.lastIndexOf(t,g+S))){var _=r(t,{errors:0,currentLocation:k,expectedLocation:g,distance:h});m=Math.min(_,m)}}k=-1;for(var L=[],w=1,A=S+y,C=1<<S-1,I=0;I<S;I+=1){for(var O=0,j=A;O<j;){r(t,{errors:I,currentLocation:g+j,expectedLocation:g,distance:h})<=m?O=j:A=j,j=Math.floor((A-O)/2+O)}A=j;var P=Math.max(1,g-j+1),F=d?y:Math.min(g+j,y)+S,T=Array(F+2);T[F+1]=(1<<I)-1;for(var z=F;z>=P;z-=1){var E=z-1,K=n[e.charAt(E)];if(K&&(x[E]=1),T[z]=(T[z+1]<<1|1)&K,0!==I&&(T[z]|=(L[z+1]|L[z])<<1|1|L[z+1]),T[z]&C&&(w=r(t,{errors:I,currentLocation:E,expectedLocation:g,distance:h}))<=m){if(m=w,(k=E)<=g)break;P=Math.max(1,2*g-k)}}if(r(t,{errors:I+1,currentLocation:g,expectedLocation:g,distance:h})>m)break;L=T}return{isMatch:k>=0,score:0===w?.001:w,matchedIndices:o(x,p)}}},function(e,t){e.exports=function(e,t){var n=t.errors,r=void 0===n?0:n,o=t.currentLocation,i=void 0===o?0:o,a=t.expectedLocation,s=void 0===a?0:a,c=t.distance,h=void 0===c?100:c,l=r/e.length,u=Math.abs(s-i);return h?l+u/h:u?1:l}},function(e,t){e.exports=function(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=[],r=-1,o=-1,i=0,a=e.length;i<a;i+=1){var s=e[i];s&&-1===r?r=i:s||-1===r||((o=i-1)-r+1>=t&&n.push([r,o]),r=-1)}return e[i-1]&&i-r>=t&&n.push([r,i-1]),n}},function(e,t){e.exports=function(e){for(var t={},n=e.length,r=0;r<n;r+=1)t[e.charAt(r)]=0;for(var o=0;o<n;o+=1)t[e.charAt(o)]|=1<<n-o-1;return t}},function(e,t,n){var r=n(0);e.exports=function(e,t){return function e(t,n,o){if(n){var i=n.indexOf("."),a=n,s=null;-1!==i&&(a=n.slice(0,i),s=n.slice(i+1));var c=t[a];if(null!=c)if(s||"string"!=typeof c&&"number"!=typeof c)if(r(c))for(var h=0,l=c.length;h<l;h+=1)e(c[h],s,o);else s&&e(c,s,o);else o.push(c.toString())}else o.push(t);return o}(e,t,[])}}])});

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "./node_modules/nearley/lib/nearley.js":
/*!*********************************************!*\
  !*** ./node_modules/nearley/lib/nearley.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function(root, factory) {
    if ( true && module.exports) {
        module.exports = factory();
    } else {
        root.nearley = factory();
    }
}(this, function() {

    function Rule(name, symbols, postprocess) {
        this.id = ++Rule.highestId;
        this.name = name;
        this.symbols = symbols;        // a list of literal | regex class | nonterminal
        this.postprocess = postprocess;
        return this;
    }
    Rule.highestId = 0;

    Rule.prototype.toString = function(withCursorAt) {
        function stringifySymbolSequence (e) {
            return e.literal ? JSON.stringify(e.literal) :
                   e.type ? '%' + e.type : e.toString();
        }
        var symbolSequence = (typeof withCursorAt === "undefined")
                             ? this.symbols.map(stringifySymbolSequence).join(' ')
                             : (   this.symbols.slice(0, withCursorAt).map(stringifySymbolSequence).join(' ')
                                 + " ● "
                                 + this.symbols.slice(withCursorAt).map(stringifySymbolSequence).join(' ')     );
        return this.name + " → " + symbolSequence;
    }


    // a State is a rule at a position from a given starting point in the input stream (reference)
    function State(rule, dot, reference, wantedBy) {
        this.rule = rule;
        this.dot = dot;
        this.reference = reference;
        this.data = [];
        this.wantedBy = wantedBy;
        this.isComplete = this.dot === rule.symbols.length;
    }

    State.prototype.toString = function() {
        return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);
    };

    State.prototype.nextState = function(child) {
        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);
        state.left = this;
        state.right = child;
        if (state.isComplete) {
            state.data = state.build();
        }
        return state;
    };

    State.prototype.build = function() {
        var children = [];
        var node = this;
        do {
            children.push(node.right.data);
            node = node.left;
        } while (node.left);
        children.reverse();
        return children;
    };

    State.prototype.finish = function() {
        if (this.rule.postprocess) {
            this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);
        }
    };


    function Column(grammar, index) {
        this.grammar = grammar;
        this.index = index;
        this.states = [];
        this.wants = {}; // states indexed by the non-terminal they expect
        this.scannable = []; // list of states that expect a token
        this.completed = {}; // states that are nullable
    }


    Column.prototype.process = function(nextColumn) {
        var states = this.states;
        var wants = this.wants;
        var completed = this.completed;

        for (var w = 0; w < states.length; w++) { // nb. we push() during iteration
            var state = states[w];

            if (state.isComplete) {
                state.finish();
                if (state.data !== Parser.fail) {
                    // complete
                    var wantedBy = state.wantedBy;
                    for (var i = wantedBy.length; i--; ) { // this line is hot
                        var left = wantedBy[i];
                        this.complete(left, state);
                    }

                    // special-case nullables
                    if (state.reference === this.index) {
                        // make sure future predictors of this rule get completed.
                        var exp = state.rule.name;
                        (this.completed[exp] = this.completed[exp] || []).push(state);
                    }
                }

            } else {
                // queue scannable states
                var exp = state.rule.symbols[state.dot];
                if (typeof exp !== 'string') {
                    this.scannable.push(state);
                    continue;
                }

                // predict
                if (wants[exp]) {
                    wants[exp].push(state);

                    if (completed.hasOwnProperty(exp)) {
                        var nulls = completed[exp];
                        for (var i = 0; i < nulls.length; i++) {
                            var right = nulls[i];
                            this.complete(state, right);
                        }
                    }
                } else {
                    wants[exp] = [state];
                    this.predict(exp);
                }
            }
        }
    }

    Column.prototype.predict = function(exp) {
        var rules = this.grammar.byName[exp] || [];

        for (var i = 0; i < rules.length; i++) {
            var r = rules[i];
            var wantedBy = this.wants[exp];
            var s = new State(r, 0, this.index, wantedBy);
            this.states.push(s);
        }
    }

    Column.prototype.complete = function(left, right) {
        var copy = left.nextState(right);
        this.states.push(copy);
    }


    function Grammar(rules, start) {
        this.rules = rules;
        this.start = start || this.rules[0].name;
        var byName = this.byName = {};
        this.rules.forEach(function(rule) {
            if (!byName.hasOwnProperty(rule.name)) {
                byName[rule.name] = [];
            }
            byName[rule.name].push(rule);
        });
    }

    // So we can allow passing (rules, start) directly to Parser for backwards compatibility
    Grammar.fromCompiled = function(rules, start) {
        var lexer = rules.Lexer;
        if (rules.ParserStart) {
          start = rules.ParserStart;
          rules = rules.ParserRules;
        }
        var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });
        var g = new Grammar(rules, start);
        g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable
        return g;
    }


    function StreamLexer() {
      this.reset("");
    }

    StreamLexer.prototype.reset = function(data, state) {
        this.buffer = data;
        this.index = 0;
        this.line = state ? state.line : 1;
        this.lastLineBreak = state ? -state.col : 0;
    }

    StreamLexer.prototype.next = function() {
        if (this.index < this.buffer.length) {
            var ch = this.buffer[this.index++];
            if (ch === '\n') {
              this.line += 1;
              this.lastLineBreak = this.index;
            }
            return {value: ch};
        }
    }

    StreamLexer.prototype.save = function() {
      return {
        line: this.line,
        col: this.index - this.lastLineBreak,
      }
    }

    StreamLexer.prototype.formatError = function(token, message) {
        // nb. this gets called after consuming the offending token,
        // so the culprit is index-1
        var buffer = this.buffer;
        if (typeof buffer === 'string') {
            var nextLineBreak = buffer.indexOf('\n', this.index);
            if (nextLineBreak === -1) nextLineBreak = buffer.length;
            var line = buffer.substring(this.lastLineBreak, nextLineBreak)
            var col = this.index - this.lastLineBreak;
            message += " at line " + this.line + " col " + col + ":\n\n";
            message += "  " + line + "\n"
            message += "  " + Array(col).join(" ") + "^"
            return message;
        } else {
            return message + " at index " + (this.index - 1);
        }
    }


    function Parser(rules, start, options) {
        if (rules instanceof Grammar) {
            var grammar = rules;
            var options = start;
        } else {
            var grammar = Grammar.fromCompiled(rules, start);
        }
        this.grammar = grammar;

        // Read options
        this.options = {
            keepHistory: false,
            lexer: grammar.lexer || new StreamLexer,
        };
        for (var key in (options || {})) {
            this.options[key] = options[key];
        }

        // Setup lexer
        this.lexer = this.options.lexer;
        this.lexerState = undefined;

        // Setup a table
        var column = new Column(grammar, 0);
        var table = this.table = [column];

        // I could be expecting anything.
        column.wants[grammar.start] = [];
        column.predict(grammar.start);
        // TODO what if start rule is nullable?
        column.process();
        this.current = 0; // token index
    }

    // create a reserved token for indicating a parse fail
    Parser.fail = {};

    Parser.prototype.feed = function(chunk) {
        var lexer = this.lexer;
        lexer.reset(chunk, this.lexerState);

        var token;
        while (token = lexer.next()) {
            // We add new states to table[current+1]
            var column = this.table[this.current];

            // GC unused states
            if (!this.options.keepHistory) {
                delete this.table[this.current - 1];
            }

            var n = this.current + 1;
            var nextColumn = new Column(this.grammar, n);
            this.table.push(nextColumn);

            // Advance all tokens that expect the symbol
            var literal = token.text !== undefined ? token.text : token.value;
            var value = lexer.constructor === StreamLexer ? token.value : token;
            var scannable = column.scannable;
            for (var w = scannable.length; w--; ) {
                var state = scannable[w];
                var expect = state.rule.symbols[state.dot];
                // Try to consume the token
                // either regex or literal
                if (expect.test ? expect.test(value) :
                    expect.type ? expect.type === token.type
                                : expect.literal === literal) {
                    // Add it
                    var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});
                    nextColumn.states.push(next);
                }
            }

            // Next, for each of the rules, we either
            // (a) complete it, and try to see if the reference row expected that
            //     rule
            // (b) predict the next nonterminal it expects by adding that
            //     nonterminal's start state
            // To prevent duplication, we also keep track of rules we have already
            // added

            nextColumn.process();

            // If needed, throw an error:
            if (nextColumn.states.length === 0) {
                // No states at all! This is not good.
                var err = new Error(this.reportError(token));
                err.offset = this.current;
                err.token = token;
                throw err;
            }

            // maybe save lexer state
            if (this.options.keepHistory) {
              column.lexerState = lexer.save()
            }

            this.current++;
        }
        if (column) {
          this.lexerState = lexer.save()
        }

        // Incrementally keep track of results
        this.results = this.finish();

        // Allow chaining, for whatever it's worth
        return this;
    };

    Parser.prototype.reportError = function(token) {
        var lines = [];
        var tokenDisplay = (token.type ? token.type + " token: " : "") + JSON.stringify(token.value !== undefined ? token.value : token);
        lines.push(this.lexer.formatError(token, "Syntax error"));
        lines.push('Unexpected ' + tokenDisplay + '. Instead, I was expecting to see one of the following:\n');
        var lastColumnIndex = this.table.length - 2;
        var lastColumn = this.table[lastColumnIndex];
        var expectantStates = lastColumn.states
            .filter(function(state) {
                const nextSymbol = state.rule.symbols[state.dot];
                return nextSymbol && typeof nextSymbol !== "string";
            });
        
        // Display a "state stack" for each expectant state
        // - which shows you how this state came to be, step by step. 
        // If there is more than one derivation, we only display the first one.
        var stateStacks = expectantStates
            .map(function(state) {
                const stacks = this.buildStateStacks(state, []);
                return stacks[0];
            }, this);
        // Display each state that is expecting a terminal symbol next.
        stateStacks.forEach(function(stateStack) {
            var state = stateStack[0];
            var nextSymbol = state.rule.symbols[state.dot];
            var symbolDisplay = this.getSymbolDisplay(nextSymbol);
            lines.push('A ' + symbolDisplay + ' based on:');
            this.displayStateStack(stateStack, lines);
        }, this);
            
        lines.push("");
        return lines.join("\n");
    };

    Parser.prototype.displayStateStack = function(stateStack, lines) {
        var lastDisplay;
        var sameDisplayCount = 0;
        for (var j = 0; j < stateStack.length; j++) {
            var state = stateStack[j];
            var display = state.rule.toString(state.dot);
            if (display === lastDisplay) {
                sameDisplayCount++;
            } else {
                if (sameDisplayCount > 0) {
                    lines.push('    ⬆ ︎' + sameDisplayCount + ' more lines identical to this');
                }
                sameDisplayCount = 0;
                lines.push('    ' + display);
            }
            lastDisplay = display;
        }
    };

    Parser.prototype.getSymbolDisplay = function(symbol) {
        var type = typeof symbol;
        if (type === "string") {
            return symbol;
        } else if (type === "object" && symbol.literal) {
            return JSON.stringify(symbol.literal);
        } else if (type === "object" && symbol instanceof RegExp) {
            return 'character matching ' + symbol;
        } else if (type === "object" && symbol.type) {
            return symbol.type + ' token';
        } else {
            throw new Error('Unknown symbol type: ' + symbol);
        }
    };

    /*
    Builds a number of "state stacks". You can think of a state stack as the call stack
    of the recursive-descent parser which the Nearley parse algorithm simulates.
    A state stack is represented as an array of state objects. Within a 
    state stack, the first item of the array will be the starting
    state, with each successive item in the array going further back into history.
    
    This function needs to be given a starting state and an empty array representing
    the visited states, and it returns an array of state stacks. 
    
    */
    Parser.prototype.buildStateStacks = function(state, visited) {
        if (visited.indexOf(state) !== -1) {
            // Found cycle, return empty array (meaning no stacks)
            // to eliminate this path from the results, because
            // we don't know how to display it meaningfully
            return [];
        }
        if (state.wantedBy.length === 0) {
            return [[state]];
        }
        var that = this;

        return state.wantedBy.reduce(function(stacks, prevState) {
            return stacks.concat(that.buildStateStacks(
                prevState,
                [state].concat(visited))
                .map(function(stack) {
                    return [state].concat(stack);
                }));
        }, []);
    };

    Parser.prototype.save = function() {
        var column = this.table[this.current];
        column.lexerState = this.lexerState;
        return column;
    };

    Parser.prototype.restore = function(column) {
        var index = column.index;
        this.current = index;
        this.table[index] = column;
        this.table.splice(index + 1);
        this.lexerState = column.lexerState;

        // Incrementally keep track of results
        this.results = this.finish();
    };

    // nb. deprecated: use save/restore instead!
    Parser.prototype.rewind = function(index) {
        if (!this.options.keepHistory) {
            throw new Error('set option `keepHistory` to enable rewinding')
        }
        // nb. recall column (table) indicies fall between token indicies.
        //        col 0   --   token 0   --   col 1
        this.restore(this.table[index]);
    };

    Parser.prototype.finish = function() {
        // Return the possible parsings
        var considerations = [];
        var start = this.grammar.start;
        var column = this.table[this.table.length - 1]
        column.states.forEach(function (t) {
            if (t.rule.name === start
                    && t.dot === t.rule.symbols.length
                    && t.reference === 0
                    && t.data !== Parser.fail) {
                considerations.push(t);
            }
        });
        return considerations.map(function(c) {return c.data; });
    };

    return {
        Parser: Parser,
        Grammar: Grammar,
        Rule: Rule,
    };

}));


/***/ }),

/***/ "./node_modules/node-libs-browser/mock/empty.js":
/*!******************************************************!*\
  !*** ./node_modules/node-libs-browser/mock/empty.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/resolve-url/resolve-url.js":
/*!*************************************************!*\
  !*** ./node_modules/resolve-url/resolve-url.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright 2014 Simon Lydell
// X11 (“MIT”) Licensed. (See LICENSE.)

void (function(root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
  } else {}
}(this, function() {

  function resolveUrl(/* ...urls */) {
    var numUrls = arguments.length

    if (numUrls === 0) {
      throw new Error("resolveUrl requires at least one argument; got none.")
    }

    var base = document.createElement("base")
    base.href = arguments[0]

    if (numUrls === 1) {
      return base.href
    }

    var head = document.getElementsByTagName("head")[0]
    head.insertBefore(base, head.firstChild)

    var a = document.createElement("a")
    var resolved

    for (var index = 1; index < numUrls; index++) {
      a.href = arguments[index]
      resolved = a.href
      base.href = resolved
    }

    head.removeChild(base)

    return resolved
  }

  return resolveUrl

}));


/***/ }),

/***/ "./node_modules/semver-compare/index.js":
/*!**********************************************!*\
  !*** ./node_modules/semver-compare/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function cmp (a, b) {
    var pa = a.split('.');
    var pb = b.split('.');
    for (var i = 0; i < 3; i++) {
        var na = Number(pa[i]);
        var nb = Number(pb[i]);
        if (na > nb) return 1;
        if (nb > na) return -1;
        if (!isNaN(na) && isNaN(nb)) return 1;
        if (isNaN(na) && !isNaN(nb)) return -1;
    }
    return 0;
};


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/source-map-resolve/source-map-resolve.js":
/*!***************************************************************!*\
  !*** ./node_modules/source-map-resolve/source-map-resolve.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(setImmediate) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright 2014, 2015, 2016, 2017 Simon Lydell
// X11 (“MIT”) Licensed. (See LICENSE.)

// Note: source-map-resolve.js is generated from source-map-resolve-node.js and
// source-map-resolve-template.js. Only edit the two latter files, _not_
// source-map-resolve.js!

void (function(root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! source-map-url */ "./node_modules/source-map-url/source-map-url.js"), __webpack_require__(/*! resolve-url */ "./node_modules/resolve-url/resolve-url.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
  } else { var resolveUrl, sourceMappingURL; }
}(this, function(sourceMappingURL, resolveUrl) {

  function callbackAsync(callback, error, result) {
    setImmediate(function() { callback(error, result) })
  }

  function parseMapToJSON(string, data) {
    try {
      return JSON.parse(string.replace(/^\)\]\}'/, ""))
    } catch (error) {
      error.sourceMapData = data
      throw error
    }
  }

  function readSync(read, url, data) {
    var readUrl = url
    try {
      return String(read(readUrl))
    } catch (error) {
      error.sourceMapData = data
      throw error
    }
  }



  function resolveSourceMap(code, codeUrl, read, callback) {
    var mapData
    try {
      mapData = resolveSourceMapHelper(code, codeUrl)
    } catch (error) {
      return callbackAsync(callback, error)
    }
    if (!mapData || mapData.map) {
      return callbackAsync(callback, null, mapData)
    }
    var readUrl = mapData.url
    read(readUrl, function(error, result) {
      if (error) {
        error.sourceMapData = mapData
        return callback(error)
      }
      mapData.map = String(result)
      try {
        mapData.map = parseMapToJSON(mapData.map, mapData)
      } catch (error) {
        return callback(error)
      }
      callback(null, mapData)
    })
  }

  function resolveSourceMapSync(code, codeUrl, read) {
    var mapData = resolveSourceMapHelper(code, codeUrl)
    if (!mapData || mapData.map) {
      return mapData
    }
    mapData.map = readSync(read, mapData.url, mapData)
    mapData.map = parseMapToJSON(mapData.map, mapData)
    return mapData
  }

  var dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/
  var jsonMimeTypeRegex = /^(?:application|text)\/json$/

  function resolveSourceMapHelper(code, codeUrl) {
    var url = sourceMappingURL.getFrom(code)
    if (!url) {
      return null
    }

    var dataUri = url.match(dataUriRegex)
    if (dataUri) {
      var mimeType = dataUri[1]
      var lastParameter = dataUri[2] || ""
      var encoded = dataUri[3] || ""
      var data = {
        sourceMappingURL: url,
        url: null,
        sourcesRelativeTo: codeUrl,
        map: encoded
      }
      if (!jsonMimeTypeRegex.test(mimeType)) {
        var error = new Error("Unuseful data uri mime type: " + (mimeType || "text/plain"))
        error.sourceMapData = data
        throw error
      }
      data.map = parseMapToJSON(
        lastParameter === ";base64" ? atob(encoded) : decodeURIComponent(encoded),
        data
      )
      return data
    }

    var mapUrl = resolveUrl(codeUrl, url)
    return {
      sourceMappingURL: url,
      url: mapUrl,
      sourcesRelativeTo: mapUrl,
      map: null
    }
  }



  function resolveSources(map, mapUrl, read, options, callback) {
    if (typeof options === "function") {
      callback = options
      options = {}
    }
    var pending = map.sources ? map.sources.length : 0
    var result = {
      sourcesResolved: [],
      sourcesContent:  []
    }

    if (pending === 0) {
      callbackAsync(callback, null, result)
      return
    }

    var done = function() {
      pending--
      if (pending === 0) {
        callback(null, result)
      }
    }

    resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
      result.sourcesResolved[index] = fullUrl
      if (typeof sourceContent === "string") {
        result.sourcesContent[index] = sourceContent
        callbackAsync(done, null)
      } else {
        var readUrl = fullUrl
        read(readUrl, function(error, source) {
          result.sourcesContent[index] = error ? error : String(source)
          done()
        })
      }
    })
  }

  function resolveSourcesSync(map, mapUrl, read, options) {
    var result = {
      sourcesResolved: [],
      sourcesContent:  []
    }

    if (!map.sources || map.sources.length === 0) {
      return result
    }

    resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
      result.sourcesResolved[index] = fullUrl
      if (read !== null) {
        if (typeof sourceContent === "string") {
          result.sourcesContent[index] = sourceContent
        } else {
          var readUrl = fullUrl
          try {
            result.sourcesContent[index] = String(read(readUrl))
          } catch (error) {
            result.sourcesContent[index] = error
          }
        }
      }
    })

    return result
  }

  var endingSlash = /\/?$/

  function resolveSourcesHelper(map, mapUrl, options, fn) {
    options = options || {}
    var fullUrl
    var sourceContent
    var sourceRoot
    for (var index = 0, len = map.sources.length; index < len; index++) {
      sourceRoot = null
      if (typeof options.sourceRoot === "string") {
        sourceRoot = options.sourceRoot
      } else if (typeof map.sourceRoot === "string" && options.sourceRoot !== false) {
        sourceRoot = map.sourceRoot
      }
      // If the sourceRoot is the empty string, it is equivalent to not setting
      // the property at all.
      if (sourceRoot === null || sourceRoot === '') {
        fullUrl = resolveUrl(mapUrl, map.sources[index])
      } else {
        // Make sure that the sourceRoot ends with a slash, so that `/scripts/subdir` becomes
        // `/scripts/subdir/<source>`, not `/scripts/<source>`. Pointing to a file as source root
        // does not make sense.
        fullUrl = resolveUrl(mapUrl, sourceRoot.replace(endingSlash, "/"), map.sources[index])
      }
      sourceContent = (map.sourcesContent || [])[index]
      fn(fullUrl, sourceContent, index)
    }
  }



  function resolve(code, codeUrl, read, options, callback) {
    if (typeof options === "function") {
      callback = options
      options = {}
    }
    if (code === null) {
      var mapUrl = codeUrl
      var data = {
        sourceMappingURL: null,
        url: mapUrl,
        sourcesRelativeTo: mapUrl,
        map: null
      }
      var readUrl = mapUrl
      read(readUrl, function(error, result) {
        if (error) {
          error.sourceMapData = data
          return callback(error)
        }
        data.map = String(result)
        try {
          data.map = parseMapToJSON(data.map, data)
        } catch (error) {
          return callback(error)
        }
        _resolveSources(data)
      })
    } else {
      resolveSourceMap(code, codeUrl, read, function(error, mapData) {
        if (error) {
          return callback(error)
        }
        if (!mapData) {
          return callback(null, null)
        }
        _resolveSources(mapData)
      })
    }

    function _resolveSources(mapData) {
      resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function(error, result) {
        if (error) {
          return callback(error)
        }
        mapData.sourcesResolved = result.sourcesResolved
        mapData.sourcesContent  = result.sourcesContent
        callback(null, mapData)
      })
    }
  }

  function resolveSync(code, codeUrl, read, options) {
    var mapData
    if (code === null) {
      var mapUrl = codeUrl
      mapData = {
        sourceMappingURL: null,
        url: mapUrl,
        sourcesRelativeTo: mapUrl,
        map: null
      }
      mapData.map = readSync(read, mapUrl, mapData)
      mapData.map = parseMapToJSON(mapData.map, mapData)
    } else {
      mapData = resolveSourceMapSync(code, codeUrl, read)
      if (!mapData) {
        return null
      }
    }
    var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options)
    mapData.sourcesResolved = result.sourcesResolved
    mapData.sourcesContent  = result.sourcesContent
    return mapData
  }



  return {
    resolveSourceMap:     resolveSourceMap,
    resolveSourceMapSync: resolveSourceMapSync,
    resolveSources:       resolveSources,
    resolveSourcesSync:   resolveSourcesSync,
    resolve:              resolve,
    resolveSync:          resolveSync,
    parseMapToJSON:       parseMapToJSON
  }

}));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/source-map-url/source-map-url.js":
/*!*******************************************************!*\
  !*** ./node_modules/source-map-url/source-map-url.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright 2014 Simon Lydell
// X11 (“MIT”) Licensed. (See LICENSE.)

void (function(root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
  } else {}
}(this, function() {

  var innerRegex = /[#@] sourceMappingURL=([^\s'"]*)/

  var regex = RegExp(
    "(?:" +
      "/\\*" +
      "(?:\\s*\r?\n(?://)?)?" +
      "(?:" + innerRegex.source + ")" +
      "\\s*" +
      "\\*/" +
      "|" +
      "//(?:" + innerRegex.source + ")" +
    ")" +
    "\\s*"
  )

  return {

    regex: regex,
    _innerRegex: innerRegex,

    getFrom: function(code) {
      var match = code.match(regex)
      return (match ? match[1] || match[2] || "" : null)
    },

    existsIn: function(code) {
      return regex.test(code)
    },

    removeFrom: function(code) {
      return code.replace(regex, "")
    },

    insertBefore: function(code, string) {
      var match = code.match(regex)
      if (match) {
        return code.slice(0, match.index) + string + code.slice(match.index)
      } else {
        return code + string
      }
    }
  }

}));


/***/ }),

/***/ "./node_modules/source-map/lib/array-set.js":
/*!**************************************************!*\
  !*** ./node_modules/source-map/lib/array-set.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "./node_modules/source-map/lib/util.js");
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;


/***/ }),

/***/ "./node_modules/source-map/lib/base64-vlq.js":
/*!***************************************************!*\
  !*** ./node_modules/source-map/lib/base64-vlq.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = __webpack_require__(/*! ./base64 */ "./node_modules/source-map/lib/base64.js");

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};


/***/ }),

/***/ "./node_modules/source-map/lib/base64.js":
/*!***********************************************!*\
  !*** ./node_modules/source-map/lib/base64.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};


/***/ }),

/***/ "./node_modules/source-map/lib/binary-search.js":
/*!******************************************************!*\
  !*** ./node_modules/source-map/lib/binary-search.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};


/***/ }),

/***/ "./node_modules/source-map/lib/mapping-list.js":
/*!*****************************************************!*\
  !*** ./node_modules/source-map/lib/mapping-list.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "./node_modules/source-map/lib/util.js");

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;


/***/ }),

/***/ "./node_modules/source-map/lib/quick-sort.js":
/*!***************************************************!*\
  !*** ./node_modules/source-map/lib/quick-sort.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};


/***/ }),

/***/ "./node_modules/source-map/lib/source-map-consumer.js":
/*!************************************************************!*\
  !*** ./node_modules/source-map/lib/source-map-consumer.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "./node_modules/source-map/lib/util.js");
var binarySearch = __webpack_require__(/*! ./binary-search */ "./node_modules/source-map/lib/binary-search.js");
var ArraySet = __webpack_require__(/*! ./array-set */ "./node_modules/source-map/lib/array-set.js").ArraySet;
var base64VLQ = __webpack_require__(/*! ./base64-vlq */ "./node_modules/source-map/lib/base64-vlq.js");
var quickSort = __webpack_require__(/*! ./quick-sort */ "./node_modules/source-map/lib/quick-sort.js").quickSort;

function SourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  if (sourceRoot) {
    sourceRoot = util.normalize(sourceRoot);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this._absoluteSources = this._sources.toArray().map(function (s) {
    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */
BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  }

  // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.
  var i;
  for (i = 0; i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }

  return -1;
};

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function (s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._absoluteSources.slice();
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }

    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;


/***/ }),

/***/ "./node_modules/source-map/lib/source-map-generator.js":
/*!*************************************************************!*\
  !*** ./node_modules/source-map/lib/source-map-generator.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = __webpack_require__(/*! ./base64-vlq */ "./node_modules/source-map/lib/base64-vlq.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/source-map/lib/util.js");
var ArraySet = __webpack_require__(/*! ./array-set */ "./node_modules/source-map/lib/array-set.js").ArraySet;
var MappingList = __webpack_require__(/*! ./mapping-list */ "./node_modules/source-map/lib/mapping-list.js").MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;


/***/ }),

/***/ "./node_modules/source-map/lib/source-node.js":
/*!****************************************************!*\
  !*** ./node_modules/source-map/lib/source-node.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = __webpack_require__(/*! ./source-map-generator */ "./node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator;
var util = __webpack_require__(/*! ./util */ "./node_modules/source-map/lib/util.js");

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      // The last line of a file might not have a newline.
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex] || '';
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || '';
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;


/***/ }),

/***/ "./node_modules/source-map/lib/util.js":
/*!*********************************************!*\
  !*** ./node_modules/source-map/lib/util.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   “sources” entry.  This value is prepended to the individual
    //   entries in the “source” field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   “sourceRoot”, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;


/***/ }),

/***/ "./node_modules/source-map/source-map.js":
/*!***********************************************!*\
  !*** ./node_modules/source-map/source-map.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = __webpack_require__(/*! ./lib/source-map-generator */ "./node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator;
exports.SourceMapConsumer = __webpack_require__(/*! ./lib/source-map-consumer */ "./node_modules/source-map/lib/source-map-consumer.js").SourceMapConsumer;
exports.SourceNode = __webpack_require__(/*! ./lib/source-node */ "./node_modules/source-map/lib/source-node.js").SourceNode;


/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/urix/index.js":
/*!************************************!*\
  !*** ./node_modules/urix/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2014 Simon Lydell
// X11 (“MIT”) Licensed. (See LICENSE.)

var path = __webpack_require__(/*! path */ "./node_modules/path-browserify/index.js")

"use strict"

function urix(aPath) {
  if (path.sep === "\\") {
    return aPath
      .replace(/\\/g, "/")
      .replace(/^[a-z]:\/?/i, "/")
  }
  return aPath
}

module.exports = urix


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/.metadata.generated.ts":
/*!************************************!*\
  !*** ./src/.metadata.generated.ts ***!
  \************************************/
/*! exports provided: everything, staticThemes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "everything", function() { return everything; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "staticThemes", function() { return staticThemes; });
/* harmony import */ var _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../compiler/types/AllTypes */ "./compiler/types/AllTypes.ts");
/* harmony import */ var _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../compiler/metadata/AllMetadata */ "./compiler/metadata/AllMetadata.ts");


let everything = new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["ProgramMetadata"](new Map([["src/excmds.ts", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["FileMetadata"](new Map([]), new Map([["getNativeVersion", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), true)],
            ["getRssLinks", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ObjectType"](new Map([["type", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["url", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["title", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)]]), false, false), false, false)], false, false), false, false), true)],
            ["rssexec", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Execute [[rsscmd]] for an rss link.\n\nIf `url` is undefined, Tridactyl will look for rss links in the current\npage. If it doesn't find any, it will display an error message. If it finds\nmultiple urls, it will offer completions in order for you to select the link\nyou're interested in. If a single rss feed is found, it will automatically\nbe selected.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, true), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["fillinput", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Fills the element matched by `selector` with content and falls back to the last used input if the element can't be found. You probably don't want this; it's used internally for [[editor]].\n\nThat said, `bind gs fillinput null [Tridactyl](https://addons.mozilla.org/en-US/firefox/addon/tridactyl-vim/) is my favourite add-on` could probably come in handy.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["getInput", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("HTMLElement", [], false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false, false), true)],
            ["getinput", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false, false), true)],
            ["getInputSelector", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false), true)],
            ["addTridactylEditorClass", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), true)],
            ["removeTridactylEditorClass", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), true)],
            ["editor", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Opens your favourite editor (which is currently gVim) and fills the last used input with whatever you write into that file.\n**Requires that the native messenger is installed, see [[native]] and [[installnative]]**.\n\nUses the `editorcmd` config option, default = `auto` looks through a list defined in lib/native.ts try find a sensible combination. If it's a bit slow, or chooses the wrong editor, or gives up completely, set editorcmd to something you want. The command must stay in the foreground until the editor exits.\n\nThe editorcmd needs to accept a filename, stay in the foreground while it's edited, save the file and exit. By default the filename is added to the end of editorcmd, if you require control over the position of that argument, the first occurrence of %f in editorcmd is replaced with the filename. %l, if it exists, is replaced with the line number of the cursor and %c with the column number. For example:\n```\nset editorcmd terminator -u -e \"vim %f -c 'normal %lG%cl'\"\n```\n\nYou're probably better off using the default insert mode bind of `<C-i>` (Ctrl-i) to access this.\n\nThis function returns a tuple containing the path to the file that was opened by the editor and its content. This enables creating commands such as the following one, which deletes the temporary file created by the editor:\n```\nalias editor_rm composite editor | jsb -p tri.native.run(`rm -f '${JS_ARG[0]}'`)\nbind --mode=insert <C-i> editor_rm\nbind --mode=input <C-i> editor_rm\n```", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false)], false, false), false, false), false)],
            ["guiset_quiet", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Like [[guiset]] but quieter.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["guiset", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Change which parts of the Firefox user interface are shown. **NB: This feature is experimental and might break stuff.**\n\nMight mangle your userChrome. Requires native messenger, and you must restart Firefox each time to see any changes (this can be done using [[restart]]). <!-- (unless you enable addon debugging and refresh using the browser toolbox) -->\n\nAlso flips the preference `toolkit.legacyUserProfileCustomizations.stylesheets` to true so that FF will read your userChrome.\n\nView available rules and options [here](/static/docs/modules/_src_lib_css_util_.html#potentialrules) and [here](/static/docs/modules/_src_lib_css_util_.html#metarules).\n\nExample usage: `guiset gui none`, `guiset gui full`, `guiset tabs autohide`.\n\nSome of the available options:\n\n- gui\n      - full\n      - none\n\n- tabs\n      - always\n      - autohide\n\n- navbar\n      - always\n      - autohide\n      - none\n\n- hoverlink (the little link that appears when you hover over a link)\n      - none\n      - left\n      - right\n      - top-left\n      - top-right\n\n- statuspanel (hoverlink + the indicator that appears when a website is loading)\n      - none\n      - left\n      - right\n      - top-left\n      - top-right\n\nIf you want to use guiset in your tridactylrc, you might want to use [[guiset_quiet]] instead.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["cssparse", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), true)],
            ["loadtheme", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), true)],
            ["unloadtheme", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), true)],
            ["colourscheme", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Changes the current theme.\n\nIf THEMENAME is any of the themes that can be found in the [Tridactyl repo](https://github.com/tridactyl/tridactyl/tree/master/src/static/themes) (e.g. 'dark'), the theme will be loaded from Tridactyl's internal storage.\n\nIf THEMENAME is set to any other value, Tridactyl will attempt to use its native binary (see [[native]]) in order to load a CSS file named THEMENAME from disk. The CSS file has to be in a directory named \"themes\" and this directory has to be in the same directory as your tridactylrc.\n\nNote that the theme name should NOT contain any dot.\n\nExample: `:colourscheme mysupertheme`\nOn linux, this will load ~/.config/tridactyl/themes/mysupertheme.css", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["setpref", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Write a setting to your user.js file.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false), false)],
            ["fixamo_quiet", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Like [[fixamo]] but quieter.\n\nNow purely a placebo as [[fixamo]] has been removed.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["fixamo", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Used to simply set\n```js\n  \"privacy.resistFingerprinting.block_mozAddonManager\":true\n  \"extensions.webextensions.restrictedDomains\":\"\"\n```\nin about:config via user.js so that Tridactyl (and other extensions!) can be used on addons.mozilla.org and other sites.\n\nRemoved at the request of the Firefox Security team. Replacements exist in our exemplar RC file.\n\nRequires `native` and a `restart`.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["nativeopen", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Uses the native messenger to open URLs.\n\n**Be *seriously* careful with this:**\n\n1. the implementation basically execs `firefox --new-tab <your shell escaped string here>`\n2. you can use it to open any URL you can open in the Firefox address bar,\n    including ones that might cause side effects (firefox does not guarantee\n    that about: pages ignore query strings).\n\nYou've been warned.\n\nThis uses the [[browser]] setting to know which binary to call. If you need to pass additional arguments to firefox (e.g. '--new-window'), make sure they appear before the url.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["exclaim", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Run command in /bin/sh (unless you're on Windows), and print the output in the command line. Non-zero exit codes and stderr are ignored, currently.\n\nRequires the native messenger, obviously.\n\nIf you want to use a different shell, just prepend your command with whatever the invocation is and keep in mind that most shells require quotes around the command to be executed, e.g. `:exclaim xonsh -c \"1+2\"`.\n\nAliased to `!` but the exclamation mark **must be followed with a space**.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["exclaim_quiet", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Like exclaim, but without any output to the command line.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["native", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Tells you if the native messenger is installed and its version.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["nativeinstall", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Simply copies \"curl -fsSl https://raw.githubusercontent.com/tridactyl/tridactyl/master/native/install.sh | bash\" to the clipboard and tells the user to run it.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["mktridactylrc", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Writes current config to a file.\n\nWith no arguments supplied the excmd will try to find an appropriate\nconfig path and write the rc file to there. Any argument given to the\nexcmd excluding the `-f` flag will be treated as a path to write the rc\nfile to relative to the native messenger's location (`~/.local/share/tridactyl/`). By default, it silently refuses to overwrite existing files.\n\nThe RC file will be split into sections that will be created if a config\nproperty is discovered within one of them:\n- General settings\n- Binds\n- Aliases\n- Autocmds\n- Autocontainers\n- Logging\n\nNote:\n- Subconfig paths fall back to using `js tri.config.set(key: obj)` notation.\n- This method is also used as a fallback mechanism for objects that didn't hit\n  any of the heuristics.\n\nAvailable flags:\n- `-f` will overwrite the config file if it exists.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["source", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Runs an RC file from disk.\n\nIf no argument given, it will try to open ~/.tridactylrc, ~/.config/tridactyl/tridactylrc or $XDG_CONFIG_HOME/tridactyl/tridactylrc in reverse order. You may use a `_` in place of a leading `.` if you wish, e.g, if you use Windows.\n\nOn Windows, the `~` expands to `%USERPROFILE%`.\n\nThe RC file is just a bunch of Tridactyl excmds (i.e, the stuff on this help page). Settings persist in local storage; add `sanitise tridactyllocal tridactylsync` to make it more Vim like. There's an [example file](https://raw.githubusercontent.com/cmcaine/tridactyl/master/.tridactylrc) if you want it.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["source_quiet", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Same as [[source]] but suppresses all errors", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["updatenative", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Updates the native messenger if it is installed, using our GitHub repo. This is run every time Tridactyl is updated.\n\nIf you want to disable this, or point it to your own native messenger, edit the `nativeinstallcmd` setting.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["BooleanType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["restart", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Restarts firefox with the same commandline arguments.\n\nWarning: This can kill your tabs, especially if you :restart several times\nin a row", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["saveas", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Download the current document.\n\nIf you have the native messenger v>=0.1.9 installed, the function accepts one optional argument, filename, which can be:\n- An absolute path\n- A path starting with ~, which will be expanded to your home directory\n- A relative path, relative to the native messenger executable (e.g. ~/.local/share/tridactyl on linux).\nIf filename is not given, a download dialogue will be opened. If filename is a directory, the file will be saved inside of it, its name being inferred from the URL. If the directories mentioned in the path do not exist or if a file already exists at this path, the file will be kept in your downloads folder and an error message will be given.\n\n**NB**: if a non-default save location is chosen, Firefox's download manager will say the file is missing. It is not - it is where you asked it to be saved.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["tabSetActive", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false), true)],
            ["getJumpPageId", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("This is used as an ID for the current page in the jumplist.\nIt has a potentially confusing behavior: if you visit site A, then site B, then visit site A again, the jumplist that was created for your first visit on A will be re-used for your second visit.\nAn ideal solution would be to have a counter that is incremented every time a new page is visited within the tab and use that as the return value for getJumpPageId but this doesn't seem to be trivial to implement.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false, false), true)],
            ["saveJumps", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), true)],
            ["curJumps", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Returns a promise for an object containing the jumplist of all pages accessed in the current tab.\nThe keys of the object currently are the page's URL, however this might change some day. Use [[getJumpPageId]] to access the jumplist of a specific page.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), true)],
            ["jumpnext", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Calls [[jumpprev]](-n)", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["jumpprev", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Similar to Pentadactyl or vim's jump list.\n\nWhen you scroll on a page, either by using the mouse or Tridactyl's key bindings, your position in the page will be saved after jumpdelay milliseconds (`:get jumpdelay` to know how many milliseconds that is). If you scroll again, you'll be able to go back to your previous position by using `:jumpprev 1`. If you need to go forward in the jumplist, use `:jumpprev -1`.\n\nKnown bug: Tridactyl will use the same jumplist for multiple visits to a same website in the same tab, see [github issue 834](https://github.com/tridactyl/tridactyl/issues/834).", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["addJump", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Called on 'scroll' events.\nIf you want to have a function that moves within the page but doesn't add a\nlocation to the jumplist, make sure to set JUMPED to true before moving\naround.\nThe setTimeout call is required because sometimes a user wants to move\nsomewhere by pressing 'j' multiple times and we don't want to add the\nin-between locations to the jump list", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("UIEvent", [], false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), true)],
            ["unfocus", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Blur (unfocus) the active element", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["scrollpx", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Scrolls the window or any scrollable child element by a pixels on the horizontal axis and b pixels on the vertical axis.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["scrollto", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("If two numbers are given, treat as x and y values to give to window.scrollTo\nIf one number is given, scroll to that percentage along a chosen axis, defaulting to the y-axis. If the number has 'c' appended to it, it will be interpreted in radians.\n\nNote that if `a` is 0 or 100 and if the document is not scrollable in the given direction, Tridactyl will attempt to scroll the first scrollable element until it reaches the very bottom of that element.\n\nExamples:\n\n- `scrollto 50` -> scroll halfway down the page.\n- `scrollto 3.14c` -> scroll approximately 49.97465213% of the way down the page.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false)], false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("x", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("y", false, false)], false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["scrollline", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Scrolls the document of its first scrollable child element by n lines.\n\nThe height of a line is defined by the site's CSS. If Tridactyl can't get it, it'll default to 22 pixels.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["scrollpage", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Scrolls the document by n pages.\n\nThe height of a page is the current height of the window.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["find", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Rudimentary find mode, left unbound by default as we don't currently support `incsearch`. Suggested binds:\n\n     bind / fillcmdline find\n     bind ? fillcmdline find -?\n     bind n findnext 1\n     bind N findnext -1\n     bind ,<Space> nohlsearch\n\nArgument: A string you want to search for.\n\nThis function accepts two flags: `-?` to search from the bottom rather than the top and `-: n` to jump directly to the nth match.\n\nThe behavior of this function is affected by the following setting:\n\n`findcase`: either \"smart\", \"sensitive\" or \"insensitive\". If \"smart\", find will be case-sensitive if the pattern contains uppercase letters.\n\nKnown bugs: find will currently happily jump to a non-visible element, and pressing n or N without having searched for anything will cause an error.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false), false)],
            ["findnext", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Jump to the next searched pattern.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false), false)],
            ["clearsearchhighlight", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false), false)],
            ["history", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), true)],
            ["forward", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Navigate forward one page in history.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["back", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Navigate back one page in history.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["reload", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Reload the next n tabs, starting with activeTab, possibly bypassingCache", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, true), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["BooleanType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["reloadall", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Reloads all tabs, bypassing the cache if hard is set to true", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["BooleanType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["reloadallbut", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Reloads all tabs except the current one, bypassing the cache if hard is set to true", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["BooleanType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["reloadhard", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Reload the next n tabs, starting with activeTab. bypass cache for all", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["open", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Open a new page in the current tab.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["bmarks", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Works exactly like [[open]], but only suggests bookmarks.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["open_quiet", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Like [[open]] but doesn't make a new entry in history.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["url2args", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("If the url of the current document matches one of your search engines, will convert it to a list of arguments that open/tabopen will understand. If the url doesn't match any search engine, returns the url without modifications.\n\nFor example, if you have searchurls.gi set to \"https://www.google.com/search?q=%s&tbm=isch\", using this function on a page you opened using \"gi butterflies\" will return \"gi butterflies\".\n\nThis is useful when combined with fillcmdline, for example like this: `bind O composite url2args | fillcmdline open`.\n\nNote that this might break with search engines that redirect you to other pages/add GET parameters that do not exist in your searchurl.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], false, false), false, false), false)],
            ["removeSource", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), true)],
            ["viewsource", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Display the (HTML) source of the current page.\n\nBehaviour can be changed by the 'viewsource' setting.\n\nIf the 'viewsource' setting is set to 'default' rather than 'tridactyl',\nthe url the source of which should be displayed can be given as argument.\nOtherwise, the source of the current document will be displayed.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["home", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Go to the homepages you have set with `set homepages [\"url1\", \"url2\"]`.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("false", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("true", false, false)], false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["help", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Show this page.\n\n`:help something` jumps to the entry for something. Something can be an excmd, an alias for an excmd, a binding or a setting.\n\nOn the ex command page, the \"nmaps\" list is a list of all the bindings for the command you're seeing and the \"exaliases\" list lists all its aliases.\n\nIf there's a conflict (e.g. you have a \"go\" binding that does something, a \"go\" excmd that does something else and a \"go\" setting that does a third thing), the binding is chosen first, then the setting, then the excmd. In such situations, if you want to let Tridactyl know you're looking for something specfic, you can specify the following flags as first arguments:\n\n`-a`: look for an alias\n`-b`: look for a binding\n`-e`: look for an ex command\n`-s`: look for a setting\n\nIf the keyword you gave to `:help` is actually an alias for a composite command (see [[composite]]) , you will be taken to the help section for the first command of the pipeline. You will be able to see the whole pipeline by hovering your mouse over the alias in the \"exaliases\" list. Unfortunately there currently is no way to display these HTML tooltips from the keyboard.\n\ne.g. `:help bind`", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["tutor", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Start the tutorial", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["credits", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Display Tridactyl's contributors in order of commits in a user-friendly fashion", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["no_mouse_mode", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Cover the current page in an overlay to prevent clicking on links with the mouse to force yourself to use hint mode. Get rid of it by reloading the page.\n\nSuggested usage: `autocmd DocLoad .* no_mouse_mode`\n\n\"There is no mouse\".", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["neo_mouse_mode", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Matrix variant of [[no_mouse_mode]]\n\n\"There is no mouse\".\n\nCoincidentally added to Tridactyl at the same time as we reached 1337 stars on GitHub.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["snow_mouse_mode", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Christmas variant of [[no_mouse_mode]] (if you live in $DEFAULT hemisphere).", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["findRelLink", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("RegExp", [], false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("HTMLAnchorElement", [], false, false), false, false), true)],
            ["selectLast", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("HTMLElement", [], false, false), false, false), true)],
            ["followpage", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Find a likely next/previous link and follow it\n\nIf a link or anchor element with rel=rel exists, use that, otherwise fall back to:\n\n    1) find the last anchor on the page with innerText matching the appropriate `followpagepattern`.\n    2) call [[urlincrement]] with 1 or -1\n\nIf you want to support e.g. French:\n\n```\nset followpagepatterns.next ^(next|newer|prochain)\\b|»|>>\nset followpagepatterns.prev ^(prev(ious)?|older|précédent)\\b|«|<<\n```", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("next", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("prev", false, false)], false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["urlincrement", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Increment the current tab URL", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["urlroot", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Go to the root domain of the current URL", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["urlparent", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Go to the parent URL of the current tab's URL", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["urlmodify", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Open a URL made by modifying the current URL\n\nThere are several modes:\n\n* Text replace mode:   `urlmodify -t <old> <new>`\n\n   Replaces the first instance of the text `old` with `new`.\n      * `http://example.com` -> (`-t exa peta`) -> `http://petample.com`\n\n* Regex replacment mode: `urlmodify -r <regexp> <new> [flags]`\n\n   Replaces the first match of the `regexp` with `new`. You can use\n   flags `i` and `g` to match case-insensitively and to match\n   all instances respectively\n      * `http://example.com` -> (`-r [ea] X g`) -> `http://XxXmplX.com`\n\n* Query set mode: `urlmodify -s <query> <value>`\n\n   Sets the value of a query to be a specific one. If the query already\n   exists, it will be replaced.\n      * `http://e.com?id=abc` -> (`-s foo bar`) -> `http://e.com?id=abc&foo=bar\n\n* Query replace mode: `urlmodify -q <query> <new_val>`\n\n   Replace the value of a query with a new one:\n      * `http://e.com?id=foo` -> (`-q id bar`) -> `http://e.com?id=bar\n\n* Query delete mode: `urlmodify -Q <query>`\n\n   Deletes the given query (and the value if any):\n      * `http://e.com?id=foo&page=1` -> (`-Q id`) -> `http://e.com?page=1`\n\n* Graft mode: `urlmodify -g <graft_point> <new_path_tail>`\n\n   \"Grafts\" a new tail on the URL path, possibly removing some of the old\n   tail. Graft point indicates where the old URL is truncated before adding\n   the new path.\n\n   * `graft_point` >= 0 counts path levels, starting from the left\n   (beginning). 0 will append from the \"root\", and no existing path will\n   remain, 1 will keep one path level, and so on.\n   * `graft_point` < 0 counts from the right (i.e. the end of the current\n   path). -1 will append to the existing path, -2 will remove the last path\n   level, and so on.\n\n   ```text\n   http://website.com/this/is/the/path/component\n   Graft point:       ^    ^  ^   ^    ^        ^\n   From left:         0    1  2   3    4        5\n   From right:       -6   -5 -4  -3   -2       -1\n   ```\n\n   Examples:\n\n   * `http://e.com/issues/42` -> (`-g 0 foo`) -> `http://e.com/foo`\n   * `http://e.com/issues/42` -> (`-g 1 foo`) -> `http://e.com/issues/foo`\n   * `http://e.com/issues/42` -> (`-g -1 foo`) -> `http://e.com/issues/42/foo`\n   * `http://e.com/issues/42` -> (`-g -2 foo`) -> `http://e.com/issues/foo`", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("-t", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("-r", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("-s", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("-q", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("-Q", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("-g", false, false)], false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["geturlsforlinks", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Returns the url of links that have a matching rel.\n\nDon't bind to this: it's an internal function.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false), true)],
            ["zoom", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Sets the current page's zoom level anywhere between 30% and 300%.\n\nIf you overshoot the level while using relative adjustments i.e. level > 300% or level < 30%\nthe zoom level will be set to it's maximum or minimum position.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, true), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["reader", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Opens the current page in Firefox's reader mode.\nYou currently cannot use Tridactyl while in reader mode.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["loadaucmds", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("DocStart", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("DocLoad", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("DocEnd", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("TabEnter", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("TabLeft", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("FullscreenEnter", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("FullscreenLeft", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("FullscreenChange", false, false)], false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), true)],
            ["focusinput", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Focus the last used input on the page", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false)], false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["changelistjump", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Focus the tab which contains the last focussed input element. If you're lucky, it will focus the right input, too.\n\nCurrently just goes to the last focussed input; being able to jump forwards and backwards is planned.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["focusbyid", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), true)],
            ["tabIndexSetActive", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Switch to the tab by index (position on tab bar), wrapping round.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false)], false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), true)],
            ["tabnext", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Switch to the next tab, wrapping round.\n\nIf increment is specified, move that many tabs forwards.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["tabnext_gt", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Switch to the next tab, wrapping round.\n\nIf an index is specified, go to the tab with that number (this mimics the\nbehaviour of `{count}gt` in vim, except that this command will accept a\ncount that is out of bounds (and will mod it so that it is within bounds as\nper [[tabmove]], etc)).", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["tabprev", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Switch to the previous tab, wrapping round.\n\nIf increment is specified, move that many tabs backwards.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["tabopen", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Like [[open]], but in a new tab. If no address is given, it will open the newtab page, which can be set with `set newtab [url]`\n\nUse the `-c` flag followed by a container name to open a tab in said container. Tridactyl will try to fuzzy match a name if an exact match is not found. If any autocontainer directives are configured and -c is not set, Tridactyl will try to use the right container automatically using your configurations.\nUse the `-b` flag to open the tab in the background.\nThese two can be combined in any order, but need to be placed as the first arguments.\n\nUnlike Firefox's Ctrl-t shortcut, this opens tabs immediately after the\ncurrently active tab rather than at the end of the tab list because that is\nthe authors' preference.\n\nIf you would rather the Firefox behaviour `set tabopenpos last`. This\npreference also affects the clipboard, quickmarks, home, help, etc.\n\nIf you would rather the URL be opened as if you'd middle clicked it, `set\ntabopenpos related`.\n\nHinting is controlled by `relatedopenpos`\n\nAlso see the [[searchengine]] and [[searchurls]] settings.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["idFromIndex", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Resolve a tab index to the tab id of the corresponding tab in this window.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false)], false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false)], false, false), false, false), true)],
            ["tabonly", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Close all other tabs in this window", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["tabduplicate", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Duplicate a tab.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["tabdetach", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Detach a tab, opening it in a new window.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["getSortedWinTabs", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Get list of tabs sorted by most recent use", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false)], false, false), false, false), true)],
            ["fullscreen", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Toggle fullscreen state", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["tabclose", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Close a tab.\n\nKnown bug: autocompletion will make it impossible to close more than one tab at once if the list of numbers looks enough like an open tab's title or URL.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["tabclosealltoright", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Close all tabs to the right of the current one", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["tabclosealltoleft", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Close all tabs to the left of the current one", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["undo", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Restore the most recently closed item.\nThe default behaviour is to restore the most recently closed tab in the\ncurrent window unless the most recently closed item is a window.\n\nSupplying either \"tab\" or \"window\" as an argument will specifically only\nrestore an item of the specified type.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false)], false, false), false, false), false)],
            ["tabmove", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Move the current tab to be just in front of the index specified.\n\nKnown bug: This supports relative movement with `tabmove +pos` and `tabmove -pos`, but autocomplete doesn't know that yet and will override positive and negative indexes.\n\nPut a space in front of tabmove if you want to disable completion and have the relative indexes at the command line.\n\nBinds are unaffected.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["pin", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Pin the current tab", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["mute", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Mute current tab or all tabs.\n\nPassing \"all\" to the excmd will operate on  the mute state of all tabs.\nPassing \"unmute\" to the excmd will unmute.\nPassing \"toggle\" to the excmd will toggle the state of `browser.tabs.tab.MutedInfo`", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["winopen", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Like [[tabopen]], but in a new window.\n\n`winopen -private [...]` will open the result in a private window (and won't store the command in your ex-history ;) ).\n\n`winopen -popup [...]` will open it in a popup window. You can combine the two for a private popup.\n\nExample: `winopen -popup -private ddg.gg`", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["winclose", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Close a tab.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false)], false, false), false, false), false)],
            ["qall", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Close all windows", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["containerclose", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Closes all tabs open in the same container across all windows.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["containercreate", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Creates a new container. Note that container names must be unique and that the checks are case-insensitive.\n\nFurther reading https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/contextualIdentities/ContextualIdentity\n\nExample usage:\n    - `:containercreate tridactyl green dollar`", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, true), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["containerdelete", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Delete a container. Closes all tabs associated with that container beforehand. Note: container names are case-insensitive.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["containerupdate", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Update a container's information. Note that none of the parameters are optional and that container names are case-insensitive.\n\nExample usage:\n\n- Changing the container name: `:containerupdate banking blockchain green dollar`\n\n- Changing the container icon: `:containerupdate banking banking green briefcase`\n\n- Changing the container color: `:containerupdate banking banking purple dollar`", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["viewcontainers", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Shows a list of the current containers in Firefox's native JSON viewer in the current tab.\n\nNB: Tridactyl cannot run on this page!", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["version", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["mode", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Switch mode.\n\nFor now you probably shouldn't manually switch to other modes than `normal` and `ignore`. Make sure you're aware of the key bindings (ignoremaps) that will allow you to go come back to normal mode from ignore mode before you run `:mode ignore` otherwise you're going to have a hard time re-enabling Tridactyl.\n\nExample:\n     - `mode ignore` to ignore almost all keys.\n\nIf you're looking for a way to temporarily disable Tridactyl, `mode ignore` might be what you're looking for.\n\nNote that when in ignore mode, Tridactyl will not switch to insert mode when focusing text areas/inputs. This is by design.\n\n**New feature:** you can add modes as simply as adding binds with `bind --mode=[newmodename]` and then enter the mode with `mode [newmodename]`.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["getnexttabs", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false)], false, false), false, false), true)],
            ["repeat", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Repeats a `cmd` `n` times.\nIf `cmd` doesn't exist, re-executes the last exstr that was executed in the tab.\nExecutes the command once if `n` isn't defined either.\n\nThis re-executes the last *exstr*, not the last *excmd*. Some excmds operate internally by constructing and evaluating exstrs, others by directly invoking excmds without going through the exstr parser. For example, aucmds and keybindings evaluate exstrs and are repeatable, while commands like `:bmarks` directly invoke `:tabopen` and you'll repeat the `:bmarks` rather than the internal `:tabopen`.\n\nIt's difficult to execute this in the background script (`:jsb`, `:run_excmd`, `:autocmd TriStart`, `:source`), but if you you do, it will re-execute the last exstr that was executed in the background script. What this may have been is unpredictable and not precisely encouraged.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, true), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["composite", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Split `cmds` on pipes (|) and treat each as its own command. Return values are passed as the last argument of the next ex command, e.g,\n\n`composite echo yes | fillcmdline` becomes `fillcmdline yes`. A more complicated example is the ex alias, `command current_url composite get_current_url | fillcmdline_notrail `, which is used in, e.g. `bind T current_url tabopen`.\n\nWorkaround: this should clearly be in the parser, but we haven't come up with a good way to deal with |s in URLs, search terms, etc. yet.\n\n`cmds` are also split with semicolons (;) and don't pass things along to each other.\n\nIf you wish to have a command that has semi-colons in it (e.g. some JavaScript or `hint -;`), first bind a [[command]] to it. For example, `command hint_focus -;`, and then `composite hint_focus; !s xdotool key Menu`.\n\nThe behaviour of combining ; and | in the same composite command is left as an exercise for the reader.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["shellescape", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Escape command for safe use in shell with composite. E.g: `composite js MALICIOUS_WEBSITE_FUNCTION() | shellescape | exclaim ls`", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["sleep", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Sleep time_ms milliseconds.\nThis is probably only useful for composite commands that need to wait until the previous asynchronous command has finished running.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["showcmdline", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["BooleanType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), true)],
            ["hidecmdline", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), true)],
            ["fillcmdline", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Set the current value of the commandline to string *with* a trailing space", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false), false)],
            ["fillcmdline_notrail", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Set the current value of the commandline to string *without* a trailing space", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false), false)],
            ["fillcmdline_nofocus", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Show and fill the command line without focusing it", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false), false)],
            ["fillcmdline_tmp", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Shows str in the command line for ms milliseconds. Recommended duration: 3000ms.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["yank", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Copy content to clipboard without feedback. Use `clipboard yank` for interactive use.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false)], false, false), false, false), false)],
            ["setclip", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Copies a string to the clipboard/selection buffer depending on the user's preferences", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false)], false, false), false, false), true)],
            ["getclip", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Fetches the content of the clipboard/selection buffer depending on user's preferences\n\nExposed for use with [[composite]], e.g. `composite getclip | fillcmdline`", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("clipboard", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("selection", false, false)], false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["clipboard", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Use the system clipboard.\n\nIf `excmd === \"open\"`, call [[open]] with the contents of the clipboard. Similarly for [[tabopen]].\n\nIf `excmd === \"yank\"`, copy the current URL, or if given, the value of toYank, into the system clipboard.\n\nIf `excmd === \"yankcanon\"`, copy the canonical URL of the current page if it exists, otherwise copy the current URL.\n\nIf `excmd === \"yankshort\"`, copy the shortlink version of the current URL, and fall back to the canonical then actual URL. Known to work on https://yankshort.neocities.org/.\n\nIf `excmd === \"yanktitle\"`, copy the title of the open page.\n\nIf `excmd === \"yankmd\"`, copy the title and url of the open page formatted in Markdown for easy use on sites such as reddit.\n\nIf you're on Linux and the native messenger is installed, Tridactyl will call an external binary (either xclip or xsel) to read or write to your X selection buffer. If you want another program to be used, set \"externalclipboardcmd\" to its name and make sure it has the same interface as xsel/xclip (\"-i\"/\"-o\" and reading from stdin).\n\nWhen doing a read operation (i.e. open or tabopen), if \"putfrom\" is set to \"selection\", the X selection buffer will be read instead of the clipboard. Set \"putfrom\" to \"clipboard\" to use the clipboard.\n\nWhen doing a write operation, if \"yankto\" is set to \"selection\", only the X selection buffer will be written to. If \"yankto\" is set to \"both\", both the X selection and the clipboard will be written to. If \"yankto\" is set to \"clipboard\", only the clipboard will be written to.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("open", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("yank", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("yankshort", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("yankcanon", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("yanktitle", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("yankmd", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("xselpaste", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("tabopen", false, false)], false, true), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["tab", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Change active tab.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("#", false, false)], false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["taball", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Change active tab.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["command", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Similar to vim's `:command`. Maps one ex-mode command to another.\nIf command already exists, this will override it, and any new commands\nadded in a future release will be SILENTLY overridden. Aliases are\nexpanded recursively.\n\nExamples:\n  - `command t tabopen`\n  - `command tn tabnext_gt`\n  = `command hello t` This will expand recursively into 'hello'->'tabopen'\n\nNote that this is only for excmd->excmd mappings. To map a normal-mode\ncommand to an excommand, see [[bind]].\n\nSee also:\n  - [[comclear]]", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false), false)],
            ["comclear", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Similar to vim's `comclear` command. Clears an excmd alias defined by\n`command`.\n\nFor example: `comclear helloworld` will reverse any changes caused\nby `command helloworld xxx`\n\nSee also:\n  - [[command]]", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["parse_bind_args", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("bind_args", [], false, false), false, false), true)],
            ["bind", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Bind a sequence of keys to an excmd or view bound sequence.\n\nThis is an easier-to-implement bodge while we work on vim-style maps.\n\nExamples:\n\n    - `bind G fillcmdline tabopen google`\n    - `bind D composite tabclose | tab #` -> close current tab and switch to most recent previous tab\n    - `bind j scrollline 20`\n    - `bind F hint -b`\n\nYou can view binds by omitting the command line:\n\n    - `bind j`\n    - `bind k`\n\nYou can bind to modifiers and special keys by enclosing them with angle brackets, for example `bind <C-\\>z fullscreen`, `unbind <F1>` (a favourite of people who use TreeStyleTabs :) ), or `bind <Backspace> forward`.\n\nModifiers are truncated to a single character, so Ctrl -> C, Alt -> A, and Shift -> S. Shift is a bit special as it is only required if Shift does not change the key inputted, e.g. `<S-ArrowDown>` is OK, but `<S-a>` should just be `A`.\n\nYou can view all special key names here: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\n\nUse [[composite]] if you want to execute multiple excmds. Use\n[[fillcmdline]] to put a string in the cmdline and focus the cmdline\n(otherwise the string is executed immediately).\n\nYou can bind to other modes with `bind --mode={insert|ignore|normal|input|ex|hint} ...`, e.g, `bind --mode=insert emacs qall` (NB: unlike vim, all preceeding characters will not be input), or `bind --mode=hint <C-[> hint.reset`.\n\nA list of editor functions can be found\n[here](/static/docs/modules/_src_lib_editor_.html).\n\nSee also:\n\n    - [[unbind]]\n    - [[reset]]", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["bindurl", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Like [[bind]] but for a specific url pattern (also see [[seturl]]).", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["keymap", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Makes one key equivalent to another for the purposes of most of our parsers. Useful for international keyboard layouts.\n\ne.g,\n     keymap ę e\n\nSee `:help keytranslatemodes` to enable keymaps in modes other than normal mode.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["searchsetkeyword", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), true)],
            ["validateSetArgs", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Validates arguments for set/seturl", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false), false, false), true)],
            ["seturl", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Usage: `seturl [pattern] key values`", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false), false)],
            ["set", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Set a key value pair in config.\n\nUse to set any string values found [here](/static/docs/classes/_src_lib_config_.default_config.html).\n\ne.g.\n    set searchurls.google https://www.google.com/search?q=\n    set logging.messaging info\n\nIf no value is given, the value of the of the key will be displayed", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false), false)],
            ["autocmd", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Set autocmds to run when certain events happen.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["autocontain", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Automatically open a domain and all its subdomains in a specified container.\n\nFor declaring containers that do not yet exist, consider using `auconscreatecontainer true` in your tridactylrc.\nThis allows tridactyl to automatically create containers from your autocontain directives. Note that they will be random icons and colors.\n\n** NB: This is an experimental feature, if you encounter issues please create an issue on github. **\n\nThe domain is passed through as a regular expression so there are a few gotchas to be aware of:\n* Unescaped periods will match *anything*. `autocontain google.co.uk work` will match `google!co$uk`. Escape your periods or accept that you might get some false positives.\n* You can use regex in your domain pattern. `autocontain google\\,(co\\.uk|com) work` will match either `google.co.uk` or `google.com`.\n\nThis *should* now peacefully coexist with the Temporary Containers and Multi-Account Containers addons. Do not trust this claim. If a fight starts the participants will try to open infinite tabs. It is *strongly* recommended that you use a tridactylrc so that you can abort a sorceror's-apprentice scenario by killing firefox, commenting out all of autocontainer directives in your rc file, and restarting firefox to clean up the mess. There are a number of strange behaviors resulting from limited coordination between extensions. Redirects can be particularly surprising; for example, with `:autocontain will-redirect.example.org example` set and `will-redirect.example.org` redirecting to `redirected.example.org`, navigating to `will-redirect.example.org` will result in the new tab being in the `example` container under some conditions and in the `firefox-default` container under others.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["autocmddelete", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Remove autocmds", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["blacklistadd", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Helper function to put Tridactyl into ignore mode on the provided URL.\n\nSimply creates a DocStart [[autocmd]] that runs `mode ignore`.\n\nDue to a Tridactyl bug, the only way to remove these rules once they are set is to delete all of your autocmds with `unset autocmds`.\n\nIf you're looking for a way to temporarily disable Tridactyl, this might be what you're looking for.\n\n<!-- this should probably be moved to an ex alias once configuration has better help --!>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["unbind", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Unbind a sequence of keys so that they do nothing at all.\n\nSee also:\n\n    - [[bind]]\n    - [[reset]]", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["unbindurl", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Unbind a sequence of keys you have set with [[bindurl]]. Note that this **kills** a bind, which means Tridactyl will pass it to the page on `pattern`. If instead you want to use the default setting again, use [[reseturl]].", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["reset", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Restores a sequence of keys to their default value.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["reseturl", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Restores a sequence of keys to their value in the global config for a specific URL.\n\nSee also:\n  - [[bind]]\n  - [[unbind]]\n  - [[reset]]\n  - [[bindurl]]\n  - [[unbindurl]]\n  - [[seturl]]\n  - [[unseturl]]", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["sanitise", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Deletes various privacy-related items.\n\nThe list of possible arguments can be found here:\nhttps://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/browsingData/DataTypeSet\n\nAdditional, tridactyl-specific arguments are:\n- commandline: Removes the in-memory commandline history.\n- tridactyllocal: Removes all tridactyl storage local to this machine. Use it with\n    commandline if you want to delete your commandline history.\n- tridactylsync: Removes all tridactyl storage associated with your Firefox Account (i.e, all user configuration, by default).\nThese arguments aren't affected by the timespan parameter.\n\nTimespan parameter:\n-t [0-9]+(m|h|d|w)\n\nExamples:\n\n- `sanitise all` -> Deletes everything\n- `sanitise history` -> Deletes all history\n- `sanitise commandline tridactyllocal tridactylsync` -> Deletes every bit of data Tridactyl holds\n- `sanitise cookies -t 3d` -> Deletes cookies that were set during the last three days.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["quickmark", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Bind a quickmark for the current URL or space-separated list of URLs to a key on the keyboard.\n\nAfterwards use go[key], gn[key], or gw[key] to [[open]], [[tabopen]], or\n[[winopen]] the URL respectively.\n\nExample:\n- `quickmark m https://mail.google.com/mail/u/0/#inbox`", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["get", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Puts the contents of config value with keys `keys` into the commandline and the background page console\n\nIt's a bit rubbish, but we don't have a good way to provide feedback to the commandline yet.\n\nYou can view the log entry in the browser console (Ctrl-Shift-j).\n\nFor example, you might try `get nmaps` to see all of your current binds.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["viewconfig", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Opens the current configuration in Firefox's native JSON viewer in the current tab.\n\nNB: Tridactyl cannot run on this page!", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["unseturl", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Reset a site-specific setting.\n\nusage: `unseturl [pattern] key`", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["unset", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Reset a config setting to default", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["hint", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Hint a page.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, true), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, true), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["rot13", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Perform rot13.\n\nTransforms all text nodes in the current tab via rot13. Only characters in\nthe ASCII range are considered.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["run_exstr", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Hacky ex string parser.\n\nUse it for fire-and-forget running of background commands in content.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false), false)],
            ["gobble", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Initialize gobble mode.\n\nIt will read `nChars` input keys, append them to `endCmd` and execute that\nstring.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["tssReadFromCss", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Read text content of elements matching the given selector", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), false)],
            ["ttsread", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Read the given text using the browser's text to speech functionality and\nthe settings currently set", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("-t", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("-c", false, false)], false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["ttsvoices", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Show a list of the voices available to the TTS system. These can be\nset in the config using `ttsvoice`", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["ttscontrol", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Cancel current reading and clear pending queue\n\nArguments:\n   - stop:    cancel current and pending utterances", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["buildFilterConfigs", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Build a set of FilterConfigs from a list of human-input filter\nspecs.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false), false, false), true)],
            ["perfdump", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Dump the raw json for our performance counters. Filters with\ntrailing slashes are class names, :start | :end | :measure specify\nwhat type of sample to pass through, and all others are function\nnames. All filters must match for a sample to be dumped.\n\nTridactyl does not collect performance information by default. To\nget this data you'll have to set the configuration option\n`perfcounters` to `\"true\"`. You may also want to examine the value\nof `perfsamples`.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["perfhistogram", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Pretty-print a histogram of execution durations for you. Arguments\nare as above, with the addition that this automatically filters to\ncounter samples of type :measure.\n\nNote that this will display its output by opening a data: url with\ntext in the place of your current tab.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["bmark", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Add or remove a bookmark.\n\nOptionally, you may give the bookmark a title. If no URL is given, a bookmark is added for the current page.\n\nIf a bookmark already exists for the URL, it is removed, even if a title is given.\n\nDoes not support creation of folders: you'll need to use the Firefox menus for that.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, true), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)],
            ["echo", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], false, false), false, false), false)],
            ["js", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Lets you execute JavaScript in the page context. If you want to get the result back, use `composite js ... | fillcmdline`\n\nSome of Tridactyl's functions are accessible here via the `tri` object. Just do `console.log(tri)` in the web console on the new tab page to see what's available.\n\nIf you want to pipe an argument to `js`, you need to use the \"-p\" flag and then use the JS_ARG global variable, e.g:\n\n`composite get_current_url | js -p alert(JS_ARG)`", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["jsb", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Lets you execute JavaScript in the background context. All the help from [[js]] applies. Gives you a different `tri` object.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["issue", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Opens a new tab the url of which is \"https://github.com/tridactyl/tridactyl/issues/new\" and automatically fill add tridactyl, firefox and os version to the issue.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["updatecheck", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Checks if there are any stable updates available for Tridactyl.\n\nRelated settings:\n\n- `update.nag = true | false` - checks for updates on Tridactyl start.\n- `update.nagwait = 7` - waits 7 days before nagging you to update.\n- `update.checkintervalsecs = 86400` - waits 24 hours between checking for an update.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("manual", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("auto_polite", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("auto_impolite", false, false)], false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["BooleanType"](false, false)], false, false), false, false), false)],
            ["keyfeed", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Feed some keys to Tridactyl's parser. E.g. `keyfeed jkjkjkjkjkjkjkjkjkjkjkjkjkjkjkjkjkjkjkjkjkjjkj`.\n\nNB:\n\n- Does _not_ function like Vim's noremap - `bind j keyfeed j` will cause an infinite loop.\n- Doesn't work in exmode - i.e. `keyfeed t<CR>` won't work.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), false)]]))],
    ["src/lib/config.ts", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["FileMetadata"](new Map([["default_config", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["ClassMetadata"](new Map([["configversion", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Internal version number Tridactyl uses to know whether it needs to update from old versions of the configuration.\n\nChanging this might do weird stuff.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false)],
                    ["subconfigs", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Internal field to handle site-specific configs. Use :seturl/:unseturl to change these values.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ObjectType"](new Map([["", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("default_config", [], false, false)]]), false, false), false)],
                    ["priority", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Internal field to handle site-specific config priorities. Use :seturl/:unseturl to change this value.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false), false)],
                    ["exmaps", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("exmaps contains all of the bindings for the command line.\nYou can of course bind regular ex commands but also [editor functions](/static/docs/modules/_src_lib_editor_.html) and [commandline-specific functions](/static/docs/modules/_src_commandline_frame_.html).", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ObjectType"](new Map([["<Enter>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<C-j>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<C-m>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<Escape>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<ArrowUp>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<ArrowDown>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<C-a>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<C-e>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<C-u>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<C-k>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<C-c>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<C-f>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<Tab>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<S-Tab>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<Space>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)]]), false, false), false)],
                    ["ignoremaps", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("ignoremaps contain all of the bindings for \"ignore mode\".\n\nThey consist of key sequences mapped to ex commands.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ObjectType"](new Map([["<S-Insert>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<CA-Escape>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<CA-`>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<S-Escape>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<C-^>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<C-6>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)]]), false, false), false)],
                    ["imaps", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("imaps contain all of the bindings for \"insert mode\".\n\nOn top of regular ex commands, you can also bind [editor functions](/static/docs/modules/_src_lib_editor_.html) in insert mode.\n\nThey consist of key sequences mapped to ex commands.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ObjectType"](new Map([["<Escape>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<C-[>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<C-i>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<CA-Escape>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<CA-`>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<C-6>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<C-^>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<S-Escape>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)]]), false, false), false)],
                    ["inputmaps", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("inputmaps contain all of the bindings for \"input mode\".\n\nOn top of regular ex commands, you can also bind [editor functions](/static/docs/modules/_src_lib_editor_.html) in input mode.\n\nThey consist of key sequences mapped to ex commands.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false)],
                    ["nmaps", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("nmaps contain all of the bindings for \"normal mode\".\n\nThey consist of key sequences mapped to ex commands.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ObjectType"](new Map([["<A-p>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<A-m>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<F1>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["o", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["O", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["w", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["W", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["t", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["]]", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["[[", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["[c", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["]c", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<C-x>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<C-a>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["T", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["yy", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["ys", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<SA-ArrowUp><SA-ArrowUp><SA-ArrowDown><SA-ArrowDown><SA-ArrowLeft><SA-ArrowRight><SA-ArrowLeft><SA-ArrowRight>ba", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)]]), false, false), false)],
                    ["hintmaps", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ObjectType"](new Map([["<Backspace>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<Escape>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<Tab>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<S-Tab>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<ArrowUp>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<ArrowDown>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<ArrowLeft>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<ArrowRight>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<Enter>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["<Space>", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)]]), false, false), false)],
                    ["leavegithubalone", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Whether to allow pages (not necessarily github) to override `/`, which is a default Firefox binding.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("false", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("true", false, false)], false, false), false)],
                    ["blacklistkeys", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Which keys to protect from pages that try to override them. Requires [[leavegithubalone]] to be set to false.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false, false), false)],
                    ["autocmds", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Autocommands that run when certain events happen, and other conditions are met.\n\nRelated ex command: `autocmd`.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ObjectType"](new Map([["DocStart", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ObjectType"](new Map([]), false, false)], ["DocLoad", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ObjectType"](new Map([["^https://github.com/tridactyl/tridactyl/issues/new$", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)]]), false, false)], ["DocEnd", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ObjectType"](new Map([]), false, false)], ["TriStart", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ObjectType"](new Map([[".*", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)]]), false, false)], ["TabEnter", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ObjectType"](new Map([]), false, false)], ["TabLeft", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ObjectType"](new Map([]), false, false)], ["FullscreenChange", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ObjectType"](new Map([]), false, false)], ["FullscreenEnter", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ObjectType"](new Map([]), false, false)], ["FullscreenLeft", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ObjectType"](new Map([]), false, false)]]), false, false), false)],
                    ["keytranslatemap", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Map for translating keys directly into other keys in normal-ish modes. For example, if you have an entry in this config option mapping `п` to `g`, then you could type `пп` instead of `gg` or `пi` instead of `gi` or `;п` instead of `;g`. This is primarily useful for international users who don't want to deal with rebuilding their bindings every time tridactyl ships a new default keybind. It's not as good as shipping properly internationalized sets of default bindings, but it's probably as close as we're going to get on a small open-source project like this.\n\nNote that the current implementation does not allow you to \"chain\" keys, for example, \"a\"=>\"b\" and \"b\"=>\"c\" for \"a\"=>\"c\". You can, however, swap or rotate keys, so \"a\"=>\"b\" and \"b\"=>\"a\" will work the way you'd expect, as will \"a\"=>\"b\" and \"b\"=>\"c\" and \"c\"=>\"a\".", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ObjectType"](new Map([]), false, false), false)],
                    ["keytranslatemodes", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Whether to use the keytranslatemap in various maps.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ObjectType"](new Map([["", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("false", false, false),
                                    new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("true", false, false)], false, false)]]), false, false), false)],
                    ["autocontain", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Automatically place these sites in the named container.\n\nEach key corresponds to a URL fragment which, if contained within the page URL, the site will be opened in a container tab instead.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false)],
                    ["exaliases", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Aliases for the commandline.\n\nYou can make a new one with `command alias ex-command`.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ObjectType"](new Map([["alias", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["au", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["aucon", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["audel", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["audelete", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["b", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["clsh", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["nohlsearch", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["noh", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["o", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["w", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["t", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["tabnew", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["tabm", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["tabo", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["mpvsafe", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)]]), false, false), false)],
                    ["followpagepatterns", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Used by `]]` and `[[` to look for links containing these words.\n\nEdit these if you want to add, e.g. other language support.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ObjectType"](new Map([["next", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["prev", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)]]), false, false), false)],
                    ["searchengine", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("The default search engine used by `open search`. If empty string, your browser's default search engine will be used. If set to something, Tridactyl will first look at your [[searchurls]] and then at the search engines for which you have defined a keyword on `about:preferences#search`.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false)],
                    ["searchurls", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Definitions of search engines for use via `open [keyword]`.\n\n`%s` will be replaced with your whole query and `%s1`, `%s2`, ..., `%sn` will be replaced with the first, second and nth word of your query. If there are none of these patterns in your search urls, your query will simply be appended to the searchurl.\n\nExamples:\n- When running `open gi cute puppies`, with a `gi` searchurl defined with `set searchurls.gi https://www.google.com/search?q=%s&tbm=isch`, tridactyl will navigate to `https://www.google.com/search?q=cute puppies&tbm=isch`.\n- When running `tabopen translate en ja Tridactyl`, with a `translate` searchurl defined with `set searchurls.translate https://translate.google.com/#view=home&op=translate&sl=%s1&tl=%s2&text=%s3`, tridactyl will navigate to `https://translate.google.com/#view=home&op=translate&sl=en&tl=ja&text=Tridactyl`.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ObjectType"](new Map([["google", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["googlelucky", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["scholar", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["googleuk", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["bing", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["duckduckgo", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["yahoo", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["twitter", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["wikipedia", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["youtube", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["amazon", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["amazonuk", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["qwant", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)]]), false, false), false)],
                    ["newtab", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("URL the newtab will redirect to.\n\nAll usual rules about things you can open with `open` apply, with the caveat that you'll get interesting results if you try to use something that needs `nativeopen`: so don't try `about:newtab`.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false)],
                    ["viewsource", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Whether `:viewsource` will use our own page that you can use Tridactyl binds on, or Firefox's default viewer, which you cannot use Tridactyl on.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("tridactyl", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("default", false, false)], false, false), false)],
                    ["storageloc", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Which storage to use. Sync storage will synchronise your settings via your Firefox Account.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("sync", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("local", false, false)], false, false), false)],
                    ["homepages", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Pages opened with `gH`. In order to set this value, use `:set homepages [\"example.org\", \"example.net\", \"example.com\"]` and so on.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false, false), false)],
                    ["hintchars", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Characters to use in hint mode.\n\nThey are used preferentially from left to right.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false)],
                    ["hintfiltermode", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("The type of hinting to use. `vimperator` will allow you to filter links based on their names by typing non-hint chars. It is recommended that you use this in conjuction with the [[hintchars]] setting, which you should probably set to e.g, `5432167890`. ´vimperator-reflow´ additionally updates the hint labels after filtering.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("simple", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("vimperator", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("vimperator-reflow", false, false)], false, false), false)],
                    ["hintnames", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Whether to optimise for the shortest possible names for each hint, or to use a simple numerical ordering. If set to `numeric`, overrides `hintchars` setting.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("short", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("numeric", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("uniform", false, false)], false, false), false)],
                    ["hintuppercase", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Whether to display the names for hints in uppercase.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("false", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("true", false, false)], false, false), false)],
                    ["hintdelay", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("The delay in milliseconds in `vimperator` style hint modes after selecting a hint before you are returned to normal mode.\n\nThe point of this is to prevent accidental execution of normal mode binds due to people typing more than is necessary to choose a hint.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false), false)],
                    ["allowautofocus", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Controls whether the page can focus elements for you via js\n\nNB: will break fancy editors such as CodeMirror on Jupyter. Simply use `seturl` to whitelist pages you need it on.\n\nBest used in conjunction with browser.autofocus in `about:config`", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("false", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("true", false, false)], false, false), false)],
                    ["preventautofocusjackhammer", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Uses a loop to prevent focus until you interact with a page. Only recommended for use via `seturl` for problematic sites as it can be a little heavy on CPU if running on all tabs. Should be used in conjuction with [[allowautofocus]]", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("false", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("true", false, false)], false, false), false)],
                    ["newtabfocus", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Controls whether the newtab focuses on tridactyl's newtab page or the firefox urlbar.\n\nTo get FF default behaviour, use \"urlbar\".", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("page", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("urlbar", false, false)], false, false), false)],
                    ["smoothscroll", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Whether to use Tridactyl's (bad) smooth scrolling.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("false", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("true", false, false)], false, false), false)],
                    ["scrollduration", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("How viscous you want smooth scrolling to feel.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false), false)],
                    ["tabopenpos", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Where to open tabs opened with `tabopen` - to the right of the current tab, or at the end of the tabs.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("next", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("last", false, false)], false, false), false)],
                    ["relatedopenpos", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Where to open tabs opened with hinting - as if it had been middle clicked, to the right of the current tab, or at the end of the tabs.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("next", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("last", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("related", false, false)], false, false), false)],
                    ["ttsvoice", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("The name of the voice to use for text-to-speech. You can get the list of installed voices by running the following snippet: `js alert(window.speechSynthesis.getVoices().reduce((a, b) => a + \" \" + b.name))`", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false)],
                    ["ttsvolume", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Controls text-to-speech volume. Has to be a number between 0 and 1.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false), false)],
                    ["ttsrate", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Controls text-to-speech speed. Has to be a number between 0.1 and 10.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false), false)],
                    ["ttspitch", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Controls text-to-speech pitch. Has to be between 0 and 2.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false), false)],
                    ["gimode", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("If nextinput, <Tab> after gi brings selects the next input\n\nIf firefox, <Tab> selects the next selectable element, e.g. a link", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("nextinput", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("firefox", false, false)], false, false), false)],
                    ["cursorpos", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Decides where to place the cursor when selecting non-empty input fields", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("beginning", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("end", false, false)], false, false), false)],
                    ["theme", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("The theme to use.\n\nPermitted values: run `:composite js tri.styling.THEMES | fillcmdline` to find out.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false)],
                    ["customthemes", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Storage for custom themes\n\nMaps theme names to CSS. Predominantly used automatically by [[colourscheme]] to store themes read from disk, as documented by [[colourscheme]]. Setting this manually is untested but might work provided that [[colourscheme]] is then used to change the theme to the right theme name.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ObjectType"](new Map([]), false, false), false)],
                    ["modeindicator", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Whether to display the mode indicator or not.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("false", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("true", false, false)], false, false), false)],
                    ["jumpdelay", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Milliseconds before registering a scroll in the jumplist", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false), false)],
                    ["logging", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Logging levels. Unless you're debugging Tridactyl, it's unlikely you'll ever need to change these.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ObjectType"](new Map([["", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("never", false, false),
                                    new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("error", false, false),
                                    new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("warning", false, false),
                                    new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("info", false, false),
                                    new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("debug", false, false)], false, false)]]), false, false), false)],
                    ["noiframe", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Disables the commandline iframe. Dangerous setting, use [[seturl]] to set it. If you ever set this setting to \"true\" globally and then want to set it to false again, you can do this by opening Tridactyl's preferences page from about:addons.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("false", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("true", false, false)], false, false), false)],
                    ["noiframeon", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false, false), false)],
                    ["editorcmd", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Insert / input mode edit-in-$EDITOR command to run\nThis has to be a command that stays in the foreground for the whole editing session\n\"auto\" will attempt to find a sane editor in your path.\nPlease send your requests to have your favourite terminal moved further up the list to /dev/null.\n          (but we are probably happy to add your terminal to the list if it isn't already there.)\n\nExample values:\n- linux: `xterm -e vim`\n- windows: `start cmd.exe /c \\\"vim\\\"`.\n\nAlso see [:editor](/static/docs/modules/_src_excmds_.html#editor).", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false)],
                    ["rsscmd", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Command that should be run by the [[rssexec]] ex command. Has the\nfollowing format:\n- %u: url\n- %t: title\n- %y: type (rss, atom, xml...)\nWarning: This is a very large footgun. %u will be inserted without any\nkind of escaping, hence you must obey the following rules if you care\nabout security:\n- Do not use a composite command. If you need a composite command,\ncreate an alias.\n- Do not use `js` or `jsb`. If you need to use them, create an alias.\n- Do not insert any %u, %t or %y in shell commands run by the native\nmessenger. Use pipes instead.\n\nHere's an example of how to save an rss url in a file on your disk\nsafely:\n`alias save_rss jsb -p tri.native.run(\"cat >> ~/.config.newsboat/urls\", JS_ARG)`\n`set rsscmd save_rss %u`\nThis is safe because the url is passed to jsb as an argument rather than\nbeing expanded inside of the string it will execute and because it is\npiped to the shell command rather than being expanded inside of it.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false)],
                    ["browser", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("The browser executable to look for in commands such as `restart`. Not as mad as it seems if you have multiple versions of Firefox...", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false)],
                    ["yankto", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Which clipboard to store items in. Requires the native messenger to be installed.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("clipboard", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("selection", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("both", false, false)], false, false), false)],
                    ["putfrom", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Which clipboard to retrieve items from. Requires the native messenger to be installed.\n\nPermitted values: `clipboard`, or `selection`.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("clipboard", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("selection", false, false)], false, false), false)],
                    ["externalclipboardcmd", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Clipboard command to try to get the selection from (e.g. `xsel` or `xclip`)", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false)],
                    ["nativeinstallcmd", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Set this to something weird if you want to have fun every time Tridactyl tries to update its native messenger.\n\n%TAG will be replaced with your version of Tridactyl for stable builds, or \"master\" for beta builds", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false)],
                    ["win_nativeinstallcmd", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Set this to something weird if you want to have fun every time Tridactyl tries to update its native messenger.\n\nReplaces %WINTAG with \"-Tag $TRI_VERSION\", similarly to [[nativeinstallcmd]].", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false)],
                    ["update", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Used by :updatecheck and related built-in functionality to automatically check for updates and prompt users to upgrade.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ObjectType"](new Map([["nag", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["BooleanType"](false, false)], ["nagwait", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false)], ["lastnaggedversion", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false)], ["lastchecktime", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false)], ["checkintervalsecs", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false)]]), false, false), false)],
                    ["profiledir", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Profile directory to use with native messenger with e.g, `guiset`.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false)],
                    ["tabopencontaineraware", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("If enabled, tabopen opens a new tab in the currently active tab's container.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("false", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("true", false, false)], false, false), false)],
                    ["containerindicator", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("If moodeindicator is enabled, containerindicator will color the border of the mode indicator with the container color.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("false", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("true", false, false)], false, false), false)],
                    ["auconcreatecontainer", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Autocontain directives create a container if it doesn't exist already.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("false", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("true", false, false)], false, false), false)],
                    ["historyresults", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Number of most recent results to ask Firefox for. We display the top 20 or so most frequently visited ones.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false), false)],
                    ["bmarkweight", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("When displaying bookmarks in history completions, how many page views to pretend they have.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false), false)],
                    ["findresults", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Number of results that should be shown in completions. -1 for unlimited", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false), false)],
                    ["findcontextlen", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Number of characters to use as context for the matches shown in completions", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false), false)],
                    ["findcase", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Whether find should be case-sensitive", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("smart", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("sensitive", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("insensitive", false, false)], false, false), false)],
                    ["incsearch", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Whether Tridactyl should jump to the first match when using `:find`", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("false", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("true", false, false)], false, false), false)],
                    ["minincsearchlen", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("How many characters should be typed before triggering incsearch/completions", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["NumberType"](false, false), false)],
                    ["csp", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Change this to \"clobber\" to ruin the \"Content Security Policy\" of all sites a bit and make Tridactyl run a bit better on some of them, e.g. raw.github*", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("untouched", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("clobber", false, false)], false, false), false)],
                    ["wordpattern", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("JavaScript RegExp used to recognize words in text.* functions (e.g. text.transpose_words). Should match any character belonging to a word.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false)],
                    ["perfcounters", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Activate tridactyl's performance counters. These have a\nmeasurable performance impact, since every sample is a few\nhundred bytes and we sample tridactyl densely, but they're good\nwhen you're trying to optimize things.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("false", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("true", false, false)], false, false), false)],
                    ["perfsamples", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("How many samples to store from the perf counters.\n\nEach performance entry is two numbers (16 bytes), an entryType\nof either \"mark\" or \"measure\" (js strings are utf-16 ad we have\ntwo marks for each measure, so amortize to about 10 bytes per\nentry), and a string name that for Tridactyl object will be\nabout 40 (utf-16) characters (80 bytes), plus object overhead\nroughly proportional to the string-length of the name of the\nconstructor (in this case something like 30 bytes), for a total\nof what we'll call 128 bytes for ease of math.\n\nWe want to store, by default, about 1MB of performance\nstatistics, so somewhere around 10k samples.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false)],
                    ["modeindicatorshowkeys", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Show (partial) command in the mode indicator.\nCorresponds to 'showcmd' option of vi.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("false", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("true", false, false)], false, false), false)],
                    ["urlparenttrailingslash", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Whether a trailing slash is appended when we get the parent of a url with\ngu (or other means).", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("false", false, false),
                            new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("true", false, false)], false, false), false)]]))]]), new Map([["o", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false), true)],
            ["schlepp", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), true)],
            ["getDeepProperty", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Given an object and a target, extract the target if it exists, else return undefined", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false), true)],
            ["setDeepProperty", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Create the key path target if it doesn't exist and set the final property to value.\n\nIf the path is an empty array, replace the obj.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false), true)],
            ["mergeDeep", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false), true)],
            ["getURL", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false), true)],
            ["get", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Get the value of the key target.\n\nIf the user has not specified a key, use the corresponding key from\ndefaults, if one exists, else undefined.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("rsscmd", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("noiframeon", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("theme", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("exaliases", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("viewsource", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("autocontain", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("configversion", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("subconfigs", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("priority", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("exmaps", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("ignoremaps", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("imaps", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("inputmaps", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("... 60 more ...", [], false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("urlparenttrailingslash", false, false)], false, true), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false), true)],
            ["getDynamic", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Get the value of the key target.\n\nPlease only use this with targets that will be used at runtime - it skips static checks. Prefer [[get]].", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), false, false), false)],
            ["getAsyncDynamic", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Get the value of the key target.\n\nPlease only use this with targets that will be used at runtime - it skips static checks. Prefer [[getAsync]].", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), false)],
            ["getAsync", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Get the value of the key target, but wait for config to be loaded from the\ndatabase first if it has not been at least once before.\n\nThis is useful if you are a content script and you've just been loaded.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("rsscmd", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("noiframeon", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("theme", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("exaliases", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("viewsource", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("autocontain", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("configversion", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("subconfigs", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("priority", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("exmaps", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("ignoremaps", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("imaps", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("inputmaps", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("... 60 more ...", [], false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("urlparenttrailingslash", false, false)], false, true), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("...", [], false, false)], false, false), false, false), true)],
            ["setURL", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), true)],
            ["set", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Full target specification, then value\n\ne.g.\n    set(\"nmaps\", \"o\", \"open\")\n    set(\"search\", \"default\", \"google\")\n    set(\"aucmd\", \"BufRead\", \"memrise.com\", \"open memrise.com\")", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), true)],
            ["unsetURL", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), true)],
            ["unset", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Delete the key at target in USERCONFIG if it exists", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["ArrayType"](new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), true)],
            ["save", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Save the config back to storage API.\n\nConfig is not synchronised between different instances of this module until\nsometime after this happens.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["UnionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("sync", false, false),
                        new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["LiteralTypeType"]("local", false, false)], false, true)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], false, false), false, false), true)],
            ["update", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Updates the config to the latest version.\nProposed semantic for config versionning:\n- x.y -> x+1.0 : major architectural changes\n- x.y -> x.y+1 : renaming settings/changing their types\nThere's no need for an updater if you're only adding a new setting/changing\na default setting\n\nWhen adding updaters, don't forget to set(\"configversion\", newversionnumber)!", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), true)],
            ["init", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Read all user configuration from storage API then notify any waiting asynchronous calls\n\nasynchronous calls generated by getAsync.", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("Promise", [new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false)], false, false), false, false), true)],
            ["addChangeListener", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("P", [], false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), true)],
            ["removeChangeListener", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["TypeReferenceType"]("P", [], false, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false), new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["AnyType"](true, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false)], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["VoidType"](false, false), false, false), true)],
            ["parseConfig", new _compiler_metadata_AllMetadata__WEBPACK_IMPORTED_MODULE_1__["SymbolMetadata"]("Parse the config into a string representation of a .tridactylrc config file.\nTries to parse the config into sectionable chunks based on keywords.\nBinds, aliases, autocmds and logging settings each have their own section while the rest are dumped into \"General Settings\".", new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["FunctionType"]([], new _compiler_types_AllTypes__WEBPACK_IMPORTED_MODULE_0__["StringType"](false, false), false, false), false)]]))]]));
let staticThemes = ["dark", "default", "greenmat", "halloween", "quake", "shydactyl"];


/***/ }),

/***/ "./src/commandline_frame.ts":
/*!**********************************!*\
  !*** ./src/commandline_frame.ts ***!
  \**********************************/
/*! exports provided: enableCompletions, focus, refresh_completions, clear, fillcmdline, setClipboard, getClipboard, getContent, editor_function */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableCompletions", function() { return enableCompletions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "focus", function() { return focus; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "refresh_completions", function() { return refresh_completions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fillcmdline", function() { return fillcmdline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setClipboard", function() { return setClipboard; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getClipboard", function() { return getClipboard; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getContent", function() { return getContent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "editor_function", function() { return editor_function; });
/* harmony import */ var _src_perf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/perf */ "./src/perf.ts");
/* harmony import */ var _src_lib_number_clamp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @src/lib/number.clamp */ "./src/lib/number.clamp.ts");
/* harmony import */ var _src_lib_number_clamp__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_src_lib_number_clamp__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _src_lib_html_tagged_template__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @src/lib/html-tagged-template */ "./src/lib/html-tagged-template.js");
/* harmony import */ var _src_lib_html_tagged_template__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_src_lib_html_tagged_template__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _src_completions_TabAll__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @src/completions/TabAll */ "./src/completions/TabAll.ts");
/* harmony import */ var _src_completions_Tab__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @src/completions/Tab */ "./src/completions/Tab.ts");
/* harmony import */ var _src_completions_Bmark__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @src/completions/Bmark */ "./src/completions/Bmark.ts");
/* harmony import */ var _src_completions_Excmd__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @src/completions/Excmd */ "./src/completions/Excmd.ts");
/* harmony import */ var _src_completions_FileSystem__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @src/completions/FileSystem */ "./src/completions/FileSystem.ts");
/* harmony import */ var _src_completions_Guiset__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @src/completions/Guiset */ "./src/completions/Guiset.ts");
/* harmony import */ var _src_completions_Help__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @src/completions/Help */ "./src/completions/Help.ts");
/* harmony import */ var _src_completions_History__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @src/completions/History */ "./src/completions/History.ts");
/* harmony import */ var _src_completions_Preferences__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @src/completions/Preferences */ "./src/completions/Preferences.ts");
/* harmony import */ var _src_completions_Rss__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @src/completions/Rss */ "./src/completions/Rss.ts");
/* harmony import */ var _src_completions_Sessions__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @src/completions/Sessions */ "./src/completions/Sessions.ts");
/* harmony import */ var _src_completions_Settings__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @src/completions/Settings */ "./src/completions/Settings.ts");
/* harmony import */ var _src_completions_Window__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @src/completions/Window */ "./src/completions/Window.ts");
/* harmony import */ var _src_lib_messaging__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @src/lib/messaging */ "./src/lib/messaging.ts");
/* harmony import */ var _src_state__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @src/state */ "./src/state.ts");
/* harmony import */ var _src_lib_logging__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @src/lib/logging */ "./src/lib/logging.ts");
/* harmony import */ var _src_content_styling__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @src/content/styling */ "./src/content/styling.ts");
/* harmony import */ var _src_parsers_genericmode__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @src/parsers/genericmode */ "./src/parsers/genericmode.ts");
/* harmony import */ var _src_lib_editor__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @src/lib/editor */ "./src/lib/editor.ts");
/* harmony import */ var _src_commandline_frame__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @src/commandline_frame */ "./src/commandline_frame.ts");
/* harmony import */ var _src_lib_commandline_cmds__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @src/lib/commandline_cmds */ "./src/lib/commandline_cmds.ts");
/** # Command line functions
 *
 * This file contains functions to interact with the command line.
 *
 * If you want to bind them to keyboard shortcuts, be sure to prefix them with "ex.". For example, if you want to bind control-p to `prev_completion`, use:
 *
 * ```
 * bind --mode=ex <C-p> ex.prev_completion
 * ```
 *
 * Note that you can also bind Tridactyl's [editor functions](/static/docs/modules/_src_lib_editor_.html) in the command line.
 *
 * Contrary to the main tridactyl help page, this one doesn't tell you whether a specific function is bound to something. For now, you'll have to make do with `:bind` and `:viewconfig`.
 *
 */
/** ignore this line */
/** Script used in the commandline iframe. Communicates with background. */























/** @hidden **/
const logger = new _src_lib_logging__WEBPACK_IMPORTED_MODULE_18__["default"]("cmdline");
/** @hidden **/
const commandline_state = {
    activeCompletions: undefined,
    clInput: window.document.getElementById("tridactyl-input"),
    clear,
    cmdline_history_position: 0,
    completionsDiv: window.document.getElementById("completions"),
    fns: undefined,
    getCompletion,
    history,
    /** @hidden
     * This is to handle Escape key which, while the cmdline is focused,
     * ends up firing both keydown and input listeners. In the worst case
     * hides the cmdline, shows and refocuses it and replaces its text
     * which could be the prefix to generate a completion.
     * tl;dr TODO: delete this and better resolve race condition
     */
    isVisible: false,
    keyEvents: [],
    refresh_completions,
    state: _src_state__WEBPACK_IMPORTED_MODULE_17__["default"],
};
// first theming of commandline iframe
Object(_src_content_styling__WEBPACK_IMPORTED_MODULE_19__["theme"])(document.querySelector(":root"));
/** @hidden **/
function resizeArea() {
    if (commandline_state.isVisible) {
        _src_lib_messaging__WEBPACK_IMPORTED_MODULE_16__["messageOwnTab"]("commandline_content", "show");
        _src_lib_messaging__WEBPACK_IMPORTED_MODULE_16__["messageOwnTab"]("commandline_content", "focus");
        focus();
    }
}
/** @hidden
 * This is a bit loosely defined at the moment.
 * Should work so long as there's only one completion source per prefix.
 */
function getCompletion() {
    if (!commandline_state.activeCompletions)
        return undefined;
    for (const comp of commandline_state.activeCompletions) {
        if (comp.state === "normal" && comp.completion !== undefined) {
            return comp.completion;
        }
    }
}
commandline_state.getCompletion = getCompletion;
/** @hidden **/
function enableCompletions() {
    if (!commandline_state.activeCompletions) {
        commandline_state.activeCompletions = [
            // FindCompletionSource,
            _src_completions_Bmark__WEBPACK_IMPORTED_MODULE_5__["BmarkCompletionSource"],
            _src_completions_TabAll__WEBPACK_IMPORTED_MODULE_3__["TabAllCompletionSource"],
            _src_completions_Tab__WEBPACK_IMPORTED_MODULE_4__["BufferCompletionSource"],
            _src_completions_Excmd__WEBPACK_IMPORTED_MODULE_6__["ExcmdCompletionSource"],
            _src_completions_FileSystem__WEBPACK_IMPORTED_MODULE_7__["FileSystemCompletionSource"],
            _src_completions_Guiset__WEBPACK_IMPORTED_MODULE_8__["GuisetCompletionSource"],
            _src_completions_Help__WEBPACK_IMPORTED_MODULE_9__["HelpCompletionSource"],
            _src_completions_History__WEBPACK_IMPORTED_MODULE_10__["HistoryCompletionSource"],
            _src_completions_Preferences__WEBPACK_IMPORTED_MODULE_11__["PreferenceCompletionSource"],
            _src_completions_Rss__WEBPACK_IMPORTED_MODULE_12__["RssCompletionSource"],
            _src_completions_Sessions__WEBPACK_IMPORTED_MODULE_13__["SessionsCompletionSource"],
            _src_completions_Settings__WEBPACK_IMPORTED_MODULE_14__["SettingsCompletionSource"],
            _src_completions_Window__WEBPACK_IMPORTED_MODULE_15__["WindowCompletionSource"],
        ]
            .map(constructorr => {
            try {
                return new constructorr(commandline_state.completionsDiv);
            }
            catch (e) { }
        })
            .filter(c => c);
        const fragment = document.createDocumentFragment();
        commandline_state.activeCompletions.forEach(comp => fragment.appendChild(comp.node));
        commandline_state.completionsDiv.appendChild(fragment);
        logger.debug(commandline_state.activeCompletions);
    }
}
/* document.addEventListener("DOMContentLoaded", enableCompletions) */
/** @hidden **/
const noblur = e => setTimeout(() => commandline_state.clInput.focus(), 0);
/** @hidden **/
function focus() {
    commandline_state.clInput.focus();
    commandline_state.clInput.removeEventListener("blur", noblur);
    commandline_state.clInput.addEventListener("blur", noblur);
}
/** @hidden **/
let HISTORY_SEARCH_STRING;
/** @hidden
 * Command line keybindings
 **/
const keyParser = keys => _src_parsers_genericmode__WEBPACK_IMPORTED_MODULE_20__["parser"]("exmaps", keys);
/** @hidden **/
let history_called = false;
/** @hidden **/
let prev_cmd_called_history = false;
/** @hidden **/
commandline_state.clInput.addEventListener("keydown", function (keyevent) {
    if (!keyevent.isTrusted)
        return;
    commandline_state.keyEvents.push(keyevent);
    const response = keyParser(commandline_state.keyEvents);
    if (response.isMatch) {
        keyevent.preventDefault();
        keyevent.stopImmediatePropagation();
    }
    else {
        // Ideally, all keys that aren't explicitly bound to an ex command
        // should be bound to a "self-insert" command that would input the
        // key itself. Because it's not possible to generate events as if
        // they originated from the user, we can't do this, but we still
        // need to simulate it, in order to have history() work.
        prev_cmd_called_history = false;
    }
    if (response.value) {
        commandline_state.keyEvents = [];
        history_called = false;
        // If excmds start with 'ex.' they're coming back to us anyway, so skip that.
        // This is definitely a hack. Should expand aliases with exmode, etc.
        // but this whole thing should be scrapped soon, so whatever.
        if (response.value.startsWith("ex.")) {
            const funcname = response.value.slice(3);
            commandline_state.fns[funcname]();
            prev_cmd_called_history = history_called;
        }
        else {
            // Send excmds directly to our own tab, which fixes the
            // old bug where a command would be issued in one tab but
            // land in another because the active tab had
            // changed. Background-mode excmds will be received by the
            // own tab's content script and then bounced through a
            // shim to the background, but the latency increase should
            // be acceptable becuase the background-mode excmds tend
            // to be a touch less latency-sensitive.
            _src_lib_messaging__WEBPACK_IMPORTED_MODULE_16__["messageOwnTab"]("controller_content", "acceptExCmd", [
                response.value,
            ]).then(_ => (prev_cmd_called_history = history_called));
        }
    }
    else {
        commandline_state.keyEvents = response.keys;
    }
}, true);
function refresh_completions(exstr) {
    if (!commandline_state.activeCompletions)
        enableCompletions();
    return Promise.all(commandline_state.activeCompletions.map(comp => comp.filter(exstr).then(() => {
        if (comp.shouldRefresh()) {
            return resizeArea();
        }
    }))).catch(err => {
        console.error(err);
        return [];
    }); // We can't use the regular logging mechanism because the user is using the command line.
}
/** @hidden **/
let onInputPromise = Promise.resolve();
/** @hidden **/
commandline_state.clInput.addEventListener("input", () => {
    const exstr = commandline_state.clInput.value;
    // Schedule completion computation. We do not start computing immediately because this would incur a slow down on quickly repeated input events (e.g. maintaining <Backspace> pressed)
    setTimeout(async () => {
        // Make sure the previous computation has ended
        await onInputPromise;
        // If we're not the current completion computation anymore, stop
        if (exstr !== commandline_state.clInput.value)
            return;
        onInputPromise = refresh_completions(exstr);
    }, 100);
});
/** @hidden **/
let cmdline_history_current = "";
/** @hidden
 * Clears the command line.
 * If you intend to close the command line after this, set evlistener to true in order to enable losing focus.
 *  Otherwise, no need to pass an argument.
 */
function clear(evlistener = false) {
    if (evlistener)
        commandline_state.clInput.removeEventListener("blur", noblur);
    commandline_state.clInput.value = "";
    commandline_state.cmdline_history_position = 0;
    cmdline_history_current = "";
}
commandline_state.clear = clear;
/** @hidden **/
function history(n) {
    history_called = true;
    if (!prev_cmd_called_history) {
        HISTORY_SEARCH_STRING = commandline_state.clInput.value;
    }
    const matches = _src_state__WEBPACK_IMPORTED_MODULE_17__["default"].cmdHistory.filter(key => key.startsWith(HISTORY_SEARCH_STRING));
    if (commandline_state.cmdline_history_position === 0) {
        cmdline_history_current = commandline_state.clInput.value;
    }
    let clamped_ind = matches.length + n - commandline_state.cmdline_history_position;
    clamped_ind = clamped_ind.clamp(0, matches.length);
    const pot_history = matches[clamped_ind];
    commandline_state.clInput.value =
        pot_history === undefined ? cmdline_history_current : pot_history;
    // if there was no clampage, update history position
    // there's a more sensible way of doing this but that would require more programmer time
    if (clamped_ind === matches.length + n - commandline_state.cmdline_history_position)
        commandline_state.cmdline_history_position = commandline_state.cmdline_history_position - n;
}
commandline_state.history = history;
/** @hidden **/
function fillcmdline(newcommand, trailspace = true, ffocus = true) {
    if (trailspace)
        commandline_state.clInput.value = newcommand + " ";
    else
        commandline_state.clInput.value = newcommand;
    commandline_state.isVisible = true;
    let result = Promise.resolve([]);
    // Focus is lost for some reason.
    if (ffocus) {
        focus();
        result = refresh_completions(commandline_state.clInput.value);
    }
    return result;
}
/** @hidden
 * Create a temporary textarea and give it to fn. Remove the textarea afterwards
 *
 * Useful for document.execCommand
 **/
function applyWithTmpTextArea(fn) {
    let textarea;
    try {
        textarea = document.createElement("textarea");
        // Scratchpad must be `display`ed, but can be tiny and invisible.
        // Being tiny and invisible means it won't make the parent page move.
        textarea.style.cssText =
            "visible: invisible; width: 0; height: 0; position: fixed";
        textarea.contentEditable = "true";
        document.documentElement.appendChild(textarea);
        return fn(textarea);
    }
    finally {
        document.documentElement.removeChild(textarea);
    }
}
/** @hidden **/
async function setClipboard(content) {
    await _src_lib_messaging__WEBPACK_IMPORTED_MODULE_16__["messageOwnTab"]("commandline_content", "focus");
    applyWithTmpTextArea(scratchpad => {
        scratchpad.value = content;
        scratchpad.select();
        if (document.execCommand("Copy")) {
            // // todo: Maybe we can consider to using some logger and show it with status bar in the future
            logger.info("set clipboard:", scratchpad.value);
        }
        else
            throw "Failed to copy!";
    });
    // Return focus to the document
    await _src_lib_messaging__WEBPACK_IMPORTED_MODULE_16__["messageOwnTab"]("commandline_content", "hide");
    return _src_lib_messaging__WEBPACK_IMPORTED_MODULE_16__["messageOwnTab"]("commandline_content", "blur");
}
/** @hidden **/
async function getClipboard() {
    await _src_lib_messaging__WEBPACK_IMPORTED_MODULE_16__["messageOwnTab"]("commandline_content", "focus");
    const result = applyWithTmpTextArea(scratchpad => {
        scratchpad.focus();
        document.execCommand("Paste");
        return scratchpad.textContent;
    });
    // Return focus to the document
    await _src_lib_messaging__WEBPACK_IMPORTED_MODULE_16__["messageOwnTab"]("commandline_content", "hide");
    await _src_lib_messaging__WEBPACK_IMPORTED_MODULE_16__["messageOwnTab"]("commandline_content", "blur");
    return result;
}
/** @hidden **/
function getContent() {
    return commandline_state.clInput.value;
}
/** @hidden **/
function editor_function(fn_name, ...args) {
    let result = Promise.resolve([]);
    if (_src_lib_editor__WEBPACK_IMPORTED_MODULE_21__[fn_name]) {
        _src_lib_editor__WEBPACK_IMPORTED_MODULE_21__[fn_name](commandline_state.clInput, ...args);
        result = refresh_completions(commandline_state.clInput.value);
    }
    else {
        // The user is using the command line so we can't log message there
        // logger.error(`No editor function named ${fn_name}!`)
        console.error(`No editor function named ${fn_name}!`);
    }
    return result;
}

_src_lib_messaging__WEBPACK_IMPORTED_MODULE_16__["addListener"]("commandline_frame", _src_lib_messaging__WEBPACK_IMPORTED_MODULE_16__["attributeCaller"](_src_commandline_frame__WEBPACK_IMPORTED_MODULE_22__));

commandline_state.fns = Object(_src_lib_commandline_cmds__WEBPACK_IMPORTED_MODULE_23__["getCommandlineFns"])(commandline_state);
_src_lib_messaging__WEBPACK_IMPORTED_MODULE_16__["addListener"]("commandline_cmd", _src_lib_messaging__WEBPACK_IMPORTED_MODULE_16__["attributeCaller"](commandline_state.fns));
window.tri = Object.assign(window.tri || {}, {
    perfObserver: _src_perf__WEBPACK_IMPORTED_MODULE_0__["listenForCounters"](),
});


/***/ }),

/***/ "./src/completions.ts":
/*!****************************!*\
  !*** ./src/completions.ts ***!
  \****************************/
/*! exports provided: DEFAULT_FAVICON, CompletionOption, CompletionSource, CompletionOptionHTML, CompletionSourceFuse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_FAVICON", function() { return DEFAULT_FAVICON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompletionOption", function() { return CompletionOption; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompletionSource", function() { return CompletionSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompletionOptionHTML", function() { return CompletionOptionHTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompletionSourceFuse", function() { return CompletionSourceFuse; });
/* harmony import */ var fuse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fuse.js */ "./node_modules/fuse.js/dist/fuse.js");
/* harmony import */ var fuse_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fuse_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _src_lib_itertools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @src/lib/itertools */ "./src/lib/itertools.ts");
/* harmony import */ var _src_lib_convert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @src/lib/convert */ "./src/lib/convert.ts");
/* harmony import */ var _src_lib_aliases__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @src/lib/aliases */ "./src/lib/aliases.ts");
/*

Have an array of all completion sources. Completion sources display nothing if the filter doesn't match for them.

On each input event, call updateCompletions on the array. That will mutate the array and update the display as required.

How to handle cached e.g. buffer information going out of date?

Concrete completion classes have been moved to src/completions/.

*/




const DEFAULT_FAVICON = browser.runtime.getURL("static/defaultFavicon.svg");
class CompletionOption {
}
class CompletionSource {
    constructor(prefixes) {
        this.prefixes = [];
        const commands = _src_lib_aliases__WEBPACK_IMPORTED_MODULE_3__["getCmdAliasMapping"]();
        // Now, for each prefix given as argument, add it to the completionsource's prefix list and also add any alias it has
        prefixes
            .map(p => p.trim())
            .forEach(p => {
            this.prefixes.push(p);
            if (commands[p])
                this.prefixes = this.prefixes.concat(commands[p]);
        });
        // Not sure this is necessary but every completion source has it
        this.prefixes = this.prefixes.map(p => p + " ");
    }
    /** Control presentation of Source */
    set state(newstate) {
        switch (newstate) {
            case "normal":
                this.node.classList.remove("hidden");
                this.completion = undefined;
                break;
            case "hidden":
                this.node.classList.add("hidden");
                break;
        }
        this._prevState = this._state;
        this._state = newstate;
    }
    get state() {
        return this._state;
    }
    shouldRefresh() {
        // A completion source should be refreshed if it is not hidden or if it just became hidden
        return this._state !== "hidden" || this.state !== this._prevState;
    }
    prev(inc = 1) {
        return this.next(-1 * inc);
    }
    deselect() {
        this.completion = undefined;
        if (this.lastFocused !== undefined)
            this.lastFocused.state = "normal";
    }
}
// Default classes
class CompletionOptionHTML extends CompletionOption {
    constructor() {
        super(...arguments);
        this._state = "hidden";
    }
    /** Control presentation of element */
    set state(newstate) {
        // console.log("state from to", this._state, newstate)
        switch (newstate) {
            case "focused":
                this.html.classList.add("focused");
                this.html.scrollIntoView();
                this.html.classList.remove("hidden");
                break;
            case "normal":
                this.html.classList.remove("focused");
                this.html.classList.remove("hidden");
                break;
            case "hidden":
                this.html.classList.remove("focused");
                this.html.classList.add("hidden");
                break;
        }
        this._state = newstate;
    }
    get state() {
        return this._state;
    }
}
class CompletionSourceFuse extends CompletionSource {
    constructor(prefixes, className, title) {
        super(prefixes);
        this.fuseOptions = {
            keys: ["fuseKeys"],
            shouldSort: true,
            id: "index",
            includeScore: true,
        };
        // PERF: Could be expensive not to cache Fuse()
        // yeah, it was.
        this.fuse = undefined;
        this.optionContainer = html `<table class="optionContainer"></table>`;
        this.node = html `<div class="${className} hidden">
                <div class="sectionHeader">${title || className}</div>
            </div>`;
        this.node.appendChild(this.optionContainer);
        this.state = "hidden";
    }
    // Helpful default implementations
    async filter(exstr) {
        this.lastExstr = exstr;
        await this.onInput(exstr);
        return this.updateChain();
    }
    updateChain(exstr = this.lastExstr, options = this.options) {
        if (options === undefined) {
            this.state = "hidden";
            return;
        }
        const [prefix, query] = this.splitOnPrefix(exstr);
        // console.log(prefix, query, options)
        // Hide self and stop if prefixes don't match
        if (prefix) {
            // Show self if prefix and currently hidden
            if (this.state === "hidden") {
                this.state = "normal";
            }
        }
        else {
            this.state = "hidden";
            return;
        }
        // Filter by query if query is not empty
        if (query) {
            this.setStateFromScore(this.scoredOptions(query));
            // Else show all options
        }
        else {
            options.forEach(option => (option.state = "normal"));
        }
        // Call concrete class
        this.updateDisplay();
    }
    select(option) {
        if (this.lastExstr !== undefined && option !== undefined) {
            const [prefix] = this.splitOnPrefix(this.lastExstr);
            this.completion = prefix + option.value;
            option.state = "focused";
            this.lastFocused = option;
        }
        else {
            throw new Error("lastExstr and option must be defined!");
        }
    }
    splitOnPrefix(exstr) {
        for (const prefix of this.prefixes) {
            if (exstr.startsWith(prefix)) {
                const query = exstr.replace(prefix, "");
                return [prefix, query];
            }
        }
        return [undefined, undefined];
    }
    /** Rtn sorted array of {option, score} */
    scoredOptions(query, options = this.options) {
        const searchThis = this.options.map((elem, index) => {
            return { index, fuseKeys: elem.fuseKeys };
        });
        this.fuse = new fuse_js__WEBPACK_IMPORTED_MODULE_0__(searchThis, this.fuseOptions);
        return this.fuse.search(query).map(result => {
            // console.log(result, result.item, query)
            const index = Object(_src_lib_convert__WEBPACK_IMPORTED_MODULE_2__["toNumber"])(result.item);
            return {
                index,
                option: this.options[index],
                score: result.score,
            };
        });
    }
    /** Set option state by score

        For now just displays all scored elements (see threshold in fuse) and
        focus the best match.
    */
    setStateFromScore(scoredOpts, autoselect = false) {
        const matches = scoredOpts.map(res => res.index);
        for (const [index, option] of Object(_src_lib_itertools__WEBPACK_IMPORTED_MODULE_1__["enumerate"])(this.options)) {
            if (matches.includes(index))
                option.state = "normal";
            else
                option.state = "hidden";
        }
        // ideally, this would not deselect anything unless it fell off the list of matches
        if (matches.length && autoselect) {
            this.select(this.options[matches[0]]);
        }
        else {
            this.deselect();
        }
    }
    /** Call to replace the current display */
    // TODO: optionContainer.replaceWith and optionContainer.remove don't work.
    // I don't know why, but it means we can't replace the div in one go. Maybe
    // an iframe thing.
    updateDisplay() {
        /* const newContainer = html`<div>` */
        while (this.optionContainer.hasChildNodes()) {
            this.optionContainer.removeChild(this.optionContainer.lastChild);
        }
        for (const option of this.options) {
            /* newContainer.appendChild(option.html) */
            if (option.state !== "hidden")
                this.optionContainer.appendChild(option.html);
        }
        /* console.log('updateDisplay', this.optionContainer, newContainer) */
        /* let result1 = this.optionContainer.remove() */
        /* let res2 = this.node.appendChild(newContainer) */
        /* console.log('results', result1, res2) */
    }
    next(inc = 1) {
        if (this.state !== "hidden") {
            const visopts = this.options.filter(o => o.state !== "hidden");
            const currind = visopts.findIndex(o => o.state === "focused");
            this.deselect();
            // visopts.length + 1 because we want an empty completion at the end
            const max = visopts.length + 1;
            const opt = visopts[(currind + inc + max) % max];
            if (opt)
                this.select(opt);
            return true;
        }
        else
            return false;
    }
}
// }}}


/***/ }),

/***/ "./src/completions/Bmark.ts":
/*!**********************************!*\
  !*** ./src/completions/Bmark.ts ***!
  \**********************************/
/*! exports provided: BmarkCompletionSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BmarkCompletionSource", function() { return BmarkCompletionSource; });
/* harmony import */ var _src_completions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/completions */ "./src/completions.ts");
/* harmony import */ var _src_completions_providers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @src/completions/providers */ "./src/completions/providers.ts");


class BmarkCompletionOption extends _src_completions__WEBPACK_IMPORTED_MODULE_0__["CompletionOptionHTML"] {
    constructor(value, bmark) {
        super();
        this.value = value;
        this.fuseKeys = [];
        if (!bmark.title) {
            bmark.title = new URL(bmark.url).host;
        }
        // Push properties we want to fuzmatch on
        this.fuseKeys.push(bmark.title, bmark.url);
        this.html = html `<tr class="BmarkCompletionOption option">
                <td class="prefix">${"".padEnd(2)}</td>
                <td class="title">${bmark.title}</td>
                <td class="content">
                    <a class="url" target="_blank" href=${bmark.url}
                        >${bmark.url}</a
                    >
                </td>
            </tr>`;
    }
}
class BmarkCompletionSource extends _src_completions__WEBPACK_IMPORTED_MODULE_0__["CompletionSourceFuse"] {
    constructor(_parent) {
        super(["bmarks"], "BmarkCompletionSource", "Bookmarks");
        this._parent = _parent;
        this._parent.appendChild(this.node);
    }
    async filter(exstr) {
        this.lastExstr = exstr;
        let [prefix, query] = this.splitOnPrefix(exstr);
        let option = "";
        // Hide self and stop if prefixes don't match
        if (prefix) {
            // Show self if prefix and currently hidden
            if (this.state === "hidden") {
                this.state = "normal";
            }
        }
        else {
            this.state = "hidden";
            return;
        }
        if (query.startsWith("-t ")) {
            option = "-t ";
            query = query.slice(3);
        }
        if (query.startsWith("-c")) {
            const args = query.split(" ");
            option += args.slice(0, 2).join(" ");
            option += " ";
            query = args.slice(2).join(" ");
        }
        this.completion = undefined;
        this.options = (await _src_completions_providers__WEBPACK_IMPORTED_MODULE_1__["getBookmarks"](query)).slice(0, 10).map(page => new BmarkCompletionOption(option + page.url, page));
        return this.updateChain();
    }
    updateChain() {
        // Options are pre-trimmed to the right length.
        this.options.forEach(option => (option.state = "normal"));
        // Call concrete class
        return this.updateDisplay();
    }
    onInput() { }
    select(option) {
        if (this.lastExstr !== undefined && option !== undefined) {
            this.completion = "bmarks " + option.value;
            option.state = "focused";
            this.lastFocused = option;
        }
        else {
            throw new Error("lastExstr and option must be defined!");
        }
    }
}


/***/ }),

/***/ "./src/completions/Excmd.ts":
/*!**********************************!*\
  !*** ./src/completions/Excmd.ts ***!
  \**********************************/
/*! exports provided: ExcmdCompletionSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExcmdCompletionSource", function() { return ExcmdCompletionSource; });
/* harmony import */ var _src_completions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/completions */ "./src/completions.ts");
/* harmony import */ var _src_metadata_generated__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @src/.metadata.generated */ "./src/.metadata.generated.ts");
/* harmony import */ var _src_lib_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @src/lib/config */ "./src/lib/config.ts");
/* harmony import */ var _src_lib_aliases__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @src/lib/aliases */ "./src/lib/aliases.ts");




class ExcmdCompletionOption extends _src_completions__WEBPACK_IMPORTED_MODULE_0__["CompletionOptionHTML"] {
    constructor(value, documentation = "") {
        super();
        this.value = value;
        this.documentation = documentation;
        this.fuseKeys = [];
        this.fuseKeys.push(this.value);
        // Create HTMLElement
        this.html = html `<tr class="ExcmdCompletionOption option">
                <td class="excmd">${value}</td>
                <td class="documentation">${documentation}</td>
            </tr>`;
    }
}
class ExcmdCompletionSource extends _src_completions__WEBPACK_IMPORTED_MODULE_0__["CompletionSourceFuse"] {
    constructor(_parent) {
        super([], "ExcmdCompletionSource", "ex commands");
        this._parent = _parent;
        this.updateOptions();
        this._parent.appendChild(this.node);
    }
    async filter(exstr) {
        this.lastExstr = exstr;
        return this.onInput(exstr);
    }
    async onInput(exstr) {
        return this.updateOptions(exstr);
    }
    updateChain(exstr = this.lastExstr, options = this.options) {
        if (this.options.length > 0)
            this.state = "normal";
        else
            this.state = "hidden";
        this.updateDisplay();
    }
    select(option) {
        this.completion = option.value;
        option.state = "focused";
        this.lastFocused = option;
    }
    setStateFromScore(scoredOpts) {
        super.setStateFromScore(scoredOpts, false);
    }
    async updateOptions(exstr = "") {
        this.lastExstr = exstr;
        const excmds = _src_metadata_generated__WEBPACK_IMPORTED_MODULE_1__["everything"].getFile("src/excmds.ts");
        if (!excmds)
            return;
        const fns = excmds.getFunctions();
        // Add all excmds that start with exstr and that tridactyl has metadata about to completions
        this.options = this.scoreOptions(fns
            .filter(([name, fn]) => !fn.hidden && name.startsWith(exstr))
            .map(([name, fn]) => new ExcmdCompletionOption(name, fn.doc)));
        // Also add aliases to possible completions
        const exaliases = Object.keys(_src_lib_config__WEBPACK_IMPORTED_MODULE_2__["get"]("exaliases")).filter(a => a.startsWith(exstr));
        for (const alias of exaliases) {
            const cmd = _src_lib_aliases__WEBPACK_IMPORTED_MODULE_3__["expandExstr"](alias);
            const fn = excmds.getFunction(cmd);
            if (fn) {
                this.options.push(new ExcmdCompletionOption(alias, `Alias for \`${cmd}\`. ${fn.doc}`));
            }
            else {
                // This can happen when the alias is a composite command or a command with arguments. We can't display doc because we don't know what parameter the alias takes or what it does.
                this.options.push(new ExcmdCompletionOption(alias, `Alias for \`${cmd}\`.`));
            }
        }
        this.options.forEach(o => (o.state = "normal"));
        return this.updateChain();
    }
    scoreOptions(options) {
        return options.sort((o1, o2) => o1.value.localeCompare(o2.value));
        // Too slow with large profiles
        // let histpos = state.cmdHistory.map(s => s.split(" ")[0]).reverse()
        // return exstrs.sort((a, b) => {
        //     let posa = histpos.findIndex(x => x == a)
        //     let posb = histpos.findIndex(x => x == b)
        //     // If two ex commands have the same position, sort lexically
        //     if (posa == posb) return a < b ? -1 : 1
        //     // If they aren't found in the list they get lower priority
        //     if (posa == -1) return 1
        //     if (posb == -1) return -1
        //     // Finally, sort by history position
        //     return posa < posb ? -1 : 1
        // })
    }
}


/***/ }),

/***/ "./src/completions/FileSystem.ts":
/*!***************************************!*\
  !*** ./src/completions/FileSystem.ts ***!
  \***************************************/
/*! exports provided: FileSystemCompletionSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FileSystemCompletionSource", function() { return FileSystemCompletionSource; });
/* harmony import */ var _src_completions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/completions */ "./src/completions.ts");
/* harmony import */ var _src_lib_native__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @src/lib/native */ "./src/lib/native.ts");


class FileSystemCompletionOption extends _src_completions__WEBPACK_IMPORTED_MODULE_0__["CompletionOptionHTML"] {
    constructor(value) {
        super();
        this.value = value;
        this.fuseKeys = [];
        this.fuseKeys = [value];
        this.html = html `<tr class="FileSystemCompletionOption option">
                <td class="value">${value}</td>
            </tr>`;
    }
}
class FileSystemCompletionSource extends _src_completions__WEBPACK_IMPORTED_MODULE_0__["CompletionSourceFuse"] {
    constructor(_parent) {
        super(["saveas", "source"], "FileSystemCompletionSource", "FileSystem");
        this._parent = _parent;
        this._parent.appendChild(this.node);
    }
    async onInput(exstr) {
        return this.filter(exstr);
    }
    async filter(exstr) {
        if (!exstr || exstr.indexOf(" ") === -1) {
            this.state = "hidden";
            return;
        }
        let [cmd, path] = this.splitOnPrefix(exstr);
        if (cmd === undefined) {
            this.state = "hidden";
            return;
        }
        if (!path)
            path = ".";
        if (!["/", "$", "~", "."].find(s => path.startsWith(s))) {
            // If the path doesn't start with a special character, it is relative to the native messenger, thus use "." as starting point
            // Does this work on windows?
            path = "./" + path;
        }
        // Update lastExstr because we modified the path and scoreOptions uses that in order to assign scores
        this.lastExstr = cmd + path;
        let req;
        try {
            req = await _src_lib_native__WEBPACK_IMPORTED_MODULE_1__["listDir"](path);
        }
        catch (e) {
            // Failing silently because we can't nativegate (the user is typing stuff in the commandline)
            this.state = "hidden";
            return;
        }
        if (req.isDir) {
            if (!path.endsWith(req.sep))
                path += req.sep;
        }
        else {
            path = path.substring(0, path.lastIndexOf("/") + 1);
        }
        this.options = req.files.map(p => new FileSystemCompletionOption(path + p));
        this.state = "normal";
        return this.updateChain();
    }
}


/***/ }),

/***/ "./src/completions/Guiset.ts":
/*!***********************************!*\
  !*** ./src/completions/Guiset.ts ***!
  \***********************************/
/*! exports provided: GuisetCompletionSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GuisetCompletionSource", function() { return GuisetCompletionSource; });
/* harmony import */ var _src_completions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/completions */ "./src/completions.ts");
/* harmony import */ var _src_lib_css_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @src/lib/css_util */ "./src/lib/css_util.ts");


class GuisetCompletionOption extends _src_completions__WEBPACK_IMPORTED_MODULE_0__["CompletionOptionHTML"] {
    constructor(value, displayValue) {
        super();
        this.value = value;
        this.fuseKeys = [];
        this.fuseKeys.push(value);
        this.html = html `<tr class="GuisetCompletionOption option">
                <td class="value">${displayValue}</td>
            </tr>`;
    }
}
class GuisetCompletionSource extends _src_completions__WEBPACK_IMPORTED_MODULE_0__["CompletionSourceFuse"] {
    constructor(_parent) {
        super(["guiset", "guiset_quiet"], "GuisetCompletionSource", "Guiset");
        this._parent = _parent;
        this._parent.appendChild(this.node);
    }
    async filter(exstr) {
        this.lastExstr = exstr;
        const [prefix, query] = this.splitOnPrefix(exstr);
        // Hide self and stop if prefixes don't match
        if (prefix) {
            // Show self if prefix and currently hidden
            if (this.state === "hidden") {
                this.state = "normal";
            }
        }
        else {
            this.state = "hidden";
            return;
        }
        this.completion = undefined;
        let ruleName = "";
        let subRule = "";
        if (query) {
            const args = query.trim().split(" ");
            ruleName = args[0] || "";
            subRule = args[1] || "";
        }
        this.options = [];
        if (_src_lib_css_util__WEBPACK_IMPORTED_MODULE_1__["metaRules"][ruleName]) {
            this.options = this.options.concat(Object.keys(_src_lib_css_util__WEBPACK_IMPORTED_MODULE_1__["metaRules"][ruleName])
                .filter(s => s.startsWith(subRule))
                .map(s => new GuisetCompletionOption(`${ruleName} ${s}`, s)));
        }
        if (_src_lib_css_util__WEBPACK_IMPORTED_MODULE_1__["potentialRules"][ruleName]) {
            this.options = this.options.concat(Object.keys(_src_lib_css_util__WEBPACK_IMPORTED_MODULE_1__["potentialRules"][ruleName].options)
                .filter(s => s.startsWith(subRule))
                .map(s => new GuisetCompletionOption(`${ruleName} ${s}`, s)));
        }
        if (this.options.length === 0) {
            this.options = Object.keys(_src_lib_css_util__WEBPACK_IMPORTED_MODULE_1__["metaRules"])
                .concat(Object.keys(_src_lib_css_util__WEBPACK_IMPORTED_MODULE_1__["potentialRules"]))
                .filter(s => s.startsWith(ruleName))
                .map(s => new GuisetCompletionOption(s, s));
        }
        return this.updateChain();
    }
    updateChain() {
        // Options are pre-trimmed to the right length.
        this.options.forEach(option => (option.state = "normal"));
        // Call concrete class
        return this.updateDisplay();
    }
    onInput(arg) {
        return this.filter(arg);
    }
}


/***/ }),

/***/ "./src/completions/Help.ts":
/*!*********************************!*\
  !*** ./src/completions/Help.ts ***!
  \*********************************/
/*! exports provided: HelpCompletionSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HelpCompletionSource", function() { return HelpCompletionSource; });
/* harmony import */ var _src_completions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/completions */ "./src/completions.ts");
/* harmony import */ var _src_metadata_generated__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @src/.metadata.generated */ "./src/.metadata.generated.ts");
/* harmony import */ var _src_lib_aliases__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @src/lib/aliases */ "./src/lib/aliases.ts");
/* harmony import */ var _src_lib_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @src/lib/config */ "./src/lib/config.ts");




class HelpCompletionOption extends _src_completions__WEBPACK_IMPORTED_MODULE_0__["CompletionOptionHTML"] {
    constructor(name, doc, flag) {
        super();
        this.name = name;
        this.fuseKeys = [];
        this.value = `${flag} ${name}`;
        this.html = html `<tr class="HelpCompletionOption option">
                <td class="name">${name}</td>
                <td class="doc">${doc}</td>
            </tr>`;
    }
}
class HelpCompletionSource extends _src_completions__WEBPACK_IMPORTED_MODULE_0__["CompletionSourceFuse"] {
    constructor(_parent) {
        super(["help"], "HelpCompletionSource", "Help");
        this._parent = _parent;
        this._parent.appendChild(this.node);
    }
    async filter(exstr) {
        this.lastExstr = exstr;
        this.completion = undefined;
        const [prefix, query] = this.splitOnPrefix(exstr);
        // Hide self and stop if prefixes don't match
        if (prefix) {
            // Show self if prefix and currently hidden
            if (this.state === "hidden") {
                this.state = "normal";
            }
        }
        else {
            this.state = "hidden";
            return;
        }
        const file = _src_metadata_generated__WEBPACK_IMPORTED_MODULE_1__["everything"].getFile("src/lib/config.ts");
        const default_config = file.getClass("default_config");
        const excmds = _src_metadata_generated__WEBPACK_IMPORTED_MODULE_1__["everything"].getFile("src/excmds.ts");
        const fns = excmds.getFunctions();
        const settings = _src_lib_config__WEBPACK_IMPORTED_MODULE_3__["get"]();
        const exaliases = settings.exaliases;
        const bindings = settings.nmaps;
        if (fns === undefined || exaliases === undefined || bindings === undefined) {
            return;
        }
        const flags = {
            "-a": (options, query) => options.concat(Object.keys(exaliases)
                .filter(alias => alias.startsWith(query))
                .map(alias => {
                const cmd = _src_lib_aliases__WEBPACK_IMPORTED_MODULE_2__["expandExstr"](alias);
                const doc = (excmds.getFunction(cmd) || {}).doc || "";
                return new HelpCompletionOption(alias, `Alias for \`${cmd}\`. ${doc}`, "-a");
            })),
            "-b": (options, query) => options.concat(Object.keys(bindings)
                .filter(binding => binding.startsWith(query))
                .map(binding => new HelpCompletionOption(binding, `Normal mode binding for \`${bindings[binding]}\``, "-b"))),
            "-e": (options, query) => options.concat(fns
                .filter(([name, fn]) => !fn.hidden && name.startsWith(query))
                .map(([name, fn]) => new HelpCompletionOption(name, `Excmd. ${fn.doc}`, "-e"))),
            "-s": (options, query) => options.concat(Object.keys(settings)
                .filter(x => x.startsWith(query))
                .map(setting => {
                const member = default_config.getMember(setting);
                let doc = "";
                if (member !== undefined) {
                    doc = member.doc;
                }
                return new HelpCompletionOption(setting, `Setting. ${doc}`, "-s");
            })),
        };
        const args = query.split(" ");
        let opts = [];
        if (Object.keys(flags).includes(args[0])) {
            opts = flags[args[0]](opts, args.slice(1).join(" "));
        }
        else {
            opts = Object.keys(flags).reduce((acc, curFlag) => flags[curFlag](acc, query), []);
        }
        this.options = opts;
        this.options.sort((compopt1, compopt2) => compopt1.name.localeCompare(compopt2.name));
        return this.updateChain();
    }
    updateChain() {
        // Options are pre-trimmed to the right length.
        this.options.forEach(option => (option.state = "normal"));
        // Call concrete class
        return this.updateDisplay();
    }
    onInput() { }
}


/***/ }),

/***/ "./src/completions/History.ts":
/*!************************************!*\
  !*** ./src/completions/History.ts ***!
  \************************************/
/*! exports provided: HistoryCompletionSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HistoryCompletionSource", function() { return HistoryCompletionSource; });
/* harmony import */ var _src_completions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/completions */ "./src/completions.ts");
/* harmony import */ var _src_lib_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @src/lib/config */ "./src/lib/config.ts");
/* harmony import */ var _src_completions_providers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @src/completions/providers */ "./src/completions/providers.ts");



class HistoryCompletionOption extends _src_completions__WEBPACK_IMPORTED_MODULE_0__["CompletionOptionHTML"] {
    constructor(value, page) {
        super();
        this.value = value;
        this.fuseKeys = [];
        if (!page.title) {
            page.title = new URL(page.url).host;
        }
        // Push properties we want to fuzmatch on
        this.fuseKeys.push(page.title, page.url); // weight by page.visitCount
        // Create HTMLElement
        this.html = html `<tr class="HistoryCompletionOption option">
                <td class="prefix">${"".padEnd(2)}</td>
                <td class="title">${page.title}</td>
                <td class="content">
                    <a class="url" target="_blank" href=${page.url}
                        >${page.url}</a
                    >
                </td>
            </tr>`;
    }
}
class HistoryCompletionSource extends _src_completions__WEBPACK_IMPORTED_MODULE_0__["CompletionSourceFuse"] {
    constructor(_parent) {
        super(["open", "tabopen", "winopen"], "HistoryCompletionSource", "History and bookmarks");
        this._parent = _parent;
        this._parent.appendChild(this.node);
    }
    async filter(exstr) {
        const prevStr = this.lastExstr;
        this.lastExstr = exstr;
        let [prefix, query] = this.splitOnPrefix(exstr);
        let options = "";
        // Hide self and stop if prefixes don't match
        if (prefix) {
            // Show self if prefix and currently hidden
            if (this.state === "hidden") {
                this.state = "normal";
            }
        }
        else {
            this.state = "hidden";
            return;
        }
        // Ignoring command-specific arguments
        // It's terrible but it's ok because it's just a stopgap until an actual commandline-parsing API is implemented
        if (prefix === "tabopen ") {
            if (query.startsWith("-c")) {
                const args = query.split(" ");
                options = args.slice(0, 2).join(" ");
                query = args.slice(2).join(" ");
            }
            if (query.startsWith("-b")) {
                const args = query.split(" ");
                options = args.slice(0, 1).join(" ");
                query = args.slice(1).join(" ");
            }
        }
        else if (prefix === "winopen " && query.startsWith("-private")) {
            options = "-private";
            query = query.substring(options.length);
        }
        options += options ? " " : "";
        // Options are pre-trimmed to the right length.
        this.options = (await this.scoreOptions(query, 10)).map(page => new HistoryCompletionOption(options + page.url, page));
        // Deselect any selected, but remember what they were.
        const lastFocused = this.lastFocused;
        this.deselect();
        // Set initial state to normal, unless the option was selected a moment
        // ago, then reselect it so that users don't lose their selections.
        this.options.forEach(option => option.state = "normal");
        for (const option of this.options) {
            if (lastFocused !== undefined && lastFocused.value === option.value && prevStr.length <= exstr.length) {
                this.select(option);
                break;
            }
        }
        return this.updateDisplay();
    }
    updateChain() { }
    onInput() { }
    async scoreOptions(query, n) {
        if (!query || _src_lib_config__WEBPACK_IMPORTED_MODULE_1__["get"]("historyresults") === 0) {
            return (await _src_completions_providers__WEBPACK_IMPORTED_MODULE_2__["getTopSites"]()).slice(0, n);
        }
        else {
            return (await _src_completions_providers__WEBPACK_IMPORTED_MODULE_2__["getCombinedHistoryBmarks"](query)).slice(0, n);
        }
    }
}


/***/ }),

/***/ "./src/completions/Preferences.ts":
/*!****************************************!*\
  !*** ./src/completions/Preferences.ts ***!
  \****************************************/
/*! exports provided: PreferenceCompletionSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PreferenceCompletionSource", function() { return PreferenceCompletionSource; });
/* harmony import */ var _src_completions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/completions */ "./src/completions.ts");
/* harmony import */ var _src_lib_native__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @src/lib/native */ "./src/lib/native.ts");


class PreferenceCompletionOption extends _src_completions__WEBPACK_IMPORTED_MODULE_0__["CompletionOptionHTML"] {
    constructor(value, prefvalue) {
        super();
        this.value = value;
        this.prefvalue = prefvalue;
        this.fuseKeys = [];
        this.fuseKeys.push(value);
        this.html = html `<tr class="PreferenceCompletionOption option">
                <td class="name">${value}</td>
                <td class="value">${prefvalue}</td>
            </tr>`;
    }
}
class PreferenceCompletionSource extends _src_completions__WEBPACK_IMPORTED_MODULE_0__["CompletionSourceFuse"] {
    constructor(_parent) {
        super(["setpref"], "PreferenceCompletionSource", "Preference");
        this._parent = _parent;
        this._parent.appendChild(this.node);
    }
    onInput(exstr) {
        return this.filter(exstr);
    }
    async filter(exstr) {
        if (!exstr) {
            this.state = "hidden";
            return;
        }
        const pref = this.splitOnPrefix(exstr)[1];
        if (pref === undefined) {
            this.state = "hidden";
            return;
        }
        this.lastExstr = exstr;
        const preferences = await _src_lib_native__WEBPACK_IMPORTED_MODULE_1__["getPrefs"]();
        this.options = Object.keys(preferences)
            .filter(key => key.startsWith(pref))
            .map(key => new PreferenceCompletionOption(key, preferences[key]));
        if (this.options.length > 0)
            this.state = "normal";
        return this.updateChain();
    }
}


/***/ }),

/***/ "./src/completions/Rss.ts":
/*!********************************!*\
  !*** ./src/completions/Rss.ts ***!
  \********************************/
/*! exports provided: RssCompletionSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RssCompletionSource", function() { return RssCompletionSource; });
/* harmony import */ var _src_lib_messaging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/lib/messaging */ "./src/lib/messaging.ts");
/* harmony import */ var _src_completions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @src/completions */ "./src/completions.ts");


class RssCompletionOption extends _src_completions__WEBPACK_IMPORTED_MODULE_1__["CompletionOptionHTML"] {
    constructor(url, title, type) {
        super();
        this.url = url;
        this.title = title;
        this.type = type;
        this.fuseKeys = [];
        this.value = `${url} ${type} ${title}`;
        this.fuseKeys.push(url);
        this.fuseKeys.push(title);
        this.html = html `<tr class="RssCompletionOption option">
                <td class="title">${title}</td>
                <td class="content">
                    <a class="url" target="_blank" href=${url}>${url}</a>
                </td>
                <td class="type">${type}</td>
            </tr>`;
    }
}
class RssCompletionSource extends _src_completions__WEBPACK_IMPORTED_MODULE_1__["CompletionSourceFuse"] {
    constructor(_parent) {
        super(["rssexec"], "RssCompletionSource", "Feeds");
        this._parent = _parent;
        this.options = [];
        this.shouldSetStateFromScore = true;
        this.updateOptions();
        this._parent.appendChild(this.node);
    }
    onInput(...whatever) {
        return this.updateOptions(...whatever);
    }
    async updateOptions(exstr = "") {
        this.lastExstr = exstr;
        const [prefix] = this.splitOnPrefix(exstr);
        // Hide self and stop if prefixes don't match
        if (prefix) {
            // Show self if prefix and currently hidden
            if (this.state === "hidden") {
                this.state = "normal";
            }
        }
        else {
            this.state = "hidden";
            return;
        }
        if (this.options.length < 1) {
            this.options = (await _src_lib_messaging__WEBPACK_IMPORTED_MODULE_0__["messageOwnTab"]("excmd_content", "getRssLinks", [])).map(link => {
                const opt = new RssCompletionOption(link.url, link.title, link.type);
                opt.state = "normal";
                return opt;
            });
        }
        return this.updateChain();
    }
}


/***/ }),

/***/ "./src/completions/Sessions.ts":
/*!*************************************!*\
  !*** ./src/completions/Sessions.ts ***!
  \*************************************/
/*! exports provided: SessionsCompletionSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SessionsCompletionSource", function() { return SessionsCompletionSource; });
/* harmony import */ var _src_lib_webext_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/lib/webext.ts */ "./src/lib/webext.ts");
/* harmony import */ var _src_completions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @src/completions */ "./src/completions.ts");


function computeDate(session) {
    let howLong = Math.round((new Date() - session.lastModified) / 1000);
    let qualifier = "s";
    if (howLong > 60) {
        qualifier = "m";
        howLong = Math.round(howLong / 60);
        if (howLong > 60) {
            qualifier = "h";
            howLong = Math.round(howLong / 60);
            if (howLong > 24) {
                qualifier = "d";
                howLong = Math.round(howLong / 24);
            }
        }
    }
    return [howLong, qualifier];
}
function getTabInfo(session) {
    let tab;
    let extraInfo;
    if (session.tab) {
        tab = session.tab;
        extraInfo = tab.url;
    }
    else {
        tab = session.window.tabs.sort((a, b) => b.lastAccessed - a.lastAccessed)[0];
        const tabCount = session.window.tabs.length;
        if (tabCount < 2) {
            extraInfo = tab.url;
        }
        else {
            extraInfo = `${tabCount - 1} more tab${tabCount > 2 ? "s" : ""}.`;
        }
    }
    return [tab, extraInfo];
}
class SessionCompletionOption extends _src_completions__WEBPACK_IMPORTED_MODULE_1__["CompletionOptionHTML"] {
    constructor(session) {
        super();
        this.session = session;
        this.fuseKeys = [];
        this.value = (session.tab || session.window).sessionId;
        const [howLong, qualifier] = computeDate(session);
        const [tab, extraInfo] = getTabInfo(session);
        this.fuseKeys.push(tab.title);
        this.html = html `<tr class="SessionCompletionOption option">
            <td class="type">${session.tab ? "T" : "W"}</td>
            <td class="time">${howLong}${qualifier}</td>
            <td class="icon"><img src="${tab.favIconUrl ||
            _src_completions__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_FAVICON"]}"/></td>
            <td class="title">${tab.title}</td>
            <td class="extraInfo">${extraInfo}</td>
        </tr>`;
    }
}
class SessionsCompletionSource extends _src_completions__WEBPACK_IMPORTED_MODULE_1__["CompletionSourceFuse"] {
    constructor(_parent) {
        super(["undo"], "SessionCompletionSource", "sessions");
        this._parent = _parent;
        this.shouldSetStateFromScore = true;
        this.updateOptions();
        this._parent.appendChild(this.node);
    }
    async onInput(exstr) {
        return this.updateOptions(exstr);
    }
    async updateOptions(exstr = "") {
        this.lastExstr = exstr;
        const [prefix] = this.splitOnPrefix(exstr);
        // Hide self and stop if prefixes don't match
        if (prefix) {
            // Show self if prefix and currently hidden
            if (this.state === "hidden") {
                this.state = "normal";
            }
        }
        else {
            this.state = "hidden";
            return;
        }
        const sessions = await _src_lib_webext_ts__WEBPACK_IMPORTED_MODULE_0__["browserBg"].sessions.getRecentlyClosed();
        this.options = sessions.map(s => new SessionCompletionOption(s));
    }
}


/***/ }),

/***/ "./src/completions/Settings.ts":
/*!*************************************!*\
  !*** ./src/completions/Settings.ts ***!
  \*************************************/
/*! exports provided: SettingsCompletionSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SettingsCompletionSource", function() { return SettingsCompletionSource; });
/* harmony import */ var _src_completions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/completions */ "./src/completions.ts");
/* harmony import */ var _src_lib_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @src/lib/config */ "./src/lib/config.ts");
/* harmony import */ var _src_metadata_generated__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @src/.metadata.generated */ "./src/.metadata.generated.ts");



class SettingsCompletionOption extends _src_completions__WEBPACK_IMPORTED_MODULE_0__["CompletionOptionHTML"] {
    constructor(value, setting) {
        super();
        this.value = value;
        this.fuseKeys = [];
        this.html = html `<tr class="SettingsCompletionOption option">
                <td class="title">${setting.name}</td>
                <td class="content">${setting.value}</td>
                <td class="type">${setting.type}</td>
                <td class="doc">${setting.doc}</td>
            </tr>`;
    }
}
class SettingsCompletionSource extends _src_completions__WEBPACK_IMPORTED_MODULE_0__["CompletionSourceFuse"] {
    constructor(_parent) {
        super(["set", "get", "unset", "seturl", "unseturl"], "SettingsCompletionSource", "Settings");
        this._parent = _parent;
        this._parent.appendChild(this.node);
    }
    async filter(exstr) {
        this.lastExstr = exstr;
        let [prefix, query] = this.splitOnPrefix(exstr);
        let options = "";
        // Hide self and stop if prefixes don't match
        if (prefix) {
            // Show self if prefix and currently hidden
            if (this.state === "hidden") {
                this.state = "normal";
            }
        }
        else {
            this.state = "hidden";
            return;
        }
        // Ignoring command-specific arguments
        // It's terrible but it's ok because it's just a stopgap until an actual commandline-parsing API is implemented
        // copy pasting code is fun and good
        if (prefix === "seturl " || prefix === "unseturl ") {
            const args = query.split(" ");
            options = args.slice(0, 1).join(" ");
            query = args.slice(1).join(" ");
        }
        options += options ? " " : "";
        const file = _src_metadata_generated__WEBPACK_IMPORTED_MODULE_2__["everything"].getFile("src/lib/config.ts");
        const default_config = file.getClass("default_config");
        const settings = _src_lib_config__WEBPACK_IMPORTED_MODULE_1__["get"]();
        if (default_config === undefined || settings === undefined) {
            return;
        }
        this.options = Object.keys(settings)
            .filter(x => x.startsWith(query))
            .sort()
            .map(setting => {
            const md = default_config.getMember(setting);
            let doc = "";
            let type = "";
            if (md !== undefined) {
                doc = md.doc;
                type = md.type.toString();
            }
            return new SettingsCompletionOption(options + setting, {
                name: setting,
                value: JSON.stringify(settings[setting]),
                doc,
                type,
            });
        });
        return this.updateChain();
    }
    updateChain() {
        // Options are pre-trimmed to the right length.
        this.options.forEach(option => (option.state = "normal"));
        // Call concrete class
        return this.updateDisplay();
    }
    onInput() { }
}


/***/ }),

/***/ "./src/completions/Tab.ts":
/*!********************************!*\
  !*** ./src/completions/Tab.ts ***!
  \********************************/
/*! exports provided: BufferCompletionSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferCompletionSource", function() { return BufferCompletionSource; });
/* harmony import */ var _src_perf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/perf */ "./src/perf.ts");
/* harmony import */ var _src_lib_webext_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @src/lib/webext.ts */ "./src/lib/webext.ts");
/* harmony import */ var _src_lib_itertools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @src/lib/itertools */ "./src/lib/itertools.ts");
/* harmony import */ var _src_lib_containers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @src/lib/containers */ "./src/lib/containers.ts");
/* harmony import */ var _src_completions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @src/completions */ "./src/completions.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};





class BufferCompletionOption extends _src_completions__WEBPACK_IMPORTED_MODULE_4__["CompletionOptionHTML"] {
    constructor(value, tab, isAlternative = false, container) {
        super();
        this.value = value;
        this.isAlternative = isAlternative;
        this.fuseKeys = [];
        // Two character tab properties prefix
        let pre = "";
        if (tab.active)
            pre += "%";
        else if (isAlternative) {
            pre += "#";
            this.value = "#";
        }
        if (tab.pinned)
            pre += "@";
        // Push prefix before padding so we don't match on whitespace
        this.fuseKeys.push(pre);
        // Push properties we want to fuzmatch on
        this.fuseKeys.push(String(tab.index + 1), tab.title, tab.url);
        // Create HTMLElement
        const favIconUrl = tab.favIconUrl
            ? tab.favIconUrl
            : _src_completions__WEBPACK_IMPORTED_MODULE_4__["DEFAULT_FAVICON"];
        this.html = html `<tr class="BufferCompletionOption option container_${container.color} container_${container.icon} container_${container.name}"
            >
                <td class="prefix">${pre.padEnd(2)}</td>
                <td class="container"></td>
                <td class="icon"><img src="${favIconUrl}" /></td>
                <td class="title">${tab.index + 1}: ${tab.title}</td>
                <td class="content">
                    <a class="url" target="_blank" href=${tab.url}
                        >${tab.url}</a
                    >
                </td>
            </tr>`;
    }
}
class BufferCompletionSource extends _src_completions__WEBPACK_IMPORTED_MODULE_4__["CompletionSourceFuse"] {
    // TODO:
    //     - store the exstr and trigger redraws on user or data input without
    //       callback faffery
    //     - sort out the element redrawing.
    constructor(_parent) {
        super(["tab", "tabclose", "tabdetach", "tabduplicate", "tabmove"], "BufferCompletionSource", "Tabs");
        this._parent = _parent;
        this.shouldSetStateFromScore = true;
        this.updateOptions();
        this._parent.appendChild(this.node);
    }
    async onInput(exstr) {
        // Schedule an update, if you like. Not very useful for tabs, but
        // will be for other things.
        return this.updateOptions(exstr);
    }
    async filter(exstr) {
        this.lastExstr = exstr;
        return this.onInput(exstr);
    }
    setStateFromScore(scoredOpts) {
        super.setStateFromScore(scoredOpts, this.shouldSetStateFromScore);
    }
    /** Score with fuse unless query is a single # or looks like a tab index */
    scoredOptions(query, options = this.options) {
        const args = query.trim().split(/\s+/gu);
        if (args.length === 1) {
            // if query is an integer n and |n| < options.length
            if (Number.isInteger(Number(args[0]))) {
                let index = Number(args[0]) - 1;
                if (Math.abs(index) < options.length) {
                    index = index.mod(options.length);
                    return [
                        {
                            index,
                            option: options[index],
                            score: 0,
                        },
                    ];
                }
            }
            else if (args[0] === "#") {
                for (const [index, option] of Object(_src_lib_itertools__WEBPACK_IMPORTED_MODULE_2__["enumerate"])(options)) {
                    if (option.isAlternative) {
                        return [
                            {
                                index,
                                option,
                                score: 0,
                            },
                        ];
                    }
                }
            }
        }
        // If not yet returned...
        return super.scoredOptions(query, options);
    }
    async updateOptions(exstr = "") {
        this.lastExstr = exstr;
        const [prefix, query] = this.splitOnPrefix(exstr);
        // Hide self and stop if prefixes don't match
        if (prefix) {
            // Show self if prefix and currently hidden
            if (this.state === "hidden") {
                this.state = "normal";
            }
        }
        else {
            this.state = "hidden";
            return;
        }
        // When the user is asking for tabmove completions, don't autoselect if the query looks like a relative move https://github.com/tridactyl/tridactyl/issues/825
        this.shouldSetStateFromScore = !(prefix === "tabmove " && query.match("^[+-][0-9]+$"));
        /* console.log('updateOptions', this.optionContainer) */
        const tabs = await _src_lib_webext_ts__WEBPACK_IMPORTED_MODULE_1__["browserBg"].tabs.query({
            currentWindow: true,
        });
        const options = [];
        // Get alternative tab, defined as last accessed tab.
        tabs.sort((a, b) => (b.lastAccessed - a.lastAccessed));
        const alt = tabs[1];
        tabs.sort((a, b) => (a.index - b.index));
        for (const tab of tabs) {
            options.push(new BufferCompletionOption((tab.index + 1).toString(), tab, tab === alt, await _src_lib_containers__WEBPACK_IMPORTED_MODULE_3__["getFromId"](tab.cookieStoreId)));
        }
        this.completion = undefined;
        this.options = options;
        if (query && query.trim().length > 0) {
            this.setStateFromScore(this.scoredOptions(query));
        }
        else {
            this.options.forEach(option => (option.state = "normal"));
        }
        return this.updateDisplay();
    }
}
__decorate([
    _src_perf__WEBPACK_IMPORTED_MODULE_0__["measuredAsync"]
], BufferCompletionSource.prototype, "updateOptions", null);


/***/ }),

/***/ "./src/completions/TabAll.ts":
/*!***********************************!*\
  !*** ./src/completions/TabAll.ts ***!
  \***********************************/
/*! exports provided: TabAllCompletionSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TabAllCompletionSource", function() { return TabAllCompletionSource; });
/* harmony import */ var _src_perf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/perf */ "./src/perf.ts");
/* harmony import */ var _src_lib_webext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @src/lib/webext */ "./src/lib/webext.ts");
/* harmony import */ var _src_lib_containers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @src/lib/containers */ "./src/lib/containers.ts");
/* harmony import */ var _src_completions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @src/completions */ "./src/completions.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




class TabAllCompletionOption extends _src_completions__WEBPACK_IMPORTED_MODULE_3__["CompletionOptionHTML"] {
    constructor(value, tab, winindex, container, incognito) {
        super();
        this.value = value;
        this.fuseKeys = [];
        this.value = `${winindex}.${tab.index + 1}`;
        this.fuseKeys.push(this.value, tab.title, tab.url);
        // Create HTMLElement
        const favIconUrl = tab.favIconUrl
            ? tab.favIconUrl
            : _src_completions__WEBPACK_IMPORTED_MODULE_3__["DEFAULT_FAVICON"];
        this.html = html `<tr class="BufferAllCompletionOption option container_${container.color} container_${container.icon} container_${container.name} ${incognito
            ? "incognito"
            : ""}"
            >
                <td class="prefix"></td>
                <td class="privatewindow"></td>
                <td class="container"></td>
                <td class="icon"><img src="${favIconUrl}" /></td>
                <td class="title">${this.value}: ${tab.title}</td>
                <td class="content">
                    <a class="url" target="_blank" href=${tab.url}
                        >${tab.url}</a
                    >
                </td>
            </tr>`;
    }
}
class TabAllCompletionSource extends _src_completions__WEBPACK_IMPORTED_MODULE_3__["CompletionSourceFuse"] {
    constructor(_parent) {
        super(["taball"], "TabAllCompletionSource", "All Tabs");
        this._parent = _parent;
        this.updateOptions();
        this._parent.appendChild(this.node);
    }
    async onInput(exstr) {
        return this.updateOptions(exstr);
    }
    setStateFromScore(scoredOpts) {
        super.setStateFromScore(scoredOpts, true);
    }
    /**
     * Map all windows into a {[windowId]: window} object
     */
    async getWindows() {
        const windows = await _src_lib_webext__WEBPACK_IMPORTED_MODULE_1__["browserBg"].windows.getAll();
        const response = {};
        windows.forEach(win => (response[win.id] = win));
        return response;
    }
    async updateOptions(exstr = "") {
        this.lastExstr = exstr;
        const [prefix] = this.splitOnPrefix(exstr);
        // Hide self and stop if prefixes don't match
        if (prefix) {
            // Show self if prefix and currently hidden
            if (this.state === "hidden") {
                this.state = "normal";
            }
        }
        else {
            this.state = "hidden";
            return;
        }
        const tabsPromise = _src_lib_webext__WEBPACK_IMPORTED_MODULE_1__["browserBg"].tabs.query({});
        const windowsPromise = this.getWindows();
        const [tabs, windows] = await Promise.all([tabsPromise, windowsPromise]);
        const options = [];
        tabs.sort((a, b) => {
            if (a.windowId === b.windowId)
                return a.index - b.index;
            return a.windowId - b.windowId;
        });
        // Window Ids don't make sense so we're using LASTID and WININDEX to compute a window index
        // This relies on the fact that tabs are sorted by window ids
        let lastId = 0;
        let winindex = 0;
        for (const tab of tabs) {
            if (lastId !== tab.windowId) {
                lastId = tab.windowId;
                winindex += 1;
            }
            options.push(new TabAllCompletionOption(tab.id.toString(), tab, winindex, await _src_lib_containers__WEBPACK_IMPORTED_MODULE_2__["getFromId"](tab.cookieStoreId), windows[tab.windowId].incognito));
        }
        this.completion = undefined;
        this.options = options;
        return this.updateChain();
    }
}
__decorate([
    _src_perf__WEBPACK_IMPORTED_MODULE_0__["measuredAsync"]
], TabAllCompletionSource.prototype, "updateOptions", null);


/***/ }),

/***/ "./src/completions/Window.ts":
/*!***********************************!*\
  !*** ./src/completions/Window.ts ***!
  \***********************************/
/*! exports provided: WindowCompletionSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WindowCompletionSource", function() { return WindowCompletionSource; });
/* harmony import */ var _src_lib_webext_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/lib/webext.ts */ "./src/lib/webext.ts");
/* harmony import */ var _src_completions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @src/completions */ "./src/completions.ts");


class WindowCompletionOption extends _src_completions__WEBPACK_IMPORTED_MODULE_1__["CompletionOptionHTML"] {
    constructor(win) {
        super();
        this.fuseKeys = [];
        this.value = win.id;
        this.fuseKeys.push(`${win.title}`);
        this.fuseKeys.push(`${win.id}`);
        // Create HTMLElement
        this.html = html `<tr class="WindowCompletionOption option ${win.incognito ? "incognito" : ""}">
            <td class="privatewindow"></td>
            <td class="id">${win.id}</td>
            <td class="title">${win.title}</td>
            <td class="tabcount">${win.tabs.length} tab${win.tabs.length !== 1 ? "s" : ""}</td>
        </tr>`;
    }
}
class WindowCompletionSource extends _src_completions__WEBPACK_IMPORTED_MODULE_1__["CompletionSourceFuse"] {
    constructor(_parent) {
        super(["winclose"], "WindowCompletionSource", "Windows");
        this._parent = _parent;
        this.updateOptions();
        this._parent.appendChild(this.node);
    }
    async onInput(exstr) {
        // Schedule an update, if you like. Not very useful for windows, but
        // will be for other things.
        return this.updateOptions(exstr);
    }
    async filter(exstr) {
        this.lastExstr = exstr;
        return this.onInput(exstr);
    }
    async updateOptions(exstr = "") {
        this.lastExstr = exstr;
        const [prefix] = this.splitOnPrefix(exstr);
        // Hide self and stop if prefixes don't match
        if (prefix) {
            // Show self if prefix and currently hidden
            if (this.state === "hidden") {
                this.state = "normal";
            }
        }
        else {
            this.state = "hidden";
            return;
        }
        this.options = (await _src_lib_webext_ts__WEBPACK_IMPORTED_MODULE_0__["browserBg"].windows.getAll({ populate: true })).map(win => {
            const o = new WindowCompletionOption(win);
            o.state = "normal";
            return o;
        });
        return this.updateDisplay();
    }
}


/***/ }),

/***/ "./src/completions/providers.ts":
/*!**************************************!*\
  !*** ./src/completions/providers.ts ***!
  \**************************************/
/*! exports provided: newtaburl, getBookmarks, getHistory, getTopSites, getCombinedHistoryBmarks */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newtaburl", function() { return newtaburl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBookmarks", function() { return getBookmarks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHistory", function() { return getHistory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTopSites", function() { return getTopSites; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCombinedHistoryBmarks", function() { return getCombinedHistoryBmarks; });
/* harmony import */ var _src_lib_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/lib/config */ "./src/lib/config.ts");
/* harmony import */ var _src_lib_webext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @src/lib/webext */ "./src/lib/webext.ts");


function newtaburl() {
    // In the nonewtab version, this will return `null` and upset getURL.
    // Ternary op below prevents the runtime error.
    const newtab = (browser.runtime.getManifest()).chrome_url_overrides.newtab;
    return newtab !== null ? browser.runtime.getURL(newtab) : null;
}
async function getBookmarks(query) {
    // Search bookmarks, dedupe and sort by most recent.
    let bookmarks = await _src_lib_webext__WEBPACK_IMPORTED_MODULE_1__["browserBg"].bookmarks.search({ query });
    // Remove folder nodes and bad URLs
    bookmarks = bookmarks.filter(b => {
        try {
            return new URL(b.url);
        }
        catch (e) {
            return false;
        }
    });
    bookmarks.sort((a, b) => b.dateAdded - a.dateAdded);
    // Remove duplicate bookmarks
    const seen = new Map();
    bookmarks = bookmarks.filter(b => {
        if (seen.get(b.title) === b.url)
            return false;
        else {
            seen.set(b.title, b.url);
            return true;
        }
    });
    return bookmarks;
}
function frecency(item) {
    // Doesn't actually care about recency yet.
    return item.visitCount * -1;
}
async function getHistory(query) {
    // Search history, dedupe and sort by frecency
    let history = await _src_lib_webext__WEBPACK_IMPORTED_MODULE_1__["browserBg"].history.search({
        text: query,
        maxResults: _src_lib_config__WEBPACK_IMPORTED_MODULE_0__["get"]("historyresults"),
        startTime: 0,
    });
    // Remove entries with duplicate URLs
    const dedupe = new Map();
    for (const page of history) {
        if (page.url !== newtaburl()) {
            if (dedupe.has(page.url)) {
                if (dedupe.get(page.url).title.length <
                    page.title.length) {
                    dedupe.set(page.url, page);
                }
            }
            else {
                dedupe.set(page.url, page);
            }
        }
    }
    history = [...dedupe.values()];
    history.sort((a, b) => frecency(a) - frecency(b));
    return history;
}
async function getTopSites() {
    return (await _src_lib_webext__WEBPACK_IMPORTED_MODULE_1__["browserBg"].topSites.get())
        .filter(page => page.url !== newtaburl());
}
async function getCombinedHistoryBmarks(query) {
    const [history, bookmarks] = await Promise.all([
        getHistory(query),
        getBookmarks(query),
    ]);
    // Join records by URL, using the title from bookmarks by preference.
    const combinedMap = new Map(bookmarks.map(bmark => [
        bmark.url, { title: bmark.title, url: bmark.url, bmark }
    ]));
    history.forEach(page => {
        if (combinedMap.has(page.url))
            combinedMap.get(page.url).history = page;
        else
            combinedMap.set(page.url, { title: page.title, url: page.url, history: page });
    });
    const score = x => (x.history ? frecency(x.history) : 0) - (x.bmark ? _src_lib_config__WEBPACK_IMPORTED_MODULE_0__["get"]("bmarkweight") : 0);
    return Array.from(combinedMap.values()).sort((a, b) => score(a) - score(b));
}


/***/ }),

/***/ "./src/content/styling.ts":
/*!********************************!*\
  !*** ./src/content/styling.ts ***!
  \********************************/
/*! exports provided: THEMES, theme */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "THEMES", function() { return THEMES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "theme", function() { return theme; });
/* harmony import */ var _src_metadata_generated__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/.metadata.generated */ "./src/.metadata.generated.ts");
/* harmony import */ var _src_lib_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @src/lib/config */ "./src/lib/config.ts");
/* harmony import */ var _src_lib_logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @src/lib/logging */ "./src/lib/logging.ts");
/* harmony import */ var _src_lib_webext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @src/lib/webext */ "./src/lib/webext.ts");




const logger = new _src_lib_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"]("styling");
const THEMES = _src_metadata_generated__WEBPACK_IMPORTED_MODULE_0__["staticThemes"];
function capitalise(str) {
    if (str === "")
        return str;
    return str[0].toUpperCase() + str.slice(1);
}
function prefixTheme(name) {
    return "TridactylTheme" + capitalise(name);
}
// At the moment elements are only ever `:root` and so this array and stuff is all a bit overdesigned.
const THEMED_ELEMENTS = [];
let insertedCSS = false;
const customCss = {
    allFrames: true,
    matchAboutBlank: true,
    code: "",
};
async function theme(element) {
    // Remove any old theme
    for (const theme of THEMES.map(prefixTheme)) {
        element.classList.remove(theme);
    }
    if (insertedCSS) {
        // Typescript doesn't seem to be aware than remove/insertCSS's tabid
        // argument is optional
        await _src_lib_webext__WEBPACK_IMPORTED_MODULE_3__["browserBg"].tabs.removeCSS(await Object(_src_lib_webext__WEBPACK_IMPORTED_MODULE_3__["ownTabId"])(), customCss);
        insertedCSS = false;
    }
    const newTheme = await _src_lib_config__WEBPACK_IMPORTED_MODULE_1__["getAsync"]("theme");
    // Add a class corresponding to config.get('theme')
    if (newTheme !== "default") {
        element.classList.add(prefixTheme(newTheme));
    }
    // Insert custom css if needed
    if (newTheme !== "default" && !THEMES.includes(newTheme)) {
        customCss.code = await _src_lib_config__WEBPACK_IMPORTED_MODULE_1__["getAsync"]("customthemes", newTheme);
        if (customCss.code) {
            await _src_lib_webext__WEBPACK_IMPORTED_MODULE_3__["browserBg"].tabs.insertCSS(await Object(_src_lib_webext__WEBPACK_IMPORTED_MODULE_3__["ownTabId"])(), customCss);
            insertedCSS = true;
        }
        else {
            logger.error("Theme " + newTheme + " couldn't be found.");
        }
    }
    // Record for re-theming
    // considering only elements :root (page and cmdline_iframe)
    // TODO:
    //     - Find ways to check if element is already pushed
    if (THEMED_ELEMENTS.length < 2 &&
        element.tagName.toUpperCase() === "HTML") {
        THEMED_ELEMENTS.push(element);
    }
}
function retheme() {
    THEMED_ELEMENTS.forEach(element => {
        theme(element).catch(e => {
            logger.warning(`Failed to retheme element "${element}". Error: ${e}`);
        });
    });
}
_src_lib_config__WEBPACK_IMPORTED_MODULE_1__["addChangeListener"]("theme", retheme);
// Sometimes pages will overwrite class names of elements. We use a MutationObserver to make sure that the HTML element always has a TridactylTheme class
// We can't just call theme() because it would first try to remove class names from the element, which would trigger the MutationObserver before we had a chance to add the theme class and thus cause infinite recursion
const cb = async (mutationList) => {
    const theme = await _src_lib_config__WEBPACK_IMPORTED_MODULE_1__["getAsync"]("theme");
    mutationList
        .filter(m => m.target.className.search(prefixTheme("")) === -1)
        .forEach(m => m.target.classList.add(prefixTheme(theme)));
};
new MutationObserver(cb).observe(document.documentElement, {
    attributes: true,
    childList: false,
    characterData: false,
    subtree: false,
    attributeOldValue: false,
    attributeFilter: ["class"],
});


/***/ }),

/***/ "./src/grammars/.bracketexpr.generated.ts":
/*!************************************************!*\
  !*** ./src/grammars/.bracketexpr.generated.ts ***!
  \************************************************/
/*! exports provided: Lexer, ParserRules, ParserStart */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Lexer", function() { return Lexer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParserRules", function() { return ParserRules; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParserStart", function() { return ParserStart; });
// Generated automatically by nearley, version 2.18.0
// http://github.com/Hardmath123/nearley
// Bypasses TS6133. Allow declared but unused functions.
// @ts-ignore
function id(d) { return d[0]; }
;
;
;
var Lexer = undefined;
var ParserRules = [
    { "name": "BracketExpr", "symbols": [{ "literal": "<" }, "Modifier", "ModKey", { "literal": ">" }], "postprocess": bexpr => bexpr.slice(1, -1) },
    { "name": "BracketExpr", "symbols": [{ "literal": "<" }, "Key", { "literal": ">" }], "postprocess": bexpr => [{}].concat(bexpr.slice(1, -1)) },
    { "name": "Modifier$ebnf$1", "symbols": [/[acmsACMS]/], "postprocess": id },
    { "name": "Modifier$ebnf$1", "symbols": [], "postprocess": () => null },
    { "name": "Modifier$ebnf$2", "symbols": [/[acmsACMS]/], "postprocess": id },
    { "name": "Modifier$ebnf$2", "symbols": [], "postprocess": () => null },
    { "name": "Modifier$ebnf$3", "symbols": [/[acmsACMS]/], "postprocess": id },
    { "name": "Modifier$ebnf$3", "symbols": [], "postprocess": () => null },
    { "name": "Modifier$ebnf$4", "symbols": [/[acmsACMS]/], "postprocess": id },
    { "name": "Modifier$ebnf$4", "symbols": [], "postprocess": () => null },
    { "name": "Modifier", "symbols": ["Modifier$ebnf$1", "Modifier$ebnf$2", "Modifier$ebnf$3", "Modifier$ebnf$4", { "literal": "-" }], "postprocess": 
        /** For each modifier present,
            add its long name as an attribute set to true to an object */
        (mods, _, reject) => {
            const longNames = new Map([
                ["A", "altKey"],
                ["C", "ctrlKey"],
                ["M", "metaKey"],
                ["S", "shiftKey"],
            ]);
            let modifiersObj = {};
            for (let mod of mods) {
                if (mod === null || mod === "-")
                    continue;
                let longName = longNames.get(mod.toUpperCase());
                if (longName) {
                    // Reject if the same name is used twice.
                    if (longName in modifiersObj)
                        return reject;
                    else
                        modifiersObj[longName] = true;
                }
            }
            return modifiersObj;
        }
    },
    { "name": "ModKey", "symbols": [{ "literal": "<" }], "postprocess": id },
    { "name": "ModKey", "symbols": [{ "literal": ">" }], "postprocess": id },
    { "name": "ModKey", "symbols": [{ "literal": "-" }], "postprocess": id },
    { "name": "ModKey", "symbols": ["Key"], "postprocess": id },
    { "name": "Key$ebnf$1", "symbols": [/[^\s<>-]/] },
    { "name": "Key$ebnf$1", "symbols": ["Key$ebnf$1", /[^\s<>-]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "Key", "symbols": ["Key$ebnf$1"], "postprocess": (key) => key[0].join("") }
];
var ParserStart = "BracketExpr";


/***/ }),

/***/ "./src/lib/aliases.ts":
/*!****************************!*\
  !*** ./src/lib/aliases.ts ***!
  \****************************/
/*! exports provided: expandExstr, getCmdAliasMapping */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expandExstr", function() { return expandExstr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCmdAliasMapping", function() { return getCmdAliasMapping; });
/* harmony import */ var _src_lib_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/lib/config */ "./src/lib/config.ts");

/**
 * Expands the alias in the provided exstr recursively. Does nothing if
 * the command is not aliased, including when the command is invalid.
 *
 * @param exstr :exstr typed by the user on the commantd line
 */
function expandExstr(exstr, aliases = _src_lib_config__WEBPACK_IMPORTED_MODULE_0__["get"]("exaliases"), prevExpansions = []) {
    // Split on whitespace
    const [command] = exstr.trim().split(/\s+/);
    // Base case: alias not found; return original command
    if (aliases[command] === undefined) {
        return exstr;
    }
    // Infinite loop detected
    if (prevExpansions.includes(command)) {
        throw `Infinite loop detected while expanding aliases. Stack: ${prevExpansions}.`;
    }
    // Add command to expansions used so far
    prevExpansions.push(command);
    // Alias exists; expand it recursively
    return expandExstr(exstr.replace(command, aliases[command]), aliases, prevExpansions);
}
/**
 * Get all aliases for all commands.
 *
 * @param aliases An object mapping aliases to commands
 * @return commands An object mapping commands to an array of aliases
 */
function getCmdAliasMapping(aliases = _src_lib_config__WEBPACK_IMPORTED_MODULE_0__["get"]("exaliases")) {
    const commands = {};
    // aliases look like this: {alias: command} but what we really need is this: {command: [alias1, alias2...]}
    // This is what this loop builds
    for (const alias of Object.keys(aliases)) {
        const cmd = expandExstr(alias, aliases).trim();
        if (!commands[cmd])
            commands[cmd] = [];
        commands[cmd].push(alias.trim());
    }
    return commands;
}


/***/ }),

/***/ "./src/lib/browser_proxy.ts":
/*!**********************************!*\
  !*** ./src/lib/browser_proxy.ts ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_lib_messaging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/lib/messaging */ "./src/lib/messaging.ts");

const browserProxy = new Proxy(Object.create(null), {
    get(target, api) {
        return new Proxy({}, {
            get(_, func) {
                return (...args) => Object(_src_lib_messaging__WEBPACK_IMPORTED_MODULE_0__["message"])("browser_proxy_background", "shim", [
                    api,
                    func,
                    args,
                ]);
            },
        });
    },
});
/* harmony default export */ __webpack_exports__["default"] = (browserProxy);


/***/ }),

/***/ "./src/lib/commandline_cmds.ts":
/*!*************************************!*\
  !*** ./src/lib/commandline_cmds.ts ***!
  \*************************************/
/*! exports provided: getCommandlineFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCommandlineFns", function() { return getCommandlineFns; });
/* harmony import */ var _src_lib_messaging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/lib/messaging */ "./src/lib/messaging.ts");

function getCommandlineFns(cmdline_state) {
    return {
        /**
         * Insert the first command line history line that starts with the content of the command line in the command line.
         */
        "complete": () => {
            const fragment = cmdline_state.clInput.value;
            const matches = cmdline_state.state.cmdHistory.filter(key => key.startsWith(fragment));
            const mostrecent = matches[matches.length - 1];
            if (mostrecent !== undefined)
                cmdline_state.clInput.value = mostrecent;
            return cmdline_state.refresh_completions(cmdline_state.clInput.value);
        },
        /**
         * Selects the next completion.
         */
        "next_completion": () => {
            if (cmdline_state.activeCompletions)
                cmdline_state.activeCompletions.forEach(comp => comp.next());
        },
        /**
         * Selects the previous completion.
         */
        "prev_completion": () => {
            if (cmdline_state.activeCompletions)
                cmdline_state.activeCompletions.forEach(comp => comp.prev());
        },
        /**
         * Deselects the currently selected completion.
         */
        "deselect_completion": () => {
            if (cmdline_state.activeCompletions)
                cmdline_state.activeCompletions.forEach(comp => comp.deselect());
        },
        /**
         * Inserts the currently selected completion and a space in the command line.
         */
        "insert_completion": () => {
            const command = cmdline_state.getCompletion();
            if (cmdline_state.activeCompletions) {
                cmdline_state.activeCompletions.forEach(comp => (comp.completion = undefined));
            }
            let result = Promise.resolve([]);
            if (command) {
                cmdline_state.clInput.value = command + " ";
                result = cmdline_state.refresh_completions(cmdline_state.clInput.value);
            }
            return result;
        },
        /**
         * If a completion is selected, inserts it in the command line with a space.
         * If no completion is selected, inserts a space where the caret is.
         */
        "insert_space_or_completion": () => {
            const command = cmdline_state.getCompletion();
            if (cmdline_state.activeCompletions) {
                cmdline_state.activeCompletions.forEach(comp => (comp.completion = undefined));
            }
            if (command) {
                cmdline_state.clInput.value = command + " ";
            }
            else {
                const selectionStart = cmdline_state.clInput.selectionStart;
                const selectionEnd = cmdline_state.clInput.selectionEnd;
                cmdline_state.clInput.value =
                    cmdline_state.clInput.value.substring(0, selectionStart) +
                        " " +
                        cmdline_state.clInput.value.substring(selectionEnd);
                cmdline_state.clInput.selectionStart = cmdline_state.clInput.selectionEnd = selectionStart + 1;
            }
            return cmdline_state.refresh_completions(cmdline_state.clInput.value);
        },
        /** Hide the command line and cmdline_state.clear its content without executing it. **/
        "hide_and_clear": () => {
            cmdline_state.clear(true);
            cmdline_state.keyEvents = [];
            // Try to make the close cmdline animation as smooth as possible.
            Object(_src_lib_messaging__WEBPACK_IMPORTED_MODULE_0__["messageOwnTab"])("commandline_content", "hide");
            Object(_src_lib_messaging__WEBPACK_IMPORTED_MODULE_0__["messageOwnTab"])("commandline_content", "blur");
            // Delete all completion sources - I don't think this is required, but this
            // way if there is a transient bug in completions it shouldn't persist.
            if (cmdline_state.activeCompletions)
                cmdline_state.activeCompletions.forEach(comp => cmdline_state.completionsDiv.removeChild(comp.node));
            cmdline_state.activeCompletions = undefined;
            cmdline_state.isVisible = false;
        },
        /**
         * Selects the next history line.
         */
        "next_history": () => {
            return cmdline_state.history(1);
        },
        /**
         * Selects the prev history line.
         */
        "prev_history": () => {
            return cmdline_state.history(-1);
        },
        /**
         * Execute the content of the command line and hide it.
         **/
        "accept_line": () => {
            const command = cmdline_state.getCompletion() || cmdline_state.clInput.value;
            cmdline_state.fns.hide_and_clear();
            const [func, ...args] = command.trim().split(/\s+/);
            if (func.length === 0 || func.startsWith("#")) {
                return;
            }
            // Save non-secret commandlines to the history.
            if (!browser.extension.inIncognitoContext &&
                !(func === "winopen" && args[0] === "-private")) {
                cmdline_state.state.cmdHistory = cmdline_state.state.cmdHistory.concat([command]);
            }
            cmdline_state.cmdline_history_position = 0;
            // Send excmds directly to our own tab, which fixes the
            // old bug where a command would be issued in one tab but
            // land in another because the active tab had
            // changed. Background-mode excmds will be received by the
            // own tab's content script and then bounced through a
            // shim to the background, but the latency increase should
            // be acceptable becuase the background-mode excmds tend
            // to be a touch less latency-sensitive.
            return Object(_src_lib_messaging__WEBPACK_IMPORTED_MODULE_0__["messageOwnTab"])("controller_content", "acceptExCmd", [command]);
        },
    };
}


/***/ }),

/***/ "./src/lib/config.ts":
/*!***************************!*\
  !*** ./src/lib/config.ts ***!
  \***************************/
/*! exports provided: o, USERCONFIG, default_config, mergeDeep, getURL, get, getDynamic, getAsyncDynamic, getAsync, setURL, set, unsetURL, unset, save, update, addChangeListener, removeChangeListener, parseConfig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return o; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "USERCONFIG", function() { return USERCONFIG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default_config", function() { return default_config; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeDeep", function() { return mergeDeep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getURL", function() { return getURL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDynamic", function() { return getDynamic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAsyncDynamic", function() { return getAsyncDynamic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAsync", function() { return getAsync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setURL", function() { return setURL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unsetURL", function() { return unsetURL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unset", function() { return unset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "save", function() { return save; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "update", function() { return update; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addChangeListener", function() { return addChangeListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeChangeListener", function() { return removeChangeListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseConfig", function() { return parseConfig; });
// Sketch
//
// Need an easy way of getting and setting settings
// If a setting is not set, the default should probably be returned.
// That probably means that binds etc. should be per-key?
//
// We should probably store all settings in memory, and only load from storage on startup and when we set it
//
// Really, we'd like a way of just letting things use the variables
//
/** # Tridactyl Configuration
 *
 * We very strongly recommend that you pretty much ignore this page and instead follow the link below DEFAULTS that will take you to our own source code which is formatted in a marginally more sane fashion.
 *
 */
/** @hidden */
const CONFIGNAME = "userconfig";
/** @hidden */
const WAITERS = [];
/** @hidden */
let INITIALISED = false;
/** @hidden */
// make a naked object
function o(object) {
    return Object.assign(Object.create(null), object);
}
/** @hidden */
// "Import" is a reserved word so this will have to do
function schlepp(settings) {
    Object.assign(USERCONFIG, settings);
}
/** @hidden */
let USERCONFIG = o({});
/**
 * This is the default configuration that Tridactyl comes with.
 *
 * You can change anything here using `set key1.key2.key3 value` or specific things any of the various helper commands such as `bind` or `command`. You can also jump to the help section of a setting using `:help $settingname`. Some of the settings have an input field containing their current value. You can modify these values and save them by pressing `<Enter>` but using `:set $setting $value` is a good habit to take as it doesn't force you to leave the page you're visiting to change your settings.
 */
class default_config {
    constructor() {
        /**
         * Internal version number Tridactyl uses to know whether it needs to update from old versions of the configuration.
         *
         * Changing this might do weird stuff.
         */
        this.configversion = "0.0";
        /**
         * Internal field to handle site-specific configs. Use :seturl/:unseturl to change these values.
         */
        this.subconfigs = {
            "www.google.com": {
                followpagepatterns: {
                    next: "Next",
                    prev: "Previous",
                },
            },
        };
        /**
         * Internal field to handle site-specific config priorities. Use :seturl/:unseturl to change this value.
         */
        this.priority = 0;
        // Note to developers: When creating new <modifier-letter> maps, make sure to make the modifier uppercase (e.g. <C-a> instead of <c-a>) otherwise some commands might not be able to find them (e.g. `bind <c-a>`)
        /**
         * exmaps contains all of the bindings for the command line.
         * You can of course bind regular ex commands but also [editor functions](/static/docs/modules/_src_lib_editor_.html) and [commandline-specific functions](/static/docs/modules/_src_commandline_frame_.html).
         */
        this.exmaps = {
            "<Enter>": "ex.accept_line",
            "<C-j>": "ex.accept_line",
            "<C-m>": "ex.accept_line",
            "<Escape>": "ex.hide_and_clear",
            "<ArrowUp>": "ex.prev_history",
            "<ArrowDown>": "ex.next_history",
            "<C-a>": "text.beginning_of_line",
            "<C-e>": "text.end_of_line",
            "<C-u>": "text.backward_kill_line",
            "<C-k>": "text.kill_line",
            "<C-c>": "text.kill_whole_line",
            "<C-f>": "ex.complete",
            "<Tab>": "ex.next_completion",
            "<S-Tab>": "ex.prev_completion",
            "<Space>": "ex.insert_space_or_completion",
        };
        /**
         * ignoremaps contain all of the bindings for "ignore mode".
         *
         * They consist of key sequences mapped to ex commands.
         */
        this.ignoremaps = {
            "<S-Insert>": "mode normal",
            "<CA-Escape>": "mode normal",
            "<CA-`>": "mode normal",
            "<S-Escape>": "mode normal",
            "<C-^>": "tab #",
            "<C-6>": "tab #",
        };
        /**
         * imaps contain all of the bindings for "insert mode".
         *
         * On top of regular ex commands, you can also bind [editor functions](/static/docs/modules/_src_lib_editor_.html) in insert mode.
         *
         * They consist of key sequences mapped to ex commands.
         */
        this.imaps = {
            "<Escape>": "composite unfocus | mode normal",
            "<C-[>": "composite unfocus | mode normal",
            "<C-i>": "editor",
            "<CA-Escape>": "mode normal",
            "<CA-`>": "mode normal",
            "<C-6>": "tab #",
            "<C-^>": "tab #",
            "<S-Escape>": "mode ignore",
        };
        /**
         * inputmaps contain all of the bindings for "input mode".
         *
         * On top of regular ex commands, you can also bind [editor functions](/static/docs/modules/_src_lib_editor_.html) in input mode.
         *
         * They consist of key sequences mapped to ex commands.
         */
        this.inputmaps = mergeDeep(this.imaps, {
            "<Tab>": "focusinput -n",
            "<S-Tab>": "focusinput -N",
        });
        /**
         * nmaps contain all of the bindings for "normal mode".
         *
         * They consist of key sequences mapped to ex commands.
         */
        this.nmaps = {
            "<A-p>": "pin",
            "<A-m>": "mute toggle",
            "<F1>": "help",
            o: "fillcmdline open",
            O: "current_url open",
            w: "fillcmdline winopen",
            W: "current_url winopen",
            t: "fillcmdline tabopen",
            "]]": "followpage next",
            "[[": "followpage prev",
            "[c": "urlincrement -1",
            "]c": "urlincrement 1",
            "<C-x>": "urlincrement -1",
            "<C-a>": "urlincrement 1",
            T: "current_url tabopen",
            yy: "clipboard yank",
            ys: "clipboard yankshort",
            yc: "clipboard yankcanon",
            ym: "clipboard yankmd",
            yt: "clipboard yanktitle",
            gh: "home",
            gH: "home true",
            p: "clipboard open",
            P: "clipboard tabopen",
            j: "scrollline 10",
            "<C-e>": "scrollline 10",
            k: "scrollline -10",
            "<C-y>": "scrollline -10",
            h: "scrollpx -50",
            l: "scrollpx 50",
            G: "scrollto 100",
            gg: "scrollto 0",
            "<C-u>": "scrollpage -0.5",
            "<C-d>": "scrollpage 0.5",
            "<C-f>": "scrollpage 1",
            "<C-b>": "scrollpage -1",
            $: "scrollto 100 x",
            // "0": "scrollto 0 x", // will get interpreted as a count
            "^": "scrollto 0 x",
            "<C-6>": "tab #",
            "<C-^>": "tab #",
            H: "back",
            L: "forward",
            "<C-o>": "jumpprev",
            "<C-i>": "jumpnext",
            d: "tabclose",
            D: "composite tabprev; tabclose #",
            gx0: "tabclosealltoleft",
            gx$: "tabclosealltoright",
            "<<": "tabmove -1",
            ">>": "tabmove +1",
            u: "undo",
            U: "undo window",
            r: "reload",
            R: "reloadhard",
            x: "stop",
            gi: "focusinput -l",
            "g?": "rot13",
            "g;": "changelistjump -1",
            J: "tabprev",
            K: "tabnext",
            gt: "tabnext_gt",
            gT: "tabprev",
            // "<c-n>": "tabnext_gt", // c-n is reserved for new window
            // "<c-p>": "tabprev",
            "g^": "tabfirst",
            g0: "tabfirst",
            g$: "tablast",
            gr: "reader",
            gu: "urlparent",
            gU: "urlroot",
            gf: "viewsource",
            ":": "fillcmdline_notrail",
            s: "fillcmdline open search",
            S: "fillcmdline tabopen search",
            // find mode not suitable for general consumption yet.
            // "/": "fillcmdline find",
            // "?": "fillcmdline find -?",
            // n: "findnext 1",
            // N: "findnext -1",
            // ",<Space>": "nohlsearch",
            M: "gobble 1 quickmark",
            B: "fillcmdline taball",
            b: "fillcmdline tab",
            ZZ: "qall",
            f: "hint",
            F: "hint -b",
            gF: "hint -br",
            ";i": "hint -i",
            ";b": "hint -b",
            ";o": "hint",
            ";I": "hint -I",
            ";k": "hint -k",
            ";y": "hint -y",
            ";p": "hint -p",
            ";P": "hint -P",
            ";r": "hint -r",
            ";s": "hint -s",
            ";S": "hint -S",
            ";a": "hint -a",
            ";A": "hint -A",
            ";;": "hint -;",
            ";#": "hint -#",
            ";v": "hint -W mpvsafe",
            ";w": "hint -w",
            ";t": "hint -W tabopen",
            ";O": "hint -W fillcmdline_notrail open ",
            ";W": "hint -W fillcmdline_notrail winopen ",
            ";T": "hint -W fillcmdline_notrail tabopen ",
            ";z": "hint -z",
            ";m": "composite hint -pipe img src | js -p tri.excmds.open('images.google.com/searchbyimage?image_url=' + JS_ARG)",
            ";M": "composite hint -pipe img src | jsb -p tri.excmds.tabopen('images.google.com/searchbyimage?image_url=' + JS_ARG)",
            ";gi": "hint -qi",
            ";gI": "hint -qI",
            ";gk": "hint -qk",
            ";gy": "hint -qy",
            ";gp": "hint -qp",
            ";gP": "hint -qP",
            ";gr": "hint -qr",
            ";gs": "hint -qs",
            ";gS": "hint -qS",
            ";ga": "hint -qa",
            ";gA": "hint -qA",
            ";g;": "hint -q;",
            ";g#": "hint -q#",
            ";gv": "hint -qW mpvsafe",
            ";gw": "hint -qw",
            ";gb": "hint -qb",
            "<S-Insert>": "mode ignore",
            "<CA-Escape>": "mode ignore",
            "<CA-`>": "mode ignore",
            "<S-Escape>": "mode ignore",
            "<Escape>": "composite mode normal ; hidecmdline",
            "<C-[>": "composite mode normal ; hidecmdline",
            a: "current_url bmark",
            A: "bmark",
            zi: "zoom 0.1 true",
            zo: "zoom -0.1 true",
            zm: "zoom 0.5 true",
            zr: "zoom -0.5 true",
            zM: "zoom 0.5 true",
            zR: "zoom -0.5 true",
            zz: "zoom 1",
            zI: "zoom 3",
            zO: "zoom 0.3",
            ".": "repeat",
            "<SA-ArrowUp><SA-ArrowUp><SA-ArrowDown><SA-ArrowDown><SA-ArrowLeft><SA-ArrowRight><SA-ArrowLeft><SA-ArrowRight>ba": "open https://www.youtube.com/watch?v=M3iOROuTuMA",
        };
        this.hintmaps = {
            "<Backspace>": "hint.popKey",
            "<Escape>": "hint.reset",
            "<Tab>": "hint.focusPreviousHint",
            "<S-Tab>": "hint.focusNextHint",
            "<ArrowUp>": "hint.focusTopHint",
            "<ArrowDown>": "hint.focusBottomHint",
            "<ArrowLeft>": "hint.focusLeftHint",
            "<ArrowRight>": "hint.focusRightHint",
            "<Enter>": "hint.selectFocusedHint",
            "<Space>": "hint.selectFocusedHint",
        };
        /**
         * Whether to allow pages (not necessarily github) to override `/`, which is a default Firefox binding.
         */
        this.leavegithubalone = "false";
        /**
         * Which keys to protect from pages that try to override them. Requires [[leavegithubalone]] to be set to false.
         */
        this.blacklistkeys = ["/"];
        /**
         * Autocommands that run when certain events happen, and other conditions are met.
         *
         * Related ex command: `autocmd`.
         */
        this.autocmds = {
            /**
             * Commands that will be run as soon as Tridactyl loads into a page.
             *
             * Each key corresponds to a URL fragment which, if contained within the page URL, will run the corresponding command.
             */
            DocStart: {
            // "addons.mozilla.org": "mode ignore",
            },
            /**
             * Commands that will be run when pages are loaded.
             *
             * Each key corresponds to a URL fragment which, if contained within the page URL, will run the corresponding command.
             */
            DocLoad: {
                "^https://github.com/tridactyl/tridactyl/issues/new$": "issue",
            },
            /**
             * Commands that will be run when pages are unloaded.
             *
             * Each key corresponds to a URL fragment which, if contained within the page URL, will run the corresponding command.
             */
            DocEnd: {
            // "emacs.org": "sanitise history",
            },
            /**
             * Commands that will be run when Tridactyl first runs each time you start your browser.
             *
             * Each key corresponds to a URL fragment which, if contained within the page URL, will run the corresponding command.
             */
            TriStart: {
                ".*": "source_quiet",
            },
            /**
             * Commands that will be run when you enter a tab.
             *
             * Each key corresponds to a URL fragment which, if contained within the page URL, will run the corresponding command.
             */
            TabEnter: {
            // "gmail.com": "mode ignore",
            },
            /**
             * Commands that will be run when you leave a tab.
             *
             * Each key corresponds to a URL fragment which, if contained within the page URL, will run the corresponding command.
             */
            TabLeft: {
            // Actually, this doesn't work because tabclose closes the current tab
            // Too bad :/
            // "emacs.org": "tabclose",
            },
            /**
             * Commands that will be run when fullscreen state changes.
             */
            FullscreenChange: {},
            /**
             * Commands that will be run when fullscreen state is entered.
             */
            FullscreenEnter: {},
            /**
             * Commands that will be run when fullscreen state is left.
             */
            FullscreenLeft: {},
        };
        /**
         * Map for translating keys directly into other keys in normal-ish modes. For example, if you have an entry in this config option mapping `п` to `g`, then you could type `пп` instead of `gg` or `пi` instead of `gi` or `;п` instead of `;g`. This is primarily useful for international users who don't want to deal with rebuilding their bindings every time tridactyl ships a new default keybind. It's not as good as shipping properly internationalized sets of default bindings, but it's probably as close as we're going to get on a small open-source project like this.
         *
         * Note that the current implementation does not allow you to "chain" keys, for example, "a"=>"b" and "b"=>"c" for "a"=>"c". You can, however, swap or rotate keys, so "a"=>"b" and "b"=>"a" will work the way you'd expect, as will "a"=>"b" and "b"=>"c" and "c"=>"a".
         */
        this.keytranslatemap = {
        // Examples (I think >_>):
        // "д": "l", // Russian language
        // "é" : "w", // BÉPO
        // "h": "j", // Dvorak
        // "n": "j", // Colemak
        // etc
        };
        /**
         * Whether to use the keytranslatemap in various maps.
         */
        this.keytranslatemodes = {
            nmaps: "true",
            imaps: "false",
            inputmaps: "false",
            ignoremaps: "false",
            exmaps: "false",
            hintmaps: "false",
        };
        /**
         * Automatically place these sites in the named container.
         *
         * Each key corresponds to a URL fragment which, if contained within the page URL, the site will be opened in a container tab instead.
         */
        this.autocontain = o({
        // "github.com": "microsoft",
        // "youtube.com": "google",
        });
        /**
         * Aliases for the commandline.
         *
         * You can make a new one with `command alias ex-command`.
         */
        this.exaliases = {
            alias: "command",
            au: "autocmd",
            aucon: "autocontain",
            audel: "autocmddelete",
            audelete: "autocmddelete",
            b: "tab",
            clsh: "clearsearchhighlight",
            nohlsearch: "clearsearchhighlight",
            noh: "clearsearchhighlight",
            o: "open",
            w: "winopen",
            t: "tabopen",
            tabnew: "tabopen",
            tabm: "tabmove",
            tabo: "tabonly",
            tn: "tabnext_gt",
            bn: "tabnext_gt",
            tnext: "tabnext_gt",
            bnext: "tabnext_gt",
            tp: "tabprev",
            tN: "tabprev",
            bp: "tabprev",
            bN: "tabprev",
            tprev: "tabprev",
            bprev: "tabprev",
            tabfirst: "tab 1",
            tablast: "tab 0",
            bfirst: "tabfirst",
            blast: "tablast",
            tfirst: "tabfirst",
            tlast: "tablast",
            buffer: "tab",
            bufferall: "taball",
            bd: "tabclose",
            bdelete: "tabclose",
            quit: "tabclose",
            q: "tabclose",
            qa: "qall",
            sanitize: "sanitise",
            tutorial: "tutor",
            h: "help",
            unmute: "mute unmute",
            authors: "credits",
            openwith: "hint -W",
            "!": "exclaim",
            "!s": "exclaim_quiet",
            containerremove: "containerdelete",
            colours: "colourscheme",
            colorscheme: "colourscheme",
            colors: "colourscheme",
            man: "help",
            "!js": "fillcmdline_tmp 3000 !js is deprecated. Please use js instead",
            "!jsb": "fillcmdline_tmp 3000 !jsb is deprecated. Please use jsb instead",
            get_current_url: "js document.location.href",
            current_url: "composite get_current_url | fillcmdline_notrail ",
            stop: "js window.stop()",
            zo: "zoom",
            installnative: "nativeinstall",
            nativeupdate: "updatenative",
            mkt: "mktridactylrc",
            "mkt!": "mktridactylrc -f",
            "mktridactylrc!": "mktridactylrc -f",
            mpvsafe: "js -p tri.excmds.shellescape(JS_ARG).then(url => tri.excmds.exclaim_quiet('mpv ' + url))",
        };
        /**
         * Used by `]]` and `[[` to look for links containing these words.
         *
         * Edit these if you want to add, e.g. other language support.
         */
        this.followpagepatterns = {
            next: "^(next|newer)\\b|»|>>|more",
            prev: "^(prev(ious)?|older)\\b|«|<<",
        };
        /**
         * The default search engine used by `open search`. If empty string, your browser's default search engine will be used. If set to something, Tridactyl will first look at your [[searchurls]] and then at the search engines for which you have defined a keyword on `about:preferences#search`.
         */
        this.searchengine = "";
        /**
         * Definitions of search engines for use via `open [keyword]`.
         *
         * `%s` will be replaced with your whole query and `%s1`, `%s2`, ..., `%sn` will be replaced with the first, second and nth word of your query. If there are none of these patterns in your search urls, your query will simply be appended to the searchurl.
         *
         * Examples:
         * - When running `open gi cute puppies`, with a `gi` searchurl defined with `set searchurls.gi https://www.google.com/search?q=%s&tbm=isch`, tridactyl will navigate to `https://www.google.com/search?q=cute puppies&tbm=isch`.
         * - When running `tabopen translate en ja Tridactyl`, with a `translate` searchurl defined with `set searchurls.translate https://translate.google.com/#view=home&op=translate&sl=%s1&tl=%s2&text=%s3`, tridactyl will navigate to `https://translate.google.com/#view=home&op=translate&sl=en&tl=ja&text=Tridactyl`.
         */
        this.searchurls = {
            google: "https://www.google.com/search?q=",
            googlelucky: "https://www.google.com/search?btnI=I'm+Feeling+Lucky&q=",
            scholar: "https://scholar.google.com/scholar?q=",
            googleuk: "https://www.google.co.uk/search?q=",
            bing: "https://www.bing.com/search?q=",
            duckduckgo: "https://duckduckgo.com/?q=",
            yahoo: "https://search.yahoo.com/search?p=",
            twitter: "https://twitter.com/search?q=",
            wikipedia: "https://en.wikipedia.org/wiki/Special:Search/",
            youtube: "https://www.youtube.com/results?search_query=",
            amazon: "https://www.amazon.com/s/ref=nb_sb_noss?url=search-alias%3Daps&field-keywords=",
            amazonuk: "https://www.amazon.co.uk/s/ref=nb_sb_noss?url=search-alias%3Daps&field-keywords=",
            startpage: "https://startpage.com/do/search?language=english&cat=web&query=",
            github: "https://github.com/search?utf8=✓&q=",
            searx: "https://searx.me/?category_general=on&q=",
            cnrtl: "http://www.cnrtl.fr/lexicographie/",
            osm: "https://www.openstreetmap.org/search?query=",
            mdn: "https://developer.mozilla.org/en-US/search?q=",
            gentoo_wiki: "https://wiki.gentoo.org/index.php?title=Special%3ASearch&profile=default&fulltext=Search&search=",
            qwant: "https://www.qwant.com/?q=",
        };
        /**
         * URL the newtab will redirect to.
         *
         * All usual rules about things you can open with `open` apply, with the caveat that you'll get interesting results if you try to use something that needs `nativeopen`: so don't try `about:newtab`.
         */
        this.newtab = "";
        /**
         * Whether `:viewsource` will use our own page that you can use Tridactyl binds on, or Firefox's default viewer, which you cannot use Tridactyl on.
         */
        this.viewsource = "tridactyl";
        /**
         * Which storage to use. Sync storage will synchronise your settings via your Firefox Account.
         */
        this.storageloc = "sync";
        /**
         * Pages opened with `gH`. In order to set this value, use `:set homepages ["example.org", "example.net", "example.com"]` and so on.
         */
        this.homepages = [];
        /**
         * Characters to use in hint mode.
         *
         * They are used preferentially from left to right.
         */
        this.hintchars = "hjklasdfgyuiopqwertnmzxcvb";
        /**
         * The type of hinting to use. `vimperator` will allow you to filter links based on their names by typing non-hint chars. It is recommended that you use this in conjuction with the [[hintchars]] setting, which you should probably set to e.g, `5432167890`. ´vimperator-reflow´ additionally updates the hint labels after filtering.
         */
        this.hintfiltermode = "simple";
        /**
         * Whether to optimise for the shortest possible names for each hint, or to use a simple numerical ordering. If set to `numeric`, overrides `hintchars` setting.
         */
        this.hintnames = "short";
        /**
         * Whether to display the names for hints in uppercase.
         */
        this.hintuppercase = "true";
        /**
         * The delay in milliseconds in `vimperator` style hint modes after selecting a hint before you are returned to normal mode.
         *
         * The point of this is to prevent accidental execution of normal mode binds due to people typing more than is necessary to choose a hint.
         */
        this.hintdelay = 300;
        /**
         * Controls whether the page can focus elements for you via js
         *
         * NB: will break fancy editors such as CodeMirror on Jupyter. Simply use `seturl` to whitelist pages you need it on.
         *
         * Best used in conjunction with browser.autofocus in `about:config`
         */
        this.allowautofocus = "true";
        /**
         * Uses a loop to prevent focus until you interact with a page. Only recommended for use via `seturl` for problematic sites as it can be a little heavy on CPU if running on all tabs. Should be used in conjuction with [[allowautofocus]]
         */
        this.preventautofocusjackhammer = "false";
        /**
         * Controls whether the newtab focuses on tridactyl's newtab page or the firefox urlbar.
         *
         * To get FF default behaviour, use "urlbar".
         */
        this.newtabfocus = "page";
        /**
         * Whether to use Tridactyl's (bad) smooth scrolling.
         */
        this.smoothscroll = "false";
        /**
         * How viscous you want smooth scrolling to feel.
         */
        this.scrollduration = 100;
        /**
         * Where to open tabs opened with `tabopen` - to the right of the current tab, or at the end of the tabs.
         */
        this.tabopenpos = "next";
        /**
         * Where to open tabs opened with hinting - as if it had been middle clicked, to the right of the current tab, or at the end of the tabs.
         */
        this.relatedopenpos = "related";
        /**
         * The name of the voice to use for text-to-speech. You can get the list of installed voices by running the following snippet: `js alert(window.speechSynthesis.getVoices().reduce((a, b) => a + " " + b.name))`
         */
        this.ttsvoice = "default"; // chosen from the listvoices list or "default"
        /**
         * Controls text-to-speech volume. Has to be a number between 0 and 1.
         */
        this.ttsvolume = 1;
        /**
         * Controls text-to-speech speed. Has to be a number between 0.1 and 10.
         */
        this.ttsrate = 1;
        /**
         * Controls text-to-speech pitch. Has to be between 0 and 2.
         */
        this.ttspitch = 1;
        /**
         * If nextinput, <Tab> after gi brings selects the next input
         *
         * If firefox, <Tab> selects the next selectable element, e.g. a link
         */
        this.gimode = "nextinput";
        /**
         * Decides where to place the cursor when selecting non-empty input fields
         */
        this.cursorpos = "end";
        /**
         * The theme to use.
         *
         * Permitted values: run `:composite js tri.styling.THEMES | fillcmdline` to find out.
         */
        this.theme = "default";
        /**
         * Storage for custom themes
         *
         * Maps theme names to CSS. Predominantly used automatically by [[colourscheme]] to store themes read from disk, as documented by [[colourscheme]]. Setting this manually is untested but might work provided that [[colourscheme]] is then used to change the theme to the right theme name.
         */
        this.customthemes = {};
        /**
         * Whether to display the mode indicator or not.
         */
        this.modeindicator = "true";
        /**
         * Milliseconds before registering a scroll in the jumplist
         */
        this.jumpdelay = 3000;
        /**
         * Logging levels. Unless you're debugging Tridactyl, it's unlikely you'll ever need to change these.
         */
        this.logging = {
            cmdline: "warning",
            containers: "warning",
            controller: "warning",
            excmd: "error",
            hinting: "warning",
            messaging: "warning",
            native: "warning",
            performance: "warning",
            state: "warning",
            styling: "warning",
        };
        /**
         * Disables the commandline iframe. Dangerous setting, use [[seturl]] to set it. If you ever set this setting to "true" globally and then want to set it to false again, you can do this by opening Tridactyl's preferences page from about:addons.
         */
        this.noiframe = "false";
        /**
         * @deprecated A list of URLs on which to not load the iframe. Use `seturl [URL] noiframe true` instead, as shown in [[noiframe]].
         */
        this.noiframeon = [];
        /**
         * Insert / input mode edit-in-$EDITOR command to run
         * This has to be a command that stays in the foreground for the whole editing session
         * "auto" will attempt to find a sane editor in your path.
         * Please send your requests to have your favourite terminal moved further up the list to /dev/null.
         *          (but we are probably happy to add your terminal to the list if it isn't already there.)
         *
         * Example values:
         * - linux: `xterm -e vim`
         * - windows: `start cmd.exe /c \"vim\"`.
         *
         * Also see [:editor](/static/docs/modules/_src_excmds_.html#editor).
         */
        this.editorcmd = "auto";
        /**
         * Command that should be run by the [[rssexec]] ex command. Has the
         * following format:
         * - %u: url
         * - %t: title
         * - %y: type (rss, atom, xml...)
         * Warning: This is a very large footgun. %u will be inserted without any
         * kind of escaping, hence you must obey the following rules if you care
         * about security:
         * - Do not use a composite command. If you need a composite command,
         * create an alias.
         * - Do not use `js` or `jsb`. If you need to use them, create an alias.
         * - Do not insert any %u, %t or %y in shell commands run by the native
         * messenger. Use pipes instead.
         *
         * Here's an example of how to save an rss url in a file on your disk
         * safely:
         * `alias save_rss jsb -p tri.native.run("cat >> ~/.config.newsboat/urls", JS_ARG)`
         * `set rsscmd save_rss %u`
         * This is safe because the url is passed to jsb as an argument rather than
         * being expanded inside of the string it will execute and because it is
         * piped to the shell command rather than being expanded inside of it.
         */
        this.rsscmd = "yank %u";
        /**
         * The browser executable to look for in commands such as `restart`. Not as mad as it seems if you have multiple versions of Firefox...
         */
        this.browser = "firefox";
        /**
         * Which clipboard to store items in. Requires the native messenger to be installed.
         */
        this.yankto = "clipboard";
        /**
         * Which clipboard to retrieve items from. Requires the native messenger to be installed.
         *
         * Permitted values: `clipboard`, or `selection`.
         */
        this.putfrom = "clipboard";
        /**
         * Clipboard command to try to get the selection from (e.g. `xsel` or `xclip`)
         */
        this.externalclipboardcmd = "auto";
        /**
         * Set this to something weird if you want to have fun every time Tridactyl tries to update its native messenger.
         *
         * %TAG will be replaced with your version of Tridactyl for stable builds, or "master" for beta builds
         */
        this.nativeinstallcmd = "curl -fsSl https://raw.githubusercontent.com/tridactyl/tridactyl/master/native/install.sh -o /tmp/trinativeinstall.sh && bash /tmp/trinativeinstall.sh %TAG";
        /**
         * Set this to something weird if you want to have fun every time Tridactyl tries to update its native messenger.
         *
         * Replaces %WINTAG with "-Tag $TRI_VERSION", similarly to [[nativeinstallcmd]].
         */
        this.win_nativeinstallcmd = `powershell -NoProfile -InputFormat None -Command "Invoke-Expression ((New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/cmcaine/tridactyl/master/native/win_install.ps1'))"`;
        /**
         * Used by :updatecheck and related built-in functionality to automatically check for updates and prompt users to upgrade.
         */
        this.update = {
            /**
             * Whether Tridactyl should check for available updates at startup.
             */
            nag: true,
            /**
             * How many days to wait after an update is first available until telling people.
             */
            nagwait: 7,
            /**
             * The version we last nagged you about. We only nag you once per version.
             */
            lastnaggedversion: "1.14.0",
            /**
             * Time we last checked for an update, milliseconds since unix epoch.
             */
            lastchecktime: 0,
            /**
             * Minimum interval between automatic update checks, in seconds.
             */
            checkintervalsecs: 60 * 60 * 24,
        };
        /**
         * Profile directory to use with native messenger with e.g, `guiset`.
         */
        this.profiledir = "auto";
        // Container settings
        /**
         * If enabled, tabopen opens a new tab in the currently active tab's container.
         */
        this.tabopencontaineraware = "false";
        /**
         * If moodeindicator is enabled, containerindicator will color the border of the mode indicator with the container color.
         */
        this.containerindicator = "true";
        /**
         * Autocontain directives create a container if it doesn't exist already.
         */
        this.auconcreatecontainer = "true";
        /**
         * Number of most recent results to ask Firefox for. We display the top 20 or so most frequently visited ones.
         */
        this.historyresults = 50;
        /**
         * When displaying bookmarks in history completions, how many page views to pretend they have.
         */
        this.bmarkweight = 100;
        /**
         * Number of results that should be shown in completions. -1 for unlimited
         */
        this.findresults = -1;
        /**
         * Number of characters to use as context for the matches shown in completions
         */
        this.findcontextlen = 100;
        /**
         * Whether find should be case-sensitive
         */
        this.findcase = "smart";
        /**
         * Whether Tridactyl should jump to the first match when using `:find`
         */
        this.incsearch = "false";
        /**
         * How many characters should be typed before triggering incsearch/completions
         */
        this.minincsearchlen = 3;
        /**
         * Change this to "clobber" to ruin the "Content Security Policy" of all sites a bit and make Tridactyl run a bit better on some of them, e.g. raw.github*
         */
        this.csp = "untouched";
        /**
         * JavaScript RegExp used to recognize words in text.* functions (e.g. text.transpose_words). Should match any character belonging to a word.
         */
        this.wordpattern = "[^\\s]+";
        /**
         * Activate tridactyl's performance counters. These have a
         * measurable performance impact, since every sample is a few
         * hundred bytes and we sample tridactyl densely, but they're good
         * when you're trying to optimize things.
         */
        this.perfcounters = "false";
        /**
         * How many samples to store from the perf counters.
         *
         * Each performance entry is two numbers (16 bytes), an entryType
         * of either "mark" or "measure" (js strings are utf-16 ad we have
         * two marks for each measure, so amortize to about 10 bytes per
         * entry), and a string name that for Tridactyl object will be
         * about 40 (utf-16) characters (80 bytes), plus object overhead
         * roughly proportional to the string-length of the name of the
         * constructor (in this case something like 30 bytes), for a total
         * of what we'll call 128 bytes for ease of math.
         *
         * We want to store, by default, about 1MB of performance
         * statistics, so somewhere around 10k samples.
         *
         */
        this.perfsamples = "10000";
        /**
         * Show (partial) command in the mode indicator.
         * Corresponds to 'showcmd' option of vi.
         */
        this.modeindicatorshowkeys = "false";
        /**
         * Whether a trailing slash is appended when we get the parent of a url with
         * gu (or other means).
         */
        this.urlparenttrailingslash = "true";
    }
}
/** @hidden */
const DEFAULTS = o(new default_config());
/** Given an object and a target, extract the target if it exists, else return undefined

    @param target path of properties as an array
    @hidden
 */
function getDeepProperty(obj, target) {
    if (obj !== undefined && target.length) {
        return getDeepProperty(obj[target[0]], target.slice(1));
    }
    else {
        return obj;
    }
}
/** Create the key path target if it doesn't exist and set the final property to value.

    If the path is an empty array, replace the obj.

    @param target path of properties as an array
    @hidden
 */
function setDeepProperty(obj, value, target) {
    if (target.length > 1) {
        // If necessary antecedent objects don't exist, create them.
        if (obj[target[0]] === undefined) {
            obj[target[0]] = o({});
        }
        return setDeepProperty(obj[target[0]], value, target.slice(1));
    }
    else {
        obj[target[0]] = value;
    }
}
/** @hidden
 * Merges two objects and any child objects they may have
 */
function mergeDeep(o1, o2) {
    const r = Array.isArray(o1) ? o1.slice() : Object.create(o1);
    Object.assign(r, o1, o2);
    if (o2 === undefined)
        return r;
    Object.keys(o1)
        .filter(key => typeof o1[key] === "object" && typeof o2[key] === "object")
        .forEach(key => Object.assign(r[key], mergeDeep(o1[key], o2[key])));
    return r;
}
/** @hidden
 * Gets a site-specific setting.
 */
function getURL(url, target) {
    function _getURL(conf, url, target) {
        if (!conf.subconfigs)
            return undefined;
        // For each key
        return (Object.keys(conf.subconfigs)
            // Keep only the ones that have a match
            .filter(k => url.match(k) &&
            getDeepProperty(conf.subconfigs[k], target) !==
                undefined)
            // Sort them from lowest to highest priority, default to a priority of 10
            .sort((k1, k2) => (conf.subconfigs[k1].priority || 10) -
            (conf.subconfigs[k2].priority || 10))
            // Merge their corresponding value if they're objects, otherwise return the last value
            .reduce((acc, curKey) => {
            const curVal = getDeepProperty(conf.subconfigs[curKey], target);
            if (acc instanceof Object && curVal instanceof Object)
                return mergeDeep(acc, curVal);
            return curVal;
        }, undefined));
    }
    const user = _getURL(USERCONFIG, url, target);
    const deflt = _getURL(DEFAULTS, url, target);
    if (user === undefined || user === null)
        return deflt;
    if (typeof user !== "object" || typeof deflt !== "object")
        return user;
    return mergeDeep(deflt, user);
}
/** Get the value of the key target.

    If the user has not specified a key, use the corresponding key from
    defaults, if one exists, else undefined.
    @hidden
 */
function get(target_typed, ...target) {
    if (target_typed === undefined) {
        target = [];
    }
    else {
        target = [target_typed].concat(target);
    }
    // Window.tri might not be defined when called from the untrusted page context
    let loc = window.location;
    if (window.tri && window.tri.contentLocation)
        loc = window.tri.contentLocation;
    // If there's a site-specifing setting, it overrides global settings
    const site = getURL(loc.href, target);
    const user = getDeepProperty(USERCONFIG, target);
    const defult = getDeepProperty(DEFAULTS, target);
    // Merge results if there's a default value and it's not an Array or primitive.
    if (typeof defult === "object") {
        return mergeDeep(mergeDeep(defult, user), site);
    }
    else {
        if (site !== undefined) {
            return site;
        }
        else if (user !== undefined) {
            return user;
        }
        else {
            return defult;
        }
    }
}
/** Get the value of the key target.

    Please only use this with targets that will be used at runtime - it skips static checks. Prefer [[get]].
 */
function getDynamic(...target) {
    return get(target[0], ...target.slice(1));
}
/** Get the value of the key target.

    Please only use this with targets that will be used at runtime - it skips static checks. Prefer [[getAsync]].
 */
async function getAsyncDynamic(...target) {
    return getAsync(target[0], ...target.slice(1));
}
/** Get the value of the key target, but wait for config to be loaded from the
    database first if it has not been at least once before.

    This is useful if you are a content script and you've just been loaded.
    @hidden
 */
async function getAsync(target_typed, ...target) {
    if (INITIALISED) {
        return get(target_typed, ...target);
    }
    else {
        return new Promise(resolve => WAITERS.push(() => resolve(get(target_typed, ...target))));
    }
}
/** @hidden
 * Like set(), but for a specific pattern.
 */
function setURL(pattern, ...args) {
    return set("subconfigs", pattern, ...args);
}
/** Full target specification, then value

    e.g.
        set("nmaps", "o", "open")
        set("search", "default", "google")
        set("aucmd", "BufRead", "memrise.com", "open memrise.com")

    @hidden
 */
function set(...args) {
    if (args.length < 2) {
        throw "You must provide at least two arguments!";
    }
    const target = args.slice(0, args.length - 1);
    const value = args[args.length - 1];
    setDeepProperty(USERCONFIG, value, target);
    return save();
}
/** @hidden
 * Delete the key at USERCONFIG[pattern][target]
 */
function unsetURL(pattern, ...target) {
    return unset("subconfigs", pattern, ...target);
}
/** Delete the key at target in USERCONFIG if it exists
 * @hidden */
function unset(...target) {
    const parent = getDeepProperty(USERCONFIG, target.slice(0, -1));
    if (parent !== undefined)
        delete parent[target[target.length - 1]];
    return save();
}
/** Save the config back to storage API.

    Config is not synchronised between different instances of this module until
    sometime after this happens.

    @hidden
 */
async function save(storage = get("storageloc")) {
    // let storageobj = storage === "local" ? browser.storage.local : browser.storage.sync
    // storageobj.set({CONFIGNAME: USERCONFIG})
    const settingsobj = o({});
    settingsobj[CONFIGNAME] = USERCONFIG;
    return storage === "local"
        ? browser.storage.local.set(settingsobj)
        : browser.storage.sync.set(settingsobj);
}
/** Updates the config to the latest version.
    Proposed semantic for config versionning:
     - x.y -> x+1.0 : major architectural changes
     - x.y -> x.y+1 : renaming settings/changing their types
    There's no need for an updater if you're only adding a new setting/changing
    a default setting

    When adding updaters, don't forget to set("configversion", newversionnumber)!
    @hidden
 */
async function update() {
    // Updates a value both in the main config and in sub (=site specific) configs
    const updateAll = (setting, fn) => {
        const val = getDeepProperty(USERCONFIG, setting);
        if (val) {
            set(...setting, fn(val));
        }
        const subconfigs = getDeepProperty(USERCONFIG, ["subconfigs"]);
        if (subconfigs) {
            Object.keys(subconfigs)
                .map(pattern => [pattern, getURL(pattern, setting)])
                .filter(([pattern, value]) => value)
                .forEach(([pattern, value]) => setURL(pattern, ...setting, fn(value)));
        }
    };
    const updaters = {
        "0.0": async () => {
            try {
                // Before we had a config system, we had nmaps, and we put them in the
                // root namespace because we were young and bold.
                const legacy_nmaps = await browser.storage.sync.get("nmaps");
                if (Object.keys(legacy_nmaps).length > 0) {
                    USERCONFIG.nmaps = Object.assign(legacy_nmaps.nmaps, USERCONFIG.nmaps);
                }
            }
            finally {
                set("configversion", "1.0");
            }
        },
        "1.0": () => {
            const vimiumgi = getDeepProperty(USERCONFIG, ["vimium-gi"]);
            if (vimiumgi === true || vimiumgi === "true")
                set("gimode", "nextinput");
            else if (vimiumgi === false || vimiumgi === "false")
                set("gimode", "firefox");
            unset("vimium-gi");
            set("configversion", "1.1");
        },
        "1.1": () => {
            const leveltostr = {
                0: "never",
                1: "error",
                2: "warning",
                3: "info",
                4: "debug",
            };
            const logging = getDeepProperty(USERCONFIG, ["logging"]);
            // logging is not necessarily defined if the user didn't change default values
            if (logging)
                Object.keys(logging).forEach(l => set("logging", l, leveltostr[logging[l]]));
            set("configversion", "1.2");
        },
        "1.2": () => {
            ;
            ["ignoremaps", "inputmaps", "imaps", "nmaps"]
                .map(mapname => [
                mapname,
                getDeepProperty(USERCONFIG, [mapname]),
            ])
                // mapobj is undefined if the user didn't define any bindings
                .filter(([mapname, mapobj]) => mapobj)
                .forEach(([mapname, mapobj]) => {
                // For each mapping
                Object.keys(mapobj)
                    // Keep only the ones with im_* functions
                    .filter(key => mapobj[key].search("^im_|([^a-zA-Z0-9_-])im_") >= 0)
                    // Replace the prefix
                    .forEach(key => setDeepProperty(USERCONFIG, mapobj[key].replace(new RegExp("^im_|([^a-zA-Z0-9_-])im_"), "$1text."), [mapname, key]));
            });
            set("configversion", "1.3");
        },
        "1.3": () => {
            ;
            [
                "priority",
                "hintdelay",
                "scrollduration",
                "ttsvolume",
                "ttsrate",
                "ttspitch",
                "jumpdelay",
                "historyresults",
            ].forEach(setting => updateAll([setting], parseInt));
            set("configversion", "1.4");
        },
        "1.4": () => {
            ;
            (getDeepProperty(USERCONFIG, ["noiframeon"]) || []).forEach(site => {
                setURL(site, "noiframe", "true");
            });
            set("configversion", "1.5");
        },
        "1.5": () => {
            unset("exaliases", "tab");
            set("configversion", "1.6");
        },
        "1.6": () => {
            const updateSetting = mapObj => {
                if (!mapObj)
                    return mapObj;
                if (mapObj[" "] !== undefined) {
                    mapObj["<Space>"] = mapObj[" "];
                    delete mapObj[" "];
                }
                ;
                [
                    "<A- >",
                    "<C- >",
                    "<M- >",
                    "<S- >",
                    "<AC- >",
                    "<AM- >",
                    "<AS- >",
                    "<CM- >",
                    "<CS- >",
                    "<MS- >",
                ].forEach(binding => {
                    if (mapObj[binding] !== undefined) {
                        const key = binding.replace(" ", "Space");
                        mapObj[key] = mapObj[binding];
                        delete mapObj[binding];
                    }
                });
                return mapObj;
            };
            ["nmaps", "exmaps", "imaps", "inputmaps", "ignoremaps"].forEach(settingName => updateAll([settingName], updateSetting));
            set("configversion", "1.7");
        },
    };
    if (!get("configversion"))
        set("configversion", "0.0");
    const updatetest = v => {
        return updaters.hasOwnProperty(v) && updaters[v] instanceof Function;
    };
    while (updatetest(get("configversion"))) {
        await updaters[get("configversion")]();
    }
}
/** Read all user configuration from storage API then notify any waiting asynchronous calls

    asynchronous calls generated by getAsync.
    @hidden
 */
async function init() {
    const syncConfig = await browser.storage.sync.get(CONFIGNAME);
    schlepp(syncConfig[CONFIGNAME]);
    // Local storage overrides sync
    const localConfig = await browser.storage.local.get(CONFIGNAME);
    schlepp(localConfig[CONFIGNAME]);
    await update();
    INITIALISED = true;
    for (const waiter of WAITERS) {
        waiter();
    }
}
/** @hidden */
const changeListeners = new Map();
/** @hidden
 * @param name The name of a "toplevel" config setting (i.e. "nmaps", not "nmaps.j")
 * @param listener A function to call when the value of $name is modified in the config. Takes the previous and new value as parameters.
 */
function addChangeListener(name, listener) {
    let arr = changeListeners.get(name);
    if (!arr) {
        arr = [];
        changeListeners.set(name, arr);
    }
    arr.push(listener);
}
/** @hidden
 * Removes event listeners set with addChangeListener
 */
function removeChangeListener(name, listener) {
    const arr = changeListeners.get(name);
    if (!arr)
        return;
    const i = arr.indexOf(listener);
    if (i >= 0)
        arr.splice(i, 1);
}
/** Parse the config into a string representation of a .tridactylrc config file.
    Tries to parse the config into sectionable chunks based on keywords.
    Binds, aliases, autocmds and logging settings each have their own section while the rest are dumped into "General Settings".

    @returns string The parsed config file.

 */
function parseConfig() {
    let p = {
        conf: [],
        binds: [],
        aliases: [],
        subconfigs: [],
        aucmds: [],
        aucons: [],
        logging: [],
    };
    p = parseConfigHelper(USERCONFIG, p);
    const s = {
        general: ``,
        binds: ``,
        aliases: ``,
        aucmds: ``,
        aucons: ``,
        subconfigs: ``,
        logging: ``,
    };
    if (p.conf.length > 0)
        s.general = `" General Settings\n${p.conf.join("\n")}\n\n`;
    if (p.binds.length > 0)
        s.binds = `" Binds\n${p.binds.join("\n")}\n\n`;
    if (p.aliases.length > 0)
        s.aliases = `" Aliases\n${p.aliases.join("\n")}\n\n`;
    if (p.aucmds.length > 0)
        s.aucmds = `" Autocmds\n${p.aucmds.join("\n")}\n\n`;
    if (p.aucons.length > 0)
        s.aucons = `" Autocontainers\n${p.aucons.join("\n")}\n\n`;
    if (p.subconfigs.length > 0)
        s.subconfigs = `" Subconfig Settings\n${p.subconfigs.join("\n")}\n\n`;
    if (p.logging.length > 0)
        s.logging = `" Logging\n${p.logging.join("\n")}\n\n`;
    const ftdetect = `" vim: set filetype=vim:`;
    return `${s.general}${s.binds}${s.subconfigs}${s.aliases}${s.aucmds}${s.aucons}${s.logging}${ftdetect}`;
}
const parseConfigHelper = (pconf, parseobj) => {
    for (const i in pconf) {
        if (typeof pconf[i] !== "object")
            parseobj.conf.push(`set ${i} ${pconf[i]}`);
        else {
            for (const e of Object.keys(pconf[i])) {
                if (i === "nmaps") {
                    if (pconf[i][e].length > 0) {
                        parseobj.binds.push(`bind ${e} ${pconf[i][e]}`);
                    }
                    else {
                        parseobj.binds.push(`unbind ${e}`);
                    }
                }
                else if (i === "exmaps") {
                    if (pconf[i][e].length > 0) {
                        parseobj.binds.push(`bind --mode=ex ${e} ${pconf[i][e]}`);
                    }
                    else {
                        parseobj.binds.push(`unbind --mode=ex ${e}`);
                    }
                }
                else if (i === "ignoremaps") {
                    if (pconf[i][e].length > 0) {
                        parseobj.binds.push(`bind --mode=ignore ${e} ${pconf[i][e]}`);
                    }
                    else {
                        parseobj.binds.push(`unbind --mode=ignore ${e}`);
                    }
                }
                else if (i === "imaps") {
                    if (pconf[i][e].length > 0) {
                        parseobj.binds.push(`bind --mode=insert ${e} ${pconf[i][e]}`);
                    }
                    else {
                        parseobj.binds.push(`unbind --mode=insert ${e}`);
                    }
                }
                else if (i === "inputmaps") {
                    if (pconf[i][e].length > 0) {
                        parseobj.binds.push(`bind --mode=input ${e} ${pconf[i][e]}`);
                    }
                    else {
                        parseobj.binds.push(`unbind --mode=input ${e}`);
                    }
                }
                else if (i === "hintmaps") {
                    if (pconf[i][e].length > 0) {
                        parseobj.binds.push(`bind --mode=hint ${e} ${pconf[i][e]}`);
                    }
                    else {
                        parseobj.binds.push(`unbind --mode=hint ${e}`);
                    }
                }
                else if (i === "subconfigs") {
                    parseobj.subconfigs.push(`js tri.config.set("${i}", {"${e}": ${JSON.stringify(pconf[i][e])}})`);
                }
                else if (i === "exaliases") {
                    // Only really useful if mapping the entire config and not just pconf.
                    if (e === "alias") {
                        parseobj.aliases.push(`command ${e} ${pconf[i][e]}`);
                    }
                    else {
                        parseobj.aliases.push(`alias ${e} ${pconf[i][e]}`);
                    }
                }
                else if (i === "autocmds") {
                    for (const a of Object.keys(pconf[i][e])) {
                        parseobj.aucmds.push(`autocmd ${e} ${a} ${pconf[i][e][a]}`);
                    }
                }
                else if (i === "autocontain") {
                    parseobj.aucons.push(`autocontain ${e} ${pconf[i][e]}`);
                }
                else if (i === "logging") {
                    // Map the int values in e to a log level
                    let level;
                    if (pconf[i][e] === 0)
                        level = "never";
                    if (pconf[i][e] === 1)
                        level = "error";
                    if (pconf[i][e] === 2)
                        level = "warning";
                    if (pconf[i][e] === 3)
                        level = "info";
                    if (pconf[i][e] === 4)
                        level = "debug";
                    parseobj.logging.push(`set logging.${e} ${level}`);
                }
                else {
                    parseobj.conf.push(`js tri.config.set("${i}", {"${e}": ${JSON.stringify(pconf[i][e])}})`);
                }
            }
        }
    }
    return parseobj;
};
// Listen for changes to the storage and update the USERCONFIG if appropriate.
// TODO: BUG! Sync and local storage are merged at startup, but not by this thing.
browser.storage.onChanged.addListener(async (changes, areaname) => {
    if (CONFIGNAME in changes) {
        const defaultConf = new default_config();
        const old = USERCONFIG;
        function triggerChangeListeners(key) {
            const arr = changeListeners.get(key);
            if (arr) {
                const v = old[key] === undefined ? defaultConf[key] : old[key];
                arr.forEach(f => f(v, USERCONFIG[key]));
            }
        }
        // newValue is undefined when calling browser.storage.AREANAME.clear()
        if (changes[CONFIGNAME].newValue !== undefined) {
            // A key has been :unset if it exists in USERCONFIG and doesn't in changes and if its value in USERCONFIG is different from the one it has in default_config
            const unsetKeys = Object.keys(USERCONFIG).filter(k => changes[CONFIGNAME].newValue[k] === undefined &&
                JSON.stringify(USERCONFIG[k]) !==
                    JSON.stringify(defaultConf[k]));
            // A key has changed if it is defined in USERCONFIG and its value in USERCONFIG is different from the one in `changes` or if the value in defaultConf is different from the one in `changes`
            const changedKeys = Object.keys(changes[CONFIGNAME].newValue).filter(k => JSON.stringify(USERCONFIG[k] !== undefined
                ? USERCONFIG[k]
                : defaultConf[k]) !== JSON.stringify(changes[CONFIGNAME].newValue[k]));
            USERCONFIG = changes[CONFIGNAME].newValue;
            // Trigger listeners
            unsetKeys.forEach(key => {
                const arr = changeListeners.get(key);
                if (arr) {
                    arr.forEach(f => f(old[key], defaultConf[key]));
                }
            });
            changedKeys.forEach(key => triggerChangeListeners(key));
        }
        else if (areaname === (await get("storageloc"))) {
            // If newValue is undefined and AREANAME is the same value as STORAGELOC, the user wants to clean their config
            USERCONFIG = o({});
            Object.keys(old)
                .filter(key => old[key] !== defaultConf[key])
                .forEach(key => triggerChangeListeners(key));
        }
    }
});
init();


/***/ }),

/***/ "./src/lib/containers.ts":
/*!*******************************!*\
  !*** ./src/lib/containers.ts ***!
  \*******************************/
/*! exports provided: create, remove, update, getFromId, exists, fromString, getAll, getId, fuzzyMatch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return remove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "update", function() { return update; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFromId", function() { return getFromId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exists", function() { return exists; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromString", function() { return fromString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAll", function() { return getAll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getId", function() { return getId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fuzzyMatch", function() { return fuzzyMatch; });
/* harmony import */ var _src_lib_webext__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/lib/webext */ "./src/lib/webext.ts");
/* harmony import */ var fuse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fuse.js */ "./node_modules/fuse.js/dist/fuse.js");
/* harmony import */ var fuse_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fuse_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _src_lib_logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @src/lib/logging */ "./src/lib/logging.ts");



const logger = new _src_lib_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"]("containers");
// As per Mozilla specification: https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/contextualIdentities/ContextualIdentity
const ContainerColor = [
    "blue",
    "turquoise",
    "green",
    "yellow",
    "orange",
    "red",
    "pink",
    "purple",
];
// As per Mozilla specification: https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/contextualIdentities/ContextualIdentity
const ContainerIcon = [
    "fingerprint",
    "briefcase",
    "dollar",
    "cart",
    "circle",
    "gift",
    "vacation",
    "food",
    "fruit",
    "pet",
    "tree",
    "chill",
];
const DefaultContainer = Object.freeze(fromString("default", "invisible", "noicond", "firefox-default"));
/** Creates a container from the specified parameters.Does not allow multiple containers with the same name.
    @param name  The container name.
    @param color  The container color, must be one of: "blue", "turquoise", "green", "yellow", "orange", "red", "pink" or "purple". If nothing is supplied, it selects one at random.
    @param icon  The container icon, must be one of: "fingerprint", "briefcase", "dollar", "cart", "circle", "gift", "vacation", "food", "fruit", "pet", "tree", "chill"
 */
async function create(name, color = "random", icon = "fingerprint") {
    if (color === "random")
        color = chooseRandomColor();
    const container = fromString(name, color, icon);
    // browser.contextualIdentities.create does not accept a cookieStoreId property.
    delete container.cookieStoreId;
    logger.debug(container);
    if (await exists(name)) {
        logger.debug(`[Container.create] container already exists ${container}`);
        throw new Error(`[Container.create] container already exists, aborting.`);
    }
    else {
        const res = await browser.contextualIdentities.create(container);
        return res.cookieStoreId;
    }
}
/** Removes specified container. No fuzzy matching is intentional here. If there are multiple containers with the same name (allowed by other container plugins), it chooses the one with the lowest cookieStoreId
    @param name The container name
 */
async function remove(name) {
    logger.debug(name);
    const id = await getId(name);
    const res = await browser.contextualIdentities.remove(id);
    logger.debug("[Container.remove] removed container:", res.cookieStoreId);
}
/** Updates the specified container.
    TODO: pass an object to this when tridactyl gets proper flag parsing
    NOTE: while browser.contextualIdentities.create does check for valid color/icon combos, browser.contextualIdentities.update does not.
    @param containerId Expects a cookieStringId e.g. "firefox-container-n".
    @param name the new name of the container
    @param color the new color of the container
    @param icon the new icon of the container
 */
async function update(containerId, updateObj) {
    if (isValidColor(updateObj.color) && isValidIcon(updateObj.icon)) {
        browser.contextualIdentities.update(containerId, updateObj);
    }
    else {
        logger.debug(updateObj);
        throw new Error("[Container.update] invalid container icon or color");
    }
}
/** Gets a container object from a supplied container id string. If no container corresponds to containerId, returns a default empty container.
    @param containerId Expects a cookieStringId e.g. "firefox-container-n"
 */
async function getFromId(containerId) {
    try {
        return await _src_lib_webext__WEBPACK_IMPORTED_MODULE_0__["browserBg"].contextualIdentities.get(containerId);
    }
    catch (e) {
        return DefaultContainer;
    }
}
/** Fetches all containers from Firefox's contextual identities API and checks if one exists with the specified name.
    Note: This operation is entirely case-insensitive.
    @param string cname
    @returns boolean Returns true when cname matches an existing container or on query error.
 */
async function exists(cname) {
    let exists = false;
    try {
        const containers = await getAll();
        const res = containers.filter(c => {
            return c.name.toLowerCase() === cname.toLowerCase();
        });
        if (res.length > 0) {
            exists = true;
        }
    }
    catch (e) {
        exists = true; // Make sure we don't accidentally break the constraint on query error.
        logger.error("[Container.exists] Error querying contextualIdentities:", e);
    }
    return exists;
}
/** Takes string parameters and returns them as a pseudo container object
    for use in other functions in the library.
    @param name
    @param color
    @param icon
 */
function fromString(name, color, icon, id = "") {
    return {
        name,
        color: color,
        icon: icon,
        cookieStoreId: id,
    }; // rules are made to be broken
}
/**
 *  @returns An array representation of all containers.
 */
async function getAll() {
    return browser.contextualIdentities.query({});
}
/** Fetches the cookieStoreId of a given container

 Note: all checks are case insensitive.

 @param name The container name
 @returns The cookieStoreId of the first match of the query.
 */
async function getId(name) {
    try {
        const containers = await getAll();
        const res = containers.filter(c => c.name.toLowerCase() === name.toLowerCase());
        if (res.length !== 1) {
            throw new Error("");
        }
        else {
            return res[0].cookieStoreId;
        }
    }
    catch (e) {
        logger.error("[Container.getId] could not find a container with that name.");
    }
}
/** Tries some simple ways to match containers to your input.
    Fuzzy matching is entirely case-insensitive.
    @param partialName The (partial) name of the container.
 */
async function fuzzyMatch(partialName) {
    const fuseOptions = {
        id: "cookieStoreId",
        shouldSort: true,
        threshold: 0.5,
        location: 0,
        distance: 100,
        mimMatchCharLength: 3,
        keys: ["name"],
    };
    const containers = await getAll();
    const fuse = new fuse_js__WEBPACK_IMPORTED_MODULE_1__(containers, fuseOptions);
    const res = fuse.search(partialName);
    if (res.length >= 1)
        return res[0];
    else {
        throw new Error("[Container.fuzzyMatch] no container matched that string");
    }
}
/** Helper function for create, returns a random valid IdentityColor for use if no color is applied at creation.*/
function chooseRandomColor() {
    const max = Math.floor(ContainerColor.length);
    const n = Math.floor(Math.random() * max);
    return ContainerColor[n];
}
function isValidColor(color) {
    return ContainerColor.indexOf(color) > -1;
}
function isValidIcon(icon) {
    return ContainerIcon.indexOf(icon) > -1;
}


/***/ }),

/***/ "./src/lib/convert.ts":
/*!****************************!*\
  !*** ./src/lib/convert.ts ***!
  \****************************/
/*! exports provided: toBoolean, toNumber */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toBoolean", function() { return toBoolean; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toNumber", function() { return toNumber; });
function toBoolean(s) {
    if (s === "true")
        return true;
    else if (s === "false")
        return false;
    else
        throw "Not a boolean";
}
function toNumber(s) {
    const n = Number(s);
    if (isNaN(n))
        throw "Not a number! " + s;
    else
        return n;
}


/***/ }),

/***/ "./src/lib/css_util.ts":
/*!*****************************!*\
  !*** ./src/lib/css_util.ts ***!
  \*****************************/
/*! exports provided: findCssRules, potentialRules, metaRules, changeSingleCss, changeCss */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findCssRules", function() { return findCssRules; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "potentialRules", function() { return potentialRules; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "metaRules", function() { return metaRules; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "changeSingleCss", function() { return changeSingleCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "changeCss", function() { return changeCss; });
/* harmony import */ var css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! css */ "./node_modules/css/index.js");
/* harmony import */ var css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(css__WEBPACK_IMPORTED_MODULE_0__);
/* tslint:disable:no-string-literal */

// Layout (of bits we care about:
// {stylesheet: {
//          rules: [{
//                      type: "rule", selectors: [string], declarations: [
//                          {type: "declaration", property: string, value: string}
/** Find rules in sheet that match selector */
function findCssRules(selectors, sheet) {
    const filtSheet = [...sheet.stylesheet.rules.entries()].filter(x => {
        const rule = x[1];
        return (rule.type === "rule" &&
            // Make sure that there are as many selectors in the current rule
            // as there are in the rule we're looking for
            rule["selectors"].length === selectors.length &&
            // Also make sure that each of the selectors of the current rule
            // are present in the rule we're looking for
            !rule["selectors"].find(selector => !selectors.includes(selector)));
    });
    return filtSheet.map(x => x[0]);
}
/** Rulename -> { name: <selector>, options: { <option-name>: <css-string> } }
 *
 *  Multi-level map of rulename, options available for rule and css for each option.
 *
 *  *findCssRules and changeSingleCss rely on the selector not containing a comma.*
 *
 *  TODO: make this more flexible with cleverer matching of selectors, merging of options
 *
 */
const potentialRules = {
    statuspanel: {
        name: `#statuspanel`,
        options: {
            none: `display: none !important;`,
            right: `right: 0; display: inline;`,
            left: ``,
            "top-left": `top: 2em; z-index: 2; display: inline;`,
            "top-right": `top: 2em; z-index: 2; right: 0; display: inline;`,
        },
    },
    hoverlink: {
        name: `statuspanel[type="overLink"], #statuspanel[type="overLink"]`,
        options: {
            none: `display: none !important;`,
            right: `right: 0; display: inline;`,
            left: ``,
            "top-left": `top: 2em; z-index: 2; display: inline;`,
            "top-right": `top: 2em; z-index: 2; right: 0; display: inline;`,
        },
    },
    tabstoolbar: {
        name: `#TabsToolbar`,
        options: {
            none: `visibility: collapse;`,
            show: ``,
        },
    },
    tabstoolbarunfocused: {
        name: `:root:not([customizing]) #navigator-toolbox:not(:hover):not(:focus-within) #TabsToolbar`,
        options: {
            hide: `visibility: collapse;`,
            show: ``,
        },
    },
    tabcounter: {
        name: `tabs`,
        options: {
            off: ``,
            on: `counter-reset: tab-counter;`,
        },
    },
    tabcounters: {
        name: `.tab-label::before`,
        options: {
            hide: ``,
            show: ` counter-increment: tab-counter;
                    content: counter(tab-counter) " - ";`,
        },
    },
    navtoolboxunfocused: {
        name: `:root:not([customizing]) #navigator-toolbox:not(:hover):not(:focus-within)`,
        options: {
            hide: `max-height: 1px; min-height: calc(0px); overflow: hidden;`,
            show: ``,
        },
    },
    navbarunfocused: {
        name: `:root:not([customizing]) #navigator-toolbox:not(:hover):not(:focus-within) #nav-bar`,
        // tridactyl auto show zone doesn't seem to make a difference
        options: {
            hide: `max-height: 0;
                    min-height: 0!important;
                    --tridactyl-auto-show-zone: 10px;
                    margin-bottom: calc(-1 * var(--tridactyl-auto-show-zone));
                    opacity: 0;`,
            show: ``,
        },
    },
    // Annoying black line at top in fullscreen
    navbarafter: {
        name: `#navigator-toolbox::after`,
        options: {
            hide: `display: none !important;`,
            show: ``,
        },
    },
    // All children except add-on panels
    navbarnonaddonchildren: {
        name: `:root:not([customizing]) #nav-bar > :not(#customizationui-widget-panel)`,
        options: {
            hide: `display: none !important;`,
            show: ``,
        },
    },
    // Set navbar height to 0
    navbarnoheight: {
        name: `:root:not([customizing]) #nav-bar`,
        options: {
            hide: ``,
            show: `max-height: 0; min-height: 0 !important;`,
        },
    },
    // This inherits transparency if we aren't careful
    menubar: {
        name: `#navigator-toolbox:not(:hover):not(:focus-within) #toolbar-menubar > *`,
        options: {
            grey: `background-color: rgb(232, 232, 231);`,
            default: ``,
        },
    },
    // Window dectorations
    titlebar: {
        name: `#titlebar`,
        options: {
            hide: `display: none !important;`,
            show: ``,
        },
    },
    padwhenmaximised: {
        name: `#main-window[sizemode="maximized"] #content-deck`,
        options: {
            some: `padding-top: 8px;`,
            none: ``,
        },
    },
};
//  Vimperator's options for reference:
//  <tags>'go' 'guioptions'</tags>
//  <spec>'guioptions' 'go'</spec>
//
//  m          Menubar
//  T          Toolbar
//  B          Bookmark bar
//  A          Add-on bar
//  n          Tab number
//  b          Bottom scrollbar
//  r          Right scrollbar
//  l          Left scrollbar
//
//  was just a simple show/hide if the characters appeared in the setting
/** Rules that index into potentialRules or metaRules
 *
 *  Please don't add cycles to this table :)
 */
const metaRules = {
    gui: {
        none: {
            hoverlink: "none",
            tabs: "none",
            navbar: "autohide",
            menubar: "grey",
            padwhenmaximised: "some",
        },
        full: {
            hoverlink: "left",
            tabs: "always",
            navbar: "always",
            menubar: "default",
            padwhenmaximised: "none",
        },
    },
    tabs: {
        none: {
            tabstoolbar: "none",
            navtoolboxunfocused: "hide",
        },
        always: {
            tabstoolbar: "show",
            tabstoolbarunfocused: "show",
            navtoolboxunfocused: "show",
        },
        autohide: {
            tabstoolbar: "show",
            tabstoolbarunfocused: "hide",
            navtoolboxunfocused: "hide",
        },
        count: {
            tabcounter: "on",
            tabcounters: "show",
        },
        nocount: {
            tabcounter: "off",
            tabcounters: "hide",
        },
    },
    navbar: {
        autohide: {
            navbarunfocused: "hide",
            navtoolboxunfocused: "hide",
            navbarafter: "hide",
            navbarnonaddonchildren: "show",
            navbarnoheight: "hide",
        },
        always: {
            navbarunfocused: "show",
            navtoolboxunfocused: "show",
            navbarafter: "show",
            navbarnonaddonchildren: "show",
            navbarnoheight: "hide",
        },
        none: {
            navbarunfocused: "show",
            navtoolboxunfocused: "show",
            navbarafter: "hide",
            navbarnonaddonchildren: "hide",
            navbarnoheight: "show",
        },
    },
};
/** Add desired non-meta rule to stylesheet replacing existing rule with the same selector if present */
function changeSingleCss(rulename, optionname, sheet) {
    const selector = potentialRules[rulename]["name"];
    const newRule = `${selector} {
        ${potentialRules[rulename]["options"][optionname]}
    }`;
    const miniSheet = css__WEBPACK_IMPORTED_MODULE_0__["parse"](newRule).stylesheet.rules[0];
    // Find pre-existing rules
    const oldRuleIndexes = findCssRules(miniSheet["selectors"], sheet);
    if (oldRuleIndexes.length > 0) {
        sheet.stylesheet.rules[oldRuleIndexes[0]] = miniSheet;
    }
    else {
        sheet.stylesheet.rules = sheet.stylesheet.rules.concat(miniSheet);
    }
    return sheet;
}
/** Apply rule to stylesheet. rulename, optionname identify a rule. They may be meta rules */
function changeCss(rulename, optionname, sheet) {
    if (rulename in metaRules) {
        const metarule = metaRules[rulename][optionname];
        for (const rule of Object.keys(metarule)) {
            // have a metarule call itself for hours of fun
            sheet = changeCss(rule, metarule[rule], sheet);
        }
    }
    else
        sheet = changeSingleCss(rulename, optionname, sheet);
    return sheet;
}


/***/ }),

/***/ "./src/lib/editor.ts":
/*!***************************!*\
  !*** ./src/lib/editor.ts ***!
  \***************************/
/*! exports provided: delete_char, delete_backward_char, tab_insert, transpose_chars, transpose_words, upcase_word, downcase_word, capitalize_word, kill_line, backward_kill_line, kill_whole_line, kill_word, backward_kill_word, beginning_of_line, end_of_line, forward_char, backward_char, forward_word, backward_word, insert_text, rot13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "delete_char", function() { return delete_char; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "delete_backward_char", function() { return delete_backward_char; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tab_insert", function() { return tab_insert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose_chars", function() { return transpose_chars; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose_words", function() { return transpose_words; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "upcase_word", function() { return upcase_word; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "downcase_word", function() { return downcase_word; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "capitalize_word", function() { return capitalize_word; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "kill_line", function() { return kill_line; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backward_kill_line", function() { return backward_kill_line; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "kill_whole_line", function() { return kill_whole_line; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "kill_word", function() { return kill_word; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backward_kill_word", function() { return backward_kill_word; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "beginning_of_line", function() { return beginning_of_line; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "end_of_line", function() { return end_of_line; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward_char", function() { return forward_char; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backward_char", function() { return backward_char; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward_word", function() { return forward_word; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backward_word", function() { return backward_word; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insert_text", function() { return insert_text; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rot13", function() { return rot13; });
/* harmony import */ var _src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/lib/editor_utils */ "./src/lib/editor_utils.ts");
/** # Editor Functions
 *
 * This file contains functions to manipulate the content of textareas/input fields/contenteditable elements.
 *
 * If you want to bind them to keyboard shortcuts, be sure to prefix them with "text.". For example, if you want to bind control-a to `beginning_of_line` in all modes, use:
 *
 * ```
 * bind --mode=ex <C-a> text.beginning_of_line
 * bind --mode=input <C-a> text.beginning_of_line
 * bind --mode=insert <C-a> text.begining_of_line
 * ```
 *
 * Also keep in mind that if you want to bind something in insert mode, you'll probably also want to bind it in input mode (insert mode is entered by clicking on text areas while input mode is entered by using `gi`).
 *
 * If you're looking for command-line only functions, go [there](/static/docs/modules/_src_commandline_frame_.html).
 *
 * Contrary to the main tridactyl help page, this one doesn't tell you whether a specific function is bound to something. For now, you'll have to make do with with `:bind` and `:viewconfig`.
 *
 */
/** ignore this line */

/**
 * Behaves like readline's [delete_char](http://web.mit.edu/gnu/doc/html/rlman_1.html#SEC14), i.e. deletes the character to the right of the caret.
 **/
const delete_char = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["wrap_input"])(Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["needs_text"])((text, selectionStart, selectionEnd) => {
    if (selectionStart !== selectionEnd) {
        // If the user selected text, then we need to delete that instead of a single char
        text =
            text.substring(0, selectionStart) + text.substring(selectionEnd);
    }
    else {
        text =
            text.substring(0, selectionStart) +
                text.substring(selectionStart + 1);
    }
    return [text, selectionStart, null];
}));
/**
 * Behaves like readline's [delete_backward_char](http://web.mit.edu/gnu/doc/html/rlman_1.html#SEC14), i.e. deletes the character to the left of the caret.
 **/
const delete_backward_char = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["wrap_input"])(Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["needs_text"])((text, selectionStart, selectionEnd) => {
    if (selectionStart !== selectionEnd) {
        text =
            text.substring(0, selectionStart) + text.substring(selectionEnd);
    }
    else {
        text =
            text.substring(0, selectionStart - 1) +
                text.substring(selectionStart);
    }
    selectionStart -= 1;
    return [text, selectionStart, null];
}));
/**
 * Behaves like readline's [tab_insert](http://web.mit.edu/gnu/doc/html/rlman_1.html#SEC14), i.e. inserts a tab character to the left of the caret.
 **/
const tab_insert = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["wrap_input"])((text, selectionStart, selectionEnd) => {
    if (selectionStart !== selectionEnd) {
        text =
            text.substring(0, selectionStart) +
                "\t" +
                text.substring(selectionEnd);
    }
    else {
        text =
            text.substring(0, selectionStart) +
                "\t" +
                text.substring(selectionStart);
    }
    selectionStart += 1;
    return [text, selectionStart, null];
});
/**
 * Behaves like readline's [transpose_chars](http://web.mit.edu/gnu/doc/html/rlman_1.html#SEC14), i.e. transposes the character to the left of the caret with the character to the right of the caret and then moves the caret one character to the right. If there are no characters to the right or to the left of the caret, uses the two characters the closest to the caret.
 **/
const transpose_chars = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["wrap_input"])((text, selectionStart, selectionEnd) => {
    if (text.length < 2)
        return [null, null, null];
    // When at the beginning of the text, transpose the first and second characters
    if (selectionStart === 0)
        selectionStart = 1;
    // When at the end of the text, transpose the last and second-to-last characters
    if (selectionStart >= text.length)
        selectionStart = text.length - 1;
    text =
        text.substring(0, selectionStart - 1) +
            text.substring(selectionStart, selectionStart + 1) +
            text.substring(selectionStart - 1, selectionStart) +
            text.substring(selectionStart + 1);
    selectionStart += 1;
    return [text, selectionStart, null];
});
/** @hidden
 * Applies a function to the word the caret is in, or to the next word if the caret is not in a word, or to the previous word if the current word is empty.
 */
function applyWord(text, selectionStart, selectionEnd, fn) {
    if (text.length === 0)
        return [null, null, null];
    // If the caret is at the end of the text, move it just before the last character
    if (selectionStart >= text.length) {
        selectionStart = text.length - 1;
    }
    const boundaries = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["getWordBoundaries"])(text, selectionStart, false);
    const beginning = text.substring(0, boundaries[0]) +
        fn(text.substring(boundaries[0], boundaries[1]));
    text = beginning + text.substring(boundaries[1]);
    selectionStart = beginning.length + 1;
    return [text, selectionStart, null];
}
/**
 * Behaves like readline's [transpose_words](http://web.mit.edu/gnu/doc/html/rlman_1.html#SEC14). Basically equivalent to [[im_transpose_chars]], but using words as defined by the wordpattern setting.
 **/
const transpose_words = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["wrap_input"])(Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["needs_text"])((text, selectionStart, selectionEnd) => {
    if (selectionStart >= text.length) {
        selectionStart = text.length - 1;
    }
    // Find the word the caret is in
    let firstBoundaries = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["getWordBoundaries"])(text, selectionStart, false);
    let secondBoundaries = firstBoundaries;
    // If there is a word after the word the caret is in, use it for the transselectionStartition, otherwise use the word before it
    const nextWord = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["wordAfterPos"])(text, firstBoundaries[1]);
    if (nextWord > -1) {
        secondBoundaries = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["getWordBoundaries"])(text, nextWord, false);
    }
    else {
        firstBoundaries = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["getWordBoundaries"])(text, firstBoundaries[0] - 1, true);
    }
    const firstWord = text.substring(firstBoundaries[0], firstBoundaries[1]);
    const secondWord = text.substring(secondBoundaries[0], secondBoundaries[1]);
    const beginning = text.substring(0, firstBoundaries[0]) +
        secondWord +
        text.substring(firstBoundaries[1], secondBoundaries[0]);
    selectionStart = beginning.length;
    return [
        beginning + firstWord + text.substring(secondBoundaries[1]),
        selectionStart,
        null,
    ];
}));
/**
 * Behaves like readline's [upcase_word](http://web.mit.edu/gnu/doc/html/rlman_1.html#SEC14). Makes the word the caret is in uppercase.
 **/
const upcase_word = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["wrap_input"])(Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["needs_text"])((text, selectionStart, selectionEnd) => {
    return applyWord(text, selectionStart, selectionEnd, word => word.toUpperCase());
}));
/**
 * Behaves like readline's [downcase_word](http://web.mit.edu/gnu/doc/html/rlman_1.html#SEC14). Makes the word the caret is in lowercase.
 **/
const downcase_word = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["wrap_input"])(Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["needs_text"])((text, selectionStart, selectionEnd) => {
    return applyWord(text, selectionStart, selectionEnd, word => word.toLowerCase());
}));
/**
 * Behaves like readline's [capitalize_word](http://web.mit.edu/gnu/doc/html/rlman_1.html#SEC14). Makes the initial character of the word the caret is in uppercase.
 **/
const capitalize_word = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["wrap_input"])(Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["needs_text"])((text, selectionStart, selectionEnd) => {
    return applyWord(text, selectionStart, selectionEnd, word => word[0].toUpperCase() + word.substring(1));
}));
/**
 * Behaves like readline's [kill_line](http://web.mit.edu/gnu/doc/html/rlman_1.html#SEC15), i.e. deletes every character to the right of the caret until reaching either the end of the text or the newline character (\n).
 **/
const kill_line = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["wrap_input"])(Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["needs_text"])((text, selectionStart, selectionEnd) => {
    let newLine = text.substring(selectionStart).search("\n");
    if (newLine !== -1) {
        // If the caret is right before the newline, kill the newline
        if (newLine === 0)
            newLine = 1;
        text =
            text.substring(0, selectionStart) +
                text.substring(selectionStart + newLine);
    }
    else {
        text = text.substring(0, selectionStart);
    }
    return [text, selectionStart, null];
}));
/**
 * Behaves like readline's [backward_kill_line](http://web.mit.edu/gnu/doc/html/rlman_1.html#SEC15), i.e. deletes every character to the left of the caret until either the beginning of the text is found or a newline character ("\n") is reached.
 **/
const backward_kill_line = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["wrap_input"])(Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["needs_text"])((text, selectionStart, selectionEnd) => {
    // If the caret is at the beginning of a line, join the lines
    if (selectionStart > 0 && text[selectionStart - 1] === "\n") {
        return [
            text.substring(0, selectionStart - 1) +
                text.substring(selectionStart),
            selectionStart,
            null,
        ];
    }
    let newLine;
    // Find the closest newline
    for (newLine = selectionStart; newLine > 0 && text[newLine - 1] !== "\n"; --newLine)
        ;
    // Remove everything between the newline and the caret
    return [
        text.substring(0, newLine) + text.substring(selectionStart),
        newLine,
        null,
    ];
}));
/**
 * Behaves like readline's [kill_whole_line](http://web.mit.edu/gnu/doc/html/rlman_1.html#SEC15). Deletes every character between the two newlines the caret is in. If a newline can't be found on the left of the caret, everything is deleted until the beginning of the text is reached. If a newline can't be found on the right, everything is deleted until the end of the text is found.
 **/
const kill_whole_line = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["wrap_input"])(Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["needs_text"])((text, selectionStart, selectionEnd) => {
    let firstNewLine;
    let secondNewLine;
    // Find the newline before the caret
    for (firstNewLine = selectionStart; firstNewLine > 0 && text[firstNewLine - 1] !== "\n"; --firstNewLine)
        ;
    // Find the newline after the caret
    for (secondNewLine = selectionStart; secondNewLine < text.length && text[secondNewLine - 1] !== "\n"; ++secondNewLine)
        ;
    // Remove everything between the newline and the caret
    return [
        text.substring(0, firstNewLine) + text.substring(secondNewLine),
        firstNewLine,
        null,
    ];
}));
/**
 * Behaves like readline's [kill_word](http://web.mit.edu/gnu/doc/html/rlman_1.html#SEC15). Deletes every character from the caret to the end of a word, with words being defined by the wordpattern setting.
 **/
const kill_word = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["wrap_input"])(Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["needs_text"])((text, selectionStart, selectionEnd) => {
    const boundaries = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["getWordBoundaries"])(text, selectionStart, false);
    if (selectionStart > boundaries[0] && selectionStart < boundaries[1])
        boundaries[0] = selectionStart;
    // Remove everything between the newline and the caret
    return [
        text.substring(0, boundaries[0]) +
            text.substring(boundaries[1] + 1),
        boundaries[0],
        null,
    ];
}));
/**
 * Behaves like readline's [backward_kill_word](http://web.mit.edu/gnu/doc/html/rlman_1.html#SEC15). Deletes every character from the caret to the beginning of a word with word being defined by the wordpattern setting.
 **/
const backward_kill_word = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["wrap_input"])(Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["needs_text"])((text, selectionStart, selectionEnd) => {
    const boundaries = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["getWordBoundaries"])(text, selectionStart, true);
    if (selectionStart > boundaries[0] && selectionStart < boundaries[1])
        boundaries[1] = selectionStart;
    // Remove everything between the newline and the caret
    return [
        text.substring(0, boundaries[0]) + text.substring(boundaries[1]),
        boundaries[0],
        null,
    ];
}));
/**
 * Behaves like readline's [beginning_of_line](http://web.mit.edu/gnu/doc/html/rlman_1.html#SEC12). Moves the caret to the right of the first newline character found at the left of the caret. If no newline can be found, move the caret to the beginning of the text.
 **/
const beginning_of_line = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["wrap_input"])(Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["needs_text"])((text, selectionStart, selectionEnd) => {
    while (text[selectionStart - 1] !== undefined &&
        text[selectionStart - 1] !== "\n")
        selectionStart -= 1;
    return [null, selectionStart, null];
}));
/**
 * Behaves like readline's [end_of_line](http://web.mit.edu/gnu/doc/html/rlman_1.html#SEC12). Moves the caret to the left of the first newline character found at the right of the caret. If no newline can be found, move the caret to the end of the text.
 **/
const end_of_line = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["wrap_input"])(Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["needs_text"])((text, selectionStart, selectionEnd) => {
    while (text[selectionStart] !== undefined &&
        text[selectionStart] !== "\n")
        selectionStart += 1;
    return [null, selectionStart, null];
}));
/**
 * Behaves like readline's [forward_char](http://web.mit.edu/gnu/doc/html/rlman_1.html#SEC12). Moves the caret one character to the right.
 **/
const forward_char = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["wrap_input"])((text, selectionStart, selectionEnd) => {
    return [null, selectionStart + 1, null];
});
/**
 * Behaves like readline's [backward_char](http://web.mit.edu/gnu/doc/html/rlman_1.html#SEC12). Moves the caret one character to the left.
 **/
const backward_char = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["wrap_input"])((text, selectionStart, selectionEnd) => {
    return [null, selectionStart - 1, null];
});
/**
 * Behaves like readline's [forward_word](http://web.mit.edu/gnu/doc/html/rlman_1.html#SEC12). Moves the caret one word to the right, with words being defined by the wordpattern setting.
 **/
const forward_word = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["wrap_input"])(Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["needs_text"])((text, selectionStart, selectionEnd) => {
    let boundaries = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["getWordBoundaries"])(text, selectionStart, false);
    if (selectionStart >= boundaries[0] && selectionStart < boundaries[1])
        boundaries = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["getWordBoundaries"])(text, boundaries[1], false);
    return [null, boundaries[0], null];
}));
/**
 * Behaves like readline's [backward_word](http://web.mit.edu/gnu/doc/html/rlman_1.html#SEC12). Moves the caret one word to the right, with words being defined by the wordpattern setting.
 **/
const backward_word = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["wrap_input"])((text, selectionStart, selectionEnd) => {
    if (selectionStart === 0)
        return [null, null, null];
    let boundaries = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["getWordBoundaries"])(text, selectionStart, true);
    if (selectionStart >= boundaries[0] && selectionStart < boundaries[1])
        boundaries = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["getWordBoundaries"])(text, boundaries[0] - 1, true);
    return [null, boundaries[0], null];
});
/**
 * Insert text in the current input.
 **/
const insert_text = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["wrap_input"])((text, selectionStart, selectionEnd, arg) => {
    return [
        text.slice(0, selectionStart) + arg + text.slice(selectionEnd),
        selectionStart + arg.length,
        null,
    ];
});
const rot13 = Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["wrap_input"])((text, selectionStart, selectionEnd) => {
    return [
        Object(_src_lib_editor_utils__WEBPACK_IMPORTED_MODULE_0__["rot13_helper"])(text.slice(0, selectionStart) + text.slice(selectionEnd)),
        selectionStart,
        null,
    ];
});


/***/ }),

/***/ "./src/lib/editor_utils.ts":
/*!*********************************!*\
  !*** ./src/lib/editor_utils.ts ***!
  \*********************************/
/*! exports provided: applyToElem, getSimpleValues, getContentEditableValues, setSimpleValues, setContentEditableValues, wrap_input, needs_text, getLineAndColNumber, getWordBoundaries, wordAfterPos, rot13_helper, charesar */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyToElem", function() { return applyToElem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSimpleValues", function() { return getSimpleValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getContentEditableValues", function() { return getContentEditableValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setSimpleValues", function() { return setSimpleValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setContentEditableValues", function() { return setContentEditableValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrap_input", function() { return wrap_input; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "needs_text", function() { return needs_text; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLineAndColNumber", function() { return getLineAndColNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getWordBoundaries", function() { return getWordBoundaries; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wordAfterPos", function() { return wordAfterPos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rot13_helper", function() { return rot13_helper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "charesar", function() { return charesar; });
/* harmony import */ var _src_lib_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/lib/config */ "./src/lib/config.ts");
// We have a single dependency on config: getting the value of the WORDPATTERN setting
// Perhaps we could find a way to get rid of it?

/**
 * Applies a function to an element. If the element is an HTMLInputElement and its type isn't "text", it is first turned into a "text" element. This is necessary because some elements (e.g. "email") do not have a selectionStart/selectionEnd.
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/setSelectionRange .
 **/
function applyToElem(e, fn) {
    let result;
    if (e instanceof HTMLInputElement && e.type !== "text") {
        const t = e.type;
        e.type = "text";
        result = fn(e);
        e.type = t;
    }
    else {
        result = fn(e);
    }
    return result;
}
/**
 * Returns values necessary for editor functions to work on textarea/input elements
 *
 * @param e the element
 * @return [string, number, number] The content of the element, the position of the caret, the position of the end of the visual selection
 */
function getSimpleValues(e) {
    return applyToElem(e, e => [e.value, e.selectionStart, e.selectionEnd]);
}
/**
 * Returns values necessary for editor functions to work on contentEditable elements
 *
 * @param e a contentEditable element
 * @return [string, number, number] The content of the element, the position of the caret, the position of the end of the visual selection
 */
function getContentEditableValues(e) {
    const selection = e.ownerDocument.getSelection();
    // The selection might actually not be in e so we need to make sure it is
    let n = selection.anchorNode;
    while (n && n !== e)
        n = n.parentNode;
    // The selection isn't for e, so we can't do anything
    if (!n)
        return [null, null, null];
    // selection might span multiple elements, might not start with the first element in e or end with the last element in e so the easiest way to compute caret position from beginning of e is to first compute distance from caret to end of e, then move beginning of selection to beginning of e and then use distance from end of selection to compute distance from beginning of selection
    const r = selection.getRangeAt(0).cloneRange();
    const selectionLength = r.toString().length;
    r.setEnd(e, e.childNodes.length);
    const lengthFromCaretToEndOfText = r.toString().length;
    r.setStart(e, 0);
    const s = r.toString();
    const caretPos = s.length - lengthFromCaretToEndOfText;
    return [s, caretPos, caretPos + selectionLength];
}
/**
 * Change text in regular textarea/input fields. Note: this destroys the field's history (i.e. C-z won't work).
 *
 * @param e The element
 * @param text The new content of the element, null if it shouldn't change
 * @param start The new position of the caret, null if the caret shouldn't move
 * @param end The end of the visual selection, null if you just want to move the caret
 */
function setSimpleValues(e, text, start, end) {
    return applyToElem(e, e => {
        if (text !== null)
            e.value = text;
        if (start !== null) {
            if (end === null)
                end = start;
            e.selectionStart = start;
            e.selectionEnd = end;
        }
    });
}
/**
 * Change text in contentEditable elements in a non-destructive way (i.e. C-z will undo changes).
 * @param e The content editable element
 * @param text The new content the element should have. null if you just want to move the caret around
 * @param start The new caret position. null if you just want to change text.
 * @param end The end of the visual selection. null if you just want to move the caret.
 */
function setContentEditableValues(e, text, start, end) {
    const selection = e.ownerDocument.getSelection();
    if (selection.rangeCount < 1) {
        const r = new Range();
        r.setStart(e, 0);
        r.setEnd(e, e.childNodes.length);
        selection.addRange(r);
    }
    if (text !== null) {
        const range = selection.getRangeAt(0);
        const anchorNode = selection.anchorNode;
        const focusNode = selection.focusNode;
        range.setStart(anchorNode, 0);
        range.setEndAfter(focusNode, focusNode.length);
        e.ownerDocument.execCommand("insertText", false, text);
    }
    if (start !== null) {
        if (end === null)
            end = start;
        let range = selection.getRangeAt(0);
        range.setStart(range.startContainer, start);
        range = selection.getRangeAt(0);
        range.setEnd(range.startContainer, end);
    }
}
/**
 * Take an editor function as parameter and return it wrapped in a function that will handle grabbing text and caret position from the HTML element it takes as parameter
 *
 * @param editor_function A function that takes a [string, selectionStart, selectionEnd] tuple as argument and returns a [string, selectionStart, selectionEnd] tuple corresponding to the new state of the text.
 *
 * @return boolean Whether the editor function was actually called or not
 *
 **/
function wrap_input(fn) {
    return (e, arg) => {
        let getValues = getSimpleValues;
        let setValues = setSimpleValues;
        if (e.isContentEditable) {
            getValues = getContentEditableValues;
            setValues = setContentEditableValues;
        }
        const [origText, origStart, origEnd] = getValues(e);
        if (origText === null || origStart === null)
            return false;
        setValues(e, ...fn(origText, origStart, origEnd, arg));
        return true;
    };
}
/**
 * Take an editor function as parameter and wrap it in a function that will handle error conditions
 */
function needs_text(fn, arg) {
    return (text, selectionStart, selectionEnd, arg) => {
        if (text.length === 0 ||
            selectionStart === null ||
            selectionStart === undefined)
            return [null, null, null];
        return fn(text, selectionStart, typeof selectionEnd === "number" ? selectionEnd : selectionStart, arg);
    };
}
/**
 * Returns line and column number.
 */
function getLineAndColNumber(text, start, end) {
    const lines = text.split("\n");
    let totalChars = 0;
    for (let i = 0; i < lines.length; ++i) {
        // +1 because we also need to take '\n' into account
        if (totalChars + lines[i].length + 1 > start) {
            return [text, i + 1, start - totalChars];
        }
        totalChars += lines[i].length + 1;
    }
    return [text, lines.length, 1];
}
/**
 * Detects the boundaries of a word in text according to the wordpattern setting. If POSITION is in a word, the boundaries of this word are returned. If POSITION is out of a word and BEFORE is true, the word before POSITION is returned. If BEFORE is false, the word after the caret is returned.
 */
function getWordBoundaries(text, position, before) {
    if (position < 0 || position > text.length)
        throw new Error(`getWordBoundaries: position (${position}) should be within text ("${text}") boundaries (0, ${text.length})`);
    const pattern = new RegExp(_src_lib_config__WEBPACK_IMPORTED_MODULE_0__["get"]("wordpattern"), "g");
    let boundary1 = position < text.length ? position : text.length - 1;
    const direction = before ? -1 : 1;
    // if the caret is not in a word, try to find the word before or after it
    while (boundary1 >= 0 &&
        boundary1 < text.length &&
        !text[boundary1].match(pattern)) {
        boundary1 += direction;
    }
    if (boundary1 < 0)
        boundary1 = 0;
    else if (boundary1 >= text.length)
        boundary1 = text.length - 1;
    // if a word couldn't be found in this direction, try the other one
    while (boundary1 >= 0 &&
        boundary1 < text.length &&
        !text[boundary1].match(pattern)) {
        boundary1 -= direction;
    }
    if (boundary1 < 0)
        boundary1 = 0;
    else if (boundary1 >= text.length)
        boundary1 = text.length - 1;
    if (!text[boundary1].match(pattern)) {
        // there is no word in text
        throw new Error(`getWordBoundaries: no characters matching wordpattern (${pattern.source}) in text (${text})`);
    }
    // now that we know the caret is in a word (it could be in the middle depending on POSITION!), try to find its beginning/end
    while (boundary1 >= 0 &&
        boundary1 < text.length &&
        !!text[boundary1].match(pattern)) {
        boundary1 += direction;
    }
    // boundary1 is now outside of the word, bring it back inside of it
    boundary1 -= direction;
    let boundary2 = boundary1;
    // now that we know the caret is at the beginning/end of a word, we need to find the other boundary
    while (boundary2 >= 0 &&
        boundary2 < text.length &&
        !!text[boundary2].match(pattern)) {
        boundary2 -= direction;
    }
    // boundary2 is outside of the word, bring it back in
    boundary2 += direction;
    // Add 1 to the end boundary because the end of a word is marked by the character after said word
    if (boundary1 > boundary2)
        return [boundary2, boundary1 + 1];
    return [boundary1, boundary2 + 1];
}
/** @hidden
 * Finds the next word as defined by the wordpattern setting after POSITION. If POSITION is in a word, POSITION is moved forward until it is out of the word.
 * @return number The position of the next word in text or -1 if the next word can't be found.
 */
function wordAfterPos(text, position) {
    if (position < 0)
        throw new Error(`wordAfterPos: position (${position}) is less that 0`);
    const pattern = new RegExp(_src_lib_config__WEBPACK_IMPORTED_MODULE_0__["get"]("wordpattern"), "g");
    // move position out of the current word
    while (position < text.length && !!text[position].match(pattern))
        position += 1;
    // try to find characters that match wordpattern
    while (position < text.length && !text[position].match(pattern))
        position += 1;
    if (position >= text.length)
        return -1;
    return position;
}
/** @hidden
 * Rots by 13.
 */
const rot13_helper = (s, n = 13) => {
    let sa = s.split("");
    sa = sa.map(x => charesar(x, n));
    return sa.join("");
};
const charesar = (c, n = 13) => {
    const cn = c.charCodeAt(0);
    if (cn >= 65 && cn <= 90)
        return String.fromCharCode((((cn - 65) + n) % 26) + 65);
    if (cn >= 97 && cn <= 122)
        return String.fromCharCode((((cn - 97) + n) % 26) + 97);
    return c;
};


/***/ }),

/***/ "./src/lib/html-tagged-template.js":
/*!*****************************************!*\
  !*** ./src/lib/html-tagged-template.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

;(function(window) {
    "use strict"

    // test for es6 support of needed functionality
    try {
        // spread operator and template strings support
        ;(function testSpreadOpAndTemplate() {
            const tag = function tag(strings, ...values) {
                return
            }
            tag`test`
        })()

        // template tag and Array.from support
        if (
            !(
                "content" in document.createElement("template") &&
                "from" in Array
            )
        ) {
            throw new Error()
        }
    } catch (e) {
        // missing support;
        console.log(
            "Your browser does not support the needed functionality to use the html tagged template",
        )
        return
    }

    if (typeof window.html === "undefined") {
        // --------------------------------------------------
        // constants
        // --------------------------------------------------

        const SUBSTITUTION_INDEX = "substitutionindex:" // tag names are always all lowercase
        const SUBSTITUTION_REGEX = new RegExp(
            SUBSTITUTION_INDEX + "([0-9]+):",
            "g",
        )

        // rejection string is used to replace xss attacks that cannot be escaped either
        // because the escaped string is still executable
        // (e.g. setTimeout(/* escaped string */)) or because it produces invalid results
        // (e.g. <h${xss}> where xss='><script>alert(1337)</script')
        // @see https://developers.google.com/closure/templates/docs/security#in_tags_and_attrs
        const REJECTION_STRING = "zXssPreventedz"

        // which characters should be encoded in which contexts
        const ENCODINGS = {
            attribute: {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
            },
            uri: {
                "&": "&amp;",
            },
        }

        // which attributes are DOM Level 0 events
        // taken from https://en.wikipedia.org/wiki/DOM_events#DOM_Level_0
        const DOM_EVENTS = [
            "onclick",
            "ondblclick",
            "onmousedown",
            "onmouseup",
            "onmouseover",
            "onmousemove",
            "onmouseout",
            "ondragstart",
            "ondrag",
            "ondragenter",
            "ondragleave",
            "ondragover",
            "ondrop",
            "ondragend",
            "onkeydown",
            "onkeypress",
            "onkeyup",
            "onload",
            "onunload",
            "onabort",
            "onerror",
            "onresize",
            "onscroll",
            "onselect",
            "onchange",
            "onsubmit",
            "onreset",
            "onfocus",
            "onblur",
            "onpointerdown",
            "onpointerup",
            "onpointercancel",
            "onpointermove",
            "onpointerover",
            "onpointerout",
            "onpointerenter",
            "onpointerleave",
            "ongotpointercapture",
            "onlostpointercapture",
            "oncut",
            "oncopy",
            "onpaste",
            "onbeforecut",
            "onbeforecopy",
            "onbeforepaste",
            "onafterupdate",
            "onbeforeupdate",
            "oncellchange",
            "ondataavailable",
            "ondatasetchanged",
            "ondatasetcomplete",
            "onerrorupdate",
            "onrowenter",
            "onrowexit",
            "onrowsdelete",
            "onrowinserted",
            "oncontextmenu",
            "ondrag",
            "ondragstart",
            "ondragenter",
            "ondragover",
            "ondragleave",
            "ondragend",
            "ondrop",
            "onselectstart",
            "help",
            "onbeforeunload",
            "onstop",
            "beforeeditfocus",
            "onstart",
            "onfinish",
            "onbounce",
            "onbeforeprint",
            "onafterprint",
            "onpropertychange",
            "onfilterchange",
            "onreadystatechange",
            "onlosecapture",
            "DOMMouseScroll",
            "ondragdrop",
            "ondragenter",
            "ondragexit",
            "ondraggesture",
            "ondragover",
            "onclose",
            "oncommand",
            "oninput",
            "DOMMenuItemActive",
            "DOMMenuItemInactive",
            "oncontextmenu",
            "onoverflow",
            "onoverflowchanged",
            "onunderflow",
            "onpopuphidden",
            "onpopuphiding",
            "onpopupshowing",
            "onpopupshown",
            "onbroadcast",
            "oncommandupdate",
        ]

        // which attributes take URIs
        // taken from https://www.w3.org/TR/html4/index/attributes.html
        const URI_ATTRIBUTES = [
            "action",
            "background",
            "cite",
            "classid",
            "codebase",
            "data",
            "href",
            "longdesc",
            "profile",
            "src",
            "usemap",
        ]

        const ENCODINGS_REGEX = {
            attribute: new RegExp(
                "[" + Object.keys(ENCODINGS.attribute).join("") + "]",
                "g",
            ),
            uri: new RegExp(
                "[" + Object.keys(ENCODINGS.uri).join("") + "]",
                "g",
            ),
        }

        // find all attributes after the first whitespace (which would follow the tag
        // name. Only used when the DOM has been clobbered to still parse attributes
        const ATTRIBUTE_PARSER_REGEX = /\s([^">=\s]+)(?:="[^"]+")?/g

        // test if a javascript substitution is wrapped with quotes
        const WRAPPED_WITH_QUOTES_REGEX = /^('|")[\s\S]*\1$/

        // allow custom attribute names that start or end with url or ui to do uri escaping
        // @see https://developers.google.com/closure/templates/docs/security#in_urls
        const CUSTOM_URI_ATTRIBUTES_REGEX = /\bur[il]|ur[il]s?$/i

        // --------------------------------------------------
        // private functions
        // --------------------------------------------------

        /**
         * Escape HTML entities in an attribute.
         * @private
         *
         * @param {string} str - String to escape.
         *
         * @returns {string}
         */
        function encodeAttributeHTMLEntities(str) {
            return str.replace(ENCODINGS_REGEX.attribute, function(match) {
                return ENCODINGS.attribute[match]
            })
        }

        /**
         * Escape entities in a URI.
         * @private
         *
         * @param {string} str - URI to escape.
         *
         * @returns {string}
         */
        function encodeURIEntities(str) {
            return str.replace(ENCODINGS_REGEX.uri, function(match) {
                return ENCODINGS.uri[match]
            })
        }

        // --------------------------------------------------
        // html tagged template function
        // --------------------------------------------------

        /**
         * Safely convert a DOM string into DOM nodes using by using E4H and contextual
         * auto-escaping techniques to prevent xss attacks.
         *
         * @param {string[]} strings - Safe string literals.
         * @param {*} values - Unsafe substitution expressions.
         *
         * @returns {HTMLElement|DocumentFragment}
         */
        window.html = function(strings, ...values) {
            // break early if called with empty content
            if (!strings[0] && values.length === 0) {
                return
            }

            /**
             * Replace a string with substitution placeholders with its substitution values.
             * @private
             *
             * @param {string} match - Matched substitution placeholder.
             * @param {string} index - Substitution placeholder index.
             */
            function replaceSubstitution(match, index) {
                return values[parseInt(index, 10)]
            }

            // insert placeholders into the generated string so we can run it through the
            // HTML parser without any malicious content.
            // (this particular placeholder will even work when used to create a DOM element)
            let str = strings[0]
            for (let i = 0; i < values.length; i++) {
                str += SUBSTITUTION_INDEX + i + ":" + strings[i + 1]
            }

            // template tags allow any HTML (even <tr> elements out of context)
            // @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template
            let template = document.createElement("template")
            template.innerHTML = str

            // find all substitution values and safely encode them using DOM APIs and
            // contextual auto-escaping
            let walker = document.createNodeIterator(
                template.content,
                NodeFilter.SHOW_ALL,
            )
            let node
            while ((node = walker.nextNode())) {
                let tag = null
                let attributesToRemove = []

                // --------------------------------------------------
                // node name substitution
                // --------------------------------------------------

                let nodeName = node.nodeName.toLowerCase()
                if (nodeName.indexOf(SUBSTITUTION_INDEX) !== -1) {
                    nodeName = nodeName.replace(
                        SUBSTITUTION_REGEX,
                        replaceSubstitution,
                    )

                    // createElement() should not need to be escaped to prevent XSS?

                    // this will throw an error if the tag name is invalid (e.g. xss tried
                    // to escape out of the tag using '><script>alert(1337)</script><')
                    // instead of replacing the tag name we'll just let the error be thrown
                    tag = document.createElement(nodeName)

                    // mark that this node needs to be cleaned up later with the newly
                    // created node
                    node._replacedWith = tag

                    // use insertBefore() instead of replaceChild() so that the node Iterator
                    // doesn't think the new tag should be the next node
                    node.parentNode.insertBefore(tag, node)
                }

                // special case for script tags:
                // using innerHTML with a string that contains a script tag causes the script
                // tag to not be executed when added to the DOM. We'll need to create a script
                // tag and append its contents which will make it execute correctly.
                // @see http://stackoverflow.com/questions/1197575/can-scripts-be-inserted-with-innerhtml
                else if (node.nodeName === "SCRIPT") {
                    let script = document.createElement("script")
                    tag = script

                    node._replacedWith = script
                    node.parentNode.insertBefore(script, node)
                }

                // --------------------------------------------------
                // attribute substitution
                // --------------------------------------------------

                let attributes
                if (node.attributes) {
                    // if the attributes property is not of type NamedNodeMap then the DOM
                    // has been clobbered. E.g. <form><input name="attributes"></form>.
                    // We'll manually build up an array of objects that mimic the Attr
                    // object so the loop will still work as expected.
                    if (!(node.attributes instanceof NamedNodeMap)) {
                        // first clone the node so we can isolate it from any children
                        let temp = node.cloneNode()

                        // parse the node string for all attributes
                        let attributeMatches = temp.outerHTML.match(
                            ATTRIBUTE_PARSER_REGEX,
                        )

                        // get all attribute names and their value
                        attributes = []
                        for (let i = 0; i < attributeMatches.length; i++) {
                            let attributeName = attributeMatches[i]
                                .trim()
                                .split("=")[0]
                            let attributeValue = node.getAttribute(
                                attributeName,
                            )

                            attributes.push({
                                name: attributeName,
                                value: attributeValue,
                            })
                        }
                    } else {
                        // Windows 10 Firefox 44 will shift the attributes NamedNodeMap and
                        // push the attribute to the end when using setAttribute(). We'll have
                        // to clone the NamedNodeMap so the order isn't changed for setAttribute()
                        attributes = Array.from(node.attributes)
                    }

                    for (let i = 0; i < attributes.length; i++) {
                        let attribute = attributes[i]
                        let name = attribute.name
                        let value = attribute.value
                        let hasSubstitution = false

                        // name has substitution
                        if (name.indexOf(SUBSTITUTION_INDEX) !== -1) {
                            name = name.replace(
                                SUBSTITUTION_REGEX,
                                replaceSubstitution,
                            )

                            // ensure substitution was with a non-empty string
                            if (name && typeof name === "string") {
                                hasSubstitution = true
                            }

                            // remove old attribute
                            attributesToRemove.push(attribute.name)
                        }

                        // value has substitution - only check if name exists (only happens
                        // when name is a substitution with an empty value)
                        if (name && value.indexOf(SUBSTITUTION_INDEX) !== -1) {
                            hasSubstitution = true

                            // if an uri attribute has been rejected
                            let isRejected = false

                            value = value.replace(SUBSTITUTION_REGEX, function(
                                match,
                                index,
                                offset,
                            ) {
                                if (isRejected) {
                                    return ""
                                }

                                let substitutionValue =
                                    values[parseInt(index, 10)]

                                // contextual auto-escaping:
                                // if attribute is a DOM Level 0 event then we need to ensure it
                                // is quoted
                                if (
                                    DOM_EVENTS.indexOf(name) !== -1 &&
                                    typeof substitutionValue === "string" &&
                                    !WRAPPED_WITH_QUOTES_REGEX.test(
                                        substitutionValue,
                                    )
                                ) {
                                    substitutionValue =
                                        '"' + substitutionValue + '"'
                                }

                                // contextual auto-escaping:
                                // if the attribute is a uri attribute then we need to uri encode it and
                                // remove bad protocols
                                else if (
                                    URI_ATTRIBUTES.indexOf(name) !== -1 ||
                                    CUSTOM_URI_ATTRIBUTES_REGEX.test(name)
                                ) {
                                    // percent encode if the value is inside of a query parameter
                                    let queryParamIndex = value.indexOf("=")
                                    if (
                                        queryParamIndex !== -1 &&
                                        offset > queryParamIndex
                                    ) {
                                        substitutionValue = encodeURIComponent(
                                            substitutionValue,
                                        )
                                    }

                                    // entity encode if value is part of the URL
                                    else {
                                        substitutionValue = encodeURI(
                                            encodeURIEntities(
                                                substitutionValue,
                                            ),
                                        )

                                        // only allow the : when used after http or https otherwise reject
                                        // the entire url (will not allow any 'javascript:' or filter
                                        // evasion techniques)
                                        if (
                                            offset === 0 &&
                                            substitutionValue.indexOf(":") !==
                                                -1
                                        ) {
                                            const authorized_protocols = [
                                                "http://",
                                                "https://",
                                                "moz-extension://",
                                                "about://",
                                                "data:image/png;base64",
                                                "data:image/gif;base64",
                                                "data:image/jpg;base64",
                                                "data:image/jpeg;base64",
                                                "data:image/x-icon;base64",
                                            ]
                                            // If substitutionValue doesn't start with any of the authorized protocols
                                            if (
                                                !authorized_protocols.find(p =>
                                                    substitutionValue.startsWith(
                                                        p,
                                                    ),
                                                )
                                            ) {
                                                isRejected = true
                                            }
                                        }
                                    }
                                }

                                // contextual auto-escaping:
                                // HTML encode attribute value if it is not a URL or URI to prevent
                                // DOM Level 0 event handlers from executing xss code
                                else if (
                                    typeof substitutionValue === "string"
                                ) {
                                    substitutionValue = encodeAttributeHTMLEntities(
                                        substitutionValue,
                                    )
                                }

                                return substitutionValue
                            })

                            if (isRejected) {
                                value = "#" + REJECTION_STRING
                            }
                        }

                        // add the attribute to the new tag or replace it on the current node
                        // setAttribute() does not need to be escaped to prevent XSS since it does
                        // all of that for us
                        // @see https://www.mediawiki.org/wiki/DOM-based_XSS
                        if (tag || hasSubstitution) {
                            let el = tag || node

                            // optional attribute
                            if (name.substr(-1) === "?") {
                                el.removeAttribute(name)

                                if (value === "true") {
                                    name = name.slice(0, -1)
                                    el.setAttribute(name, "")
                                }
                            } else {
                                el.setAttribute(name, value)
                            }
                        }
                    }
                }

                // remove placeholder attributes outside of the attribute loop since it
                // will modify the attributes NamedNodeMap indices.
                // @see https://github.com/straker/html-tagged-template/issues/13
                attributesToRemove.forEach(function(attribute) {
                    node.removeAttribute(attribute)
                })

                // append the current node to a replaced parent
                let parentNode
                if (node.parentNode && node.parentNode._replacedWith) {
                    parentNode = node.parentNode
                    node.parentNode._replacedWith.appendChild(node)
                }

                // remove the old node from the DOM
                if (
                    (node._replacedWith && node.childNodes.length === 0) ||
                    (parentNode && parentNode.childNodes.length === 0)
                ) {
                    ;(parentNode || node).remove()
                }

                // --------------------------------------------------
                // text content substitution
                // --------------------------------------------------

                if (
                    node.nodeType === 3 &&
                    node.nodeValue.indexOf(SUBSTITUTION_INDEX) !== -1
                ) {
                    let nodeValue = node.nodeValue.replace(
                        SUBSTITUTION_REGEX,
                        replaceSubstitution,
                    )

                    // createTextNode() should not need to be escaped to prevent XSS?
                    let text = document.createTextNode(nodeValue)

                    // since the parent node has already gone through the iterator, we can use
                    // replaceChild() here
                    node.parentNode.replaceChild(text, node)
                }
            }

            // return the documentFragment for multiple nodes
            if (template.content.childNodes.length > 1) {
                return template.content
            }

            return template.content.firstChild
        }
    }
})(window)


/***/ }),

/***/ "./src/lib/itertools.ts":
/*!******************************!*\
  !*** ./src/lib/itertools.ts ***!
  \******************************/
/*! exports provided: head, tail, filter, find, zip, range, enumerate, izip, iterEq, zeros, islice, chain, permutationsWithReplacement, map, unique, uniqueBy, flatten, dropwhile, takewhile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "head", function() { return head; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tail", function() { return tail; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filter", function() { return filter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "find", function() { return find; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return zip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumerate", function() { return enumerate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "izip", function() { return izip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "iterEq", function() { return iterEq; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zeros", function() { return zeros; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "islice", function() { return islice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chain", function() { return chain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "permutationsWithReplacement", function() { return permutationsWithReplacement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "map", function() { return map; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unique", function() { return unique; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uniqueBy", function() { return uniqueBy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flatten", function() { return flatten; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dropwhile", function() { return dropwhile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "takewhile", function() { return takewhile; });
/* harmony import */ var _src_lib_number_mod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/lib/number.mod */ "./src/lib/number.mod.ts");

function head(iter) {
    iter = iter[Symbol.iterator]();
    const result = iter.next();
    if (result.done)
        throw RangeError("Empty iterator has no head/tail");
    else
        return result.value;
}
/** Get the last item of an array or iterable */
function tail(iter) {
    if (Array.isArray(iter)) {
        if (iter.length < 1)
            throw RangeError("Empty iterator has no head/tail");
        return iter[iter.length - 1];
    }
    else {
        // Re-use error handling in head()
        let last = head(iter);
        for (last of iter)
            ;
        return last;
    }
}
function* filter(iter, predicate) {
    for (const v of iter) {
        if (predicate(v))
            yield v;
    }
}
function find(iter, predicate) {
    return head(filter(iter, predicate));
}
/** Zip some arrays together

    If you need variable length args, you need izip for now.

*/
function zip(...arrays) {
    // Make an array of length values
    // TODO: Explain how this works
    return [...Array(arrays[0].length)].map((_, i) => arrays.map(a => a[i]));
}
function* range(length) {
    if (length < 0)
        return;
    for (let index = 0; index < length; index++) {
        yield index;
    }
}
function* enumerate(iterable) {
    let index = 0;
    for (const element of iterable) {
        yield [index, element];
        index++;
    }
}
/* Zip arbitrary iterators together */
function* izip(...arrays) {
    const iterators = arrays.map(e => e[Symbol.iterator]());
    const box = Array(arrays.length);
    for (let v of iterators[0]) {
        box[0] = v;
        let i;
        try {
            for ([i, v] of enumerate(iterators.slice(1))) {
                box[i + 1] = head(v);
            }
            yield [...box];
        }
        catch (e) {
            return;
        }
    }
}
/* Test if two iterables are equal */
function iterEq(...arrays) {
    for (const a of zip(...arrays)) {
        if (!a.reduce((x, y) => x === y))
            return false;
    }
    return true;
}
function zeros(n) {
    return new Array(n).fill(0);
}
/** islice(iter, stop) = Give the first `stop` elements
    islice(iter, start, stop)
        skip `start` elements, then give `stop - start` elements,
        unless `stop` is null, then emit indefinitely

    If the iterator runs out early so will this.
*/
function* islice(iterable, start, stop) {
    const iter = iterable[Symbol.iterator]();
    // If stop is not defined then they're using the two argument variant
    if (stop === undefined) {
        stop = start;
        start = 0;
    }
    // Skip elements until start
    for (const _ of range(start)) {
        const res = iter.next();
        if (res.done)
            return;
    }
    // Emit elements
    if (stop === null) {
        yield* iter;
    }
    else {
        for (let i = start; i < stop; i++) {
            const res = iter.next();
            if (res.done)
                return;
            else
                yield res.value;
        }
    }
}
function* chain(...iterables) {
    for (const iter of iterables) {
        yield* iter[Symbol.iterator]();
    }
}
/** All permutations of n items from array */
function* permutationsWithReplacement(arr, n) {
    const len = arr.length;
    const counters = zeros(n);
    let index = 1;
    for (const _ of range(Math.pow(len, n))) {
        yield counters.map(i => arr[i]);
        for (const i of range(counters.length)) {
            if (index.mod(Math.pow(len, counters.length - 1 - i)) === 0)
                counters[i] = (counters[i] + 1).mod(len);
        }
        index++;
    }
}
function* map(arr, func) {
    for (const v of arr)
        yield func(v);
}
// Returns an array of unique elements.
function unique(arr) {
    return arr.reduce((acc, cur) => {
        if (!acc.includes(cur))
            acc.push(cur);
        return acc;
    }, []);
}
/** Yield values that are unique under hasher(value) */
function* uniqueBy(arr, hasher) {
    const hashes = new Set();
    for (const e of arr) {
        const hash = hasher(e);
        if (!hashes.has(hash)) {
            yield e;
            hashes.add(hash);
        }
    }
}
function flatten(arr) {
    let result = [];
    for (const elem of arr) {
        if (elem instanceof Array) {
            result = result.concat(flatten(elem));
        }
        else {
            result.push(elem);
        }
    }
    return result;
}
/** Drop from iterable until predicate is false */
function* dropwhile(iterable, predicate) {
    let allmatched = true;
    for (const elem of iterable) {
        if (!(allmatched && predicate(elem))) {
            allmatched = false;
            yield elem;
        }
    }
}
/** Take from iterable until predicate is false */
function* takewhile(iterable, predicate) {
    for (const elem of iterable) {
        if (predicate(elem)) {
            yield elem;
        }
        else {
            return;
        }
    }
}


/***/ }),

/***/ "./src/lib/keyseq.ts":
/*!***************************!*\
  !*** ./src/lib/keyseq.ts ***!
  \***************************/
/*! exports provided: MinimalKey, parse, completions, bracketexprToKey, mapstrToKeyseq, mapstrMapToKeyMap, hasModifiers, hasNonShiftModifiers, isSimpleKey, translateKeysUsingKeyTranslateMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MinimalKey", function() { return MinimalKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "completions", function() { return completions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bracketexprToKey", function() { return bracketexprToKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapstrToKeyseq", function() { return mapstrToKeyseq; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapstrMapToKeyMap", function() { return mapstrMapToKeyMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasModifiers", function() { return hasModifiers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasNonShiftModifiers", function() { return hasNonShiftModifiers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSimpleKey", function() { return isSimpleKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translateKeysUsingKeyTranslateMap", function() { return translateKeysUsingKeyTranslateMap; });
/* harmony import */ var _src_lib_itertools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/lib/itertools */ "./src/lib/itertools.ts");
/* harmony import */ var _src_lib_nearley_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @src/lib/nearley_utils */ "./src/lib/nearley_utils.ts");
/* harmony import */ var _src_grammars_bracketexpr_generated__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @src/grammars/.bracketexpr.generated */ "./src/grammars/.bracketexpr.generated.ts");
/** Key-sequence parser

    If `map` is a Map of `MinimalKey[]` to objects (exstrs or callbacks)
    and `keyseq` is an array of [[MinimalKey]] compatible objects...

     - `parse(keyseq, map)` returns the mapped object and a count OR a prefix
       of `MinimalKey[]` (possibly empty) that, if more keys are pressed, could
       map to an object.
     - `completions(keyseq, map)` returns the fragment of `map` that keyseq is
       a valid prefix of.
     - `mapstrToKeySeq` generates KeySequences for the rest of the API.

    No key sequence in a `map` may be a prefix of another key sequence in that
    map. This is a point of difference from Vim that removes any time-dependence
    in the parser. Vimperator, Pentadactyl, saka-key, etc, all share this
    limitation.

    If a key is represented by a single character then the shift modifier state
    is ignored unless other modifiers are also present.

*/
/** */



const bracketexpr_parser = new _src_lib_nearley_utils__WEBPACK_IMPORTED_MODULE_1__["Parser"](_src_grammars_bracketexpr_generated__WEBPACK_IMPORTED_MODULE_2__);
class MinimalKey {
    constructor(key, modifiers) {
        this.key = key;
        this.altKey = false;
        this.ctrlKey = false;
        this.metaKey = false;
        this.shiftKey = false;
        if (modifiers !== undefined) {
            for (const mod of Object.keys(modifiers)) {
                this[mod] = modifiers[mod];
            }
        }
    }
    /** Does this key match a given MinimalKey extending object? */
    match(keyevent) {
        // 'in' doesn't include prototypes, so it's safe for this object.
        for (const attr in this) {
            // Don't check shiftKey for normal keys.
            if (attr === "shiftKey" && this.key.length === 1)
                continue;
            if (this[attr] !== keyevent[attr])
                return false;
        }
        return true;
    }
    toMapstr() {
        let str = "";
        let needsBrackets = this.key.length > 1;
        // Format modifiers
        const modifiers = new Map([
            ["A", "altKey"],
            ["C", "ctrlKey"],
            ["M", "metaKey"],
            ["S", "shiftKey"],
        ]);
        for (const [letter, attr] of modifiers.entries()) {
            if (this[attr]) {
                str += letter;
                needsBrackets = true;
            }
        }
        if (str) {
            str += "-";
        }
        let key = this.key;
        if (key === " ") {
            key = "Space";
            needsBrackets = true;
        }
        // Format the rest
        str += key;
        if (needsBrackets) {
            str = "<" + str + ">";
        }
        return str;
    }
}
function splitNumericPrefix(keyseq) {
    // If the first key is in 1:9, partition all numbers until you reach a non-number.
    if (!hasModifiers(keyseq[0]) && [1, 2, 3, 4, 5, 6, 7, 8, 9].includes(Number(keyseq[0].key))) {
        const prefix = [keyseq[0]];
        for (const ke of keyseq.slice(1)) {
            if (!hasModifiers(ke) && [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].includes(Number(ke.key)))
                prefix.push(ke);
            else
                break;
        }
        const rest = keyseq.slice(prefix.length);
        return [prefix, rest];
    }
    else {
        return [[], keyseq];
    }
}
function parse(keyseq, map) {
    // Remove bare modifiers
    keyseq = keyseq.filter(key => !["Control", "Shift", "Alt", "AltGraph", "Meta"].includes(key.key));
    // If the keyseq is now empty, abort.
    if (keyseq.length === 0)
        return { keys: [], isMatch: false };
    // Split into numeric prefix and non-numeric suffix
    let numericPrefix;
    [numericPrefix, keyseq] = splitNumericPrefix(keyseq);
    // If keyseq is a prefix of a key in map, proceed, else try dropping keys
    // from keyseq until it is empty or is a prefix.
    let possibleMappings = completions(keyseq, map);
    while (possibleMappings.size === 0 && keyseq.length > 0) {
        keyseq.shift();
        numericPrefix = [];
        possibleMappings = completions(keyseq, map);
    }
    if (possibleMappings.size > 0) {
        // Check if any of the mappings is a perfect match (this will only
        // happen if some sequences in the KeyMap are prefixes of other seqs).
        try {
            const perfect = Object(_src_lib_itertools__WEBPACK_IMPORTED_MODULE_0__["find"])(possibleMappings, ([k, v]) => k.length === keyseq.length);
            return {
                value: perfect[1],
                exstr: perfect[1] + numericPrefixToExstrSuffix(numericPrefix),
                isMatch: true,
                numericPrefix: numericPrefix.length ? Number(numericPrefix.map(ke => ke.key).join("")) : undefined,
            };
        }
        catch (e) {
            if (!(e instanceof RangeError))
                throw e;
        }
    }
    // keyseq is the longest suffix of keyseq that is the prefix of a
    // command, numericPrefix is a numeric prefix of that. We want to
    // preserve that whole thing, so concat them back together before
    // returning.
    return { keys: numericPrefix.concat(keyseq), isMatch: keyseq.length > 0 };
}
/** True if seq1 is a prefix or equal to seq2 */
function prefixes(seq1, seq2) {
    if (seq1.length > seq2.length) {
        return false;
    }
    else {
        for (const [key1, key2] of Object(_src_lib_itertools__WEBPACK_IMPORTED_MODULE_0__["izip"])(seq1, seq2)) {
            if (!key2.match(key1))
                return false;
        }
        return true;
    }
}
/** returns the fragment of `map` that keyseq is a valid prefix of. */
function completions(keyseq, map) {
    return new Map(Object(_src_lib_itertools__WEBPACK_IMPORTED_MODULE_0__["filter"])(map.entries(), ([ks, maptarget]) => prefixes(keyseq, ks)));
}
// }}}
// {{{ mapStrToKeySeq stuff
/** Expand special key aliases that Vim provides to canonical values

    Vim aliases are case insensitive.
*/
function expandAliases(key) {
    // Vim compatibility aliases
    const aliases = {
        cr: "Enter",
        esc: "Escape",
        return: "Enter",
        enter: "Enter",
        space: " ",
        bar: "|",
        del: "Delete",
        bs: "Backspace",
        lt: "<",
    };
    if (key.toLowerCase() in aliases)
        return aliases[key.toLowerCase()];
    else
        return key;
}
/** String starting with a `<` to MinimalKey and remainder.

    Bracket expressions generally start with a `<` contain no angle brackets or
    whitespace and end with a `>.` These special-cased expressions are also
    permitted: `<{modifier}<>`, `<{modifier}>>`, and `<{modifier}->`.

    If the string passed does not match this definition, it is treated as a
    literal `<.`

    Backus Naur approximation:

    ```
        - bracketexpr ::= '<' modifier? key '>'
        - modifier ::= 'm'|'s'|'a'|'c' '-'
        - key ::= '<'|'>'|/[^\s<>-]+/
    ```

    See `src/grammars/bracketExpr.ne` for the canonical definition.

    Modifiers are case insensitive.

    Some case insensitive vim compatibility aliases are also defined, see
    [[expandAliases]].

    Compatibility breaks:

    Shift + key must use the correct capitalisation of key:
        `<S-j> != J, <S-J> == J`.

    In Vim `<A-x> == <M-x>` on most systems. Not so here: we can't detect
    platform, so just have to use what the browser gives us.

    Vim has a predefined list of special key sequences, we don't: there are too
    many (and they're non-standard) [1].

    In the future, we may just use the names as defined in keyNameList.h [2].

    In Vim, you're still allowed to use `<lt>` within angled brackets:
        `<M-<> == <M-lt> == <M-<lt>>`
    Here only the first two will work.

    Restrictions:

    It is not possible to map to a keyevent that actually sends the key value
    of any of the aliases or to any multi-character sequence containing a space
    or `>.` It is unlikely that browsers will ever do either of those things.

    [1]: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values
    [2]: https://searchfox.org/mozilla-central/source/dom/events/KeyNameList.h

*/
function bracketexprToKey(inputStr) {
    if (inputStr.indexOf(">") > 0) {
        try {
            const [[modifiers, key], remainder,] = bracketexpr_parser.feedUntilError(inputStr);
            return [new MinimalKey(expandAliases(key), modifiers), remainder];
        }
        catch (e) {
            // No valid bracketExpr
            return [new MinimalKey("<"), inputStr.slice(1)];
        }
    }
    else {
        // No end bracket to match == no valid bracketExpr
        return [new MinimalKey("<"), inputStr.slice(1)];
    }
}
/** Generate KeySequences for the rest of the API.

    A map expression is something like:

    ```
    j scrollline 10
    <C-f> scrollpage 0.5
    <C-d> scrollpage 0.5
    <C-/><C-n> mode normal
    ```

    A mapstr is the bit before the space.

    mapstrToKeyseq turns a mapstr into a keySequence that looks like this:

    ```
    [MinimalKey {key: 'j'}]
    [MinimalKey {key: 'f', ctrlKey: true}]
    [MinimalKey {key: 'd', ctrlKey: true}]
    [MinimalKey {key: '/', ctrlKey: true}, MinimalKey {key: 'n', ctrlKey: true}]
    ```

    (All four {modifier}Key flags are actually provided on all MinimalKeys)
*/
function mapstrToKeyseq(mapstr) {
    const keyseq = [];
    let key;
    // Reduce mapstr by one character or one bracket expression per iteration
    while (mapstr.length) {
        if (mapstr[0] === "<") {
            [key, mapstr] = bracketexprToKey(mapstr);
            keyseq.push(key);
        }
        else {
            keyseq.push(new MinimalKey(mapstr[0]));
            mapstr = mapstr.slice(1);
        }
    }
    return keyseq;
}
/** Convert a map of mapstrs (e.g. from config) to a KeyMap */
function mapstrMapToKeyMap(mapstrMap) {
    const newKeyMap = new Map();
    for (const [mapstr, target] of mapstrMap.entries()) {
        newKeyMap.set(mapstrToKeyseq(mapstr), target);
    }
    return newKeyMap;
}
// }}}
// {{{ Utility functions for dealing with KeyboardEvents
function hasModifiers(keyEvent) {
    return (keyEvent.ctrlKey ||
        keyEvent.altKey ||
        keyEvent.metaKey ||
        keyEvent.shiftKey);
}
/** shiftKey is true for any capital letter, most numbers, etc. Generally care about other modifiers. */
function hasNonShiftModifiers(keyEvent) {
    return keyEvent.ctrlKey || keyEvent.altKey || keyEvent.metaKey;
}
/** A simple key event is a non-special key (length 1) that is not modified by ctrl, alt, or shift. */
function isSimpleKey(keyEvent) {
    return !(keyEvent.key.length > 1 || hasNonShiftModifiers(keyEvent));
}
function numericPrefixToExstrSuffix(numericPrefix) {
    if (numericPrefix.length > 0) {
        return " " + numericPrefix.map(k => k.key).join("");
    }
    else {
        return "";
    }
}
/**
 * Translates the given set of keyEvents (in place) as specified by
 * the given key translation map. All keys *and* values in the key
 * translation map must be length-1 strings.
 */
function translateKeysUsingKeyTranslateMap(keyEvents, keytranslatemap) {
    for (let index = 0; index < keyEvents.length; index++) {
        const keyEvent = keyEvents[index];
        const newkey = keytranslatemap[keyEvent.key];
        // KeyboardEvents can't have been translated, MinimalKeys may
        // have been. We can't add anything to the MinimalKey without
        // breaking a ton of other stuff, so instead we'll just assume
        // that the only way we've gotten a MinimalKey is if the key
        // has already been translated. We err way on the side of
        // safety becase translating anything more than once would
        // almost certainly mean oscillations and other super-weird
        // breakage.
        const neverTranslated = keyEvent instanceof KeyboardEvent;
        if (neverTranslated && newkey !== undefined) {
            // We can't update the keyEvent in place. However, the
            // entire pipeline works with MinimalKeys all the way
            // through, so we just swap the key event out for a new
            // MinimalKey with the right key and modifiers copied from
            // the original.
            keyEvents[index] = new MinimalKey(newkey, {
                altKey: keyEvent.altKey,
                ctrlKey: keyEvent.ctrlKey,
                metaKey: keyEvent.metaKey,
                shiftKey: keyEvent.shiftKey,
            });
        }
    }
}
// }}}


/***/ }),

/***/ "./src/lib/logging.ts":
/*!****************************!*\
  !*** ./src/lib/logging.ts ***!
  \****************************/
/*! exports provided: Logger, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Logger", function() { return Logger; });
/* harmony import */ var _src_lib_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/lib/config */ "./src/lib/config.ts");
/**
 * Helper functions for logging
 */

const LevelToNum = new Map();
LevelToNum.set("never", 0);
LevelToNum.set("error", 1);
LevelToNum.set("warning", 2);
LevelToNum.set("info", 3);
LevelToNum.set("debug", 4);
class Logger {
    /**
     * Config-aware Logger class.
     *
     * @param logModule     the logging module name: this is ued to look up the
     *                      configured/default level in the user config
     */
    constructor(logModule) {
        this.logModule = logModule;
    }
    /**
     * Config-aware logging function.
     *
     * @param level         the level of the logging - if <= configured, the message
     *                      will be shown
     *
     * @return              logging function: this is returned as a function to
     *                      retain the call site
     */
    log(level) {
        const configedLevel = _src_lib_config__WEBPACK_IMPORTED_MODULE_0__["get"]("logging", this.logModule);
        if (LevelToNum.get(level) <= LevelToNum.get(configedLevel)) {
            // hand over to console.log, error or debug as needed
            switch (level) {
                case "error":
                    // TODO: replicate this for other levels, don't steal focus
                    // work out how to import messaging/webext without breaking everything
                    return async (...message) => {
                        console.error(...message);
                        return browser.runtime.sendMessage({
                            type: "controller_background",
                            command: "acceptExCmd",
                            args: ["fillcmdline_nofocus # " + message.join(" ")],
                        });
                    };
                case "warning":
                    return console.warn;
                case "info":
                    return console.log;
                case "debug":
                    return console.debug;
            }
        }
        // do nothing with the message
        return function (...args) { };
    }
    // These are all getters so that logger.debug = console.debug and
    // logger.debug('blah') translates into console.debug('blah') with the
    // filename and line correct.
    get debug() {
        return this.log("debug");
    }
    get info() {
        return this.log("info");
    }
    get warning() {
        return this.log("warning");
    }
    get error() {
        return this.log("error");
    }
}
/* harmony default export */ __webpack_exports__["default"] = (Logger);


/***/ }),

/***/ "./src/lib/math.ts":
/*!*************************!*\
  !*** ./src/lib/math.ts ***!
  \*************************/
/*! exports provided: log, linspace, buckets, bucketize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log", function() { return log; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linspace", function() { return linspace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buckets", function() { return buckets; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bucketize", function() { return bucketize; });
function log(x, base) {
    return Math.log(x) / Math.log(base);
}
// Copied from Numeric Javascript under the MIT license
// https://github.com/sloisel/numeric/blob/656fa1254be540f428710738ca9c1539625777f1/src/numeric.js#L922
function linspace(a, b, n) {
    if (typeof n === "undefined")
        n = Math.max(Math.round(b - a) + 1, 1);
    if (n < 2) {
        return n === 1 ? [a] : [];
    }
    let i;
    const ret = Array(n);
    n--;
    for (i = n; i >= 0; i--) {
        ret[i] = (i * b + (n - i) * a) / n;
    }
    return ret;
}
function buckets(values, numBuckets) {
    const min = values.reduce((a, b) => Math.min(a, b));
    const max = values.reduce((a, b) => Math.max(a, b));
    return linspace(min, max, numBuckets);
}
function bucketize(values, buckets) {
    // Init result storage
    const result = new Map();
    for (const bucketval of buckets) {
        result.set(bucketval, 0);
    }
    // We place a value in a bucket by going through the buckets from
    // smallest to largest, finding the smallest bucket that's larger
    // than or equal to than the value. This will have the following
    // results:
    //
    // * A value that's larger than all bucket values will not be
    //   placed at all.
    // * A value with exactly the value of the largest bucket will be
    //   placed in the largest bucket.
    // * A value with exactly the value of the smallest bucket will be
    //   placed in the smallest bucket.
    // * A value that's smaller than all bucket values will be placed
    //   in the smallest bucket.
    //
    // If we build our buckets as linspace(min(values), max(values)),
    // then this means that the largest bucket is guaranteed to have
    // exactly one element in it.
    const placeValue = (val) => {
        for (const bucketval of buckets) {
            if (bucketval >= val) {
                result.set(bucketval, result.get(bucketval) + 1);
                return;
            }
        }
    };
    // Bucketize every value.
    for (const val of values) {
        placeValue(val);
    }
    // Return just the counts in each bucket
    return result;
}


/***/ }),

/***/ "./src/lib/messaging.ts":
/*!******************************!*\
  !*** ./src/lib/messaging.ts ***!
  \******************************/
/*! exports provided: attributeCaller, message, messageActiveTab, messageTab, messageOwnTab, messageAllTabs, addListener */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "attributeCaller", function() { return attributeCaller; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "message", function() { return message; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "messageActiveTab", function() { return messageActiveTab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "messageTab", function() { return messageTab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "messageOwnTab", function() { return messageOwnTab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "messageAllTabs", function() { return messageAllTabs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addListener", function() { return addListener; });
/* harmony import */ var _src_lib_webext__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/lib/webext */ "./src/lib/webext.ts");
/* harmony import */ var _src_lib_logging__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @src/lib/logging */ "./src/lib/logging.ts");


const logger = new _src_lib_logging__WEBPACK_IMPORTED_MODULE_1__["default"]("messaging");
// Calls methods on obj that match .command and sends responses back
function attributeCaller(obj) {
    function handler(message, sender, sendResponse) {
        logger.debug(message);
        // Args may be undefined, but you can't spread undefined...
        if (message.args === undefined)
            message.args = [];
        // Call command on obj
        try {
            const response = obj[message.command](...message.args);
            // Return response to sender
            if (response instanceof Promise) {
                logger.debug("Returning promise...", response);
                sendResponse(response);
                // Docs say you should be able to return a promise, but that
                // doesn't work.
                /* return response */
            }
            else if (response !== undefined) {
                logger.debug("Returning synchronously...", response);
                sendResponse(response);
            }
        }
        catch (e) {
            logger.error(`Error processing ${message.command}(${message.args})`, e);
            return Promise.reject(e);
        }
    }
    return handler;
}
/** Send a message to non-content scripts */
async function message(type, command, args) {
    return browser.runtime.sendMessage({ type, command, args });
}
/** Message the active tab of the currentWindow */
async function messageActiveTab(type, command, args) {
    return messageTab(await Object(_src_lib_webext__WEBPACK_IMPORTED_MODULE_0__["activeTabId"])(), type, command, args);
}
async function messageTab(tabId, type, command, args) {
    const message = {
        type,
        command,
        args,
    };
    return _src_lib_webext__WEBPACK_IMPORTED_MODULE_0__["browserBg"].tabs.sendMessage(tabId, message);
}
let _ownTabId;
async function messageOwnTab(type, command, args) {
    if (_ownTabId === undefined) {
        _ownTabId = await Object(_src_lib_webext__WEBPACK_IMPORTED_MODULE_0__["ownTabId"])();
    }
    if (_ownTabId === undefined)
        throw new Error("Can't message own tab: _ownTabId is undefined");
    return messageTab(_ownTabId, type, command, args);
}
async function messageAllTabs(type, command, args) {
    const responses = [];
    for (const tab of await _src_lib_webext__WEBPACK_IMPORTED_MODULE_0__["browserBg"].tabs.query({})) {
        try {
            responses.push(await messageTab(tab.id, type, command, args));
        }
        catch (e) {
            logger.error(e);
        }
    }
    return responses;
}
const listeners = new Map();
/** Register a listener to be called for each message with type */
function addListener(type, callback) {
    if (!listeners.get(type)) {
        listeners.set(type, new Set());
    }
    listeners.get(type).add(callback);
    return () => {
        listeners.get(type).delete(callback);
    };
}
if (Object(_src_lib_webext__WEBPACK_IMPORTED_MODULE_0__["getContext"])() === "background") {
    // Warning: lib/webext.ts:ownTab() relies on this listener being added in order to work
    addListener("owntab_background", (message, sender, sendResponse) => {
        const x = Object.assign(Object.create(null), sender.tab);
        x.mutedInfo = Object.assign(Object.create(null), sender.tab.mutedInfo);
        x.sharingState = Object.assign(Object.create(null), sender.tab.sharingState);
        sendResponse(Promise.resolve(x));
    });
}
/** Recv a message from runtime.onMessage and send to all listeners */
function onMessage(message, sender, sendResponse) {
    if (listeners.get(message.type)) {
        for (const listener of listeners.get(message.type)) {
            listener(message, sender, sendResponse);
        }
    }
}
browser.runtime.onMessage.addListener(onMessage);


/***/ }),

/***/ "./src/lib/native.ts":
/*!***************************!*\
  !*** ./src/lib/native.ts ***!
  \***************************/
/*! exports provided: getrcpath, getrc, getNativeMessengerVersion, getBestEditor, nativegate, inpath, firstinpath, editor, read, write, writerc, mkdir, temp, move, listDir, winFirefoxRestart, run, pyeval, getenv, clipboard, ff_cmdline, parseProfilesIni, getFirefoxDir, getProfileUncached, getProfile, getProfileName, getProfileDir, parsePrefs, loadPrefs, getPrefs, getPref, getConfElsePref, getConfElsePrefElseDefault, writePref */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getrcpath", function() { return getrcpath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getrc", function() { return getrc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNativeMessengerVersion", function() { return getNativeMessengerVersion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBestEditor", function() { return getBestEditor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nativegate", function() { return nativegate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inpath", function() { return inpath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "firstinpath", function() { return firstinpath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "editor", function() { return editor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "read", function() { return read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "write", function() { return write; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "writerc", function() { return writerc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mkdir", function() { return mkdir; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "temp", function() { return temp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "move", function() { return move; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listDir", function() { return listDir; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "winFirefoxRestart", function() { return winFirefoxRestart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "run", function() { return run; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pyeval", function() { return pyeval; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getenv", function() { return getenv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clipboard", function() { return clipboard; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ff_cmdline", function() { return ff_cmdline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseProfilesIni", function() { return parseProfilesIni; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFirefoxDir", function() { return getFirefoxDir; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getProfileUncached", function() { return getProfileUncached; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getProfile", function() { return getProfile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getProfileName", function() { return getProfileName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getProfileDir", function() { return getProfileDir; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parsePrefs", function() { return parsePrefs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadPrefs", function() { return loadPrefs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPrefs", function() { return getPrefs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPref", function() { return getPref; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getConfElsePref", function() { return getConfElsePref; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getConfElsePrefElseDefault", function() { return getConfElsePrefElseDefault; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "writePref", function() { return writePref; });
/* harmony import */ var semver_compare__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! semver-compare */ "./node_modules/semver-compare/index.js");
/* harmony import */ var semver_compare__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver_compare__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _src_lib_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @src/lib/config */ "./src/lib/config.ts");
/* harmony import */ var _src_lib_webext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @src/lib/webext */ "./src/lib/webext.ts");
/* harmony import */ var _src_lib_logging__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @src/lib/logging */ "./src/lib/logging.ts");
/**
 * Background functions for the native messenger interface
 */




const logger = new _src_lib_logging__WEBPACK_IMPORTED_MODULE_3__["default"]("native");
const NATIVE_NAME = "tridactyl";
/**
 * Posts using the one-time message API; native is killed after message returns
 */
async function sendNativeMsg(cmd, opts, quiet = false) {
    const send = Object.assign({ cmd }, opts);
    let resp;
    logger.info(`Sending message: ${JSON.stringify(send)}`);
    try {
        resp = await _src_lib_webext__WEBPACK_IMPORTED_MODULE_2__["browserBg"].runtime.sendNativeMessage(NATIVE_NAME, send);
        logger.info(`Received response:`, resp);
        return resp;
    }
    catch (e) {
        if (!quiet) {
            throw new Error("Failed to send message to native messenger. If it is correctly installed (run `:native`), please report this bug on https://github.com/tridactyl/tridactyl/issues .");
        }
    }
}
async function getrcpath() {
    const res = await sendNativeMsg("getconfigpath", {});
    if (res.code !== 0)
        throw new Error("getrcpath error: " + res.code);
    return res.content;
}
async function getrc() {
    const res = await sendNativeMsg("getconfig", {});
    if (res.content && !res.error) {
        logger.info(`Successfully retrieved fs config:\n${res.content}`);
        return res.content;
    }
    else {
        // Have to make this a warning as async exceptions apparently don't get caught
        logger.info(`Error in retrieving config: ${res.error}`);
    }
}
async function getNativeMessengerVersion(quiet = false) {
    const res = await sendNativeMsg("version", {}, quiet);
    if (res === undefined) {
        if (quiet)
            return undefined;
        throw `Error retrieving version: ${res.error}`;
    }
    if (res.version && !res.error) {
        logger.info(`Native version: ${res.version}`);
        return res.version;
    }
}
async function getBestEditor() {
    let gui_candidates = [];
    let term_emulators = [];
    let tui_editors = [];
    let last_resorts = [];
    if ((await _src_lib_webext__WEBPACK_IMPORTED_MODULE_2__["browserBg"].runtime.getPlatformInfo()).os === "mac") {
        gui_candidates = [
            "/Applications/MacVim.app/Contents/bin/mvim -f",
            "/usr/local/bin/vimr --wait --nvim +only",
        ];
        // if anyone knows of any "sensible" terminals that let you send them commands to run,
        // please let us know in issue #451!
        term_emulators = [
            "/Applications/cool-retro-term.app/Contents/MacOS/cool-retro-term -e",
        ];
        last_resorts = ["open -nWt"];
    }
    else {
        // Tempted to put this behind another config setting: prefergui
        gui_candidates = ["gvim -f"];
        // we generally try to give the terminal the class "tridactyl_editor" so that
        // it can be made floating, e.g in i3:
        // for_window [class="tridactyl_editor"] floating enable border pixel 1
        term_emulators = [
            "st -c tridactyl_editor",
            "xterm -class tridactyl_editor -e",
            "uxterm -class tridactyl_editor -e",
            "urxvt -e",
            "alacritty -e",
            // Terminator and termite require  -e commands to be in quotes
            'terminator -u -e "%c"',
            'termite --class tridactyl_editor -e "%c"',
            "sakura --class tridactyl_editor -e",
            "lilyterm -e",
            "mlterm -e",
            "roxterm -e",
            "cool-retro-term -e",
        ];
        last_resorts = [
            "emacs",
            "gedit",
            "kate",
            "abiword",
            "sublime",
            "atom -w",
        ];
    }
    tui_editors = ["vim %f", "nvim %f", "nano %f", "emacs -nw %f"];
    // Consider GUI editors
    let cmd = await firstinpath(gui_candidates);
    if (cmd === undefined) {
        // Try to find a terminal emulator
        cmd = await firstinpath(term_emulators);
        if (cmd !== undefined) {
            // and a text editor
            const tuicmd = await firstinpath(tui_editors);
            if (cmd.includes("%c")) {
                cmd = cmd.replace("%c", tuicmd);
            }
            else {
                cmd = cmd + " " + tuicmd;
            }
        }
        else {
            // or fall back to some really stupid stuff
            cmd = await firstinpath(last_resorts);
        }
    }
    return cmd;
}
/**
 * Used internally to gate off functions that use the native messenger. Gives a
 * helpful error message in the command line if the native messenger is not
 * installed, or is the wrong version.
 *
 * @arg version: A string representing the minimal required version.
 * @arg interactive: True if a message should be displayed on version mismatch.
 * @return false if the required version is higher than the currently available
 * native messenger version.
 */
async function nativegate(version = "0", interactive = true, desiredOS = ["mac", "win", "linux", "openbsd"]) {
    if (!desiredOS.includes((await _src_lib_webext__WEBPACK_IMPORTED_MODULE_2__["browserBg"].runtime.getPlatformInfo()).os)) {
        if (interactive) {
            logger.error("# Tridactyl's native messenger doesn't support your operating system, yet.");
        }
        return false;
    }
    try {
        const actualVersion = await getNativeMessengerVersion();
        if (actualVersion !== undefined) {
            if (semver_compare__WEBPACK_IMPORTED_MODULE_0__(version, actualVersion) > 0) {
                if (interactive)
                    logger.error("# Please update to native messenger " +
                        version +
                        ", for example by running `:updatenative`.");
                // TODO: add update procedure and document here.
                return false;
            }
            return true;
        }
        else if (interactive)
            logger.error("# Native messenger not found. Please run `:installnative` and follow the instructions.");
        return false;
    }
    catch (e) {
        if (interactive)
            logger.error("# Native messenger not found. Please run `:installnative` and follow the instructions.");
        return false;
    }
}
async function inpath(cmd) {
    const pathcmd = (await _src_lib_webext__WEBPACK_IMPORTED_MODULE_2__["browserBg"].runtime.getPlatformInfo()).os === "win"
        ? "where "
        : "which ";
    return (await run(pathcmd + cmd.split(" ")[0])).code === 0;
}
async function firstinpath(cmdarray) {
    let ind = 0;
    let cmd = cmdarray[ind];
    // Try to find a text editor
    while (!(await inpath(cmd.split(" ")[0]))) {
        ind++;
        cmd = cmdarray[ind];
        if (cmd === undefined)
            break;
    }
    return cmd;
}
async function editor(file, line, col, content) {
    if (content !== undefined)
        await write(file, content);
    const editorcmd = (_src_lib_config__WEBPACK_IMPORTED_MODULE_1__["get"]("editorcmd") === "auto"
        ? await getBestEditor()
        : _src_lib_config__WEBPACK_IMPORTED_MODULE_1__["get"]("editorcmd"))
        .replace(/%l/, line)
        .replace(/%c/, col);
    let exec;
    if (editorcmd.indexOf("%f") !== -1) {
        exec = await run(editorcmd.replace(/%f/, file));
    }
    else {
        exec = await run(editorcmd + " " + file);
    }
    if (exec.code != 0)
        return exec;
    return read(file);
}
async function read(file) {
    return sendNativeMsg("read", { file }).catch(e => {
        throw `Failed to read ${file}. ${e}`;
    });
}
async function write(file, content) {
    return sendNativeMsg("write", { file, content }).catch(e => {
        throw `Failed to write '${content}' to '${file}'. ${e}`;
    });
}
async function writerc(file, force, content) {
    return sendNativeMsg("writerc", { file, force, content }).catch(e => {
        throw `Failed to write '${content}' to '${file}'. ${e}`;
    });
}
async function mkdir(dir, exist_ok) {
    return sendNativeMsg("mkdir", { dir, exist_ok }).catch(e => {
        throw `Failed to create directory '${dir}'. ${e}`;
    });
}
async function temp(content, prefix) {
    return sendNativeMsg("temp", { content, prefix }).catch(e => {
        throw `Failed to write '${content}' to temp file '${prefix}'. ${e}`;
    });
}
async function move(from, to) {
    return sendNativeMsg("move", { from, to }).catch(e => {
        throw `Failed to move '${from}' to '${to}'. ${e}.`;
    });
}
async function listDir(dir) {
    return sendNativeMsg("list_dir", { path: dir }).catch(e => {
        throw `Failed to read directory '${dir}'. ${e}`;
    });
}
async function winFirefoxRestart(profiledir, browsercmd) {
    const required_version = "0.1.6";
    if (!(await nativegate(required_version, false))) {
        throw `'restart' on Windows needs native messenger version >= ${required_version}.`;
    }
    return sendNativeMsg("win_firefox_restart", { profiledir, browsercmd });
}
async function run(command, content = "") {
    const msg = await sendNativeMsg("run", { command, content });
    logger.info(msg);
    return msg;
}
/** Evaluates a string in the native messenger. This has to be python code. If
 *  you want to run shell strings, use run() instead.
 */
async function pyeval(command) {
    return sendNativeMsg("eval", { command });
}
async function getenv(variable) {
    const required_version = "0.1.2";
    if (!(await nativegate(required_version, false))) {
        throw `'getenv' needs native messenger version >= ${required_version}.`;
    }
    return (await sendNativeMsg("env", { var: variable })).content;
}
/** Calls an external program, to either set or get the content of the X selection.
 *  When setting the selection or if getting it failed, will return an empty string.
 **/
async function clipboard(action, str) {
    let clipcmd = await _src_lib_config__WEBPACK_IMPORTED_MODULE_1__["get"]("externalclipboardcmd");
    if (clipcmd === "auto")
        clipcmd = await firstinpath(["xsel", "xclip"]);
    if (clipcmd === undefined) {
        throw new Error("Couldn't find an external clipboard executable");
    }
    if (action === "get") {
        const result = await run(clipcmd + " -o");
        if (result.code !== 0) {
            throw new Error(`External command failed with code ${result.code}: ${clipcmd}`);
        }
        return result.content;
    }
    else if (action === "set") {
        const required_version = "0.1.7";
        if (await nativegate(required_version, false)) {
            const result = await run(`${clipcmd} -i`, str);
            if (result.code !== 0)
                throw new Error(`External command failed with code ${result.code}: ${clipcmd}`);
            return "";
        }
        else {
            // Fall back to hacky old fashioned way
            // We're going to pretend that we don't know about stdin, and we need to insert str, which we can't trust, into the clipcmd
            // In order to do this safely we'll use here documents:
            // http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_07_04
            // Find a delimiter that isn't in str
            let heredoc = "TRIDACTYL";
            while (str.search(heredoc) !== -1)
                heredoc += Math.round(Math.random() * 10);
            // Use delimiter to insert str into clipcmd's stdin
            // We use sed to remove the newline added by the here document
            clipcmd = `sed -z 's/.$//' <<'${heredoc}' | ${clipcmd} -i \n${str}\n${heredoc}`;
            await run(clipcmd);
            return "";
        }
    }
    throw new Error("Unknown action!");
}
/** This returns the commandline that was used to start firefox.
 You'll get both firefox binary (not necessarily an absolute path) and flags */
async function ff_cmdline() {
    // Using ' and + rather that ` because we don't want newlines
    if ((await _src_lib_webext__WEBPACK_IMPORTED_MODULE_2__["browserBg"].runtime.getPlatformInfo()).os === "win") {
        throw `Error: "ff_cmdline() is currently broken on Windows and should be avoided."`;
    }
    else {
        const output = await pyeval('handleMessage({"cmd": "run", ' +
            '"command": "ps -p " + str(os.getppid()) + " -oargs="})["content"]');
        return output.content.trim().split(" ");
    }
}
async function parseProfilesIni(content, basePath) {
    const lines = content.split("\n");
    let current = "General";
    const result = {};
    for (const line of lines) {
        let match = line.match(/^\[([^\]]+)\]$/);
        if (match !== null) {
            current = match[1];
            result[current] = {};
        }
        else {
            match = line.match(/^([^=]+)=([^=]+)$/);
            if (match !== null) {
                result[current][match[1]] = match[2];
            }
        }
    }
    for (const profileName of Object.keys(result)) {
        const profile = result[profileName];
        // New profiles.ini have a useless section at the top
        if (profile.Path == undefined) {
            delete result[profileName];
            continue;
        }
        // On windows, profiles.ini paths will be expressed with `/`, but we're
        // on windows, so we need `\`
        if ((await _src_lib_webext__WEBPACK_IMPORTED_MODULE_2__["browserBg"].runtime.getPlatformInfo()).os === "win") {
            profile.Path = profile.Path.replace("/", "\\");
        }
        // profile.IsRelative can be 0, 1 or undefined
        if (profile.IsRelative === "1") {
            profile.relativePath = profile.Path;
            profile.absolutePath = basePath + profile.relativePath;
        }
        else if (profile.IsRelative === "0") {
            if (profile.Path.substring(0, basePath.length) !== basePath) {
                throw new Error(`Error parsing profiles ini: basePath "${basePath}" doesn't match profile path ${profile.Path}`);
            }
            profile.relativePath = profile.Path.substring(basePath.length);
            profile.absolutePath = profile.Path;
        }
    }
    return result;
}
async function getFirefoxDir() {
    switch ((await _src_lib_webext__WEBPACK_IMPORTED_MODULE_2__["browserBg"].runtime.getPlatformInfo()).os) {
        case "win":
            return getenv("APPDATA").then(path => path + "\\Mozilla\\Firefox\\");
        case "mac":
            return getenv("HOME").then(path => path + "/Library/Application Support/Firefox/");
        default:
            return getenv("HOME").then(path => path + "/.mozilla/firefox/");
    }
}
async function getProfileUncached() {
    const ffDir = await getFirefoxDir();
    const iniPath = ffDir + "profiles.ini";
    let iniObject = {};
    let iniSucceeded = false;
    const iniContent = await read(iniPath);
    if (iniContent.code === 0 && iniContent.content.length > 0) {
        try {
            iniObject = await parseProfilesIni(iniContent.content, ffDir);
            iniSucceeded = true;
        }
        catch (e) { }
    }
    const curProfileDir = _src_lib_config__WEBPACK_IMPORTED_MODULE_1__["get"]("profiledir");
    // First, try to see if the 'profiledir' setting matches a profile in profile.ini
    if (curProfileDir !== "auto") {
        if (iniSucceeded) {
            for (const profileName of Object.keys(iniObject)) {
                const profile = iniObject[profileName];
                if (profile.absolutePath === curProfileDir) {
                    return profile;
                }
            }
        }
        return {
            Name: undefined,
            IsRelative: "0",
            Path: curProfileDir,
            relativePath: undefined,
            absolutePath: curProfileDir,
        };
    }
    // Then, try to find a profile path in the arguments given to Firefox
    const cmdline = await ff_cmdline().catch(e => "");
    let profile = cmdline.indexOf("--profile");
    if (profile === -1)
        profile = cmdline.indexOf("-profile");
    if (profile >= 0 && profile < cmdline.length - 1) {
        const profilePath = cmdline[profile + 1];
        if (iniSucceeded) {
            for (const profileName of Object.keys(iniObject)) {
                const profile = iniObject[profileName];
                if (profile.absolutePath === profilePath) {
                    return profile;
                }
            }
        }
        // We're running in a profile that isn't stored in profiles.ini
        // Let's fill in the default info profile.ini profiles have anyway
        return {
            Name: undefined,
            IsRelative: "0",
            Path: profilePath,
            relativePath: undefined,
            absolutePath: profilePath,
        };
    }
    if (iniSucceeded) {
        // Try to find a profile name in firefox's arguments
        let p = cmdline.indexOf("-p");
        if (p === -1)
            p = cmdline.indexOf("-P");
        if (p >= 0 && p < cmdline.length - 1) {
            const pName = cmdline[p + 1];
            for (const profileName of Object.keys(iniObject)) {
                const profile = iniObject[profileName];
                if (profile.Name === pName) {
                    return profile;
                }
            }
            throw new Error(`native.ts:getProfile() : '${cmdline[p]}' found in command line arguments but no matching profile name found in "${iniPath}"`);
        }
    }
    // Still nothing, try to find a profile in use
    let hacky_profile_finder = `find "${ffDir}" -maxdepth 2 -name lock`;
    if ((await _src_lib_webext__WEBPACK_IMPORTED_MODULE_2__["browserBg"].runtime.getPlatformInfo()).os === "mac")
        hacky_profile_finder = `find "${ffDir}" -maxdepth 2 -name .parentlock`;
    const profilecmd = await run(hacky_profile_finder);
    if (profilecmd.code === 0 && profilecmd.content.length !== 0) {
        // Remove trailing newline
        profilecmd.content = profilecmd.content.trim();
        // If there's only one profile in use, use that to find the right profile
        if (profilecmd.content.split("\n").length === 1) {
            const path = profilecmd.content
                .split("/")
                .slice(0, -1)
                .join("/");
            if (iniSucceeded) {
                for (const profileName of Object.keys(iniObject)) {
                    const profile = iniObject[profileName];
                    if (profile.absolutePath === path) {
                        return profile;
                    }
                }
            }
            return {
                Name: undefined,
                IsRelative: "0",
                Path: path,
                relativePath: undefined,
                absolutePath: path,
            };
        }
    }
    if (iniSucceeded) {
        // Multiple profiles used but no -p or --profile, this means that we're using the default profile
        for (const profileName of Object.keys(iniObject)) {
            const profile = iniObject[profileName];
            if (profile.Default === 1 || profile.Default === "1") {
                return profile;
            }
        }
    }
    throw new Error(`Couldn't deduce which profile you want. See ':help profiledir'`);
}
// Disk operations are extremely slow on windows, let's cache our profile info
let cachedProfile;
async function getProfile() {
    if (cachedProfile === undefined)
        cachedProfile = await getProfileUncached();
    return cachedProfile;
}
// It makes sense to pre-fetch this value in the background script because it's
// long-lived. Other contexts are created and destroyed all the time so we
// don't want to pre-fetch in these.
if (Object(_src_lib_webext__WEBPACK_IMPORTED_MODULE_2__["getContext"])() === "background") {
    getProfile();
}
_src_lib_config__WEBPACK_IMPORTED_MODULE_1__["addChangeListener"]("profiledir", (prev, cur) => {
    cachedProfile = undefined;
    getProfile();
});
function getProfileName() {
    return getProfile().then(p => p.Name);
}
async function getProfileDir() {
    const profiledir = _src_lib_config__WEBPACK_IMPORTED_MODULE_1__["get"]("profiledir");
    if (profiledir !== "auto")
        return Promise.resolve(profiledir);
    return getProfile().then(p => p.absolutePath);
}
async function parsePrefs(prefFileContent) {
    //  This RegExp currently only deals with " but for correctness it should
    //  also deal with ' and `
    //  We could also just give up on parsing and eval() the whole thing
    const regex = new RegExp(/^(user_|sticky_|lock)?[pP]ref\("([^"]+)",\s*"?([^\)]+?)"?\);$/);
    // Fragile parsing
    return prefFileContent.split("\n").reduce((prefs, line) => {
        const matches = line.match(regex);
        if (!matches) {
            return prefs;
        }
        const key = matches[2];
        let value = matches[3];
        // value = " means that it should be an empty string
        if (value === '"')
            value = "";
        prefs[key] = value;
        return prefs;
    }, {});
}
/** When given the name of a firefox preference file, will load said file and
 *  return a promise for an object the keys of which correspond to preference
 *  names and the values of which correspond to preference values.
 *  When the file couldn't be loaded or doesn't contain any preferences, will
 *  return a promise for an empty object.
 */
async function loadPrefs(filename) {
    const result = await read(filename);
    if (result.code !== 0)
        return {};
    return parsePrefs(result.content);
}
let cached_prefs = null;
/** Returns a promise for an object that should contain every about:config
 *  setting.
 *
 *  Performance is slow so we need to cache the results.
 */
async function getPrefs() {
    if (cached_prefs !== null)
        return cached_prefs;
    const profile = (await getProfileDir()) + "/";
    const prefFiles = [
        // Debian has these
        "/usr/share/firefox/browser/defaults/preferences/firefox.js",
        "/usr/share/firefox/browser/defaults/preferences/debugger.js",
        "/usr/share/firefox/browser/defaults/preferences/devtools-startup-prefs.js",
        "/usr/share/firefox/browser/defaults/preferences/devtools.js",
        "/usr/share/firefox/browser/defaults/preferences/firefox-branding.js",
        "/usr/share/firefox/browser/defaults/preferences/vendor.js",
        "/usr/share/firefox/browser/defaults/preferences/firefox.js",
        "/etc/firefox/firefox.js",
        // Pref files can be found here:
        // https://developer.mozilla.org/en-US/docs/Mozilla/Preferences/A_brief_guide_to_Mozilla_preferences
        profile + "grepref.js",
        profile + "services/common/services-common.js",
        profile + "defaults/pref/services-sync.js",
        profile + "browser/app/profile/channel-prefs.js",
        profile + "browser/app/profile/firefox.js",
        profile + "browser/app/profile/firefox-branding.js",
        profile + "browser/defaults/preferences/firefox-l10n.js",
        profile + "prefs.js",
        profile + "user.js",
    ];
    const promises = [];
    // Starting all promises before awaiting because we want the calls to be
    // made in parallel
    for (const file of prefFiles) {
        promises.push(loadPrefs(file));
    }
    cached_prefs = promises.reduce(async (a, b) => Object.assign(await a, await b));
    return cached_prefs;
}
/** Returns the value for the corresponding about:config setting */
async function getPref(name) {
    return (await getPrefs())[name];
}
/** Fetches a config option from the config. If the option is undefined, fetch
 *  a preference from preferences. It would make more sense for this function to
 *  be in config.ts but this would require importing this file in config.ts and
 *  Webpack doesn't like circular dependencies.
 */
async function getConfElsePref(confName, prefName) {
    let option = await _src_lib_config__WEBPACK_IMPORTED_MODULE_1__["getAsyncDynamic"](confName);
    if (option === undefined) {
        try {
            option = await getPref(prefName);
        }
        catch (e) { }
    }
    return option;
}
/** Fetches a config option from the config. If the option is undefined, fetch
 *  prefName from the preferences. If prefName is undefined too, return a
 *  default.
 */
async function getConfElsePrefElseDefault(confName, prefName, def) {
    const option = await getConfElsePref(confName, prefName);
    if (option === undefined)
        return def;
    return option;
}
/** Writes a preference to user.js */
async function writePref(name, value) {
    if (cached_prefs)
        cached_prefs[name] = value;
    const file = (await getProfileDir()) + "/user.js";
    // No need to check the return code because read returns "" when failing to
    // read a file
    const text = (await read(file)).content;
    const prefPos = text.indexOf(`pref("${name}",`);
    if (prefPos < 0) {
        write(file, `${text}\nuser_pref("${name}", ${value});\n`);
    }
    else {
        let substr = text.substring(prefPos);
        const prefEnd = substr.indexOf(";\n");
        substr = text.substring(prefPos, prefPos + prefEnd);
        write(file, text.replace(substr, `pref("${name}", ${value})`));
    }
}


/***/ }),

/***/ "./src/lib/nearley_utils.ts":
/*!**********************************!*\
  !*** ./src/lib/nearley_utils.ts ***!
  \**********************************/
/*! exports provided: Parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Parser", function() { return Parser; });
/* harmony import */ var nearley__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nearley */ "./node_modules/nearley/lib/nearley.js");
/* harmony import */ var nearley__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(nearley__WEBPACK_IMPORTED_MODULE_0__);

/** Friendlier interface around nearley parsers */
class Parser {
    /* public results */
    constructor(grammar) {
        this.parser = new nearley__WEBPACK_IMPORTED_MODULE_0__["Parser"](nearley__WEBPACK_IMPORTED_MODULE_0__["Grammar"].fromCompiled(grammar));
        this.initial_state = this.parser.save();
        /* this.results = this.parser.results */
    }
    feedUntilError(input) {
        let lastResult;
        let consumedIndex = 0;
        try {
            for (const val of input) {
                this.parser.feed(val);
                lastResult = this.parser.results[0];
                consumedIndex++;
            }
        }
        finally {
            this.reset();
            if (lastResult === undefined) {
                throw "Error: no result!";
            }
            else {
                return [lastResult, input.slice(consumedIndex)];
            }
        }
    }
    reset() {
        this.parser.restore(this.initial_state);
    }
}


/***/ }),

/***/ "./src/lib/number.clamp.ts":
/*!*********************************!*\
  !*** ./src/lib/number.clamp.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 * Clamp a number n between two values lo, hi
 * such that if n is in [lo, hi], we return n
 * otherwise if n < lo, return lo
 * else return hi.
 */
Number.prototype.clamp = function (lo, hi) {
    return Math.max(lo, Math.min(this, hi));
};


/***/ }),

/***/ "./src/lib/number.mod.ts":
/*!*******************************!*\
  !*** ./src/lib/number.mod.ts ***!
  \*******************************/
/*! exports provided: knuth_mod, my_mod, euclid_mod */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "knuth_mod", function() { return knuth_mod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "my_mod", function() { return my_mod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "euclid_mod", function() { return euclid_mod; });
/** Number theory-friendly modulo implementation

    If divisor is positive, return value will be too.
*/
Number.prototype.mod = function (n) {
    return knuth_mod(this, n);
};
/** Takes sign of divisor -- incl. returning -0 */
function knuth_mod(dividend, divisor) {
    return dividend - divisor * Math.floor(dividend / divisor);
}
/** Equivalent to knuth_mod but doesn't return -0 */
function my_mod(dividend, divisor) {
    return (dividend % divisor + divisor) % divisor;
}
/** Always gives a positive result.

    Equivalent to knuth_mod when divisor is +ve
    Equivalent to % when dividend is +ve
*/
function euclid_mod(dividend, divisor) {
    const abs_divisor = Math.abs(divisor);
    const quotient = Math.floor(dividend / abs_divisor);
    return dividend - abs_divisor * quotient;
}


/***/ }),

/***/ "./src/lib/url_util.ts":
/*!*****************************!*\
  !*** ./src/lib/url_util.ts ***!
  \*****************************/
/*! exports provided: incrementUrl, getUrlRoot, getUrlParent, getDownloadFilenameForUrl, deleteQuery, setQueryValue, replaceQueryValue, graftUrlPath, interpolateSearchItem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "incrementUrl", function() { return incrementUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUrlRoot", function() { return getUrlRoot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUrlParent", function() { return getUrlParent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDownloadFilenameForUrl", function() { return getDownloadFilenameForUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteQuery", function() { return deleteQuery; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setQueryValue", function() { return setQueryValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "replaceQueryValue", function() { return replaceQueryValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "graftUrlPath", function() { return graftUrlPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateSearchItem", function() { return interpolateSearchItem; });
/** URL handling utlity functions
 */
/** Increment the last number in a URL.
 *
 * (perhaps this could be made so you can select the "nth" number in a
 * URL rather than just the last one?)
 *
 * @param url       the URL to increment
 * @param count     increment step to advance by (can be negative)
 * @return          the incremented URL, or null if cannot be incremented
 */
function incrementUrl(url, count) {
    // Find the final number in a URL
    const matches = url.match(/(.*?)(\d+)(\D*)$/);
    // no number in URL - nothing to do here
    if (matches === null) {
        return null;
    }
    const [, pre, number, post] = matches;
    const newNumber = parseInt(number, 10) + count;
    let newNumberStr = String(newNumber > 0 ? newNumber : 0);
    // Re-pad numbers that were zero-padded to be the same length:
    // 0009 + 1 => 0010
    if (number.match(/^0/)) {
        while (newNumberStr.length < number.length) {
            newNumberStr = "0" + newNumberStr;
        }
    }
    return pre + newNumberStr + post;
}
/** Get the root of a URL
 *
 * @param url   the url to find the root of
 * @return      the root of the URL, or the original URL when the URL isn't
 *              suitable for finding the root of.
 */
function getUrlRoot(url) {
    // exclude these special protocols for now;
    if (/(about|mailto):/.test(url.protocol)) {
        return null;
    }
    // this works even for file:/// where the root is ""
    return new URL(url.protocol + "//" + (url.host || ""));
}
/** Get the parent of the current URL. Parent is determined as:
 *
 * * if there is a hash fragment, strip that, or
 * * If there is a query string, strip that, or
 * * Remove one level from the path if there is one, or
 * * Remove one subdomain from the front if there is one
 *
 * @param url               the URL to get the parent of
 * @param trailingSlash     whether the returned URL has a trailing slash
 * @param count             how many "generations" you wish to go back (1 = parent, 2 = grandparent, etc.)
 * @return                  the parent of the URL, or null if there is no parent
 */
function getUrlParent(url, trailingSlash, count = 1) {
    // Helper function.
    function gup(parent, trailingSlash, count) {
        if (count < 1) {
            // remove trailing slash(s) if desired
            if (!trailingSlash) {
                // remove 1 or more trailing slashes
                parent.pathname = parent.pathname.replace(/\/+$/, "");
            }
            return parent;
        }
        // strip, in turn, hash/fragment and query/search
        if (parent.hash) {
            parent.hash = "";
            return gup(parent, trailingSlash, count - 1);
        }
        if (parent.search) {
            parent.search = "";
            return gup(parent, trailingSlash, count - 1);
        }
        // empty path is '/'
        if (parent.pathname !== "/") {
            // Remove trailing slashes and everything to the next slash:
            parent.pathname = parent.pathname.replace(/\/[^\/]*?\/*$/, "/");
            return gup(parent, trailingSlash, count - 1);
        }
        // strip off the first subdomain if there is one
        {
            const domains = parent.host.split(".");
            // more than domain + TLD
            if (domains.length > 2) {
                // domains.pop()
                parent.host = domains.slice(1).join(".");
                return gup(parent, trailingSlash, count - 1);
            }
        }
        // nothing to trim off URL, so no parent
        return null;
    }
    // exclude these special protocols where parents don't really make sense
    if (/(about|mailto):/.test(url.protocol)) {
        return null;
    }
    const parent = new URL(url);
    return gup(parent, trailingSlash, count);
}
/** Very incomplete lookup of extension for common mime types that might be
 * encountered when saving elements on a page. There are NPM libs for this,
 * but this should cover 99% of basic cases
 *
 * @param mime  mime type to get extension for (eg 'image/png')
 *
 * @return an extension for that mimetype, or undefined if that type is not
 * supported
 */
function getExtensionForMimetype(mime) {
    const types = {
        "image/png": ".png",
        "image/jpeg": ".jpg",
        "image/gif": ".gif",
        "image/x-icon": ".ico",
        "image/svg+xml": ".svg",
        "image/tiff": ".tiff",
        "image/webp": ".webp",
        "text/plain": ".txt",
        "text/html": ".html",
        "text/css": ".css",
        "text/csv": ".csv",
        "text/calendar": ".ics",
        "application/octet-stream": ".bin",
        "application/javascript": ".js",
        "application/xhtml+xml": ".xhtml",
        "font/otf": ".otf",
        "font/woff": ".woff",
        "font/woff2": ".woff2",
        "font/ttf": ".ttf",
    };
    return types[mime] || "";
}
/** Get a suitable default filename for a given URL
 *
 * If the URL:
 *  - is a data URL, construct from the data and mimetype
 *  - has a path, use the last part of that (eg image.png, index.html)
 *  - otherwise, use the hostname of the URL
 *  - if that fails, "download"
 *
 * @param URL   the URL to make a filename for
 * @return      the filename according to the above rules
 */
function getDownloadFilenameForUrl(url) {
    // for a data URL, we have no really useful naming data intrinsic to the
    // data, so we construct one using the data and guessing an extension
    // from any mimetype
    if (url.protocol === "data:") {
        // data:[<mediatype>][;base64],<data>
        const [prefix, data] = url.pathname.split(",", 2);
        const [mediatype, b64] = prefix.split(";", 2);
        // take a 15-char prefix of the data as a reasonably unique name
        // sanitize in a very rough manner
        let filename = data
            .slice(0, 15)
            .replace(/[^a-zA-Z0-9_\-]/g, "_")
            .replace(/_{2,}/g, "_");
        // add a base64 prefix and the extension
        filename =
            (b64 ? b64 + "-" : "") +
                filename +
                getExtensionForMimetype(mediatype);
        return filename;
    }
    // if there's a useful path, use that directly
    if (url.pathname !== "/") {
        const paths = url.pathname.split("/").slice(1);
        // pop off empty pat bh tails
        // e.g. https://www.mozilla.org/en-GB/firefox/new/
        while (paths.length && !paths[paths.length - 1]) {
            paths.pop();
        }
        if (paths.length) {
            return paths.slice(-1)[0];
        }
    }
    // if there's no path, use the domain (otherwise the FF-provided
    // default is just "download"
    return url.hostname || "download";
}
/**
 * Get an Array of the queries in a URL.
 *
 * These could be like "query" or "query=val"
 */
function getUrlQueries(url) {
    let qys = [];
    if (url.search) {
        // get each query separately, leave the "?" off
        qys = url.search.slice(1).split("&");
    }
    return qys;
}
/**
 * Update a URL with a new array of queries
 */
function setUrlQueries(url, qys) {
    url.search = "";
    if (qys.length) {
        // rebuild string with the filtered list
        url.search = "?" + qys.join("&");
    }
}
/**
 * Delete a query (and its value) in a URL
 *
 * If a query appears multiple times (which is a bit odd),
 * all instances are removed
 *
 * @param url           the URL to act on
 * @param query         the query to delete
 *
 * @return              the modified URL
 */
function deleteQuery(url, matchQuery) {
    const newUrl = new URL(url.href);
    const qys = getUrlQueries(url);
    const new_qys = qys.filter(q => {
        return q.split("=")[0] !== matchQuery;
    });
    setUrlQueries(newUrl, new_qys);
    return newUrl;
}
/**
 * Sets the value of a query in a URL with a specific one
 *
 * @param url           the URL to act on
 * @param matchQuery    the query key to set the value for
 * @param value         the value to use
 */
function setQueryValue(url, matchQuery, value) {
    const newUrl = new URL(url.href);
    // get each query separately, leave the "?" off
    const qys = getUrlQueries(url);
    // if the query exists just replace it
    if (qys.map(q => q.split("=")[0]).includes(matchQuery)) {
        return replaceQueryValue(url, matchQuery, value);
    }
    // the query does not exist so add it
    qys.push(matchQuery + "=" + value);
    setUrlQueries(newUrl, qys);
    return newUrl;
}
/**
 * Replace the value of a query in a URL with a new one
 *
 * @param url           the URL to act on
 * @param matchQuery    the query key to replace the value for
 * @param newVal        the new value to use
 */
function replaceQueryValue(url, matchQuery, newVal) {
    const newUrl = new URL(url.href);
    // get each query separately, leave the "?" off
    const qys = getUrlQueries(url);
    const new_qys = qys.map(q => {
        const [key] = q.split("=");
        // found a matching query key
        if (q.split("=")[0] === matchQuery) {
            // return key=val or key as needed
            if (newVal) {
                return key + "=" + newVal;
            }
            else {
                return key;
            }
        }
        // don't touch it
        return q;
    });
    setUrlQueries(newUrl, new_qys);
    return newUrl;
}
/**
 * Graft a new path onto some parent of the current URL
 *
 * E.g. grafting "by-name/foobar" onto the 2nd parent path:
 *      example.com/items/by-id/42 -> example.com/items/by-name/foobar
 *
 * @param url       the URL to modify
 * @param newTail   the new "grafted" URL path tail
 * @param level     the graft point in terms of path levels
 *                      >= 0: start at / and count right
 *                      <0: start at the current path and count left
 */
function graftUrlPath(url, newTail, level) {
    const newUrl = new URL(url.href);
    // path parts, ignore first /
    const pathParts = url.pathname.split("/").splice(1);
    // more levels than we can handle
    // (remember, if level <0, we start at -1)
    if ((level >= 0 && level > pathParts.length) ||
        (level < 0 && -level - 1 > pathParts.length)) {
        return null;
    }
    const graftPoint = level >= 0 ? level : pathParts.length + level + 1;
    // lop off parts after the graft point
    pathParts.splice(graftPoint, pathParts.length - graftPoint);
    // extend part array with new parts
    pathParts.push(...newTail.split("/"));
    newUrl.pathname = pathParts.join("/");
    return newUrl;
}
/**
 * Interpolates a query or other search item into a URL
 *
 * If the URL pattern contains "%s", the query is interpolated there. If not,
 * it is appended to the end of the pattern.
 *
 * If the interpolation point is in the query string of the URL, it is
 * percent encoded, otherwise it is is inserted verbatim.
 *
 * @param urlPattern        a URL to interpolate/append a query to
 * @param query             a query to interpolate/append into the URL
 *
 * @return                  the URL with the query encoded (if needed) and
 *                          inserted at the relevant point
 */
function interpolateSearchItem(urlPattern, query) {
    const hasInterpolationPoint = urlPattern.href.includes("%s");
    let queryWords = query.split(" ");
    // percent-encode if theres a %s in the query string, or if we're apppending
    // and there's a query string
    if ((hasInterpolationPoint && urlPattern.search.includes("%s")) ||
        urlPattern.search !== "") {
        query = encodeURIComponent(query);
        queryWords = queryWords.map(w => encodeURIComponent(w));
    }
    // replace or append as needed
    if (hasInterpolationPoint) {
        const resultingURL = new URL(urlPattern.href.replace(/%s\d+/g, function (x) {
            const index = parseInt(x.slice(2), 10) - 1;
            if (index >= queryWords.length) {
                return "";
            }
            return queryWords[index];
        }));
        return new URL(resultingURL.href.replace("%s", query));
    }
    else {
        return new URL(urlPattern.href + query);
    }
}


/***/ }),

/***/ "./src/lib/webext.ts":
/*!***************************!*\
  !*** ./src/lib/webext.ts ***!
  \***************************/
/*! exports provided: inContentScript, getContext, browserBg, activeTab, activeTabId, activeTabContainerId, ownTab, ownTabId, ownTabContainer, activeTabContainer, firefoxVersionAtLeast, openInNewTab, openInNewWindow, openInTab */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inContentScript", function() { return inContentScript; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getContext", function() { return getContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "browserBg", function() { return browserBg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "activeTab", function() { return activeTab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "activeTabId", function() { return activeTabId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "activeTabContainerId", function() { return activeTabContainerId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ownTab", function() { return ownTab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ownTabId", function() { return ownTabId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ownTabContainer", function() { return ownTabContainer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "activeTabContainer", function() { return activeTabContainer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "firefoxVersionAtLeast", function() { return firefoxVersionAtLeast; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "openInNewTab", function() { return openInNewTab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "openInNewWindow", function() { return openInNewWindow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "openInTab", function() { return openInTab; });
/* harmony import */ var _src_lib_convert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/lib/convert */ "./src/lib/convert.ts");
/* harmony import */ var _src_lib_browser_proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @src/lib/browser_proxy */ "./src/lib/browser_proxy.ts");
/* harmony import */ var _src_lib_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @src/lib/config */ "./src/lib/config.ts");
/* harmony import */ var _src_lib_url_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @src/lib/url_util */ "./src/lib/url_util.ts");




function inContentScript() {
    return getContext() === "content";
}
/** WebExt code can be run from three contexts:

    Content script
    Extension page
    Background page
*/
function getContext() {
    if (!browser.tabs) {
        return "content";
    }
    else if (browser.runtime.getURL("_generated_background_page.html") ===
        window.location.href) {
        return "background";
    }
    else {
        return "extension";
    }
}
let browserBg;
// Make this library work for both content and background.
if (inContentScript()) {
    browserBg = _src_lib_browser_proxy__WEBPACK_IMPORTED_MODULE_1__["default"];
}
else {
    browserBg = browser;
}
/** The first active tab in the currentWindow.
 *
 * TODO: Highlander theory: Can there ever be more than one?
 *
 */
async function activeTab() {
    return (await browserBg.tabs.query({
        active: true,
        currentWindow: true,
    }))[0];
}
async function activeTabId() {
    return (await activeTab()).id;
}
async function activeTabContainerId() {
    return (await activeTab()).cookieStoreId;
}
async function ownTab() {
    // Warning: this relies on the owntab_background listener being set in messaging.ts in order to work
    return browser.runtime.sendMessage({ type: "owntab_background" });
}
async function ownTabId() {
    return (await ownTab()).id;
}
async function ownTabContainer() {
    return browserBg.contextualIdentities.get((await ownTab()).cookieStoreId);
}
async function activeTabContainer() {
    const containerId = await activeTabContainerId();
    if (containerId !== "firefox-default")
        return browserBg.contextualIdentities.get(containerId);
    else
        throw new Error("firefox-default is not a valid contextualIdentity (activeTabContainer)");
}
/** Compare major firefox versions */
async function firefoxVersionAtLeast(desiredmajor) {
    const versionstr = (await browserBg.runtime.getBrowserInfo()).version;
    const actualmajor = _src_lib_convert__WEBPACK_IMPORTED_MODULE_0__["toNumber"](versionstr.split(".")[0]);
    return actualmajor >= desiredmajor;
}
/** Simpler tabs.create option.

    If related = true && relatedopenpos = 'related' then open a new tab with
    some URL as if that URL had been middle clicked on the current tab. If
    relatedopenpos = 'next', open it as the next tab. If 'last', open it last
    and don't tell Firefox who opened it.

    Similarly for tabopenpos, but only tell FF that the newtab is related to
    the activeTab if tabopenpos == 'related'.

    i.e. place that tab just after the current tab and set openerTabId
*/
async function openInNewTab(url, kwargs = {
    active: true,
    related: false,
    cookieStoreId: undefined,
}) {
    const thisTab = await activeTab();
    const options = {
        active: kwargs.active,
        url,
        cookieStoreId: kwargs.cookieStoreId,
    };
    // Be nice to behrmann, #342
    let pos;
    if (kwargs.related)
        pos = _src_lib_config__WEBPACK_IMPORTED_MODULE_2__["get"]("relatedopenpos");
    else
        pos = _src_lib_config__WEBPACK_IMPORTED_MODULE_2__["get"]("tabopenpos");
    switch (pos) {
        case "next":
            options.index = thisTab.index + 1;
            if (kwargs.related && (await firefoxVersionAtLeast(57)))
                options.openerTabId = thisTab.id;
            break;
        case "last":
            // Infinity can't be serialised, apparently.
            options.index = (await browserBg.tabs.query({
                currentWindow: true,
            })).length;
            break;
        case "related":
            if (await firefoxVersionAtLeast(57)) {
                options.openerTabId = thisTab.id;
            }
            else {
                options.index = thisTab.index + 1;
            }
            break;
    }
    return browserBg.tabs.create(options);
}
// lazily copied from excmds.ts' winopen - forceURI really ought to be moved to lib/webext
// Should consider changing interface of this to match openInNewTab or vice versa
async function openInNewWindow(createData = {}) {
    browserBg.windows.create(createData);
}
async function openInTab(tab, opts = {}, strarr) {
    let address = strarr.join(" ");
    if (address === "") {
        address = _src_lib_config__WEBPACK_IMPORTED_MODULE_2__["get"]("newtab");
    }
    const index = address.indexOf(" ");
    let firstWord = address;
    if (index > -1)
        firstWord = address.substr(0, index);
    if (firstWord === "") {
        // No query, no newtab set, the user is asking for Tridactyl's newtab page
        return browserBg.tabs.update(tab.id, Object.assign({ url: "/static/newtab.html" }, opts));
    }
    // Perhaps the user typed a URL?
    if (/^[a-zA-Z0-9+.-]+:[^\s:]/.test(address)) {
        try {
            return browserBg.tabs.update(tab.id, Object.assign({ url: new URL(address).href }, opts));
        }
        catch (e) {
            // Not a problem, we'll treat address as a regular search query
        }
    }
    // `+ 1` because we want to get rid of the space
    const rest = address.substr(firstWord.length + 1);
    const searchurls = _src_lib_config__WEBPACK_IMPORTED_MODULE_2__["get"]("searchurls");
    if (searchurls[firstWord]) {
        const url = _src_lib_url_util__WEBPACK_IMPORTED_MODULE_3__["interpolateSearchItem"](new URL(searchurls[firstWord]), rest);
        // firstWord is a searchurl, so let's use that
        return browserBg.tabs.update(tab.id, Object.assign({ url: url.href }, opts));
    }
    const searchEngines = await browserBg.search.get();
    let engine = searchEngines.find(engine => engine.alias === firstWord);
    // Maybe firstWord is the name of a firefox search engine?
    if (engine !== undefined) {
        return browserBg.search.search({
            tabId: tab.id,
            engine: engine.name,
            query: rest,
        });
    }
    // Maybe it's a domain without protocol
    try {
        const url = new URL("http://" + address);
        // Ignore unlikely domains
        if (url.hostname.includes(".") || url.port || url.password) {
            return browserBg.tabs.update(tab.id, Object.assign({ url: url.href }, opts));
        }
    }
    catch (e) { }
    // Let's default to the user's search engine then
    // if firstWord is "search", remove it from the query.
    // This allows users to search for a URL or a word they defined as searchurl
    let queryString = address;
    if (firstWord === "search") {
        queryString = rest;
    }
    const enginename = _src_lib_config__WEBPACK_IMPORTED_MODULE_2__["get"]("searchengine");
    // firstWord is neither a searchurl nor a search engine, let's see if a search engine has been defined in Tridactyl
    if (enginename) {
        if (searchurls[enginename]) {
            const url = _src_lib_url_util__WEBPACK_IMPORTED_MODULE_3__["interpolateSearchItem"](new URL(searchurls[enginename]), queryString);
            return browserBg.tabs.update(tab.id, Object.assign({ url: url.href }, opts));
        }
        engine = searchEngines.find(engine => engine.alias === enginename);
        if (engine !== undefined) {
            return browserBg.search.search({
                tabId: tab.id,
                engine: engine.name,
                query: queryString,
            });
        }
    }
    // No search engine has been defined in Tridactyl, let's use firefox's default search engine
    return browserBg.search.search({ tabId: tab.id, query: queryString });
}


/***/ }),

/***/ "./src/parsers/genericmode.ts":
/*!************************************!*\
  !*** ./src/parsers/genericmode.ts ***!
  \************************************/
/*! exports provided: parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parser", function() { return parser; });
/* harmony import */ var _src_lib_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/lib/config */ "./src/lib/config.ts");
/* harmony import */ var _src_lib_keyseq__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @src/lib/keyseq */ "./src/lib/keyseq.ts");
/** Tridactyl helper mode */


function parser(conf, keys) {
    let maps = _src_lib_config__WEBPACK_IMPORTED_MODULE_0__["get"](conf);
    if (maps === undefined)
        throw new Error("No binds defined for this mode. Reload page with <C-r> and add binds, e.g. :bind --mode=[mode] <Esc> mode normal");
    // If so configured, translate keys using the key translation map
    if (_src_lib_config__WEBPACK_IMPORTED_MODULE_0__["get"]("keytranslatemodes")[conf] === "true") {
        const translationmap = _src_lib_config__WEBPACK_IMPORTED_MODULE_0__["get"]("keytranslatemap");
        _src_lib_keyseq__WEBPACK_IMPORTED_MODULE_1__["translateKeysUsingKeyTranslateMap"](keys, translationmap);
    }
    // Remove unbound keys
    maps = Object.entries(maps).filter(([k, v]) => v !== "");
    // Convert to KeyMap
    maps = _src_lib_keyseq__WEBPACK_IMPORTED_MODULE_1__["mapstrMapToKeyMap"](new Map(maps));
    return _src_lib_keyseq__WEBPACK_IMPORTED_MODULE_1__["parse"](keys, maps);
}


/***/ }),

/***/ "./src/perf.ts":
/*!*********************!*\
  !*** ./src/perf.ts ***!
  \*********************/
/*! exports provided: measured, measuredAsync, Marker, listenForCounters, StatsLogger, renderStatsHistogram, StatsFilter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "measured", function() { return measured; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "measuredAsync", function() { return measuredAsync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Marker", function() { return Marker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listenForCounters", function() { return listenForCounters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StatsLogger", function() { return StatsLogger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderStatsHistogram", function() { return renderStatsHistogram; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StatsFilter", function() { return StatsFilter; });
/* harmony import */ var _src_lib_messaging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/lib/messaging */ "./src/lib/messaging.ts");
/* harmony import */ var _src_lib_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @src/lib/config */ "./src/lib/config.ts");
/* harmony import */ var _src_lib_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @src/lib/math */ "./src/lib/math.ts");
/* harmony import */ var _src_lib_logging__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @src/lib/logging */ "./src/lib/logging.ts");
/**
 * Library used for measuring performance. The basic steps are as follows:
 *
 * 1. Set up a persistent StatsLogger object to store samples.
 * 2. Invoke listenForCounters with the StatsLogger to start logging
 *    performance counters to the stats logger.
 * 3. If you have other scripts (content, iframes, web workers, etc),
 *    set up to receive stats from those other sources:
 *    * Set the stats logger up with an attributeCaller receiving messages as
 *      "performance_background".
 *    * For each other context, invoke listenForCounters without arguments and
 *      hold on to the resulting object.
 * 4. Instrument methods using the @measured or @measuredAsync
 *    decorators (for class methods) or by using Marker objects in
 *    your functions.
 * 5. Collect data!
 * 6. Use getEntries to retrieve data from the statsLogger.
 */




const logger = new _src_lib_logging__WEBPACK_IMPORTED_MODULE_3__["Logger"]("performance");
/**
 * Decorator for performance measuring. If performance is enabled,
 * wraps the function call with performance marks and a measure that
 * can be used for profiling. The mark's ownerName will be the name of
 * the containing class and the functionName will be the name of the
 * function. For example:
 *
 * class Foo {
 *   @Perf.measured
 *   function doFoos() { stuff() }
 * }
 *
 * These counters can be obtained using listenForCounters and a
 * StatsLogger.
 *
 */
function measured(cls, propertyKey, descriptor) {
    if (!performanceApiAvailable())
        return;
    const originalMethod = descriptor.value;
    descriptor.value = function (...args) {
        const marker = new Marker(cls.constructor.name, propertyKey).start();
        const result = originalMethod.apply(this, args);
        marker.end();
        return result;
    };
    return descriptor;
}
/**
 * Like the @measured decorator, but properly handles async functions
 * by chaining a resolution onto the promise that marks completion
 * when the function resolves its promise.
 */
function measuredAsync(cls, propertyKey, descriptor) {
    if (!performanceApiAvailable())
        return;
    const originalMethod = descriptor.value;
    descriptor.value = async function (...args) {
        const marker = new Marker(cls.constructor.name, propertyKey).start();
        const result = await originalMethod.apply(this, args);
        marker.end();
        return result;
    };
    return descriptor;
}
/**
 * Convenience object for collecting timing information. Create it and
 * call start() to create a mark entry for the start of the duration
 * to measure. Later, call end() to create a mark entry for the end of
 * the duration and a measure entry for the duration from the start
 * mark to the end mark. Marks are given a unique identifier to ensure
 * that async, multi-threaded, or reentrant code doesn't have collisions.
 *
 * WARNING! Will SILENTLY DEACTIVATE ITSELF if the "perfcounters"
 * config option is not set to "true"! This is done to minimize the
 * performance overhead of instrumentation when performance counters
 * are turned off.
 *
 * The ownerName and functionName are encoded into the name of the
 * performance entry in a way that allows entries to be retrieved
 * using StatsFilters.
 *
 */
class Marker {
    constructor(ownerName, functionName, active = performanceApiAvailable() &&
        _src_lib_config__WEBPACK_IMPORTED_MODULE_1__["get"]("perfcounters") === "true", metricName = new MetricName(ownerName, functionName)) {
        this.active = active;
        this.metricName = metricName;
    }
    start() {
        if (!this.active)
            return this;
        logger.debug("Marking startpoint of performance counter for %o", this.metricName);
        performance.mark(this.metricName.startName);
        return this;
    }
    end() {
        if (!this.active)
            return this;
        logger.debug("Marking endpoint of performance counter for %o", this.metricName);
        performance.mark(this.metricName.endName);
        performance.measure(this.metricName.fullName, this.metricName.startName, this.metricName.endName);
        return this;
    }
}
/**
 * Start listening for performance counters. Note that you _must_
 * attach the returned PerformanceObserver to some long-lived object
 * like the window; there's some kind of bug that causes
 * PerformanceObservers to be incorrectly garbage-collected even if
 * they're still attached and observing.
 *
 * @param statsLogger If given, stats will be logged directly to the
 * given stats logger. If absent, stats will be sent to the
 * performance_background receiver using messaging.
 */
function listenForCounters(statsLogger) {
    let callback;
    if (statsLogger === undefined) {
        callback = (list, observer) => {
            sendStats(list.getEntries());
        };
    }
    else {
        callback = (list, observer) => {
            statsLogger.pushList(list.getEntries());
        };
    }
    const perfObserver = new PerformanceObserver(callback);
    perfObserver.observe({ entryTypes: ["mark", "measure"] });
    return perfObserver;
}
/**
 * Stores a bounded-size buffer of performance entries and provides
 * convenience functions for accessing subsets of the buffer. Very
 * simple circular buffer.
 */
class StatsLogger {
    constructor() {
        // TODO: Consider mapping each name to a symbol and storing the
        // mapped symbol instead of the name so we're storing more like 50
        // bytes per sample instead of 130 @_@
        this.buffer = [];
        this.idx = 0;
        this.buffersize = 10000;
        this.lastError = 0;
    }
    /**
     * Target for receiving stats entries from other threads - there
     * was some issue with encoding that I couldn't figure out so I
     * just kludged it.
     */
    receiveStatsJson(entriesJson) {
        this.pushList(JSON.parse(entriesJson));
    }
    /**
     * Ingests the given performance entries into the buffer.
     */
    pushList(entries) {
        for (const entry of entries) {
            this.pushEntry(entry);
        }
    }
    /**
     * Returns only entries that match _all_ of the given filter
     * configs.
     */
    getEntries(...filterConfigs) {
        // Explicit stream fusion, wheeeee.
        //
        // Well, sort of. We're not fusing all the way up to the regex
        // match, so that's a ton of duplicated work. Not that it
        // matters, since this should only ever be invoked when a
        // developer asks for data.
        const filters = filterConfigs.map(fc => new StatsFilter(fc));
        const filterFun = e => filters.every(f => f.matches(e));
        return this.buffer.filter(filterFun);
    }
    updateBuffersize() {
        // Changing the buffer length while this is running will
        // probably result in weirdness, but that shouldn't be a major
        // issue - it's not like we need these to be in order or
        // otherwise coherent, we're just trying to store a big pile
        // of recent-ish samples.
        const perfsamples = Number(_src_lib_config__WEBPACK_IMPORTED_MODULE_1__["get"]("perfsamples"));
        // Check for NaN or non-integer
        if (Number.isInteger(perfsamples)) {
            this.buffersize = perfsamples;
        }
        else {
            // This function could be called a hundred times a second
            // and would error out every single time if someone has
            // given an invalid config, so rate-limit the error log -
            // one every five seconds.
            if (performance.now() - this.lastError > 5000) {
                this.lastError = performance.now();
                logger.error("perfsamples must be an integer, is %O", perfsamples);
            }
        }
    }
    pushEntry(entry) {
        logger.debug("Pushing performance entry %o into performance counters", entry);
        // Drop samples that aren't for tridactyl, since performance
        // events are global and there are some badly-behaved
        // libraries spamming them all over our own data.
        if (!entry.name.startsWith(TRI_PERFORMANCE_NAME_PREFIX))
            return;
        // We depend on arrays auto-vivifying when elements past the
        // end are set to make this easy.
        this.buffer[this.idx] = entry;
        this.incrementIdx();
    }
    incrementIdx() {
        this.idx = (this.idx + 1) % this.buffersize;
    }
}
/**
 * Pretty-prints a pile of performance samples of type measure (others
 * won't work because they have duration zero or undefined) as a
 * horizontal ASCII histogram. Useful if you just want basic
 * statistics about performance and don't want to spend a bunch of
 * time mucking about in python or julia.
 *
 * A very small example of what you'll get:
 *
 *   0     ####
 *   125   ##########
 *   250   ###############
 *   375   ######
 *   500   ##
 *
 * @param samples A set of samples to plot.
 * @param buckets The number of bins to divide the samples into.
 * @param width The width of the chart.
 */
function renderStatsHistogram(samples, buckets = 15, width = 80) {
    const durs = samples.map(sample => sample.duration);
    const min = durs.reduce((a, b) => Math.min(a, b));
    const max = durs.reduce((a, b) => Math.max(a, b));
    const bucketvals = _src_lib_math__WEBPACK_IMPORTED_MODULE_2__["linspace"](min, max, buckets);
    const bucketed = _src_lib_math__WEBPACK_IMPORTED_MODULE_2__["bucketize"](durs, bucketvals);
    const maxcount = Array.from(bucketed.values()).reduce((a, b) => Math.max(a, b), 0);
    const labelwidth = 20;
    const barwidth = width - labelwidth;
    const tobarwidth = n => (barwidth * n) / maxcount;
    const result = [];
    for (const [bucketval, bucketcount] of bucketed.entries()) {
        const bar = "#".repeat(tobarwidth(bucketcount));
        const label = bucketval.toString().padEnd(labelwidth);
        result.push(label + bar);
    }
    return result.join("\n");
}
/**
 * Implements filtering of performance entries using the
 * StatsFilterConfig. Exposed so users of the library can do more
 * filtering themselves if they want to.
 */
class StatsFilter {
    constructor(config) {
        this.config = config;
    }
    matches(entry) {
        const metricNameInfo = extractMetricName(entry.name);
        if (this.config.kind === "functionName" &&
            this.config.functionName !== metricNameInfo.functionName) {
            return false;
        }
        if (this.config.kind === "ownerName" &&
            this.config.ownerName !== metricNameInfo.ownerName) {
            return false;
        }
        if (this.config.kind === "eventType" &&
            this.config.eventType !== entry.entryType) {
            return false;
        }
        return true;
    }
}
const TRI_PERFORMANCE_NAME_PREFIX = "tri";
function performanceApiAvailable() {
    return performance.mark !== undefined;
}
const extractRegExp = new RegExp(`^${TRI_PERFORMANCE_NAME_PREFIX}` +
    // owner name
    `/([^/]+)` +
    // function name
    `/([^:]+)` +
    // unique suffix
    `:([^:]+)`);
function extractMetricName(counterName) {
    const matchresult = counterName.match(extractRegExp);
    if (!matchresult)
        return;
    const [ownerName, functionName, uniqueSuffix] = matchresult.slice(1);
    return {
        ownerName,
        functionName,
        uniqueSuffix,
    };
}
class MetricName {
    constructor(ownerName, functionName) {
        const uniqueSuffix = Math.floor(Math.random() * Math.floor(1e6)).toString();
        this.fullName = `${TRI_PERFORMANCE_NAME_PREFIX}/${ownerName}/${functionName}:${uniqueSuffix}`;
        this.startName = `${this.fullName}:start`;
        this.endName = `${this.fullName}:end`;
    }
}
function sendStats(list) {
    _src_lib_messaging__WEBPACK_IMPORTED_MODULE_0__["message"]("performance_background", "receiveStatsJson", [
        JSON.stringify(list),
    ]);
}


/***/ }),

/***/ "./src/state.ts":
/*!**********************!*\
  !*** ./src/state.ts ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return state; });
/* harmony import */ var _src_lib_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/lib/logging */ "./src/lib/logging.ts");
/** Tridactyl shared state

    Any context with access to browser.storage can safely import this file and
    get a self-updating consistent copy of the shared program state.

    Any context may modify their copy of the state and that modification will
    be propagated to the rest of the program.

    This works by proxying the state object such that setting any property
    causes the entire state to be saved to storage and adding a listener that
    listens for storage events and updates the proxied object on each storage
    event.

    If this turns out to be expensive there are improvements available.
*/

const logger = new _src_lib_logging__WEBPACK_IMPORTED_MODULE_0__["default"]("state");
class State {
    constructor() {
        this.lastSearchQuery = undefined;
        this.cmdHistory = [];
        this.prevInputs = [
            {
                inputId: undefined,
                tab: undefined,
                jumppos: undefined,
            },
        ];
    }
}
// Don't change these from const or you risk breaking the Proxy below.
const defaults = Object.freeze(new State());
const overlay = {};
browser.storage.local
    .get("state")
    .then(res => {
    if ("state" in res) {
        logger.debug("Loaded initial state:", res.state);
        Object.assign(overlay, res.state);
    }
})
    .catch((...args) => logger.error(...args));
const state = (new Proxy(overlay, {
    /** Give defaults if overlay doesn't have the key */
    get(target, property) {
        if (property in target) {
            return target[property];
        }
        else {
            return defaults[property];
        }
    },
    /** Persist sets to storage immediately */
    set(target, property, value) {
        logger.debug("State changed!", property, value);
        target[property] = value;
        browser.storage.local.set({ state: target });
        return true;
    },
}));
browser.storage.onChanged.addListener((changes, areaname) => {
    if (areaname === "local" && "state" in changes) {
        Object.assign(overlay, changes.state.newValue);
    }
});



/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vY29tcGlsZXIvbWV0YWRhdGEvQWxsTWV0YWRhdGEudHMiLCJ3ZWJwYWNrOi8vLy4vY29tcGlsZXIvbWV0YWRhdGEvQ2xhc3NNZXRhZGF0YS50cyIsIndlYnBhY2s6Ly8vLi9jb21waWxlci9tZXRhZGF0YS9GaWxlTWV0YWRhdGEudHMiLCJ3ZWJwYWNrOi8vLy4vY29tcGlsZXIvbWV0YWRhdGEvUHJvZ3JhbU1ldGFkYXRhLnRzIiwid2VicGFjazovLy8uL2NvbXBpbGVyL21ldGFkYXRhL1N5bWJvbE1ldGFkYXRhLnRzIiwid2VicGFjazovLy8uL2NvbXBpbGVyL3R5cGVzL0FsbFR5cGVzLnRzIiwid2VicGFjazovLy8uL2NvbXBpbGVyL3R5cGVzL0FueVR5cGUudHMiLCJ3ZWJwYWNrOi8vLy4vY29tcGlsZXIvdHlwZXMvQXJyYXlUeXBlLnRzIiwid2VicGFjazovLy8uL2NvbXBpbGVyL3R5cGVzL0Jvb2xlYW5UeXBlLnRzIiwid2VicGFjazovLy8uL2NvbXBpbGVyL3R5cGVzL0Z1bmN0aW9uVHlwZS50cyIsIndlYnBhY2s6Ly8vLi9jb21waWxlci90eXBlcy9MaXRlcmFsVHlwZVR5cGUudHMiLCJ3ZWJwYWNrOi8vLy4vY29tcGlsZXIvdHlwZXMvTnVtYmVyVHlwZS50cyIsIndlYnBhY2s6Ly8vLi9jb21waWxlci90eXBlcy9PYmplY3RUeXBlLnRzIiwid2VicGFjazovLy8uL2NvbXBpbGVyL3R5cGVzL1N0cmluZ1R5cGUudHMiLCJ3ZWJwYWNrOi8vLy4vY29tcGlsZXIvdHlwZXMvVHVwbGVUeXBlLnRzIiwid2VicGFjazovLy8uL2NvbXBpbGVyL3R5cGVzL1R5cGVSZWZlcmVuY2VUeXBlLnRzIiwid2VicGFjazovLy8uL2NvbXBpbGVyL3R5cGVzL1VuaW9uVHlwZS50cyIsIndlYnBhY2s6Ly8vLi9jb21waWxlci90eXBlcy9Wb2lkVHlwZS50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MvbGliL3BhcnNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MvbGliL3N0cmluZ2lmeS9jb21waWxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzL2xpYi9zdHJpbmdpZnkvY29tcHJlc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy9saWIvc3RyaW5naWZ5L2lkZW50aXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MvbGliL3N0cmluZ2lmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzL2xpYi9zdHJpbmdpZnkvc291cmNlLW1hcC1zdXBwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mdXNlLmpzL2Rpc3QvZnVzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVhcmxleS9saWIvbmVhcmxleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Jlc29sdmUtdXJsL3Jlc29sdmUtdXJsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZW12ZXItY29tcGFyZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1yZXNvbHZlL3NvdXJjZS1tYXAtcmVzb2x2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC11cmwvc291cmNlLW1hcC11cmwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2FycmF5LXNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYmFzZTY0LXZscS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYmFzZTY0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iaW5hcnktc2VhcmNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9tYXBwaW5nLWxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3F1aWNrLXNvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAtY29uc3VtZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAtZ2VuZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2Utbm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9zb3VyY2UtbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91cml4L2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjLy5tZXRhZGF0YS5nZW5lcmF0ZWQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1hbmRsaW5lX2ZyYW1lLnRzIiwid2VicGFjazovLy8uL3NyYy9jb21wbGV0aW9ucy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcGxldGlvbnMvQm1hcmsudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBsZXRpb25zL0V4Y21kLnRzIiwid2VicGFjazovLy8uL3NyYy9jb21wbGV0aW9ucy9GaWxlU3lzdGVtLnRzIiwid2VicGFjazovLy8uL3NyYy9jb21wbGV0aW9ucy9HdWlzZXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBsZXRpb25zL0hlbHAudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBsZXRpb25zL0hpc3RvcnkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBsZXRpb25zL1ByZWZlcmVuY2VzLnRzIiwid2VicGFjazovLy8uL3NyYy9jb21wbGV0aW9ucy9Sc3MudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBsZXRpb25zL1Nlc3Npb25zLnRzIiwid2VicGFjazovLy8uL3NyYy9jb21wbGV0aW9ucy9TZXR0aW5ncy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcGxldGlvbnMvVGFiLnRzIiwid2VicGFjazovLy8uL3NyYy9jb21wbGV0aW9ucy9UYWJBbGwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBsZXRpb25zL1dpbmRvdy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcGxldGlvbnMvcHJvdmlkZXJzLnRzIiwid2VicGFjazovLy8uL3NyYy9jb250ZW50L3N0eWxpbmcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dyYW1tYXJzLy5icmFja2V0ZXhwci5nZW5lcmF0ZWQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9hbGlhc2VzLnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvYnJvd3Nlcl9wcm94eS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL2NvbW1hbmRsaW5lX2NtZHMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9jb25maWcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9jb250YWluZXJzLnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvY29udmVydC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL2Nzc191dGlsLnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvZWRpdG9yLnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvZWRpdG9yX3V0aWxzLnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvaHRtbC10YWdnZWQtdGVtcGxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9pdGVydG9vbHMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9rZXlzZXEudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9sb2dnaW5nLnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvbWF0aC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL21lc3NhZ2luZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL25hdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL25lYXJsZXlfdXRpbHMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9udW1iZXIuY2xhbXAudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9udW1iZXIubW9kLnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvdXJsX3V0aWwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi93ZWJleHQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhcnNlcnMvZ2VuZXJpY21vZGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BlcmYudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0YXRlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlE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QUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN1NBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIs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LCtDQUErQztBQUMvQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLEtBQUssSUFBSTtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYTtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7Ozs7Ozs7QUNwVEQ7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBMEM7QUFDaEQsSUFBSSxvQ0FBTyxPQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUEsb0dBQUM7QUFDbkIsR0FBRyxNQUFNLEVBSU47QUFDSCxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7Ozs7Ozs7O0FDeERELGdC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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzlHQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLHFEQUFROztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUM5RUEsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2pIQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLHFEQUFRO0FBQzNCLG1CQUFtQixtQkFBTyxDQUFDLHVFQUFpQjtBQUM1QyxlQUFlLG1CQUFPLENBQUMsK0RBQWE7QUFDcEMsZ0JBQWdCLG1CQUFPLENBQUMsaUVBQWM7QUFDdEMsZ0JBQWdCLG1CQUFPLENBQUMsaUVBQWM7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixNQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtDQUFrQztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0QsWUFBWTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGNBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3Q0FBd0M7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsbUJBQW1CLEVBQUU7QUFDcEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QyxxQkFBcUIsK0NBQStDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBLHFCQUFxQiw0QkFBNEI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ3huQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLGlFQUFjO0FBQ3RDLFdBQVcsbUJBQU8sQ0FBQyxxREFBUTtBQUMzQixlQUFlLG1CQUFPLENBQUMsK0RBQWE7QUFDcEMsa0JBQWtCLG1CQUFPLENBQUMscUVBQWdCOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUN4YUEsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixtQkFBTyxDQUFDLHFGQUF3QjtBQUN6RCxXQUFXLG1CQUFPLENBQUMscURBQVE7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGNBQWM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVILFVBQVU7QUFDVjs7QUFFQTs7Ozs7Ozs7Ozs7O0FDNVpBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtB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RSxLQUFLLENBQUMsRUFBRSxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLDBFQUFpQixDQUFDLFNBQVMsRUFBRSxDQUFDLElBQUksaUVBQVEsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ3BQLENBQUMsUUFBUSxFQUFFLElBQUksNkVBQWMsQ0FBQywyREFBMkQsRUFBRSxJQUFJLHFFQUFZLENBQUMsQ0FBQyxJQUFJLG1FQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxFQUFDLElBQUksa0VBQVMsQ0FBQyxJQUFJLG1FQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksMEVBQWlCLENBQUMsU0FBUyxFQUFFLENBQUMsSUFBSSxnRUFBTyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDdlMsQ0FBQyxZQUFZLEVBQUUsSUFBSSw2RUFBYyxDQUFDLHdEQUF3RCxFQUFFLElBQUkscUVBQVksQ0FBQyxDQUFDLElBQUksa0VBQVMsQ0FBQyxJQUFJLG1FQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksMEVBQWlCLENBQUMsU0FBUyxFQUFFLENBQUMsSUFBSSxnRUFBTyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDM1EsQ0FBQyxVQUFVLEVBQUUsSUFBSSw2RUFBYyxDQUFDLDZxQkFBNnFCLEVBQUUsSUFBSSxxRUFBWSxDQUFDLEVB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QUssQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO29CQUM5SyxDQUFDLFFBQVEsRUFBRSxJQUFJLDZFQUFjLENBQUMsd1FBQXdRLEVBQUUsSUFBSSxtRUFBVSxDQUFDLElBQUksR0FBRyxDQUFlLENBQUMsQ0FBQyxTQUFTLEVBQUUsSUFBSSxtRUFBVSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLElBQUksbUVBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxJQUFJLG1FQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUUsSUFBSSxtRUFBVSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsV0FBVyxFQUFFLElBQUksbUVBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLGFBQWEsRUFBRSxJQUFJLG1FQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxtRUFBVSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLElBQUksbUVBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxJQUFJLG1FQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxtRUFBVSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLElBQUksbUVBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxJQUFJLG1FQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxtRUFBVSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FB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QUFFLENBQUMsR0FBRyxFQUFFLElBQUksbUVBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxJQUFJLG1FQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsSUFBSSxtRUFBVSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFLElBQUksbUVBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxJQUFJLG1FQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxtRUFBVSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFLElBQUksbUVBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxJQUFJLG1FQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxtRUFBVSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLElBQUksbUVBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxJQUFJLG1FQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxtRUFBVSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsa0hBQWtILEVBQUUsSUFBSSxtRUFBVSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7b0JBQy8rQixDQUFDLFVBQVUsRUFBRSxJQUFJLDZFQUFjLENBQUMsRUFBRSxFQUFFLElBQUksbUVBQVUsQ0FBQyxJQUFJLEdBQUcsQ0FBZSxDQUFDLENBQUMsYUFBYSxFQUFFLElBQUksbUVBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxJQUFJLG1FQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxtRUFBVSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsU0FBUyxFQUFFLElBQUksbUVBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLFdBQVcsRUFBRSxJQUFJLG1FQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxhQUFhLEVBQUUsSUFBSSxtRUFBVSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsYUFBYSxFQUFFLElBQUksbUVBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLGNBQWMsRUFBRSxJQUFJLG1FQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxTQUFTLEVBQUUsSUFBSSxtRUFBVSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsU0FBUyxFQUFFLElBQUksbUVBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO29CQUNsaUIsQ0FBQyxrQkFBa0IsRUFBRSxJQUFJLDZFQUFjLENBQUMsc0dBQXNHLEVBQUUsSUFBSSxrRUFBUyxDQUFDLENBQUMsSUFBSSx3RUFBZSxDQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDOzRCQUN6TSxJQUFJLHdFQUFlLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztvQkFDbEUsQ0FBQyxlQUFlLEVBQUUsSUFBSSw2RUFBYyxDQUFDLCtHQUErRyxFQUFFLElBQUksa0VBQVMsQ0FBQyxJQUFJLG1FQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztvQkFDeE4sQ0FBQyxVQUFVLEVBQUUsSUFBSSw2RUFBYyxDQUFDLG1IQUFtSCxFQUFFLElBQUksbUVBQVUsQ0FBQyxJQUFJLEdBQUcsQ0FBZSxDQUFDLENBQUMsVUFBVSxFQUFFLElBQUksbUVBQVUsQ0FBQyxJQUFJLEdBQUcsQ0FBZSxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLFNBQVMsRUFBRSxJQUFJLG1FQUFVLENBQUMsSUFBSSxHQUFHLENBQWUsQ0FBQyxDQUFDLHFEQUFxRCxFQUFFLElBQUksbUVBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsSUFBSSxtRUFBVSxDQUFDLElBQUksR0FBRyxDQUFlLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLElBQUksbUVBQVUsQ0FBQyxJQUFJLEdBQUcsQ0FBZSxDQUFDLENBQUMsSUFBSSxFQUFFLElBQUksbUVBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUUsSUFBSSxtRUFBVSxDQUFDLElBQUksR0FBRyxDQUFlLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsU0FBUyxFQUFFLElBQUksbUVBQVUsQ0FBQyxJQUFJLEdBQUcsQ0FBZSxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLGtCQUFrQixFQUFFLElBQUksbUVBQVUsQ0FBQyxJQUFJLEdBQUcsQ0FBZSxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLGlCQUFpQixFQUFFLElBQUksbUVBQVUsQ0FBQyxJQUFJLEdBQUcsQ0FBZSxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLGdCQUFnQixFQUFFLElBQUksbUVBQVUsQ0FBQyxJQUFJLEdBQUcsQ0FBZSxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO29CQUM1OUIsQ0FBQyxpQkFBaUIsRUFBRSxJQUFJLDZFQUFjLENBQUMsKzFCQUErMUIsRUFBRSxJQUFJLG1FQUFVLENBQUMsSUFBSSxHQUFHLENBQWUsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO29CQUN4OEIsQ0FBQyxtQkFBbUIsRUFBRSxJQUFJLDZFQUFjLENBQUMscURBQXFELEVBQUUsSUFBSSxtRUFBVSxDQUFDLElBQUksR0FBRyxDQUFlLENBQUMsQ0FBQyxFQUFFLEVBQUUsSUFBSSxrRUFBUyxDQUFDLENBQUMsSUFBSSx3RUFBZSxDQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDO29DQUNwTSxJQUFJLHdFQUFlLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7b0JBQ3BGLENBQUMsYUFBYSxFQUFFLElBQUksNkVBQWMsQ0FBQyxnTUFBZ00sRUFBRSxJQUFJLGdFQUFPLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO29CQUN0USxDQUFDLFdBQVcsRUFBRSxJQUFJLDZFQUFjLENBQUMseUZBQXlGLEVBQUUsSUFBSSxtRUFBVSxDQUFDLElBQUksR0FBRyxDQUFlLENBQUMsQ0FBQyxPQUFPLEVBQUUsSUFBSSxtRUFBVSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFLElBQUksbUVBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxJQUFJLG1FQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxtRUFBVSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLElBQUksbUVBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxJQUFJLG1FQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsSUFBSSxtRUFBVSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsWUFBWSxFQUFFLElBQUksbUVBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxJQUFJLG1FQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsSUFBSSxtRUFBVSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLElBQUksbUVBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxJQUFJLG1FQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsSUFBSSxtRUFBVSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsTUFBTSxF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QUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEdBQUc7UUFDckIsT0FBTyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDM0QsT0FBTyxDQUFDO0FBQ1osQ0FBQzs7Ozs7Ozs7Ozs7O0FDcFNELENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLGFBQWE7QUFDYjtBQUNBLDJCQUEyQjtBQUMzQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixFQUFFO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtB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QUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDO0tBQ2pEO0FBQ0wsQ0FBQyxDQUFDO0FBRXlCIiwiZmlsZSI6ImNvbW1hbmRsaW5lX2ZyYW1lLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvY29tbWFuZGxpbmVfZnJhbWUudHNcIik7XG4iLCJleHBvcnQgeyBTeW1ib2xNZXRhZGF0YSB9IGZyb20gXCIuL1N5bWJvbE1ldGFkYXRhXCJcbmV4cG9ydCB7IENsYXNzTWV0YWRhdGEgfSBmcm9tIFwiLi9DbGFzc01ldGFkYXRhXCJcbmV4cG9ydCB7IEZpbGVNZXRhZGF0YSB9IGZyb20gXCIuL0ZpbGVNZXRhZGF0YVwiXG5leHBvcnQgeyBQcm9ncmFtTWV0YWRhdGEgfSBmcm9tIFwiLi9Qcm9ncmFtTWV0YWRhdGFcIlxuIiwiXG5pbXBvcnQgeyBTeW1ib2xNZXRhZGF0YSB9IGZyb20gXCIuL1N5bWJvbE1ldGFkYXRhXCJcblxuZXhwb3J0IGNsYXNzIENsYXNzTWV0YWRhdGEge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgbWVtYmVyczogTWFwPHN0cmluZywgU3ltYm9sTWV0YWRhdGE+ID0gbmV3IE1hcDxcbiAgICAgICAgICAgIHN0cmluZyxcbiAgICAgICAgICAgIFN5bWJvbE1ldGFkYXRhXG4gICAgICAgID4oKSxcbiAgICApIHt9XG5cbiAgICBwdWJsaWMgc2V0TWVtYmVyKG5hbWU6IHN0cmluZywgczogU3ltYm9sTWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzLnNldChuYW1lLCBzKVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRNZW1iZXIobmFtZTogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lbWJlcnMuZ2V0KG5hbWUpXG4gICAgfVxuXG4gICAgcHVibGljIGdldE1lbWJlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lbWJlcnMua2V5cygpXG4gICAgfVxuXG4gICAgcHVibGljIHRvQ29uc3RydWN0b3IoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBgbmV3IENsYXNzTWV0YWRhdGEobmV3IE1hcDxzdHJpbmcsIFN5bWJvbE1ldGFkYXRhPihbYCArXG4gICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMubWVtYmVycy5lbnRyaWVzKCkpXG4gICAgICAgICAgICAgICAgLm1hcCgoW24sIG1dKSA9PiBgWyR7SlNPTi5zdHJpbmdpZnkobil9LCAke20udG9Db25zdHJ1Y3RvcigpfV1gKVxuICAgICAgICAgICAgICAgIC5qb2luKFwiLFxcblwiKSArXG4gICAgICAgICAgICBgXSkpYFxuICAgICAgICApXG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ2xhc3NNZXRhZGF0YSB9IGZyb20gXCIuL0NsYXNzTWV0YWRhdGFcIlxuaW1wb3J0IHsgU3ltYm9sTWV0YWRhdGEgfSBmcm9tIFwiLi9TeW1ib2xNZXRhZGF0YVwiXG5cbmV4cG9ydCBjbGFzcyBGaWxlTWV0YWRhdGEge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgY2xhc3NlczogTWFwPHN0cmluZywgQ2xhc3NNZXRhZGF0YT4gPSBuZXcgTWFwPFxuICAgICAgICAgICAgc3RyaW5nLFxuICAgICAgICAgICAgQ2xhc3NNZXRhZGF0YVxuICAgICAgICA+KCksXG4gICAgICAgIHB1YmxpYyBmdW5jdGlvbnM6IE1hcDxzdHJpbmcsIFN5bWJvbE1ldGFkYXRhPiA9IG5ldyBNYXA8XG4gICAgICAgICAgICBzdHJpbmcsXG4gICAgICAgICAgICBTeW1ib2xNZXRhZGF0YVxuICAgICAgICA+KCksXG4gICAgKSB7fVxuXG4gICAgcHVibGljIHNldENsYXNzKG5hbWU6IHN0cmluZywgYzogQ2xhc3NNZXRhZGF0YSkge1xuICAgICAgICB0aGlzLmNsYXNzZXMuc2V0KG5hbWUsIGMpXG4gICAgfVxuXG4gICAgcHVibGljIGdldENsYXNzKG5hbWU6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGFzc2VzLmdldChuYW1lKVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNsYXNzZXMua2V5cygpKVxuICAgIH1cblxuICAgIHB1YmxpYyBzZXRGdW5jdGlvbihuYW1lOiBzdHJpbmcsIGY6IFN5bWJvbE1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuZnVuY3Rpb25zLnNldChuYW1lLCBmKVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRGdW5jdGlvbihuYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuY3Rpb25zLmdldChuYW1lKVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRGdW5jdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuZnVuY3Rpb25zLmVudHJpZXMoKSlcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0RnVuY3Rpb25OYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5mdW5jdGlvbnMua2V5cygpKVxuICAgIH1cblxuICAgIHB1YmxpYyB0b0NvbnN0cnVjdG9yKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgYG5ldyBGaWxlTWV0YWRhdGEobmV3IE1hcDxzdHJpbmcsIENsYXNzTWV0YWRhdGE+KFtgICtcbiAgICAgICAgICAgIEFycmF5LmZyb20odGhpcy5jbGFzc2VzLmVudHJpZXMoKSlcbiAgICAgICAgICAgICAgICAubWFwKChbbiwgY10pID0+IGBbJHtKU09OLnN0cmluZ2lmeShuKX0sICR7Yy50b0NvbnN0cnVjdG9yKCl9XWApXG4gICAgICAgICAgICAgICAgLmpvaW4oXCIsXFxuXCIpICtcbiAgICAgICAgICAgIGBdKSwgbmV3IE1hcDxzdHJpbmcsIFN5bWJvbE1ldGFkYXRhPihbYCArXG4gICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMuZnVuY3Rpb25zLmVudHJpZXMoKSlcbiAgICAgICAgICAgICAgICAubWFwKChbbiwgZl0pID0+IGBbJHtKU09OLnN0cmluZ2lmeShuKX0sICR7Zi50b0NvbnN0cnVjdG9yKCl9XWApXG4gICAgICAgICAgICAgICAgLmpvaW4oXCIsXFxuXCIpICtcbiAgICAgICAgICAgIGBdKSlgXG4gICAgICAgIClcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBGaWxlTWV0YWRhdGEgfSBmcm9tIFwiLi9GaWxlTWV0YWRhdGFcIlxuXG5leHBvcnQgY2xhc3MgUHJvZ3JhbU1ldGFkYXRhIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHVibGljIGZpbGVzOiBNYXA8c3RyaW5nLCBGaWxlTWV0YWRhdGE+ID0gbmV3IE1hcDxcbiAgICAgICAgICAgIHN0cmluZyxcbiAgICAgICAgICAgIEZpbGVNZXRhZGF0YVxuICAgICAgICA+KCksXG4gICAgKSB7fVxuXG4gICAgcHVibGljIHNldEZpbGUobmFtZTogc3RyaW5nLCBmaWxlOiBGaWxlTWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5maWxlcy5zZXQobmFtZSwgZmlsZSlcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0RmlsZShuYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsZXMuZ2V0KG5hbWUpXG4gICAgfVxuXG4gICAgcHVibGljIHRvQ29uc3RydWN0b3IoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBgbmV3IFByb2dyYW1NZXRhZGF0YShuZXcgTWFwPHN0cmluZywgRmlsZU1ldGFkYXRhPihbYCArXG4gICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMuZmlsZXMuZW50cmllcygpKVxuICAgICAgICAgICAgICAgIC5tYXAoKFtuLCBmXSkgPT4gYFske0pTT04uc3RyaW5naWZ5KG4pfSwgJHtmLnRvQ29uc3RydWN0b3IoKX1dYClcbiAgICAgICAgICAgICAgICAuam9pbihcIixcXG5cIikgK1xuICAgICAgICAgICAgYF0pKWBcbiAgICAgICAgKVxuICAgIH1cbn1cbiIsImltcG9ydCB7IFR5cGUgfSBmcm9tIFwiLi4vdHlwZXMvQWxsVHlwZXNcIlxuXG5leHBvcnQgY2xhc3MgU3ltYm9sTWV0YWRhdGEge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBkb2M6IHN0cmluZywgcHVibGljIHR5cGU6IFR5cGUsIHB1YmxpYyBoaWRkZW4gPSBmYWxzZSkge31cblxuICAgIHB1YmxpYyB0b0NvbnN0cnVjdG9yKCkge1xuICAgICAgICByZXR1cm4gYG5ldyBTeW1ib2xNZXRhZGF0YSgke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgdGhpcy5kb2MsXG4gICAgICAgICl9LCAke3RoaXMudHlwZS50b0NvbnN0cnVjdG9yKCl9LCAke3RoaXMuaGlkZGVufSlgXG4gICAgfVxufVxuIiwiZXhwb3J0IHsgVHlwZSB9IGZyb20gXCIuL1R5cGVcIlxuZXhwb3J0IHsgQW55VHlwZSB9IGZyb20gXCIuL0FueVR5cGVcIlxuZXhwb3J0IHsgQm9vbGVhblR5cGUgfSBmcm9tIFwiLi9Cb29sZWFuVHlwZVwiXG5leHBvcnQgeyBGdW5jdGlvblR5cGUgfSBmcm9tIFwiLi9GdW5jdGlvblR5cGVcIlxuZXhwb3J0IHsgTnVtYmVyVHlwZSB9IGZyb20gXCIuL051bWJlclR5cGVcIlxuZXhwb3J0IHsgT2JqZWN0VHlwZSB9IGZyb20gXCIuL09iamVjdFR5cGVcIlxuZXhwb3J0IHsgU3RyaW5nVHlwZSB9IGZyb20gXCIuL1N0cmluZ1R5cGVcIlxuZXhwb3J0IHsgVHlwZVJlZmVyZW5jZVR5cGUgfSBmcm9tIFwiLi9UeXBlUmVmZXJlbmNlVHlwZVwiXG5leHBvcnQgeyBWb2lkVHlwZSB9IGZyb20gXCIuL1ZvaWRUeXBlXCJcbmV4cG9ydCB7IEFycmF5VHlwZSB9IGZyb20gXCIuL0FycmF5VHlwZVwiXG5leHBvcnQgeyBMaXRlcmFsVHlwZVR5cGUgfSBmcm9tIFwiLi9MaXRlcmFsVHlwZVR5cGVcIlxuZXhwb3J0IHsgVHVwbGVUeXBlIH0gZnJvbSBcIi4vVHVwbGVUeXBlXCJcbmV4cG9ydCB7IFVuaW9uVHlwZSB9IGZyb20gXCIuL1VuaW9uVHlwZVwiXG4iLCJpbXBvcnQgeyBUeXBlIH0gZnJvbSBcIi4vVHlwZVwiXG5cbmV4cG9ydCBjbGFzcyBBbnlUeXBlIGltcGxlbWVudHMgVHlwZSB7XG4gICAgcHVibGljIGtpbmQgPSBcImFueVwiXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgaXNEb3REb3REb3QgPSBmYWxzZSwgcHVibGljIGlzUXVlc3Rpb24gPSBmYWxzZSkge31cblxuICAgIHB1YmxpYyB0b0NvbnN0cnVjdG9yKCkge1xuICAgICAgICByZXR1cm4gYG5ldyBBbnlUeXBlKCR7IXRoaXMuaXNEb3REb3REb3R9LCAke3RoaXMuaXNRdWVzdGlvbn0pYFxuICAgIH1cblxuICAgIHB1YmxpYyB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2luZFxuICAgIH1cblxuICAgIHB1YmxpYyBjb252ZXJ0KGFyZ3VtZW50KSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudFxuICAgIH1cbn1cbiIsImltcG9ydCB7IFR5cGUgfSBmcm9tIFwiLi9UeXBlXCJcblxuZXhwb3J0IGNsYXNzIEFycmF5VHlwZSBpbXBsZW1lbnRzIFR5cGUge1xuICAgIHB1YmxpYyBraW5kID0gXCJhcnJheVwiXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZWxlbVR5cGU6IFR5cGUsIHB1YmxpYyBpc0RvdERvdERvdCA9IGZhbHNlLCBwdWJsaWMgaXNRdWVzdGlvbiA9IGZhbHNlKSB7fVxuXG4gICAgcHVibGljIHRvQ29uc3RydWN0b3IoKSB7XG4gICAgICAgIHJldHVybiBgbmV3IEFycmF5VHlwZSgke3RoaXMuZWxlbVR5cGUudG9Db25zdHJ1Y3RvcigpfSwgJHt0aGlzLmlzRG90RG90RG90fSwgJHt0aGlzLmlzUXVlc3Rpb259KWBcbiAgICB9XG5cbiAgICBwdWJsaWMgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmVsZW1UeXBlLnRvU3RyaW5nKCl9W11gXG4gICAgfVxuXG4gICAgcHVibGljIGNvbnZlcnQoYXJndW1lbnQpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZ3VtZW50KSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhcmd1bWVudCA9IEpTT04ucGFyc2UoYXJndW1lbnQpXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBjb252ZXJ0ICR7YXJndW1lbnR9IHRvIGFycmF5OmApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJndW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBjb252ZXJ0ICR7YXJndW1lbnR9IHRvIGFycmF5OmApXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50Lm1hcCh2ID0+IHRoaXMuZWxlbVR5cGUuY29udmVydCh2KSlcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBUeXBlIH0gZnJvbSBcIi4vVHlwZVwiXG5cbmV4cG9ydCBjbGFzcyBCb29sZWFuVHlwZSBpbXBsZW1lbnRzIFR5cGUge1xuICAgIHB1YmxpYyBraW5kID0gXCJib29sZWFuXCJcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBpc0RvdERvdERvdCA9IGZhbHNlLCBwdWJsaWMgaXNRdWVzdGlvbiA9IGZhbHNlKSB7fVxuXG4gICAgcHVibGljIHRvQ29uc3RydWN0b3IoKSB7XG4gICAgICAgIHJldHVybiBgbmV3IEJvb2xlYW5UeXBlKCR7dGhpcy5pc0RvdERvdERvdH0sICR7dGhpcy5pc1F1ZXN0aW9ufSlgXG4gICAgfVxuXG4gICAgcHVibGljIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5raW5kXG4gICAgfVxuXG4gICAgcHVibGljIGNvbnZlcnQoYXJndW1lbnQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50ID09PSBcInRydWVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudCA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjb252ZXJ0ICR7YXJndW1lbnR9IHRvIGJvb2xlYW5cIilcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBUeXBlIH0gZnJvbSBcIi4vVHlwZVwiXG5cbmV4cG9ydCBjbGFzcyBGdW5jdGlvblR5cGUgaW1wbGVtZW50cyBUeXBlIHtcbiAgICBwdWJsaWMga2luZCA9IFwiZnVuY3Rpb25cIlxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGFyZ3M6IFR5cGVbXSwgcHVibGljIHJldDogVHlwZSwgcHVibGljIGlzRG90RG90RG90ID0gZmFsc2UsIHB1YmxpYyBpc1F1ZXN0aW9uID0gZmFsc2UpIHt9XG5cbiAgICBwdWJsaWMgdG9Db25zdHJ1Y3RvcigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGBuZXcgRnVuY3Rpb25UeXBlKFtgICtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgZXZlcnkgYXJndW1lbnQgdHlwZSB0byBpdHMgc3RyaW5nIGNvbnN0cnVjdG9yIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgICB0aGlzLmFyZ3MubWFwKGN1ciA9PiBjdXIudG9Db25zdHJ1Y3RvcigpKSArXG4gICAgICAgICAgICBgXSwgJHt0aGlzLnJldC50b0NvbnN0cnVjdG9yKCl9LCAke3RoaXMuaXNEb3REb3REb3R9LCAke3RoaXMuaXNRdWVzdGlvbn0pYFxuICAgICAgICApXG4gICAgfVxuXG4gICAgcHVibGljIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYCgke3RoaXMuYXJncy5tYXAoYSA9PiBhLnRvU3RyaW5nKCkpLmpvaW4oXCIsIFwiKX0pID0+ICR7dGhpcy5yZXQudG9TdHJpbmcoKX1gXG4gICAgfVxuXG4gICAgcHVibGljIGNvbnZlcnQoYXJndW1lbnQpIHtcbiAgICAgICAgLy8gUG9zc2libGUgc3RyYXRlZ2llczpcbiAgICAgICAgLy8gLSBldmFsKClcbiAgICAgICAgLy8gLSB3aW5kb3dbYXJndW1lbnRdXG4gICAgICAgIC8vIC0gdHJpLmV4Y21kc1thcmd1bWVudF1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb252ZXJzaW9uIHRvIGZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZDogJHthcmd1bWVudH1gKVxuICAgIH1cbn1cbiIsImltcG9ydCB7IFR5cGUgfSBmcm9tIFwiLi9UeXBlXCJcblxuZXhwb3J0IGNsYXNzIExpdGVyYWxUeXBlVHlwZSBpbXBsZW1lbnRzIFR5cGUge1xuICAgIHB1YmxpYyBraW5kID0gXCJMaXRlcmFsVHlwZVwiXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgdmFsdWU6IHN0cmluZywgcHVibGljIGlzRG90RG90RG90ID0gZmFsc2UsIHB1YmxpYyBpc1F1ZXN0aW9uID0gZmFsc2UpIHt9XG5cbiAgICBwdWJsaWMgdG9Db25zdHJ1Y3RvcigpIHtcbiAgICAgICAgcmV0dXJuIGBuZXcgTGl0ZXJhbFR5cGVUeXBlKCR7SlNPTi5zdHJpbmdpZnkodGhpcy52YWx1ZSl9LCAke3RoaXMuaXNEb3REb3REb3R9LCAke3RoaXMuaXNRdWVzdGlvbn0pYFxuICAgIH1cblxuICAgIHB1YmxpYyB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudmFsdWUpXG4gICAgfVxuXG4gICAgcHVibGljIGNvbnZlcnQoYXJndW1lbnQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50ID09PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQXJndW1lbnQgZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgdmFsdWUgKCR7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZVxuICAgICAgICAgICAgfSk6ICR7YXJndW1lbnR9YCxcbiAgICAgICAgKVxuICAgIH1cbn1cbiIsImltcG9ydCB7IFR5cGUgfSBmcm9tIFwiLi9UeXBlXCJcblxuZXhwb3J0IGNsYXNzIE51bWJlclR5cGUgaW1wbGVtZW50cyBUeXBlIHtcbiAgICBwdWJsaWMga2luZCA9IFwibnVtYmVyXCJcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihwdWJsaWMgaXNEb3REb3REb3QgPSBmYWxzZSwgcHVibGljIGlzUXVlc3Rpb24gPSBmYWxzZSkge31cblxuICAgIHB1YmxpYyB0b0NvbnN0cnVjdG9yKCkge1xuICAgICAgICByZXR1cm4gYG5ldyBOdW1iZXJUeXBlKCR7dGhpcy5pc0RvdERvdERvdH0sICR7dGhpcy5pc1F1ZXN0aW9ufSlgXG4gICAgfVxuXG4gICAgcHVibGljIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5raW5kXG4gICAgfVxuXG4gICAgcHVibGljIGNvbnZlcnQoYXJndW1lbnQpIHtcbiAgICAgICAgY29uc3QgbiA9IHBhcnNlRmxvYXQoYXJndW1lbnQpXG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKG4pKSB7XG4gICAgICAgICAgICByZXR1cm4gblxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgY29udmVydCB0byBudW1iZXI6ICR7YXJndW1lbnR9YClcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBUeXBlIH0gZnJvbSBcIi4vVHlwZVwiXG5cbmV4cG9ydCBjbGFzcyBPYmplY3RUeXBlIGltcGxlbWVudHMgVHlwZSB7XG4gICAgcHVibGljIGtpbmQgPSBcIm9iamVjdFwiXG5cbiAgICAvLyBOb3RlOiBhIG1hcCB0aGF0IGhhcyBhbiBlbXB0eSBrZXkgKFwiXCIpIHVzZXMgdGhlIGNvcnJlc3BvbmRpbmcgdHlwZSBhcyBkZWZhdWx0IHR5cGVcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgbWVtYmVyczogTWFwPHN0cmluZywgVHlwZT4gPSBuZXcgTWFwPHN0cmluZywgVHlwZT4oKSwgcHVibGljIGlzRG90RG90RG90ID0gZmFsc2UsIHB1YmxpYyBpc1F1ZXN0aW9uID0gZmFsc2UpIHt9XG5cbiAgICBwdWJsaWMgdG9Db25zdHJ1Y3RvcigpIHtcbiAgICAgICAgcmV0dXJuIGBuZXcgT2JqZWN0VHlwZShuZXcgTWFwPHN0cmluZywgVHlwZT4oW2AgK1xuICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLm1lbWJlcnMuZW50cmllcygpKS5tYXAoKFtuLCBtXSkgPT4gYFske0pTT04uc3RyaW5naWZ5KG4pfSwgJHttLnRvQ29uc3RydWN0b3IoKX1dYClcbiAgICAgICAgICAgIC5qb2luKFwiLCBcIikgK1xuICAgICAgICBgXSksICR7dGhpcy5pc0RvdERvdERvdH0sICR7dGhpcy5pc1F1ZXN0aW9ufSlgXG4gICAgfVxuXG4gICAgcHVibGljIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5raW5kXG4gICAgfVxuXG4gICAgcHVibGljIGNvbnZlcnRNZW1iZXIobWVtYmVyTmFtZTogc3RyaW5nW10sIG1lbWJlclZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgbGV0IHR5cGUgPSB0aGlzLm1lbWJlcnMuZ2V0KG1lbWJlck5hbWVbMF0pXG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgLy8gTm8gdHlwZSwgdHJ5IHRvIGdldCB0aGUgZGVmYXVsdCB0eXBlXG4gICAgICAgICAgICB0eXBlID0gdGhpcy5tZW1iZXJzLmdldChcIlwiKVxuICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gaW5mbyBmb3IgdGhpcyBtZW1iZXIgYW5kIG5vIGRlZmF1bHQgdHlwZSwgYW55dGhpbmcgZ29lc1xuICAgICAgICAgICAgICAgIHJldHVybiBtZW1iZXJWYWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlLmtpbmQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiAodHlwZSBhcyBPYmplY3RUeXBlKS5jb252ZXJ0TWVtYmVyKG1lbWJlck5hbWUuc2xpY2UoMSksIG1lbWJlclZhbHVlKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlLmNvbnZlcnQobWVtYmVyVmFsdWUpXG4gICAgfVxuXG4gICAgcHVibGljIGNvbnZlcnQoYXJndW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGFyZ3VtZW50KVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGNvbnZlcnQgdG8gb2JqZWN0OiAke2FyZ3VtZW50fWApXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBUeXBlIH0gZnJvbSBcIi4vVHlwZVwiXG5cbmV4cG9ydCBjbGFzcyBTdHJpbmdUeXBlIGltcGxlbWVudHMgVHlwZSB7XG4gICAgcHVibGljIGtpbmQgPSBcInN0cmluZ1wiXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgaXNEb3REb3REb3QgPSBmYWxzZSwgcHVibGljIGlzUXVlc3Rpb24gPSBmYWxzZSkge31cblxuICAgIHB1YmxpYyB0b0NvbnN0cnVjdG9yKCkge1xuICAgICAgICByZXR1cm4gYG5ldyBTdHJpbmdUeXBlKCR7dGhpcy5pc0RvdERvdERvdH0sICR7dGhpcy5pc1F1ZXN0aW9ufSlgXG4gICAgfVxuXG4gICAgcHVibGljIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5raW5kXG4gICAgfVxuXG4gICAgcHVibGljIGNvbnZlcnQoYXJndW1lbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBjb252ZXJ0IHRvIHN0cmluZzogJHthcmd1bWVudH1gKVxuICAgIH1cbn1cbiIsImltcG9ydCB7IFR5cGUgfSBmcm9tIFwiLi9UeXBlXCJcblxuZXhwb3J0IGNsYXNzIFR1cGxlVHlwZSBpbXBsZW1lbnRzIFR5cGUge1xuICAgIHB1YmxpYyBraW5kID0gXCJ0dXBsZVwiXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZWxlbVR5cGVzOiBUeXBlW10sIHB1YmxpYyBpc0RvdERvdERvdCA9IGZhbHNlLCBwdWJsaWMgaXNRdWVzdGlvbiA9IGZhbHNlKSB7fVxuXG4gICAgcHVibGljIHRvQ29uc3RydWN0b3IoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBgbmV3IFR1cGxlVHlwZShbYCArXG4gICAgICAgICAgICAvLyBDb252ZXJ0IGV2ZXJ5IGVsZW1lbnQgdHlwZSB0byBpdHMgY29uc3RydWN0b3IgcmVwcmVzZW50YXRpb25cbiAgICAgICAgICAgIHRoaXMuZWxlbVR5cGVzLm1hcChjdXIgPT4gY3VyLnRvQ29uc3RydWN0b3IoKSkuam9pbihcIixcXG5cIikgK1xuICAgICAgICAgICAgYF0sICR7dGhpcy5pc0RvdERvdERvdH0sICR7dGhpcy5pc1F1ZXN0aW9ufSlgXG4gICAgICAgIClcbiAgICB9XG5cbiAgICBwdWJsaWMgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgWyR7dGhpcy5lbGVtVHlwZXMubWFwKGUgPT4gZS50b1N0cmluZygpKS5qb2luKFwiLCBcIil9XWBcbiAgICB9XG5cbiAgICBwdWJsaWMgY29udmVydChhcmd1bWVudCkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJndW1lbnQpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gSlNPTi5wYXJzZShhcmd1bWVudClcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGNvbnZlcnQgdG8gdHVwbGU6ICR7YXJndW1lbnR9YClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcmd1bWVudCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGNvbnZlcnQgdG8gdHVwbGU6ICR7YXJndW1lbnR9YClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJndW1lbnQubGVuZ3RoICE9PSB0aGlzLmVsZW1UeXBlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgRXJyb3IgY29udmVydGluZyB0dXBsZTogbnVtYmVyIG9mIGVsZW1lbnRzIGFuZCB0eXBlIG1pc21hdGNoICR7YXJndW1lbnR9YCxcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJndW1lbnQubWFwKCh2LCBpKSA9PiB0aGlzLmVsZW1UeXBlc1tpXS5jb252ZXJ0KHYpKVxuICAgIH1cbn1cbiIsImltcG9ydCB7IFR5cGUgfSBmcm9tIFwiLi9UeXBlXCJcblxuZXhwb3J0IGNsYXNzIFR5cGVSZWZlcmVuY2VUeXBlIGltcGxlbWVudHMgVHlwZSB7XG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHB1YmxpYyBraW5kOiBzdHJpbmcsIHB1YmxpYyBhcmdzOiBUeXBlW10sIHB1YmxpYyBpc0RvdERvdERvdCA9IGZhbHNlLCBwdWJsaWMgaXNRdWVzdGlvbiA9IGZhbHNlKSB7fVxuXG4gICAgcHVibGljIHRvQ29uc3RydWN0b3IoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKCR7SlNPTi5zdHJpbmdpZnkodGhpcy5raW5kKX0sIFtgICtcbiAgICAgICAgICAgIC8vIFR1cm4gZXZlcnkgdHlwZSBhcmd1bWVudCBpbnRvIGl0cyBjb25zdHJ1Y3RvciByZXByZXNlbnRhdGlvblxuICAgICAgICAgICAgdGhpcy5hcmdzLm1hcChjdXIgPT4gY3VyLnRvQ29uc3RydWN0b3IoKSkuam9pbihcIixcXG5cIikgK1xuICAgICAgICAgICAgYF0sICR7dGhpcy5pc0RvdERvdERvdH0sICR7dGhpcy5pc1F1ZXN0aW9ufSlgXG4gICAgICAgIClcbiAgICB9XG5cbiAgICBwdWJsaWMgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmtpbmR9PCR7dGhpcy5hcmdzLm1hcChhID0+IGEudG9TdHJpbmcoKSkuam9pbihcIiwgXCIpfT5gXG4gICAgfVxuXG4gICAgcHVibGljIGNvbnZlcnQoYXJndW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udmVyc2lvbiBvZiBzaW1wbGUgdHlwZSByZWZlcmVuY2VzIG5vdCBpbXBsZW1lbnRlZC5cIilcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBUeXBlIH0gZnJvbSBcIi4vVHlwZVwiXG5cbmV4cG9ydCBjbGFzcyBVbmlvblR5cGUgaW1wbGVtZW50cyBUeXBlIHtcbiAgICBwdWJsaWMga2luZCA9IFwidW5pb25cIlxuXG4gICAgY29uc3RydWN0b3IocHVibGljIHR5cGVzOiBUeXBlW10sIHB1YmxpYyBpc0RvdERvdERvdCA9IGZhbHNlLCBwdWJsaWMgaXNRdWVzdGlvbiA9IGZhbHNlKSB7fVxuXG4gICAgcHVibGljIHRvQ29uc3RydWN0b3IoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBgbmV3IFVuaW9uVHlwZShbYCArXG4gICAgICAgICAgICAvLyBDb252ZXJ0IGV2ZXJ5IHR5cGUgdG8gaXRzIHN0cmluZyBjb25zdHJ1Y3RvciByZXByZXNlbnRhdGlvblxuICAgICAgICAgICAgdGhpcy50eXBlcy5tYXAoY3VyID0+IGN1ci50b0NvbnN0cnVjdG9yKCkpLmpvaW4oXCIsXFxuXCIpICtcbiAgICAgICAgICAgIGBdLCAke3RoaXMuaXNEb3REb3REb3R9LCAke3RoaXMuaXNRdWVzdGlvbn0pYFxuICAgICAgICApXG4gICAgfVxuXG4gICAgcHVibGljIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlcy5tYXAodCA9PiB0LnRvU3RyaW5nKCkpLmpvaW4oXCIgfCBcIilcbiAgICB9XG5cbiAgICBwdWJsaWMgY29udmVydChhcmd1bWVudCkge1xuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgdGhpcy50eXBlcykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdC5jb252ZXJ0KGFyZ3VtZW50KVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGNvbnZlcnQgXCIke2FyZ3VtZW50fVwiIHRvIGFueSBvZjogJHt0aGlzLnR5cGVzfWApXG4gICAgfVxufVxuIiwiaW1wb3J0IHsgVHlwZSB9IGZyb20gXCIuL1R5cGVcIlxuXG5leHBvcnQgY2xhc3MgVm9pZFR5cGUgaW1wbGVtZW50cyBUeXBlIHtcbiAgICBwdWJsaWMga2luZCA9IFwidm9pZFwiXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgaXNEb3REb3REb3QgPSBmYWxzZSwgcHVibGljIGlzUXVlc3Rpb24gPSBmYWxzZSkge31cblxuICAgIHB1YmxpYyB0b0NvbnN0cnVjdG9yKCkge1xuICAgICAgICByZXR1cm4gYG5ldyBWb2lkVHlwZSgke3RoaXMuaXNEb3REb3REb3R9LCAke3RoaXMuaXNRdWVzdGlvbn0pYFxuICAgIH1cblxuICAgIHB1YmxpYyB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2luZFxuICAgIH1cblxuICAgIHB1YmxpYyBjb252ZXJ0KGFyZ3VtZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxufVxuIiwiZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vbGliL3BhcnNlJyk7XG5leHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vbGliL3N0cmluZ2lmeScpO1xuIiwiLy8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvZ3JhbW1hci5odG1sXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdmlzaW9ubWVkaWEvY3NzLXBhcnNlL3B1bGwvNDkjaXNzdWVjb21tZW50LTMwMDg4MDI3XG52YXIgY29tbWVudHJlID0gL1xcL1xcKlteKl0qXFwqKyhbXi8qXVteKl0qXFwqKykqXFwvL2dcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjc3MsIG9wdGlvbnMpe1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvKipcbiAgICogUG9zaXRpb25hbC5cbiAgICovXG5cbiAgdmFyIGxpbmVubyA9IDE7XG4gIHZhciBjb2x1bW4gPSAxO1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgbGluZW5vIGFuZCBjb2x1bW4gYmFzZWQgb24gYHN0cmAuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKHN0cikge1xuICAgIHZhciBsaW5lcyA9IHN0ci5tYXRjaCgvXFxuL2cpO1xuICAgIGlmIChsaW5lcykgbGluZW5vICs9IGxpbmVzLmxlbmd0aDtcbiAgICB2YXIgaSA9IHN0ci5sYXN0SW5kZXhPZignXFxuJyk7XG4gICAgY29sdW1uID0gfmkgPyBzdHIubGVuZ3RoIC0gaSA6IGNvbHVtbiArIHN0ci5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogTWFyayBwb3NpdGlvbiBhbmQgcGF0Y2ggYG5vZGUucG9zaXRpb25gLlxuICAgKi9cblxuICBmdW5jdGlvbiBwb3NpdGlvbigpIHtcbiAgICB2YXIgc3RhcnQgPSB7IGxpbmU6IGxpbmVubywgY29sdW1uOiBjb2x1bW4gfTtcbiAgICByZXR1cm4gZnVuY3Rpb24obm9kZSl7XG4gICAgICBub2RlLnBvc2l0aW9uID0gbmV3IFBvc2l0aW9uKHN0YXJ0KTtcbiAgICAgIHdoaXRlc3BhY2UoKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU3RvcmUgcG9zaXRpb24gaW5mb3JtYXRpb24gZm9yIGEgbm9kZVxuICAgKi9cblxuICBmdW5jdGlvbiBQb3NpdGlvbihzdGFydCkge1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLmVuZCA9IHsgbGluZTogbGluZW5vLCBjb2x1bW46IGNvbHVtbiB9O1xuICAgIHRoaXMuc291cmNlID0gb3B0aW9ucy5zb3VyY2U7XG4gIH1cblxuICAvKipcbiAgICogTm9uLWVudW1lcmFibGUgc291cmNlIHN0cmluZ1xuICAgKi9cblxuICBQb3NpdGlvbi5wcm90b3R5cGUuY29udGVudCA9IGNzcztcblxuICAvKipcbiAgICogRXJyb3IgYG1zZ2AuXG4gICAqL1xuXG4gIHZhciBlcnJvcnNMaXN0ID0gW107XG5cbiAgZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcihvcHRpb25zLnNvdXJjZSArICc6JyArIGxpbmVubyArICc6JyArIGNvbHVtbiArICc6ICcgKyBtc2cpO1xuICAgIGVyci5yZWFzb24gPSBtc2c7XG4gICAgZXJyLmZpbGVuYW1lID0gb3B0aW9ucy5zb3VyY2U7XG4gICAgZXJyLmxpbmUgPSBsaW5lbm87XG4gICAgZXJyLmNvbHVtbiA9IGNvbHVtbjtcbiAgICBlcnIuc291cmNlID0gY3NzO1xuXG4gICAgaWYgKG9wdGlvbnMuc2lsZW50KSB7XG4gICAgICBlcnJvcnNMaXN0LnB1c2goZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBzdHlsZXNoZWV0LlxuICAgKi9cblxuICBmdW5jdGlvbiBzdHlsZXNoZWV0KCkge1xuICAgIHZhciBydWxlc0xpc3QgPSBydWxlcygpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdzdHlsZXNoZWV0JyxcbiAgICAgIHN0eWxlc2hlZXQ6IHtcbiAgICAgICAgc291cmNlOiBvcHRpb25zLnNvdXJjZSxcbiAgICAgICAgcnVsZXM6IHJ1bGVzTGlzdCxcbiAgICAgICAgcGFyc2luZ0Vycm9yczogZXJyb3JzTGlzdFxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogT3BlbmluZyBicmFjZS5cbiAgICovXG5cbiAgZnVuY3Rpb24gb3BlbigpIHtcbiAgICByZXR1cm4gbWF0Y2goL157XFxzKi8pO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NpbmcgYnJhY2UuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIHJldHVybiBtYXRjaCgvXn0vKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBydWxlc2V0LlxuICAgKi9cblxuICBmdW5jdGlvbiBydWxlcygpIHtcbiAgICB2YXIgbm9kZTtcbiAgICB2YXIgcnVsZXMgPSBbXTtcbiAgICB3aGl0ZXNwYWNlKCk7XG4gICAgY29tbWVudHMocnVsZXMpO1xuICAgIHdoaWxlIChjc3MubGVuZ3RoICYmIGNzcy5jaGFyQXQoMCkgIT0gJ30nICYmIChub2RlID0gYXRydWxlKCkgfHwgcnVsZSgpKSkge1xuICAgICAgaWYgKG5vZGUgIT09IGZhbHNlKSB7XG4gICAgICAgIHJ1bGVzLnB1c2gobm9kZSk7XG4gICAgICAgIGNvbW1lbnRzKHJ1bGVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ1bGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hdGNoIGByZWAgYW5kIHJldHVybiBjYXB0dXJlcy5cbiAgICovXG5cbiAgZnVuY3Rpb24gbWF0Y2gocmUpIHtcbiAgICB2YXIgbSA9IHJlLmV4ZWMoY3NzKTtcbiAgICBpZiAoIW0pIHJldHVybjtcbiAgICB2YXIgc3RyID0gbVswXTtcbiAgICB1cGRhdGVQb3NpdGlvbihzdHIpO1xuICAgIGNzcyA9IGNzcy5zbGljZShzdHIubGVuZ3RoKTtcbiAgICByZXR1cm4gbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSB3aGl0ZXNwYWNlLlxuICAgKi9cblxuICBmdW5jdGlvbiB3aGl0ZXNwYWNlKCkge1xuICAgIG1hdGNoKC9eXFxzKi8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGNvbW1lbnRzO1xuICAgKi9cblxuICBmdW5jdGlvbiBjb21tZW50cyhydWxlcykge1xuICAgIHZhciBjO1xuICAgIHJ1bGVzID0gcnVsZXMgfHwgW107XG4gICAgd2hpbGUgKGMgPSBjb21tZW50KCkpIHtcbiAgICAgIGlmIChjICE9PSBmYWxzZSkge1xuICAgICAgICBydWxlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnVsZXM7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgY29tbWVudC5cbiAgICovXG5cbiAgZnVuY3Rpb24gY29tbWVudCgpIHtcbiAgICB2YXIgcG9zID0gcG9zaXRpb24oKTtcbiAgICBpZiAoJy8nICE9IGNzcy5jaGFyQXQoMCkgfHwgJyonICE9IGNzcy5jaGFyQXQoMSkpIHJldHVybjtcblxuICAgIHZhciBpID0gMjtcbiAgICB3aGlsZSAoXCJcIiAhPSBjc3MuY2hhckF0KGkpICYmICgnKicgIT0gY3NzLmNoYXJBdChpKSB8fCAnLycgIT0gY3NzLmNoYXJBdChpICsgMSkpKSArK2k7XG4gICAgaSArPSAyO1xuXG4gICAgaWYgKFwiXCIgPT09IGNzcy5jaGFyQXQoaS0xKSkge1xuICAgICAgcmV0dXJuIGVycm9yKCdFbmQgb2YgY29tbWVudCBtaXNzaW5nJyk7XG4gICAgfVxuXG4gICAgdmFyIHN0ciA9IGNzcy5zbGljZSgyLCBpIC0gMik7XG4gICAgY29sdW1uICs9IDI7XG4gICAgdXBkYXRlUG9zaXRpb24oc3RyKTtcbiAgICBjc3MgPSBjc3Muc2xpY2UoaSk7XG4gICAgY29sdW1uICs9IDI7XG5cbiAgICByZXR1cm4gcG9zKHtcbiAgICAgIHR5cGU6ICdjb21tZW50JyxcbiAgICAgIGNvbW1lbnQ6IHN0clxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIHNlbGVjdG9yLlxuICAgKi9cblxuICBmdW5jdGlvbiBzZWxlY3RvcigpIHtcbiAgICB2YXIgbSA9IG1hdGNoKC9eKFtee10rKS8pO1xuICAgIGlmICghbSkgcmV0dXJuO1xuICAgIC8qIEBmaXggUmVtb3ZlIGFsbCBjb21tZW50cyBmcm9tIHNlbGVjdG9yc1xuICAgICAqIGh0dHA6Ly9vc3Rlcm1pbGxlci5vcmcvZmluZGNvbW1lbnQuaHRtbCAqL1xuICAgIHJldHVybiB0cmltKG1bMF0pXG4gICAgICAucmVwbGFjZSgvXFwvXFwqKFteKl18W1xcclxcbl18KFxcKisoW14qL118W1xcclxcbl0pKSkqXFwqXFwvKy9nLCAnJylcbiAgICAgIC5yZXBsYWNlKC9cIig/OlxcXFxcInxbXlwiXSkqXCJ8Jyg/OlxcXFwnfFteJ10pKicvZywgZnVuY3Rpb24obSkge1xuICAgICAgICByZXR1cm4gbS5yZXBsYWNlKC8sL2csICdcXHUyMDBDJyk7XG4gICAgICB9KVxuICAgICAgLnNwbGl0KC9cXHMqKD8hW14oXSpcXCkpLFxccyovKVxuICAgICAgLm1hcChmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1xcdTIwMEMvZywgJywnKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGRlY2xhcmF0aW9uLlxuICAgKi9cblxuICBmdW5jdGlvbiBkZWNsYXJhdGlvbigpIHtcbiAgICB2YXIgcG9zID0gcG9zaXRpb24oKTtcblxuICAgIC8vIHByb3BcbiAgICB2YXIgcHJvcCA9IG1hdGNoKC9eKFxcKj9bLSNcXC9cXCpcXFxcXFx3XSsoXFxbWzAtOWEtel8tXStcXF0pPylcXHMqLyk7XG4gICAgaWYgKCFwcm9wKSByZXR1cm47XG4gICAgcHJvcCA9IHRyaW0ocHJvcFswXSk7XG5cbiAgICAvLyA6XG4gICAgaWYgKCFtYXRjaCgvXjpcXHMqLykpIHJldHVybiBlcnJvcihcInByb3BlcnR5IG1pc3NpbmcgJzonXCIpO1xuXG4gICAgLy8gdmFsXG4gICAgdmFyIHZhbCA9IG1hdGNoKC9eKCg/OicoPzpcXFxcJ3wuKSo/J3xcIig/OlxcXFxcInwuKSo/XCJ8XFwoW15cXCldKj9cXCl8W159O10pKykvKTtcblxuICAgIHZhciByZXQgPSBwb3Moe1xuICAgICAgdHlwZTogJ2RlY2xhcmF0aW9uJyxcbiAgICAgIHByb3BlcnR5OiBwcm9wLnJlcGxhY2UoY29tbWVudHJlLCAnJyksXG4gICAgICB2YWx1ZTogdmFsID8gdHJpbSh2YWxbMF0pLnJlcGxhY2UoY29tbWVudHJlLCAnJykgOiAnJ1xuICAgIH0pO1xuXG4gICAgLy8gO1xuICAgIG1hdGNoKC9eWztcXHNdKi8pO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBkZWNsYXJhdGlvbnMuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGRlY2xhcmF0aW9ucygpIHtcbiAgICB2YXIgZGVjbHMgPSBbXTtcblxuICAgIGlmICghb3BlbigpKSByZXR1cm4gZXJyb3IoXCJtaXNzaW5nICd7J1wiKTtcbiAgICBjb21tZW50cyhkZWNscyk7XG5cbiAgICAvLyBkZWNsYXJhdGlvbnNcbiAgICB2YXIgZGVjbDtcbiAgICB3aGlsZSAoZGVjbCA9IGRlY2xhcmF0aW9uKCkpIHtcbiAgICAgIGlmIChkZWNsICE9PSBmYWxzZSkge1xuICAgICAgICBkZWNscy5wdXNoKGRlY2wpO1xuICAgICAgICBjb21tZW50cyhkZWNscyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjbG9zZSgpKSByZXR1cm4gZXJyb3IoXCJtaXNzaW5nICd9J1wiKTtcbiAgICByZXR1cm4gZGVjbHM7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2Uga2V5ZnJhbWUuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGtleWZyYW1lKCkge1xuICAgIHZhciBtO1xuICAgIHZhciB2YWxzID0gW107XG4gICAgdmFyIHBvcyA9IHBvc2l0aW9uKCk7XG5cbiAgICB3aGlsZSAobSA9IG1hdGNoKC9eKChcXGQrXFwuXFxkK3xcXC5cXGQrfFxcZCspJT98W2Etel0rKVxccyovKSkge1xuICAgICAgdmFscy5wdXNoKG1bMV0pO1xuICAgICAgbWF0Y2goL14sXFxzKi8pO1xuICAgIH1cblxuICAgIGlmICghdmFscy5sZW5ndGgpIHJldHVybjtcblxuICAgIHJldHVybiBwb3Moe1xuICAgICAgdHlwZTogJ2tleWZyYW1lJyxcbiAgICAgIHZhbHVlczogdmFscyxcbiAgICAgIGRlY2xhcmF0aW9uczogZGVjbGFyYXRpb25zKClcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBrZXlmcmFtZXMuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGF0a2V5ZnJhbWVzKCkge1xuICAgIHZhciBwb3MgPSBwb3NpdGlvbigpO1xuICAgIHZhciBtID0gbWF0Y2goL15AKFstXFx3XSspP2tleWZyYW1lc1xccyovKTtcblxuICAgIGlmICghbSkgcmV0dXJuO1xuICAgIHZhciB2ZW5kb3IgPSBtWzFdO1xuXG4gICAgLy8gaWRlbnRpZmllclxuICAgIHZhciBtID0gbWF0Y2goL14oWy1cXHddKylcXHMqLyk7XG4gICAgaWYgKCFtKSByZXR1cm4gZXJyb3IoXCJAa2V5ZnJhbWVzIG1pc3NpbmcgbmFtZVwiKTtcbiAgICB2YXIgbmFtZSA9IG1bMV07XG5cbiAgICBpZiAoIW9wZW4oKSkgcmV0dXJuIGVycm9yKFwiQGtleWZyYW1lcyBtaXNzaW5nICd7J1wiKTtcblxuICAgIHZhciBmcmFtZTtcbiAgICB2YXIgZnJhbWVzID0gY29tbWVudHMoKTtcbiAgICB3aGlsZSAoZnJhbWUgPSBrZXlmcmFtZSgpKSB7XG4gICAgICBmcmFtZXMucHVzaChmcmFtZSk7XG4gICAgICBmcmFtZXMgPSBmcmFtZXMuY29uY2F0KGNvbW1lbnRzKCkpO1xuICAgIH1cblxuICAgIGlmICghY2xvc2UoKSkgcmV0dXJuIGVycm9yKFwiQGtleWZyYW1lcyBtaXNzaW5nICd9J1wiKTtcblxuICAgIHJldHVybiBwb3Moe1xuICAgICAgdHlwZTogJ2tleWZyYW1lcycsXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmVuZG9yOiB2ZW5kb3IsXG4gICAgICBrZXlmcmFtZXM6IGZyYW1lc1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIHN1cHBvcnRzLlxuICAgKi9cblxuICBmdW5jdGlvbiBhdHN1cHBvcnRzKCkge1xuICAgIHZhciBwb3MgPSBwb3NpdGlvbigpO1xuICAgIHZhciBtID0gbWF0Y2goL15Ac3VwcG9ydHMgKihbXntdKykvKTtcblxuICAgIGlmICghbSkgcmV0dXJuO1xuICAgIHZhciBzdXBwb3J0cyA9IHRyaW0obVsxXSk7XG5cbiAgICBpZiAoIW9wZW4oKSkgcmV0dXJuIGVycm9yKFwiQHN1cHBvcnRzIG1pc3NpbmcgJ3snXCIpO1xuXG4gICAgdmFyIHN0eWxlID0gY29tbWVudHMoKS5jb25jYXQocnVsZXMoKSk7XG5cbiAgICBpZiAoIWNsb3NlKCkpIHJldHVybiBlcnJvcihcIkBzdXBwb3J0cyBtaXNzaW5nICd9J1wiKTtcblxuICAgIHJldHVybiBwb3Moe1xuICAgICAgdHlwZTogJ3N1cHBvcnRzJyxcbiAgICAgIHN1cHBvcnRzOiBzdXBwb3J0cyxcbiAgICAgIHJ1bGVzOiBzdHlsZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGhvc3QuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGF0aG9zdCgpIHtcbiAgICB2YXIgcG9zID0gcG9zaXRpb24oKTtcbiAgICB2YXIgbSA9IG1hdGNoKC9eQGhvc3RcXHMqLyk7XG5cbiAgICBpZiAoIW0pIHJldHVybjtcblxuICAgIGlmICghb3BlbigpKSByZXR1cm4gZXJyb3IoXCJAaG9zdCBtaXNzaW5nICd7J1wiKTtcblxuICAgIHZhciBzdHlsZSA9IGNvbW1lbnRzKCkuY29uY2F0KHJ1bGVzKCkpO1xuXG4gICAgaWYgKCFjbG9zZSgpKSByZXR1cm4gZXJyb3IoXCJAaG9zdCBtaXNzaW5nICd9J1wiKTtcblxuICAgIHJldHVybiBwb3Moe1xuICAgICAgdHlwZTogJ2hvc3QnLFxuICAgICAgcnVsZXM6IHN0eWxlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgbWVkaWEuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGF0bWVkaWEoKSB7XG4gICAgdmFyIHBvcyA9IHBvc2l0aW9uKCk7XG4gICAgdmFyIG0gPSBtYXRjaCgvXkBtZWRpYSAqKFtee10rKS8pO1xuXG4gICAgaWYgKCFtKSByZXR1cm47XG4gICAgdmFyIG1lZGlhID0gdHJpbShtWzFdKTtcblxuICAgIGlmICghb3BlbigpKSByZXR1cm4gZXJyb3IoXCJAbWVkaWEgbWlzc2luZyAneydcIik7XG5cbiAgICB2YXIgc3R5bGUgPSBjb21tZW50cygpLmNvbmNhdChydWxlcygpKTtcblxuICAgIGlmICghY2xvc2UoKSkgcmV0dXJuIGVycm9yKFwiQG1lZGlhIG1pc3NpbmcgJ30nXCIpO1xuXG4gICAgcmV0dXJuIHBvcyh7XG4gICAgICB0eXBlOiAnbWVkaWEnLFxuICAgICAgbWVkaWE6IG1lZGlhLFxuICAgICAgcnVsZXM6IHN0eWxlXG4gICAgfSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBQYXJzZSBjdXN0b20tbWVkaWEuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGF0Y3VzdG9tbWVkaWEoKSB7XG4gICAgdmFyIHBvcyA9IHBvc2l0aW9uKCk7XG4gICAgdmFyIG0gPSBtYXRjaCgvXkBjdXN0b20tbWVkaWFcXHMrKC0tW15cXHNdKylcXHMqKFteeztdKyk7Lyk7XG4gICAgaWYgKCFtKSByZXR1cm47XG5cbiAgICByZXR1cm4gcG9zKHtcbiAgICAgIHR5cGU6ICdjdXN0b20tbWVkaWEnLFxuICAgICAgbmFtZTogdHJpbShtWzFdKSxcbiAgICAgIG1lZGlhOiB0cmltKG1bMl0pXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgcGFnZWQgbWVkaWEuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGF0cGFnZSgpIHtcbiAgICB2YXIgcG9zID0gcG9zaXRpb24oKTtcbiAgICB2YXIgbSA9IG1hdGNoKC9eQHBhZ2UgKi8pO1xuICAgIGlmICghbSkgcmV0dXJuO1xuXG4gICAgdmFyIHNlbCA9IHNlbGVjdG9yKCkgfHwgW107XG5cbiAgICBpZiAoIW9wZW4oKSkgcmV0dXJuIGVycm9yKFwiQHBhZ2UgbWlzc2luZyAneydcIik7XG4gICAgdmFyIGRlY2xzID0gY29tbWVudHMoKTtcblxuICAgIC8vIGRlY2xhcmF0aW9uc1xuICAgIHZhciBkZWNsO1xuICAgIHdoaWxlIChkZWNsID0gZGVjbGFyYXRpb24oKSkge1xuICAgICAgZGVjbHMucHVzaChkZWNsKTtcbiAgICAgIGRlY2xzID0gZGVjbHMuY29uY2F0KGNvbW1lbnRzKCkpO1xuICAgIH1cblxuICAgIGlmICghY2xvc2UoKSkgcmV0dXJuIGVycm9yKFwiQHBhZ2UgbWlzc2luZyAnfSdcIik7XG5cbiAgICByZXR1cm4gcG9zKHtcbiAgICAgIHR5cGU6ICdwYWdlJyxcbiAgICAgIHNlbGVjdG9yczogc2VsLFxuICAgICAgZGVjbGFyYXRpb25zOiBkZWNsc1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGRvY3VtZW50LlxuICAgKi9cblxuICBmdW5jdGlvbiBhdGRvY3VtZW50KCkge1xuICAgIHZhciBwb3MgPSBwb3NpdGlvbigpO1xuICAgIHZhciBtID0gbWF0Y2goL15AKFstXFx3XSspP2RvY3VtZW50ICooW157XSspLyk7XG4gICAgaWYgKCFtKSByZXR1cm47XG5cbiAgICB2YXIgdmVuZG9yID0gdHJpbShtWzFdKTtcbiAgICB2YXIgZG9jID0gdHJpbShtWzJdKTtcblxuICAgIGlmICghb3BlbigpKSByZXR1cm4gZXJyb3IoXCJAZG9jdW1lbnQgbWlzc2luZyAneydcIik7XG5cbiAgICB2YXIgc3R5bGUgPSBjb21tZW50cygpLmNvbmNhdChydWxlcygpKTtcblxuICAgIGlmICghY2xvc2UoKSkgcmV0dXJuIGVycm9yKFwiQGRvY3VtZW50IG1pc3NpbmcgJ30nXCIpO1xuXG4gICAgcmV0dXJuIHBvcyh7XG4gICAgICB0eXBlOiAnZG9jdW1lbnQnLFxuICAgICAgZG9jdW1lbnQ6IGRvYyxcbiAgICAgIHZlbmRvcjogdmVuZG9yLFxuICAgICAgcnVsZXM6IHN0eWxlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgZm9udC1mYWNlLlxuICAgKi9cblxuICBmdW5jdGlvbiBhdGZvbnRmYWNlKCkge1xuICAgIHZhciBwb3MgPSBwb3NpdGlvbigpO1xuICAgIHZhciBtID0gbWF0Y2goL15AZm9udC1mYWNlXFxzKi8pO1xuICAgIGlmICghbSkgcmV0dXJuO1xuXG4gICAgaWYgKCFvcGVuKCkpIHJldHVybiBlcnJvcihcIkBmb250LWZhY2UgbWlzc2luZyAneydcIik7XG4gICAgdmFyIGRlY2xzID0gY29tbWVudHMoKTtcblxuICAgIC8vIGRlY2xhcmF0aW9uc1xuICAgIHZhciBkZWNsO1xuICAgIHdoaWxlIChkZWNsID0gZGVjbGFyYXRpb24oKSkge1xuICAgICAgZGVjbHMucHVzaChkZWNsKTtcbiAgICAgIGRlY2xzID0gZGVjbHMuY29uY2F0KGNvbW1lbnRzKCkpO1xuICAgIH1cblxuICAgIGlmICghY2xvc2UoKSkgcmV0dXJuIGVycm9yKFwiQGZvbnQtZmFjZSBtaXNzaW5nICd9J1wiKTtcblxuICAgIHJldHVybiBwb3Moe1xuICAgICAgdHlwZTogJ2ZvbnQtZmFjZScsXG4gICAgICBkZWNsYXJhdGlvbnM6IGRlY2xzXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgaW1wb3J0XG4gICAqL1xuXG4gIHZhciBhdGltcG9ydCA9IF9jb21waWxlQXRydWxlKCdpbXBvcnQnKTtcblxuICAvKipcbiAgICogUGFyc2UgY2hhcnNldFxuICAgKi9cblxuICB2YXIgYXRjaGFyc2V0ID0gX2NvbXBpbGVBdHJ1bGUoJ2NoYXJzZXQnKTtcblxuICAvKipcbiAgICogUGFyc2UgbmFtZXNwYWNlXG4gICAqL1xuXG4gIHZhciBhdG5hbWVzcGFjZSA9IF9jb21waWxlQXRydWxlKCduYW1lc3BhY2UnKTtcblxuICAvKipcbiAgICogUGFyc2Ugbm9uLWJsb2NrIGF0LXJ1bGVzXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gX2NvbXBpbGVBdHJ1bGUobmFtZSkge1xuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoJ15AJyArIG5hbWUgKyAnXFxcXHMqKFteO10rKTsnKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zID0gcG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gbWF0Y2gocmUpO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG4gICAgICB2YXIgcmV0ID0geyB0eXBlOiBuYW1lIH07XG4gICAgICByZXRbbmFtZV0gPSBtWzFdLnRyaW0oKTtcbiAgICAgIHJldHVybiBwb3MocmV0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYXQgcnVsZS5cbiAgICovXG5cbiAgZnVuY3Rpb24gYXRydWxlKCkge1xuICAgIGlmIChjc3NbMF0gIT0gJ0AnKSByZXR1cm47XG5cbiAgICByZXR1cm4gYXRrZXlmcmFtZXMoKVxuICAgICAgfHwgYXRtZWRpYSgpXG4gICAgICB8fCBhdGN1c3RvbW1lZGlhKClcbiAgICAgIHx8IGF0c3VwcG9ydHMoKVxuICAgICAgfHwgYXRpbXBvcnQoKVxuICAgICAgfHwgYXRjaGFyc2V0KClcbiAgICAgIHx8IGF0bmFtZXNwYWNlKClcbiAgICAgIHx8IGF0ZG9jdW1lbnQoKVxuICAgICAgfHwgYXRwYWdlKClcbiAgICAgIHx8IGF0aG9zdCgpXG4gICAgICB8fCBhdGZvbnRmYWNlKCk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgcnVsZS5cbiAgICovXG5cbiAgZnVuY3Rpb24gcnVsZSgpIHtcbiAgICB2YXIgcG9zID0gcG9zaXRpb24oKTtcbiAgICB2YXIgc2VsID0gc2VsZWN0b3IoKTtcblxuICAgIGlmICghc2VsKSByZXR1cm4gZXJyb3IoJ3NlbGVjdG9yIG1pc3NpbmcnKTtcbiAgICBjb21tZW50cygpO1xuXG4gICAgcmV0dXJuIHBvcyh7XG4gICAgICB0eXBlOiAncnVsZScsXG4gICAgICBzZWxlY3RvcnM6IHNlbCxcbiAgICAgIGRlY2xhcmF0aW9uczogZGVjbGFyYXRpb25zKClcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBhZGRQYXJlbnQoc3R5bGVzaGVldCgpKTtcbn07XG5cbi8qKlxuICogVHJpbSBgc3RyYC5cbiAqL1xuXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyID8gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKSA6ICcnO1xufVxuXG4vKipcbiAqIEFkZHMgbm9uLWVudW1lcmFibGUgcGFyZW50IG5vZGUgcmVmZXJlbmNlIHRvIGVhY2ggbm9kZS5cbiAqL1xuXG5mdW5jdGlvbiBhZGRQYXJlbnQob2JqLCBwYXJlbnQpIHtcbiAgdmFyIGlzTm9kZSA9IG9iaiAmJiB0eXBlb2Ygb2JqLnR5cGUgPT09ICdzdHJpbmcnO1xuICB2YXIgY2hpbGRQYXJlbnQgPSBpc05vZGUgPyBvYmogOiBwYXJlbnQ7XG5cbiAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICB2YXIgdmFsdWUgPSBvYmpba107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHYpIHsgYWRkUGFyZW50KHYsIGNoaWxkUGFyZW50KTsgfSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBhZGRQYXJlbnQodmFsdWUsIGNoaWxkUGFyZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNOb2RlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgJ3BhcmVudCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogcGFyZW50IHx8IG51bGxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG4iLCJcbi8qKlxuICogRXhwb3NlIGBDb21waWxlcmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBDb21waWxlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgY29tcGlsZXIuXG4gKlxuICogQHBhcmFtIHtUeXBlfSBuYW1lXG4gKiBAcmV0dXJuIHtUeXBlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBDb21waWxlcihvcHRzKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdHMgfHwge307XG59XG5cbi8qKlxuICogRW1pdCBgc3RyYFxuICovXG5cbkNvbXBpbGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFZpc2l0IGBub2RlYC5cbiAqL1xuXG5Db21waWxlci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbihub2RlKXtcbiAgcmV0dXJuIHRoaXNbbm9kZS50eXBlXShub2RlKTtcbn07XG5cbi8qKlxuICogTWFwIHZpc2l0IG92ZXIgYXJyYXkgb2YgYG5vZGVzYCwgb3B0aW9uYWxseSB1c2luZyBhIGBkZWxpbWBcbiAqL1xuXG5Db21waWxlci5wcm90b3R5cGUubWFwVmlzaXQgPSBmdW5jdGlvbihub2RlcywgZGVsaW0pe1xuICB2YXIgYnVmID0gJyc7XG4gIGRlbGltID0gZGVsaW0gfHwgJyc7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG5vZGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgYnVmICs9IHRoaXMudmlzaXQobm9kZXNbaV0pO1xuICAgIGlmIChkZWxpbSAmJiBpIDwgbGVuZ3RoIC0gMSkgYnVmICs9IHRoaXMuZW1pdChkZWxpbSk7XG4gIH1cblxuICByZXR1cm4gYnVmO1xufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9jb21waWxlcicpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuLyoqXG4gKiBFeHBvc2UgY29tcGlsZXIuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBDb21waWxlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBDb21waWxlcmAuXG4gKi9cblxuZnVuY3Rpb24gQ29tcGlsZXIob3B0aW9ucykge1xuICBCYXNlLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXG4gKi9cblxuaW5oZXJpdHMoQ29tcGlsZXIsIEJhc2UpO1xuXG4vKipcbiAqIENvbXBpbGUgYG5vZGVgLlxuICovXG5cbkNvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24obm9kZSl7XG4gIHJldHVybiBub2RlLnN0eWxlc2hlZXRcbiAgICAucnVsZXMubWFwKHRoaXMudmlzaXQsIHRoaXMpXG4gICAgLmpvaW4oJycpO1xufTtcblxuLyoqXG4gKiBWaXNpdCBjb21tZW50IG5vZGUuXG4gKi9cblxuQ29tcGlsZXIucHJvdG90eXBlLmNvbW1lbnQgPSBmdW5jdGlvbihub2RlKXtcbiAgcmV0dXJuIHRoaXMuZW1pdCgnJywgbm9kZS5wb3NpdGlvbik7XG59O1xuXG4vKipcbiAqIFZpc2l0IGltcG9ydCBub2RlLlxuICovXG5cbkNvbXBpbGVyLnByb3RvdHlwZS5pbXBvcnQgPSBmdW5jdGlvbihub2RlKXtcbiAgcmV0dXJuIHRoaXMuZW1pdCgnQGltcG9ydCAnICsgbm9kZS5pbXBvcnQgKyAnOycsIG5vZGUucG9zaXRpb24pO1xufTtcblxuLyoqXG4gKiBWaXNpdCBtZWRpYSBub2RlLlxuICovXG5cbkNvbXBpbGVyLnByb3RvdHlwZS5tZWRpYSA9IGZ1bmN0aW9uKG5vZGUpe1xuICByZXR1cm4gdGhpcy5lbWl0KCdAbWVkaWEgJyArIG5vZGUubWVkaWEsIG5vZGUucG9zaXRpb24pXG4gICAgKyB0aGlzLmVtaXQoJ3snKVxuICAgICsgdGhpcy5tYXBWaXNpdChub2RlLnJ1bGVzKVxuICAgICsgdGhpcy5lbWl0KCd9Jyk7XG59O1xuXG4vKipcbiAqIFZpc2l0IGRvY3VtZW50IG5vZGUuXG4gKi9cblxuQ29tcGlsZXIucHJvdG90eXBlLmRvY3VtZW50ID0gZnVuY3Rpb24obm9kZSl7XG4gIHZhciBkb2MgPSAnQCcgKyAobm9kZS52ZW5kb3IgfHwgJycpICsgJ2RvY3VtZW50ICcgKyBub2RlLmRvY3VtZW50O1xuXG4gIHJldHVybiB0aGlzLmVtaXQoZG9jLCBub2RlLnBvc2l0aW9uKVxuICAgICsgdGhpcy5lbWl0KCd7JylcbiAgICArIHRoaXMubWFwVmlzaXQobm9kZS5ydWxlcylcbiAgICArIHRoaXMuZW1pdCgnfScpO1xufTtcblxuLyoqXG4gKiBWaXNpdCBjaGFyc2V0IG5vZGUuXG4gKi9cblxuQ29tcGlsZXIucHJvdG90eXBlLmNoYXJzZXQgPSBmdW5jdGlvbihub2RlKXtcbiAgcmV0dXJuIHRoaXMuZW1pdCgnQGNoYXJzZXQgJyArIG5vZGUuY2hhcnNldCArICc7Jywgbm9kZS5wb3NpdGlvbik7XG59O1xuXG4vKipcbiAqIFZpc2l0IG5hbWVzcGFjZSBub2RlLlxuICovXG5cbkNvbXBpbGVyLnByb3RvdHlwZS5uYW1lc3BhY2UgPSBmdW5jdGlvbihub2RlKXtcbiAgcmV0dXJuIHRoaXMuZW1pdCgnQG5hbWVzcGFjZSAnICsgbm9kZS5uYW1lc3BhY2UgKyAnOycsIG5vZGUucG9zaXRpb24pO1xufTtcblxuLyoqXG4gKiBWaXNpdCBzdXBwb3J0cyBub2RlLlxuICovXG5cbkNvbXBpbGVyLnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uKG5vZGUpe1xuICByZXR1cm4gdGhpcy5lbWl0KCdAc3VwcG9ydHMgJyArIG5vZGUuc3VwcG9ydHMsIG5vZGUucG9zaXRpb24pXG4gICAgKyB0aGlzLmVtaXQoJ3snKVxuICAgICsgdGhpcy5tYXBWaXNpdChub2RlLnJ1bGVzKVxuICAgICsgdGhpcy5lbWl0KCd9Jyk7XG59O1xuXG4vKipcbiAqIFZpc2l0IGtleWZyYW1lcyBub2RlLlxuICovXG5cbkNvbXBpbGVyLnByb3RvdHlwZS5rZXlmcmFtZXMgPSBmdW5jdGlvbihub2RlKXtcbiAgcmV0dXJuIHRoaXMuZW1pdCgnQCdcbiAgICArIChub2RlLnZlbmRvciB8fCAnJylcbiAgICArICdrZXlmcmFtZXMgJ1xuICAgICsgbm9kZS5uYW1lLCBub2RlLnBvc2l0aW9uKVxuICAgICsgdGhpcy5lbWl0KCd7JylcbiAgICArIHRoaXMubWFwVmlzaXQobm9kZS5rZXlmcmFtZXMpXG4gICAgKyB0aGlzLmVtaXQoJ30nKTtcbn07XG5cbi8qKlxuICogVmlzaXQga2V5ZnJhbWUgbm9kZS5cbiAqL1xuXG5Db21waWxlci5wcm90b3R5cGUua2V5ZnJhbWUgPSBmdW5jdGlvbihub2RlKXtcbiAgdmFyIGRlY2xzID0gbm9kZS5kZWNsYXJhdGlvbnM7XG5cbiAgcmV0dXJuIHRoaXMuZW1pdChub2RlLnZhbHVlcy5qb2luKCcsJyksIG5vZGUucG9zaXRpb24pXG4gICAgKyB0aGlzLmVtaXQoJ3snKVxuICAgICsgdGhpcy5tYXBWaXNpdChkZWNscylcbiAgICArIHRoaXMuZW1pdCgnfScpO1xufTtcblxuLyoqXG4gKiBWaXNpdCBwYWdlIG5vZGUuXG4gKi9cblxuQ29tcGlsZXIucHJvdG90eXBlLnBhZ2UgPSBmdW5jdGlvbihub2RlKXtcbiAgdmFyIHNlbCA9IG5vZGUuc2VsZWN0b3JzLmxlbmd0aFxuICAgID8gbm9kZS5zZWxlY3RvcnMuam9pbignLCAnKVxuICAgIDogJyc7XG5cbiAgcmV0dXJuIHRoaXMuZW1pdCgnQHBhZ2UgJyArIHNlbCwgbm9kZS5wb3NpdGlvbilcbiAgICArIHRoaXMuZW1pdCgneycpXG4gICAgKyB0aGlzLm1hcFZpc2l0KG5vZGUuZGVjbGFyYXRpb25zKVxuICAgICsgdGhpcy5lbWl0KCd9Jyk7XG59O1xuXG4vKipcbiAqIFZpc2l0IGZvbnQtZmFjZSBub2RlLlxuICovXG5cbkNvbXBpbGVyLnByb3RvdHlwZVsnZm9udC1mYWNlJ10gPSBmdW5jdGlvbihub2RlKXtcbiAgcmV0dXJuIHRoaXMuZW1pdCgnQGZvbnQtZmFjZScsIG5vZGUucG9zaXRpb24pXG4gICAgKyB0aGlzLmVtaXQoJ3snKVxuICAgICsgdGhpcy5tYXBWaXNpdChub2RlLmRlY2xhcmF0aW9ucylcbiAgICArIHRoaXMuZW1pdCgnfScpO1xufTtcblxuLyoqXG4gKiBWaXNpdCBob3N0IG5vZGUuXG4gKi9cblxuQ29tcGlsZXIucHJvdG90eXBlLmhvc3QgPSBmdW5jdGlvbihub2RlKXtcbiAgcmV0dXJuIHRoaXMuZW1pdCgnQGhvc3QnLCBub2RlLnBvc2l0aW9uKVxuICAgICsgdGhpcy5lbWl0KCd7JylcbiAgICArIHRoaXMubWFwVmlzaXQobm9kZS5ydWxlcylcbiAgICArIHRoaXMuZW1pdCgnfScpO1xufTtcblxuLyoqXG4gKiBWaXNpdCBjdXN0b20tbWVkaWEgbm9kZS5cbiAqL1xuXG5Db21waWxlci5wcm90b3R5cGVbJ2N1c3RvbS1tZWRpYSddID0gZnVuY3Rpb24obm9kZSl7XG4gIHJldHVybiB0aGlzLmVtaXQoJ0BjdXN0b20tbWVkaWEgJyArIG5vZGUubmFtZSArICcgJyArIG5vZGUubWVkaWEgKyAnOycsIG5vZGUucG9zaXRpb24pO1xufTtcblxuLyoqXG4gKiBWaXNpdCBydWxlIG5vZGUuXG4gKi9cblxuQ29tcGlsZXIucHJvdG90eXBlLnJ1bGUgPSBmdW5jdGlvbihub2RlKXtcbiAgdmFyIGRlY2xzID0gbm9kZS5kZWNsYXJhdGlvbnM7XG4gIGlmICghZGVjbHMubGVuZ3RoKSByZXR1cm4gJyc7XG5cbiAgcmV0dXJuIHRoaXMuZW1pdChub2RlLnNlbGVjdG9ycy5qb2luKCcsJyksIG5vZGUucG9zaXRpb24pXG4gICAgKyB0aGlzLmVtaXQoJ3snKVxuICAgICsgdGhpcy5tYXBWaXNpdChkZWNscylcbiAgICArIHRoaXMuZW1pdCgnfScpO1xufTtcblxuLyoqXG4gKiBWaXNpdCBkZWNsYXJhdGlvbiBub2RlLlxuICovXG5cbkNvbXBpbGVyLnByb3RvdHlwZS5kZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKG5vZGUpe1xuICByZXR1cm4gdGhpcy5lbWl0KG5vZGUucHJvcGVydHkgKyAnOicgKyBub2RlLnZhbHVlLCBub2RlLnBvc2l0aW9uKSArIHRoaXMuZW1pdCgnOycpO1xufTtcblxuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2NvbXBpbGVyJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG4vKipcbiAqIEV4cG9zZSBjb21waWxlci5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBpbGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYENvbXBpbGVyYC5cbiAqL1xuXG5mdW5jdGlvbiBDb21waWxlcihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBCYXNlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuaW5kZW50YXRpb24gPSBvcHRpb25zLmluZGVudDtcbn1cblxuLyoqXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cbiAqL1xuXG5pbmhlcml0cyhDb21waWxlciwgQmFzZSk7XG5cbi8qKlxuICogQ29tcGlsZSBgbm9kZWAuXG4gKi9cblxuQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbihub2RlKXtcbiAgcmV0dXJuIHRoaXMuc3R5bGVzaGVldChub2RlKTtcbn07XG5cbi8qKlxuICogVmlzaXQgc3R5bGVzaGVldCBub2RlLlxuICovXG5cbkNvbXBpbGVyLnByb3RvdHlwZS5zdHlsZXNoZWV0ID0gZnVuY3Rpb24obm9kZSl7XG4gIHJldHVybiB0aGlzLm1hcFZpc2l0KG5vZGUuc3R5bGVzaGVldC5ydWxlcywgJ1xcblxcbicpO1xufTtcblxuLyoqXG4gKiBWaXNpdCBjb21tZW50IG5vZGUuXG4gKi9cblxuQ29tcGlsZXIucHJvdG90eXBlLmNvbW1lbnQgPSBmdW5jdGlvbihub2RlKXtcbiAgcmV0dXJuIHRoaXMuZW1pdCh0aGlzLmluZGVudCgpICsgJy8qJyArIG5vZGUuY29tbWVudCArICcqLycsIG5vZGUucG9zaXRpb24pO1xufTtcblxuLyoqXG4gKiBWaXNpdCBpbXBvcnQgbm9kZS5cbiAqL1xuXG5Db21waWxlci5wcm90b3R5cGUuaW1wb3J0ID0gZnVuY3Rpb24obm9kZSl7XG4gIHJldHVybiB0aGlzLmVtaXQoJ0BpbXBvcnQgJyArIG5vZGUuaW1wb3J0ICsgJzsnLCBub2RlLnBvc2l0aW9uKTtcbn07XG5cbi8qKlxuICogVmlzaXQgbWVkaWEgbm9kZS5cbiAqL1xuXG5Db21waWxlci5wcm90b3R5cGUubWVkaWEgPSBmdW5jdGlvbihub2RlKXtcbiAgcmV0dXJuIHRoaXMuZW1pdCgnQG1lZGlhICcgKyBub2RlLm1lZGlhLCBub2RlLnBvc2l0aW9uKVxuICAgICsgdGhpcy5lbWl0KFxuICAgICAgICAnIHtcXG4nXG4gICAgICAgICsgdGhpcy5pbmRlbnQoMSkpXG4gICAgKyB0aGlzLm1hcFZpc2l0KG5vZGUucnVsZXMsICdcXG5cXG4nKVxuICAgICsgdGhpcy5lbWl0KFxuICAgICAgICB0aGlzLmluZGVudCgtMSlcbiAgICAgICAgKyAnXFxufScpO1xufTtcblxuLyoqXG4gKiBWaXNpdCBkb2N1bWVudCBub2RlLlxuICovXG5cbkNvbXBpbGVyLnByb3RvdHlwZS5kb2N1bWVudCA9IGZ1bmN0aW9uKG5vZGUpe1xuICB2YXIgZG9jID0gJ0AnICsgKG5vZGUudmVuZG9yIHx8ICcnKSArICdkb2N1bWVudCAnICsgbm9kZS5kb2N1bWVudDtcblxuICByZXR1cm4gdGhpcy5lbWl0KGRvYywgbm9kZS5wb3NpdGlvbilcbiAgICArIHRoaXMuZW1pdChcbiAgICAgICAgJyAnXG4gICAgICArICcge1xcbidcbiAgICAgICsgdGhpcy5pbmRlbnQoMSkpXG4gICAgKyB0aGlzLm1hcFZpc2l0KG5vZGUucnVsZXMsICdcXG5cXG4nKVxuICAgICsgdGhpcy5lbWl0KFxuICAgICAgICB0aGlzLmluZGVudCgtMSlcbiAgICAgICAgKyAnXFxufScpO1xufTtcblxuLyoqXG4gKiBWaXNpdCBjaGFyc2V0IG5vZGUuXG4gKi9cblxuQ29tcGlsZXIucHJvdG90eXBlLmNoYXJzZXQgPSBmdW5jdGlvbihub2RlKXtcbiAgcmV0dXJuIHRoaXMuZW1pdCgnQGNoYXJzZXQgJyArIG5vZGUuY2hhcnNldCArICc7Jywgbm9kZS5wb3NpdGlvbik7XG59O1xuXG4vKipcbiAqIFZpc2l0IG5hbWVzcGFjZSBub2RlLlxuICovXG5cbkNvbXBpbGVyLnByb3RvdHlwZS5uYW1lc3BhY2UgPSBmdW5jdGlvbihub2RlKXtcbiAgcmV0dXJuIHRoaXMuZW1pdCgnQG5hbWVzcGFjZSAnICsgbm9kZS5uYW1lc3BhY2UgKyAnOycsIG5vZGUucG9zaXRpb24pO1xufTtcblxuLyoqXG4gKiBWaXNpdCBzdXBwb3J0cyBub2RlLlxuICovXG5cbkNvbXBpbGVyLnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uKG5vZGUpe1xuICByZXR1cm4gdGhpcy5lbWl0KCdAc3VwcG9ydHMgJyArIG5vZGUuc3VwcG9ydHMsIG5vZGUucG9zaXRpb24pXG4gICAgKyB0aGlzLmVtaXQoXG4gICAgICAnIHtcXG4nXG4gICAgICArIHRoaXMuaW5kZW50KDEpKVxuICAgICsgdGhpcy5tYXBWaXNpdChub2RlLnJ1bGVzLCAnXFxuXFxuJylcbiAgICArIHRoaXMuZW1pdChcbiAgICAgICAgdGhpcy5pbmRlbnQoLTEpXG4gICAgICAgICsgJ1xcbn0nKTtcbn07XG5cbi8qKlxuICogVmlzaXQga2V5ZnJhbWVzIG5vZGUuXG4gKi9cblxuQ29tcGlsZXIucHJvdG90eXBlLmtleWZyYW1lcyA9IGZ1bmN0aW9uKG5vZGUpe1xuICByZXR1cm4gdGhpcy5lbWl0KCdAJyArIChub2RlLnZlbmRvciB8fCAnJykgKyAna2V5ZnJhbWVzICcgKyBub2RlLm5hbWUsIG5vZGUucG9zaXRpb24pXG4gICAgKyB0aGlzLmVtaXQoXG4gICAgICAnIHtcXG4nXG4gICAgICArIHRoaXMuaW5kZW50KDEpKVxuICAgICsgdGhpcy5tYXBWaXNpdChub2RlLmtleWZyYW1lcywgJ1xcbicpXG4gICAgKyB0aGlzLmVtaXQoXG4gICAgICAgIHRoaXMuaW5kZW50KC0xKVxuICAgICAgICArICd9Jyk7XG59O1xuXG4vKipcbiAqIFZpc2l0IGtleWZyYW1lIG5vZGUuXG4gKi9cblxuQ29tcGlsZXIucHJvdG90eXBlLmtleWZyYW1lID0gZnVuY3Rpb24obm9kZSl7XG4gIHZhciBkZWNscyA9IG5vZGUuZGVjbGFyYXRpb25zO1xuXG4gIHJldHVybiB0aGlzLmVtaXQodGhpcy5pbmRlbnQoKSlcbiAgICArIHRoaXMuZW1pdChub2RlLnZhbHVlcy5qb2luKCcsICcpLCBub2RlLnBvc2l0aW9uKVxuICAgICsgdGhpcy5lbWl0KFxuICAgICAgJyB7XFxuJ1xuICAgICAgKyB0aGlzLmluZGVudCgxKSlcbiAgICArIHRoaXMubWFwVmlzaXQoZGVjbHMsICdcXG4nKVxuICAgICsgdGhpcy5lbWl0KFxuICAgICAgdGhpcy5pbmRlbnQoLTEpXG4gICAgICArICdcXG4nXG4gICAgICArIHRoaXMuaW5kZW50KCkgKyAnfVxcbicpO1xufTtcblxuLyoqXG4gKiBWaXNpdCBwYWdlIG5vZGUuXG4gKi9cblxuQ29tcGlsZXIucHJvdG90eXBlLnBhZ2UgPSBmdW5jdGlvbihub2RlKXtcbiAgdmFyIHNlbCA9IG5vZGUuc2VsZWN0b3JzLmxlbmd0aFxuICAgID8gbm9kZS5zZWxlY3RvcnMuam9pbignLCAnKSArICcgJ1xuICAgIDogJyc7XG5cbiAgcmV0dXJuIHRoaXMuZW1pdCgnQHBhZ2UgJyArIHNlbCwgbm9kZS5wb3NpdGlvbilcbiAgICArIHRoaXMuZW1pdCgne1xcbicpXG4gICAgKyB0aGlzLmVtaXQodGhpcy5pbmRlbnQoMSkpXG4gICAgKyB0aGlzLm1hcFZpc2l0KG5vZGUuZGVjbGFyYXRpb25zLCAnXFxuJylcbiAgICArIHRoaXMuZW1pdCh0aGlzLmluZGVudCgtMSkpXG4gICAgKyB0aGlzLmVtaXQoJ1xcbn0nKTtcbn07XG5cbi8qKlxuICogVmlzaXQgZm9udC1mYWNlIG5vZGUuXG4gKi9cblxuQ29tcGlsZXIucHJvdG90eXBlWydmb250LWZhY2UnXSA9IGZ1bmN0aW9uKG5vZGUpe1xuICByZXR1cm4gdGhpcy5lbWl0KCdAZm9udC1mYWNlICcsIG5vZGUucG9zaXRpb24pXG4gICAgKyB0aGlzLmVtaXQoJ3tcXG4nKVxuICAgICsgdGhpcy5lbWl0KHRoaXMuaW5kZW50KDEpKVxuICAgICsgdGhpcy5tYXBWaXNpdChub2RlLmRlY2xhcmF0aW9ucywgJ1xcbicpXG4gICAgKyB0aGlzLmVtaXQodGhpcy5pbmRlbnQoLTEpKVxuICAgICsgdGhpcy5lbWl0KCdcXG59Jyk7XG59O1xuXG4vKipcbiAqIFZpc2l0IGhvc3Qgbm9kZS5cbiAqL1xuXG5Db21waWxlci5wcm90b3R5cGUuaG9zdCA9IGZ1bmN0aW9uKG5vZGUpe1xuICByZXR1cm4gdGhpcy5lbWl0KCdAaG9zdCcsIG5vZGUucG9zaXRpb24pXG4gICAgKyB0aGlzLmVtaXQoXG4gICAgICAgICcge1xcbidcbiAgICAgICAgKyB0aGlzLmluZGVudCgxKSlcbiAgICArIHRoaXMubWFwVmlzaXQobm9kZS5ydWxlcywgJ1xcblxcbicpXG4gICAgKyB0aGlzLmVtaXQoXG4gICAgICAgIHRoaXMuaW5kZW50KC0xKVxuICAgICAgICArICdcXG59Jyk7XG59O1xuXG4vKipcbiAqIFZpc2l0IGN1c3RvbS1tZWRpYSBub2RlLlxuICovXG5cbkNvbXBpbGVyLnByb3RvdHlwZVsnY3VzdG9tLW1lZGlhJ10gPSBmdW5jdGlvbihub2RlKXtcbiAgcmV0dXJuIHRoaXMuZW1pdCgnQGN1c3RvbS1tZWRpYSAnICsgbm9kZS5uYW1lICsgJyAnICsgbm9kZS5tZWRpYSArICc7Jywgbm9kZS5wb3NpdGlvbik7XG59O1xuXG4vKipcbiAqIFZpc2l0IHJ1bGUgbm9kZS5cbiAqL1xuXG5Db21waWxlci5wcm90b3R5cGUucnVsZSA9IGZ1bmN0aW9uKG5vZGUpe1xuICB2YXIgaW5kZW50ID0gdGhpcy5pbmRlbnQoKTtcbiAgdmFyIGRlY2xzID0gbm9kZS5kZWNsYXJhdGlvbnM7XG4gIGlmICghZGVjbHMubGVuZ3RoKSByZXR1cm4gJyc7XG5cbiAgcmV0dXJuIHRoaXMuZW1pdChub2RlLnNlbGVjdG9ycy5tYXAoZnVuY3Rpb24ocyl7IHJldHVybiBpbmRlbnQgKyBzIH0pLmpvaW4oJyxcXG4nKSwgbm9kZS5wb3NpdGlvbilcbiAgICArIHRoaXMuZW1pdCgnIHtcXG4nKVxuICAgICsgdGhpcy5lbWl0KHRoaXMuaW5kZW50KDEpKVxuICAgICsgdGhpcy5tYXBWaXNpdChkZWNscywgJ1xcbicpXG4gICAgKyB0aGlzLmVtaXQodGhpcy5pbmRlbnQoLTEpKVxuICAgICsgdGhpcy5lbWl0KCdcXG4nICsgdGhpcy5pbmRlbnQoKSArICd9Jyk7XG59O1xuXG4vKipcbiAqIFZpc2l0IGRlY2xhcmF0aW9uIG5vZGUuXG4gKi9cblxuQ29tcGlsZXIucHJvdG90eXBlLmRlY2xhcmF0aW9uID0gZnVuY3Rpb24obm9kZSl7XG4gIHJldHVybiB0aGlzLmVtaXQodGhpcy5pbmRlbnQoKSlcbiAgICArIHRoaXMuZW1pdChub2RlLnByb3BlcnR5ICsgJzogJyArIG5vZGUudmFsdWUsIG5vZGUucG9zaXRpb24pXG4gICAgKyB0aGlzLmVtaXQoJzsnKTtcbn07XG5cbi8qKlxuICogSW5jcmVhc2UsIGRlY3JlYXNlIG9yIHJldHVybiBjdXJyZW50IGluZGVudGF0aW9uLlxuICovXG5cbkNvbXBpbGVyLnByb3RvdHlwZS5pbmRlbnQgPSBmdW5jdGlvbihsZXZlbCkge1xuICB0aGlzLmxldmVsID0gdGhpcy5sZXZlbCB8fCAxO1xuXG4gIGlmIChudWxsICE9IGxldmVsKSB7XG4gICAgdGhpcy5sZXZlbCArPSBsZXZlbDtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gQXJyYXkodGhpcy5sZXZlbCkuam9pbih0aGlzLmluZGVudGF0aW9uIHx8ICcgICcpO1xufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBDb21wcmVzc2VkID0gcmVxdWlyZSgnLi9jb21wcmVzcycpO1xudmFyIElkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIFN0cmluZ2Z5IHRoZSBnaXZlbiBBU1QgYG5vZGVgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGNvbXByZXNzYCBzcGFjZS1vcHRpbWl6ZWQgb3V0cHV0XG4gKiAgLSBgc291cmNlbWFwYCByZXR1cm4gYW4gb2JqZWN0IHdpdGggYC5jb2RlYCBhbmQgYC5tYXBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG5vZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihub2RlLCBvcHRpb25zKXtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIGNvbXBpbGVyID0gb3B0aW9ucy5jb21wcmVzc1xuICAgID8gbmV3IENvbXByZXNzZWQob3B0aW9ucylcbiAgICA6IG5ldyBJZGVudGl0eShvcHRpb25zKTtcblxuICAvLyBzb3VyY2UgbWFwc1xuICBpZiAob3B0aW9ucy5zb3VyY2VtYXApIHtcbiAgICB2YXIgc291cmNlbWFwcyA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC1zdXBwb3J0Jyk7XG4gICAgc291cmNlbWFwcyhjb21waWxlcik7XG5cbiAgICB2YXIgY29kZSA9IGNvbXBpbGVyLmNvbXBpbGUobm9kZSk7XG4gICAgY29tcGlsZXIuYXBwbHlTb3VyY2VNYXBzKCk7XG5cbiAgICB2YXIgbWFwID0gb3B0aW9ucy5zb3VyY2VtYXAgPT09ICdnZW5lcmF0b3InXG4gICAgICA/IGNvbXBpbGVyLm1hcFxuICAgICAgOiBjb21waWxlci5tYXAudG9KU09OKCk7XG5cbiAgICByZXR1cm4geyBjb2RlOiBjb2RlLCBtYXA6IG1hcCB9O1xuICB9XG5cbiAgdmFyIGNvZGUgPSBjb21waWxlci5jb21waWxlKG5vZGUpO1xuICByZXR1cm4gY29kZTtcbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgU291cmNlTWFwID0gcmVxdWlyZSgnc291cmNlLW1hcCcpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbnZhciBTb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoJ3NvdXJjZS1tYXAnKS5Tb3VyY2VNYXBDb25zdW1lcjtcbnZhciBzb3VyY2VNYXBSZXNvbHZlID0gcmVxdWlyZSgnc291cmNlLW1hcC1yZXNvbHZlJyk7XG52YXIgdXJpeCA9IHJlcXVpcmUoJ3VyaXgnKTtcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuLyoqXG4gKiBFeHBvc2UgYG1peGluKClgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gbWl4aW47XG5cbi8qKlxuICogTWl4aW4gc291cmNlIG1hcCBzdXBwb3J0IGludG8gYGNvbXBpbGVyYC5cbiAqXG4gKiBAcGFyYW0ge0NvbXBpbGVyfSBjb21waWxlclxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihjb21waWxlcikge1xuICBjb21waWxlci5fY29tbWVudCA9IGNvbXBpbGVyLmNvbW1lbnQ7XG4gIGNvbXBpbGVyLm1hcCA9IG5ldyBTb3VyY2VNYXAoKTtcbiAgY29tcGlsZXIucG9zaXRpb24gPSB7IGxpbmU6IDEsIGNvbHVtbjogMSB9O1xuICBjb21waWxlci5maWxlcyA9IHt9O1xuICBmb3IgKHZhciBrIGluIGV4cG9ydHMpIGNvbXBpbGVyW2tdID0gZXhwb3J0c1trXTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy51cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uKHN0cikge1xuICB2YXIgbGluZXMgPSBzdHIubWF0Y2goL1xcbi9nKTtcbiAgaWYgKGxpbmVzKSB0aGlzLnBvc2l0aW9uLmxpbmUgKz0gbGluZXMubGVuZ3RoO1xuICB2YXIgaSA9IHN0ci5sYXN0SW5kZXhPZignXFxuJyk7XG4gIHRoaXMucG9zaXRpb24uY29sdW1uID0gfmkgPyBzdHIubGVuZ3RoIC0gaSA6IHRoaXMucG9zaXRpb24uY29sdW1uICsgc3RyLmxlbmd0aDtcbn07XG5cbi8qKlxuICogRW1pdCBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge09iamVjdH0gW3Bvc11cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW1pdCA9IGZ1bmN0aW9uKHN0ciwgcG9zKSB7XG4gIGlmIChwb3MpIHtcbiAgICB2YXIgc291cmNlRmlsZSA9IHVyaXgocG9zLnNvdXJjZSB8fCAnc291cmNlLmNzcycpO1xuXG4gICAgdGhpcy5tYXAuYWRkTWFwcGluZyh7XG4gICAgICBzb3VyY2U6IHNvdXJjZUZpbGUsXG4gICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgbGluZTogdGhpcy5wb3NpdGlvbi5saW5lLFxuICAgICAgICBjb2x1bW46IE1hdGgubWF4KHRoaXMucG9zaXRpb24uY29sdW1uIC0gMSwgMClcbiAgICAgIH0sXG4gICAgICBvcmlnaW5hbDoge1xuICAgICAgICBsaW5lOiBwb3Muc3RhcnQubGluZSxcbiAgICAgICAgY29sdW1uOiBwb3Muc3RhcnQuY29sdW1uIC0gMVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5hZGRGaWxlKHNvdXJjZUZpbGUsIHBvcyk7XG4gIH1cblxuICB0aGlzLnVwZGF0ZVBvc2l0aW9uKHN0cik7XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogQWRkcyBhIGZpbGUgdG8gdGhlIHNvdXJjZSBtYXAgb3V0cHV0IGlmIGl0IGhhcyBub3QgYWxyZWFkeSBiZWVuIGFkZGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZVxuICogQHBhcmFtIHtPYmplY3R9IHBvc1xuICovXG5cbmV4cG9ydHMuYWRkRmlsZSA9IGZ1bmN0aW9uKGZpbGUsIHBvcykge1xuICBpZiAodHlwZW9mIHBvcy5jb250ZW50ICE9PSAnc3RyaW5nJykgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuZmlsZXMsIGZpbGUpKSByZXR1cm47XG5cbiAgdGhpcy5maWxlc1tmaWxlXSA9IHBvcy5jb250ZW50O1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIGFueSBvcmlnaW5hbCBzb3VyY2UgbWFwcyB0byB0aGUgb3V0cHV0IGFuZCBlbWJlZHMgdGhlIHNvdXJjZSBmaWxlXG4gKiBjb250ZW50cyBpbiB0aGUgc291cmNlIG1hcC5cbiAqL1xuXG5leHBvcnRzLmFwcGx5U291cmNlTWFwcyA9IGZ1bmN0aW9uKCkge1xuICBPYmplY3Qua2V5cyh0aGlzLmZpbGVzKS5mb3JFYWNoKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICB2YXIgY29udGVudCA9IHRoaXMuZmlsZXNbZmlsZV07XG4gICAgdGhpcy5tYXAuc2V0U291cmNlQ29udGVudChmaWxlLCBjb250ZW50KTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuaW5wdXRTb3VyY2VtYXBzICE9PSBmYWxzZSkge1xuICAgICAgdmFyIG9yaWdpbmFsTWFwID0gc291cmNlTWFwUmVzb2x2ZS5yZXNvbHZlU3luYyhcbiAgICAgICAgY29udGVudCwgZmlsZSwgZnMucmVhZEZpbGVTeW5jKTtcbiAgICAgIGlmIChvcmlnaW5hbE1hcCkge1xuICAgICAgICB2YXIgbWFwID0gbmV3IFNvdXJjZU1hcENvbnN1bWVyKG9yaWdpbmFsTWFwLm1hcCk7XG4gICAgICAgIHZhciByZWxhdGl2ZVRvID0gb3JpZ2luYWxNYXAuc291cmNlc1JlbGF0aXZlVG87XG4gICAgICAgIHRoaXMubWFwLmFwcGx5U291cmNlTWFwKG1hcCwgZmlsZSwgdXJpeChwYXRoLmRpcm5hbWUocmVsYXRpdmVUbykpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHRoaXMpO1xufTtcblxuLyoqXG4gKiBQcm9jZXNzIGNvbW1lbnRzLCBkcm9wcyBzb3VyY2VNYXAgY29tbWVudHMuXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuICovXG5cbmV4cG9ydHMuY29tbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgaWYgKC9eIyBzb3VyY2VNYXBwaW5nVVJMPS8udGVzdChub2RlLmNvbW1lbnQpKVxuICAgIHJldHVybiB0aGlzLmVtaXQoJycsIG5vZGUucG9zaXRpb24pO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuX2NvbW1lbnQobm9kZSk7XG59O1xuIiwiLyohXG4gKiBGdXNlLmpzIHYzLjQuNSAtIExpZ2h0d2VpZ2h0IGZ1enp5LXNlYXJjaCAoaHR0cDovL2Z1c2Vqcy5pbylcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgS2lyb2xsb3MgUmlzayAoaHR0cDovL2tpcm8ubWUpXG4gKiBBbGwgUmlnaHRzIFJlc2VydmVkLiBBcGFjaGUgU29mdHdhcmUgTGljZW5zZSAyLjBcbiAqIFxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cbiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFwiRnVzZVwiLFtdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMuRnVzZT10KCk6ZS5GdXNlPXQoKX0odGhpcyxmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgdD17fTtmdW5jdGlvbiBuKHIpe2lmKHRbcl0pcmV0dXJuIHRbcl0uZXhwb3J0czt2YXIgbz10W3JdPXtpOnIsbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gZVtyXS5jYWxsKG8uZXhwb3J0cyxvLG8uZXhwb3J0cyxuKSxvLmw9ITAsby5leHBvcnRzfXJldHVybiBuLm09ZSxuLmM9dCxuLmQ9ZnVuY3Rpb24oZSx0LHIpe24ubyhlLHQpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtlbnVtZXJhYmxlOiEwLGdldDpyfSl9LG4ucj1mdW5jdGlvbihlKXtcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxuLnQ9ZnVuY3Rpb24oZSx0KXtpZigxJnQmJihlPW4oZSkpLDgmdClyZXR1cm4gZTtpZig0JnQmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHI9T2JqZWN0LmNyZWF0ZShudWxsKTtpZihuLnIociksT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pLDImdCYmXCJzdHJpbmdcIiE9dHlwZW9mIGUpZm9yKHZhciBvIGluIGUpbi5kKHIsbyxmdW5jdGlvbih0KXtyZXR1cm4gZVt0XX0uYmluZChudWxsLG8pKTtyZXR1cm4gcn0sbi5uPWZ1bmN0aW9uKGUpe3ZhciB0PWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiBuLmQodCxcImFcIix0KSx0fSxuLm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LG4ucD1cIlwiLG4obi5zPTEpfShbZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuIEFycmF5LmlzQXJyYXk/QXJyYXkuaXNBcnJheShlKTpcIltvYmplY3QgQXJyYXldXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSl9fSxmdW5jdGlvbihlLHQsbil7ZnVuY3Rpb24gcihlKXtyZXR1cm4ocj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfSkoZSl9ZnVuY3Rpb24gbyhlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19dmFyIGk9bigyKSxhPW4oOCkscz1uKDApLGM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsbil7dmFyIHI9bi5sb2NhdGlvbixvPXZvaWQgMD09PXI/MDpyLGk9bi5kaXN0YW5jZSxzPXZvaWQgMD09PWk/MTAwOmksYz1uLnRocmVzaG9sZCxoPXZvaWQgMD09PWM/LjY6YyxsPW4ubWF4UGF0dGVybkxlbmd0aCx1PXZvaWQgMD09PWw/MzI6bCxmPW4uY2FzZVNlbnNpdGl2ZSxkPXZvaWQgMCE9PWYmJmYsdj1uLnRva2VuU2VwYXJhdG9yLHA9dm9pZCAwPT09dj8vICsvZzp2LGc9bi5maW5kQWxsTWF0Y2hlcyx5PXZvaWQgMCE9PWcmJmcsbT1uLm1pbk1hdGNoQ2hhckxlbmd0aCxrPXZvaWQgMD09PW0/MTptLFM9bi5pZCx4PXZvaWQgMD09PVM/bnVsbDpTLGI9bi5rZXlzLE09dm9pZCAwPT09Yj9bXTpiLF89bi5zaG91bGRTb3J0LEw9dm9pZCAwPT09X3x8Xyx3PW4uZ2V0Rm4sQT12b2lkIDA9PT13P2E6dyxDPW4uc29ydEZuLEk9dm9pZCAwPT09Qz9mdW5jdGlvbihlLHQpe3JldHVybiBlLnNjb3JlLXQuc2NvcmV9OkMsTz1uLnRva2VuaXplLGo9dm9pZCAwIT09TyYmTyxQPW4ubWF0Y2hBbGxUb2tlbnMsRj12b2lkIDAhPT1QJiZQLFQ9bi5pbmNsdWRlTWF0Y2hlcyx6PXZvaWQgMCE9PVQmJlQsRT1uLmluY2x1ZGVTY29yZSxLPXZvaWQgMCE9PUUmJkUsJD1uLnZlcmJvc2UsSj12b2lkIDAhPT0kJiYkOyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZSksdGhpcy5vcHRpb25zPXtsb2NhdGlvbjpvLGRpc3RhbmNlOnMsdGhyZXNob2xkOmgsbWF4UGF0dGVybkxlbmd0aDp1LGlzQ2FzZVNlbnNpdGl2ZTpkLHRva2VuU2VwYXJhdG9yOnAsZmluZEFsbE1hdGNoZXM6eSxtaW5NYXRjaENoYXJMZW5ndGg6ayxpZDp4LGtleXM6TSxpbmNsdWRlTWF0Y2hlczp6LGluY2x1ZGVTY29yZTpLLHNob3VsZFNvcnQ6TCxnZXRGbjpBLHNvcnRGbjpJLHZlcmJvc2U6Six0b2tlbml6ZTpqLG1hdGNoQWxsVG9rZW5zOkZ9LHRoaXMuc2V0Q29sbGVjdGlvbih0KX12YXIgdCxuLGM7cmV0dXJuIHQ9ZSwobj1be2tleTpcInNldENvbGxlY3Rpb25cIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5saXN0PWUsZX19LHtrZXk6XCJzZWFyY2hcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e2xpbWl0OiExfTt0aGlzLl9sb2coJy0tLS0tLS0tLVxcblNlYXJjaCBwYXR0ZXJuOiBcIicuY29uY2F0KGUsJ1wiJykpO3ZhciBuPXRoaXMuX3ByZXBhcmVTZWFyY2hlcnMoZSkscj1uLnRva2VuU2VhcmNoZXJzLG89bi5mdWxsU2VhcmNoZXIsaT10aGlzLl9zZWFyY2gocixvKSxhPWkud2VpZ2h0cyxzPWkucmVzdWx0cztyZXR1cm4gdGhpcy5fY29tcHV0ZVNjb3JlKGEscyksdGhpcy5vcHRpb25zLnNob3VsZFNvcnQmJnRoaXMuX3NvcnQocyksdC5saW1pdCYmXCJudW1iZXJcIj09dHlwZW9mIHQubGltaXQmJihzPXMuc2xpY2UoMCx0LmxpbWl0KSksdGhpcy5fZm9ybWF0KHMpfX0se2tleTpcIl9wcmVwYXJlU2VhcmNoZXJzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06XCJcIix0PVtdO2lmKHRoaXMub3B0aW9ucy50b2tlbml6ZSlmb3IodmFyIG49ZS5zcGxpdCh0aGlzLm9wdGlvbnMudG9rZW5TZXBhcmF0b3IpLHI9MCxvPW4ubGVuZ3RoO3I8bztyKz0xKXQucHVzaChuZXcgaShuW3JdLHRoaXMub3B0aW9ucykpO3JldHVybnt0b2tlblNlYXJjaGVyczp0LGZ1bGxTZWFyY2hlcjpuZXcgaShlLHRoaXMub3B0aW9ucyl9fX0se2tleTpcIl9zZWFyY2hcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTpbXSx0PWFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwLG49dGhpcy5saXN0LHI9e30sbz1bXTtpZihcInN0cmluZ1wiPT10eXBlb2YgblswXSl7Zm9yKHZhciBpPTAsYT1uLmxlbmd0aDtpPGE7aSs9MSl0aGlzLl9hbmFseXplKHtrZXk6XCJcIix2YWx1ZTpuW2ldLHJlY29yZDppLGluZGV4Oml9LHtyZXN1bHRNYXA6cixyZXN1bHRzOm8sdG9rZW5TZWFyY2hlcnM6ZSxmdWxsU2VhcmNoZXI6dH0pO3JldHVybnt3ZWlnaHRzOm51bGwscmVzdWx0czpvfX1mb3IodmFyIHM9e30sYz0wLGg9bi5sZW5ndGg7YzxoO2MrPTEpZm9yKHZhciBsPW5bY10sdT0wLGY9dGhpcy5vcHRpb25zLmtleXMubGVuZ3RoO3U8Zjt1Kz0xKXt2YXIgZD10aGlzLm9wdGlvbnMua2V5c1t1XTtpZihcInN0cmluZ1wiIT10eXBlb2YgZCl7aWYoc1tkLm5hbWVdPXt3ZWlnaHQ6MS1kLndlaWdodHx8MX0sZC53ZWlnaHQ8PTB8fGQud2VpZ2h0PjEpdGhyb3cgbmV3IEVycm9yKFwiS2V5IHdlaWdodCBoYXMgdG8gYmUgPiAwIGFuZCA8PSAxXCIpO2Q9ZC5uYW1lfWVsc2Ugc1tkXT17d2VpZ2h0OjF9O3RoaXMuX2FuYWx5emUoe2tleTpkLHZhbHVlOnRoaXMub3B0aW9ucy5nZXRGbihsLGQpLHJlY29yZDpsLGluZGV4OmN9LHtyZXN1bHRNYXA6cixyZXN1bHRzOm8sdG9rZW5TZWFyY2hlcnM6ZSxmdWxsU2VhcmNoZXI6dH0pfXJldHVybnt3ZWlnaHRzOnMscmVzdWx0czpvfX19LHtrZXk6XCJfYW5hbHl6ZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5rZXkscj1lLmFycmF5SW5kZXgsbz12b2lkIDA9PT1yPy0xOnIsaT1lLnZhbHVlLGE9ZS5yZWNvcmQsYz1lLmluZGV4LGg9dC50b2tlblNlYXJjaGVycyxsPXZvaWQgMD09PWg/W106aCx1PXQuZnVsbFNlYXJjaGVyLGY9dm9pZCAwPT09dT9bXTp1LGQ9dC5yZXN1bHRNYXAsdj12b2lkIDA9PT1kP3t9OmQscD10LnJlc3VsdHMsZz12b2lkIDA9PT1wP1tdOnA7aWYobnVsbCE9aSl7dmFyIHk9ITEsbT0tMSxrPTA7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGkpe3RoaXMuX2xvZyhcIlxcbktleTogXCIuY29uY2F0KFwiXCI9PT1uP1wiLVwiOm4pKTt2YXIgUz1mLnNlYXJjaChpKTtpZih0aGlzLl9sb2coJ0Z1bGwgdGV4dDogXCInLmNvbmNhdChpLCdcIiwgc2NvcmU6ICcpLmNvbmNhdChTLnNjb3JlKSksdGhpcy5vcHRpb25zLnRva2VuaXplKXtmb3IodmFyIHg9aS5zcGxpdCh0aGlzLm9wdGlvbnMudG9rZW5TZXBhcmF0b3IpLGI9W10sTT0wO008bC5sZW5ndGg7TSs9MSl7dmFyIF89bFtNXTt0aGlzLl9sb2coJ1xcblBhdHRlcm46IFwiJy5jb25jYXQoXy5wYXR0ZXJuLCdcIicpKTtmb3IodmFyIEw9ITEsdz0wO3c8eC5sZW5ndGg7dys9MSl7dmFyIEE9eFt3XSxDPV8uc2VhcmNoKEEpLEk9e307Qy5pc01hdGNoPyhJW0FdPUMuc2NvcmUseT0hMCxMPSEwLGIucHVzaChDLnNjb3JlKSk6KElbQV09MSx0aGlzLm9wdGlvbnMubWF0Y2hBbGxUb2tlbnN8fGIucHVzaCgxKSksdGhpcy5fbG9nKCdUb2tlbjogXCInLmNvbmNhdChBLCdcIiwgc2NvcmU6ICcpLmNvbmNhdChJW0FdKSl9TCYmKGsrPTEpfW09YlswXTtmb3IodmFyIE89Yi5sZW5ndGgsaj0xO2o8TztqKz0xKW0rPWJbal07bS89Tyx0aGlzLl9sb2coXCJUb2tlbiBzY29yZSBhdmVyYWdlOlwiLG0pfXZhciBQPVMuc2NvcmU7bT4tMSYmKFA9KFArbSkvMiksdGhpcy5fbG9nKFwiU2NvcmUgYXZlcmFnZTpcIixQKTt2YXIgRj0hdGhpcy5vcHRpb25zLnRva2VuaXplfHwhdGhpcy5vcHRpb25zLm1hdGNoQWxsVG9rZW5zfHxrPj1sLmxlbmd0aDtpZih0aGlzLl9sb2coXCJcXG5DaGVjayBNYXRjaGVzOiBcIi5jb25jYXQoRikpLCh5fHxTLmlzTWF0Y2gpJiZGKXt2YXIgVD12W2NdO1Q/VC5vdXRwdXQucHVzaCh7a2V5Om4sYXJyYXlJbmRleDpvLHZhbHVlOmksc2NvcmU6UCxtYXRjaGVkSW5kaWNlczpTLm1hdGNoZWRJbmRpY2VzfSk6KHZbY109e2l0ZW06YSxvdXRwdXQ6W3trZXk6bixhcnJheUluZGV4Om8sdmFsdWU6aSxzY29yZTpQLG1hdGNoZWRJbmRpY2VzOlMubWF0Y2hlZEluZGljZXN9XX0sZy5wdXNoKHZbY10pKX19ZWxzZSBpZihzKGkpKWZvcih2YXIgej0wLEU9aS5sZW5ndGg7ejxFO3orPTEpdGhpcy5fYW5hbHl6ZSh7a2V5Om4sYXJyYXlJbmRleDp6LHZhbHVlOmlbel0scmVjb3JkOmEsaW5kZXg6Y30se3Jlc3VsdE1hcDp2LHJlc3VsdHM6Zyx0b2tlblNlYXJjaGVyczpsLGZ1bGxTZWFyY2hlcjpmfSl9fX0se2tleTpcIl9jb21wdXRlU2NvcmVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3RoaXMuX2xvZyhcIlxcblxcbkNvbXB1dGluZyBzY29yZTpcXG5cIik7Zm9yKHZhciBuPTAscj10Lmxlbmd0aDtuPHI7bis9MSl7Zm9yKHZhciBvPXRbbl0ub3V0cHV0LGk9by5sZW5ndGgsYT0xLHM9MSxjPTA7YzxpO2MrPTEpe3ZhciBoPWU/ZVtvW2NdLmtleV0ud2VpZ2h0OjEsbD0oMT09PWg/b1tjXS5zY29yZTpvW2NdLnNjb3JlfHwuMDAxKSpoOzEhPT1oP3M9TWF0aC5taW4ocyxsKToob1tjXS5uU2NvcmU9bCxhKj1sKX10W25dLnNjb3JlPTE9PT1zP2E6cyx0aGlzLl9sb2codFtuXSl9fX0se2tleTpcIl9zb3J0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5fbG9nKFwiXFxuXFxuU29ydGluZy4uLi5cIiksZS5zb3J0KHRoaXMub3B0aW9ucy5zb3J0Rm4pfX0se2tleTpcIl9mb3JtYXRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1bXTtpZih0aGlzLm9wdGlvbnMudmVyYm9zZSl7dmFyIG49W107dGhpcy5fbG9nKFwiXFxuXFxuT3V0cHV0OlxcblxcblwiLEpTT04uc3RyaW5naWZ5KGUsZnVuY3Rpb24oZSx0KXtpZihcIm9iamVjdFwiPT09cih0KSYmbnVsbCE9PXQpe2lmKC0xIT09bi5pbmRleE9mKHQpKXJldHVybjtuLnB1c2godCl9cmV0dXJuIHR9KSksbj1udWxsfXZhciBvPVtdO3RoaXMub3B0aW9ucy5pbmNsdWRlTWF0Y2hlcyYmby5wdXNoKGZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5vdXRwdXQ7dC5tYXRjaGVzPVtdO2Zvcih2YXIgcj0wLG89bi5sZW5ndGg7cjxvO3IrPTEpe3ZhciBpPW5bcl07aWYoMCE9PWkubWF0Y2hlZEluZGljZXMubGVuZ3RoKXt2YXIgYT17aW5kaWNlczppLm1hdGNoZWRJbmRpY2VzLHZhbHVlOmkudmFsdWV9O2kua2V5JiYoYS5rZXk9aS5rZXkpLGkuaGFzT3duUHJvcGVydHkoXCJhcnJheUluZGV4XCIpJiZpLmFycmF5SW5kZXg+LTEmJihhLmFycmF5SW5kZXg9aS5hcnJheUluZGV4KSx0Lm1hdGNoZXMucHVzaChhKX19fSksdGhpcy5vcHRpb25zLmluY2x1ZGVTY29yZSYmby5wdXNoKGZ1bmN0aW9uKGUsdCl7dC5zY29yZT1lLnNjb3JlfSk7Zm9yKHZhciBpPTAsYT1lLmxlbmd0aDtpPGE7aSs9MSl7dmFyIHM9ZVtpXTtpZih0aGlzLm9wdGlvbnMuaWQmJihzLml0ZW09dGhpcy5vcHRpb25zLmdldEZuKHMuaXRlbSx0aGlzLm9wdGlvbnMuaWQpWzBdKSxvLmxlbmd0aCl7Zm9yKHZhciBjPXtpdGVtOnMuaXRlbX0saD0wLGw9by5sZW5ndGg7aDxsO2grPTEpb1toXShzLGMpO3QucHVzaChjKX1lbHNlIHQucHVzaChzLml0ZW0pfXJldHVybiB0fX0se2tleTpcIl9sb2dcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlO3RoaXMub3B0aW9ucy52ZXJib3NlJiYoZT1jb25zb2xlKS5sb2cuYXBwbHkoZSxhcmd1bWVudHMpfX1dKSYmbyh0LnByb3RvdHlwZSxuKSxjJiZvKHQsYyksZX0oKTtlLmV4cG9ydHM9Y30sZnVuY3Rpb24oZSx0LG4pe2Z1bmN0aW9uIHIoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsci5rZXkscil9fXZhciBvPW4oMyksaT1uKDQpLGE9big3KSxzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4pe3ZhciByPW4ubG9jYXRpb24sbz12b2lkIDA9PT1yPzA6cixpPW4uZGlzdGFuY2Uscz12b2lkIDA9PT1pPzEwMDppLGM9bi50aHJlc2hvbGQsaD12b2lkIDA9PT1jPy42OmMsbD1uLm1heFBhdHRlcm5MZW5ndGgsdT12b2lkIDA9PT1sPzMyOmwsZj1uLmlzQ2FzZVNlbnNpdGl2ZSxkPXZvaWQgMCE9PWYmJmYsdj1uLnRva2VuU2VwYXJhdG9yLHA9dm9pZCAwPT09dj8vICsvZzp2LGc9bi5maW5kQWxsTWF0Y2hlcyx5PXZvaWQgMCE9PWcmJmcsbT1uLm1pbk1hdGNoQ2hhckxlbmd0aCxrPXZvaWQgMD09PW0/MTptOyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZSksdGhpcy5vcHRpb25zPXtsb2NhdGlvbjpvLGRpc3RhbmNlOnMsdGhyZXNob2xkOmgsbWF4UGF0dGVybkxlbmd0aDp1LGlzQ2FzZVNlbnNpdGl2ZTpkLHRva2VuU2VwYXJhdG9yOnAsZmluZEFsbE1hdGNoZXM6eSxtaW5NYXRjaENoYXJMZW5ndGg6a30sdGhpcy5wYXR0ZXJuPXRoaXMub3B0aW9ucy5pc0Nhc2VTZW5zaXRpdmU/dDp0LnRvTG93ZXJDYXNlKCksdGhpcy5wYXR0ZXJuLmxlbmd0aDw9dSYmKHRoaXMucGF0dGVybkFscGhhYmV0PWEodGhpcy5wYXR0ZXJuKSl9dmFyIHQsbixzO3JldHVybiB0PWUsKG49W3trZXk6XCJzZWFyY2hcIix2YWx1ZTpmdW5jdGlvbihlKXtpZih0aGlzLm9wdGlvbnMuaXNDYXNlU2Vuc2l0aXZlfHwoZT1lLnRvTG93ZXJDYXNlKCkpLHRoaXMucGF0dGVybj09PWUpcmV0dXJue2lzTWF0Y2g6ITAsc2NvcmU6MCxtYXRjaGVkSW5kaWNlczpbWzAsZS5sZW5ndGgtMV1dfTt2YXIgdD10aGlzLm9wdGlvbnMsbj10Lm1heFBhdHRlcm5MZW5ndGgscj10LnRva2VuU2VwYXJhdG9yO2lmKHRoaXMucGF0dGVybi5sZW5ndGg+bilyZXR1cm4gbyhlLHRoaXMucGF0dGVybixyKTt2YXIgYT10aGlzLm9wdGlvbnMscz1hLmxvY2F0aW9uLGM9YS5kaXN0YW5jZSxoPWEudGhyZXNob2xkLGw9YS5maW5kQWxsTWF0Y2hlcyx1PWEubWluTWF0Y2hDaGFyTGVuZ3RoO3JldHVybiBpKGUsdGhpcy5wYXR0ZXJuLHRoaXMucGF0dGVybkFscGhhYmV0LHtsb2NhdGlvbjpzLGRpc3RhbmNlOmMsdGhyZXNob2xkOmgsZmluZEFsbE1hdGNoZXM6bCxtaW5NYXRjaENoYXJMZW5ndGg6dX0pfX1dKSYmcih0LnByb3RvdHlwZSxuKSxzJiZyKHQscyksZX0oKTtlLmV4cG9ydHM9c30sZnVuY3Rpb24oZSx0KXt2YXIgbj0vW1xcLVxcW1xcXVxcL1xce1xcfVxcKFxcKVxcKlxcK1xcP1xcLlxcXFxcXF5cXCRcXHxdL2c7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7dmFyIHI9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOi8gKy9nLG89bmV3IFJlZ0V4cCh0LnJlcGxhY2UobixcIlxcXFwkJlwiKS5yZXBsYWNlKHIsXCJ8XCIpKSxpPWUubWF0Y2gobyksYT0hIWkscz1bXTtpZihhKWZvcih2YXIgYz0wLGg9aS5sZW5ndGg7YzxoO2MrPTEpe3ZhciBsPWlbY107cy5wdXNoKFtlLmluZGV4T2YobCksbC5sZW5ndGgtMV0pfXJldHVybntzY29yZTphPy41OjEsaXNNYXRjaDphLG1hdGNoZWRJbmRpY2VzOnN9fX0sZnVuY3Rpb24oZSx0LG4pe3ZhciByPW4oNSksbz1uKDYpO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQsbixpKXtmb3IodmFyIGE9aS5sb2NhdGlvbixzPXZvaWQgMD09PWE/MDphLGM9aS5kaXN0YW5jZSxoPXZvaWQgMD09PWM/MTAwOmMsbD1pLnRocmVzaG9sZCx1PXZvaWQgMD09PWw/LjY6bCxmPWkuZmluZEFsbE1hdGNoZXMsZD12b2lkIDAhPT1mJiZmLHY9aS5taW5NYXRjaENoYXJMZW5ndGgscD12b2lkIDA9PT12PzE6dixnPXMseT1lLmxlbmd0aCxtPXUsaz1lLmluZGV4T2YodCxnKSxTPXQubGVuZ3RoLHg9W10sYj0wO2I8eTtiKz0xKXhbYl09MDtpZigtMSE9PWspe3ZhciBNPXIodCx7ZXJyb3JzOjAsY3VycmVudExvY2F0aW9uOmssZXhwZWN0ZWRMb2NhdGlvbjpnLGRpc3RhbmNlOmh9KTtpZihtPU1hdGgubWluKE0sbSksLTEhPT0oaz1lLmxhc3RJbmRleE9mKHQsZytTKSkpe3ZhciBfPXIodCx7ZXJyb3JzOjAsY3VycmVudExvY2F0aW9uOmssZXhwZWN0ZWRMb2NhdGlvbjpnLGRpc3RhbmNlOmh9KTttPU1hdGgubWluKF8sbSl9fWs9LTE7Zm9yKHZhciBMPVtdLHc9MSxBPVMreSxDPTE8PFMtMSxJPTA7STxTO0krPTEpe2Zvcih2YXIgTz0wLGo9QTtPPGo7KXtyKHQse2Vycm9yczpJLGN1cnJlbnRMb2NhdGlvbjpnK2osZXhwZWN0ZWRMb2NhdGlvbjpnLGRpc3RhbmNlOmh9KTw9bT9PPWo6QT1qLGo9TWF0aC5mbG9vcigoQS1PKS8yK08pfUE9ajt2YXIgUD1NYXRoLm1heCgxLGctaisxKSxGPWQ/eTpNYXRoLm1pbihnK2oseSkrUyxUPUFycmF5KEYrMik7VFtGKzFdPSgxPDxJKS0xO2Zvcih2YXIgej1GO3o+PVA7ei09MSl7dmFyIEU9ei0xLEs9bltlLmNoYXJBdChFKV07aWYoSyYmKHhbRV09MSksVFt6XT0oVFt6KzFdPDwxfDEpJkssMCE9PUkmJihUW3pdfD0oTFt6KzFdfExbel0pPDwxfDF8TFt6KzFdKSxUW3pdJkMmJih3PXIodCx7ZXJyb3JzOkksY3VycmVudExvY2F0aW9uOkUsZXhwZWN0ZWRMb2NhdGlvbjpnLGRpc3RhbmNlOmh9KSk8PW0pe2lmKG09dywoaz1FKTw9ZylicmVhaztQPU1hdGgubWF4KDEsMipnLWspfX1pZihyKHQse2Vycm9yczpJKzEsY3VycmVudExvY2F0aW9uOmcsZXhwZWN0ZWRMb2NhdGlvbjpnLGRpc3RhbmNlOmh9KT5tKWJyZWFrO0w9VH1yZXR1cm57aXNNYXRjaDprPj0wLHNjb3JlOjA9PT13Py4wMDE6dyxtYXRjaGVkSW5kaWNlczpvKHgscCl9fX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmVycm9ycyxyPXZvaWQgMD09PW4/MDpuLG89dC5jdXJyZW50TG9jYXRpb24saT12b2lkIDA9PT1vPzA6byxhPXQuZXhwZWN0ZWRMb2NhdGlvbixzPXZvaWQgMD09PWE/MDphLGM9dC5kaXN0YW5jZSxoPXZvaWQgMD09PWM/MTAwOmMsbD1yL2UubGVuZ3RoLHU9TWF0aC5hYnMocy1pKTtyZXR1cm4gaD9sK3UvaDp1PzE6bH19LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTpbXSx0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXToxLG49W10scj0tMSxvPS0xLGk9MCxhPWUubGVuZ3RoO2k8YTtpKz0xKXt2YXIgcz1lW2ldO3MmJi0xPT09cj9yPWk6c3x8LTE9PT1yfHwoKG89aS0xKS1yKzE+PXQmJm4ucHVzaChbcixvXSkscj0tMSl9cmV0dXJuIGVbaS0xXSYmaS1yPj10JiZuLnB1c2goW3IsaS0xXSksbn19LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD17fSxuPWUubGVuZ3RoLHI9MDtyPG47cis9MSl0W2UuY2hhckF0KHIpXT0wO2Zvcih2YXIgbz0wO288bjtvKz0xKXRbZS5jaGFyQXQobyldfD0xPDxuLW8tMTtyZXR1cm4gdH19LGZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1uKDApO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQpe3JldHVybiBmdW5jdGlvbiBlKHQsbixvKXtpZihuKXt2YXIgaT1uLmluZGV4T2YoXCIuXCIpLGE9bixzPW51bGw7LTEhPT1pJiYoYT1uLnNsaWNlKDAsaSkscz1uLnNsaWNlKGkrMSkpO3ZhciBjPXRbYV07aWYobnVsbCE9YylpZihzfHxcInN0cmluZ1wiIT10eXBlb2YgYyYmXCJudW1iZXJcIiE9dHlwZW9mIGMpaWYocihjKSlmb3IodmFyIGg9MCxsPWMubGVuZ3RoO2g8bDtoKz0xKWUoY1toXSxzLG8pO2Vsc2UgcyYmZShjLHMsbyk7ZWxzZSBvLnB1c2goYy50b1N0cmluZygpKX1lbHNlIG8ucHVzaCh0KTtyZXR1cm4gb30oZSx0LFtdKX19XSl9KTsiLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QubmVhcmxleSA9IGZhY3RvcnkoKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uKCkge1xuXG4gICAgZnVuY3Rpb24gUnVsZShuYW1lLCBzeW1ib2xzLCBwb3N0cHJvY2Vzcykge1xuICAgICAgICB0aGlzLmlkID0gKytSdWxlLmhpZ2hlc3RJZDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zeW1ib2xzID0gc3ltYm9sczsgICAgICAgIC8vIGEgbGlzdCBvZiBsaXRlcmFsIHwgcmVnZXggY2xhc3MgfCBub250ZXJtaW5hbFxuICAgICAgICB0aGlzLnBvc3Rwcm9jZXNzID0gcG9zdHByb2Nlc3M7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBSdWxlLmhpZ2hlc3RJZCA9IDA7XG5cbiAgICBSdWxlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKHdpdGhDdXJzb3JBdCkge1xuICAgICAgICBmdW5jdGlvbiBzdHJpbmdpZnlTeW1ib2xTZXF1ZW5jZSAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUubGl0ZXJhbCA/IEpTT04uc3RyaW5naWZ5KGUubGl0ZXJhbCkgOlxuICAgICAgICAgICAgICAgICAgIGUudHlwZSA/ICclJyArIGUudHlwZSA6IGUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3ltYm9sU2VxdWVuY2UgPSAodHlwZW9mIHdpdGhDdXJzb3JBdCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnN5bWJvbHMubWFwKHN0cmluZ2lmeVN5bWJvbFNlcXVlbmNlKS5qb2luKCcgJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoICAgdGhpcy5zeW1ib2xzLnNsaWNlKDAsIHdpdGhDdXJzb3JBdCkubWFwKHN0cmluZ2lmeVN5bWJvbFNlcXVlbmNlKS5qb2luKCcgJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgXCIg4pePIFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIHRoaXMuc3ltYm9scy5zbGljZSh3aXRoQ3Vyc29yQXQpLm1hcChzdHJpbmdpZnlTeW1ib2xTZXF1ZW5jZSkuam9pbignICcpICAgICApO1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgXCIg4oaSIFwiICsgc3ltYm9sU2VxdWVuY2U7XG4gICAgfVxuXG5cbiAgICAvLyBhIFN0YXRlIGlzIGEgcnVsZSBhdCBhIHBvc2l0aW9uIGZyb20gYSBnaXZlbiBzdGFydGluZyBwb2ludCBpbiB0aGUgaW5wdXQgc3RyZWFtIChyZWZlcmVuY2UpXG4gICAgZnVuY3Rpb24gU3RhdGUocnVsZSwgZG90LCByZWZlcmVuY2UsIHdhbnRlZEJ5KSB7XG4gICAgICAgIHRoaXMucnVsZSA9IHJ1bGU7XG4gICAgICAgIHRoaXMuZG90ID0gZG90O1xuICAgICAgICB0aGlzLnJlZmVyZW5jZSA9IHJlZmVyZW5jZTtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgIHRoaXMud2FudGVkQnkgPSB3YW50ZWRCeTtcbiAgICAgICAgdGhpcy5pc0NvbXBsZXRlID0gdGhpcy5kb3QgPT09IHJ1bGUuc3ltYm9scy5sZW5ndGg7XG4gICAgfVxuXG4gICAgU3RhdGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIntcIiArIHRoaXMucnVsZS50b1N0cmluZyh0aGlzLmRvdCkgKyBcIn0sIGZyb206IFwiICsgKHRoaXMucmVmZXJlbmNlIHx8IDApO1xuICAgIH07XG5cbiAgICBTdGF0ZS5wcm90b3R5cGUubmV4dFN0YXRlID0gZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gbmV3IFN0YXRlKHRoaXMucnVsZSwgdGhpcy5kb3QgKyAxLCB0aGlzLnJlZmVyZW5jZSwgdGhpcy53YW50ZWRCeSk7XG4gICAgICAgIHN0YXRlLmxlZnQgPSB0aGlzO1xuICAgICAgICBzdGF0ZS5yaWdodCA9IGNoaWxkO1xuICAgICAgICBpZiAoc3RhdGUuaXNDb21wbGV0ZSkge1xuICAgICAgICAgICAgc3RhdGUuZGF0YSA9IHN0YXRlLmJ1aWxkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH07XG5cbiAgICBTdGF0ZS5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgICAgIHZhciBub2RlID0gdGhpcztcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChub2RlLnJpZ2h0LmRhdGEpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgfSB3aGlsZSAobm9kZS5sZWZ0KTtcbiAgICAgICAgY2hpbGRyZW4ucmV2ZXJzZSgpO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfTtcblxuICAgIFN0YXRlLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucnVsZS5wb3N0cHJvY2Vzcykge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5ydWxlLnBvc3Rwcm9jZXNzKHRoaXMuZGF0YSwgdGhpcy5yZWZlcmVuY2UsIFBhcnNlci5mYWlsKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIGZ1bmN0aW9uIENvbHVtbihncmFtbWFyLCBpbmRleCkge1xuICAgICAgICB0aGlzLmdyYW1tYXIgPSBncmFtbWFyO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuc3RhdGVzID0gW107XG4gICAgICAgIHRoaXMud2FudHMgPSB7fTsgLy8gc3RhdGVzIGluZGV4ZWQgYnkgdGhlIG5vbi10ZXJtaW5hbCB0aGV5IGV4cGVjdFxuICAgICAgICB0aGlzLnNjYW5uYWJsZSA9IFtdOyAvLyBsaXN0IG9mIHN0YXRlcyB0aGF0IGV4cGVjdCBhIHRva2VuXG4gICAgICAgIHRoaXMuY29tcGxldGVkID0ge307IC8vIHN0YXRlcyB0aGF0IGFyZSBudWxsYWJsZVxuICAgIH1cblxuXG4gICAgQ29sdW1uLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24obmV4dENvbHVtbikge1xuICAgICAgICB2YXIgc3RhdGVzID0gdGhpcy5zdGF0ZXM7XG4gICAgICAgIHZhciB3YW50cyA9IHRoaXMud2FudHM7XG4gICAgICAgIHZhciBjb21wbGV0ZWQgPSB0aGlzLmNvbXBsZXRlZDtcblxuICAgICAgICBmb3IgKHZhciB3ID0gMDsgdyA8IHN0YXRlcy5sZW5ndGg7IHcrKykgeyAvLyBuYi4gd2UgcHVzaCgpIGR1cmluZyBpdGVyYXRpb25cbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHN0YXRlc1t3XTtcblxuICAgICAgICAgICAgaWYgKHN0YXRlLmlzQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5maW5pc2goKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZGF0YSAhPT0gUGFyc2VyLmZhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcGxldGVcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdhbnRlZEJ5ID0gc3RhdGUud2FudGVkQnk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSB3YW50ZWRCeS5sZW5ndGg7IGktLTsgKSB7IC8vIHRoaXMgbGluZSBpcyBob3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gd2FudGVkQnlbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlKGxlZnQsIHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpYWwtY2FzZSBudWxsYWJsZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLnJlZmVyZW5jZSA9PT0gdGhpcy5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGZ1dHVyZSBwcmVkaWN0b3JzIG9mIHRoaXMgcnVsZSBnZXQgY29tcGxldGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cCA9IHN0YXRlLnJ1bGUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmNvbXBsZXRlZFtleHBdID0gdGhpcy5jb21wbGV0ZWRbZXhwXSB8fCBbXSkucHVzaChzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcXVldWUgc2Nhbm5hYmxlIHN0YXRlc1xuICAgICAgICAgICAgICAgIHZhciBleHAgPSBzdGF0ZS5ydWxlLnN5bWJvbHNbc3RhdGUuZG90XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4cCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FubmFibGUucHVzaChzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHByZWRpY3RcbiAgICAgICAgICAgICAgICBpZiAod2FudHNbZXhwXSkge1xuICAgICAgICAgICAgICAgICAgICB3YW50c1tleHBdLnB1c2goc3RhdGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQuaGFzT3duUHJvcGVydHkoZXhwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG51bGxzID0gY29tcGxldGVkW2V4cF07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gbnVsbHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZShzdGF0ZSwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2FudHNbZXhwXSA9IFtzdGF0ZV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJlZGljdChleHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIENvbHVtbi5wcm90b3R5cGUucHJlZGljdCA9IGZ1bmN0aW9uKGV4cCkge1xuICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLmdyYW1tYXIuYnlOYW1lW2V4cF0gfHwgW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHIgPSBydWxlc1tpXTtcbiAgICAgICAgICAgIHZhciB3YW50ZWRCeSA9IHRoaXMud2FudHNbZXhwXTtcbiAgICAgICAgICAgIHZhciBzID0gbmV3IFN0YXRlKHIsIDAsIHRoaXMuaW5kZXgsIHdhbnRlZEJ5KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVzLnB1c2gocyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBDb2x1bW4ucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdmFyIGNvcHkgPSBsZWZ0Lm5leHRTdGF0ZShyaWdodCk7XG4gICAgICAgIHRoaXMuc3RhdGVzLnB1c2goY29weSk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBHcmFtbWFyKHJ1bGVzLCBzdGFydCkge1xuICAgICAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydCB8fCB0aGlzLnJ1bGVzWzBdLm5hbWU7XG4gICAgICAgIHZhciBieU5hbWUgPSB0aGlzLmJ5TmFtZSA9IHt9O1xuICAgICAgICB0aGlzLnJ1bGVzLmZvckVhY2goZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICAgICAgaWYgKCFieU5hbWUuaGFzT3duUHJvcGVydHkocnVsZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGJ5TmFtZVtydWxlLm5hbWVdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBieU5hbWVbcnVsZS5uYW1lXS5wdXNoKHJ1bGUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTbyB3ZSBjYW4gYWxsb3cgcGFzc2luZyAocnVsZXMsIHN0YXJ0KSBkaXJlY3RseSB0byBQYXJzZXIgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgR3JhbW1hci5mcm9tQ29tcGlsZWQgPSBmdW5jdGlvbihydWxlcywgc3RhcnQpIHtcbiAgICAgICAgdmFyIGxleGVyID0gcnVsZXMuTGV4ZXI7XG4gICAgICAgIGlmIChydWxlcy5QYXJzZXJTdGFydCkge1xuICAgICAgICAgIHN0YXJ0ID0gcnVsZXMuUGFyc2VyU3RhcnQ7XG4gICAgICAgICAgcnVsZXMgPSBydWxlcy5QYXJzZXJSdWxlcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcnVsZXMgPSBydWxlcy5tYXAoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIChuZXcgUnVsZShyLm5hbWUsIHIuc3ltYm9scywgci5wb3N0cHJvY2VzcykpOyB9KTtcbiAgICAgICAgdmFyIGcgPSBuZXcgR3JhbW1hcihydWxlcywgc3RhcnQpO1xuICAgICAgICBnLmxleGVyID0gbGV4ZXI7IC8vIG5iLiBzdG9yaW5nIGxleGVyIG9uIEdyYW1tYXIgaXMgaWZmeSwgYnV0IHVuYXZvaWRhYmxlXG4gICAgICAgIHJldHVybiBnO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gU3RyZWFtTGV4ZXIoKSB7XG4gICAgICB0aGlzLnJlc2V0KFwiXCIpO1xuICAgIH1cblxuICAgIFN0cmVhbUxleGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKGRhdGEsIHN0YXRlKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gZGF0YTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMubGluZSA9IHN0YXRlID8gc3RhdGUubGluZSA6IDE7XG4gICAgICAgIHRoaXMubGFzdExpbmVCcmVhayA9IHN0YXRlID8gLXN0YXRlLmNvbCA6IDA7XG4gICAgfVxuXG4gICAgU3RyZWFtTGV4ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPCB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuYnVmZmVyW3RoaXMuaW5kZXgrK107XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgIHRoaXMubGluZSArPSAxO1xuICAgICAgICAgICAgICB0aGlzLmxhc3RMaW5lQnJlYWsgPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHt2YWx1ZTogY2h9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgU3RyZWFtTGV4ZXIucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IHRoaXMubGluZSxcbiAgICAgICAgY29sOiB0aGlzLmluZGV4IC0gdGhpcy5sYXN0TGluZUJyZWFrLFxuICAgICAgfVxuICAgIH1cblxuICAgIFN0cmVhbUxleGVyLnByb3RvdHlwZS5mb3JtYXRFcnJvciA9IGZ1bmN0aW9uKHRva2VuLCBtZXNzYWdlKSB7XG4gICAgICAgIC8vIG5iLiB0aGlzIGdldHMgY2FsbGVkIGFmdGVyIGNvbnN1bWluZyB0aGUgb2ZmZW5kaW5nIHRva2VuLFxuICAgICAgICAvLyBzbyB0aGUgY3VscHJpdCBpcyBpbmRleC0xXG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgbmV4dExpbmVCcmVhayA9IGJ1ZmZlci5pbmRleE9mKCdcXG4nLCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIGlmIChuZXh0TGluZUJyZWFrID09PSAtMSkgbmV4dExpbmVCcmVhayA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgbGluZSA9IGJ1ZmZlci5zdWJzdHJpbmcodGhpcy5sYXN0TGluZUJyZWFrLCBuZXh0TGluZUJyZWFrKVxuICAgICAgICAgICAgdmFyIGNvbCA9IHRoaXMuaW5kZXggLSB0aGlzLmxhc3RMaW5lQnJlYWs7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIGF0IGxpbmUgXCIgKyB0aGlzLmxpbmUgKyBcIiBjb2wgXCIgKyBjb2wgKyBcIjpcXG5cXG5cIjtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgIFwiICsgbGluZSArIFwiXFxuXCJcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgIFwiICsgQXJyYXkoY29sKS5qb2luKFwiIFwiKSArIFwiXlwiXG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlICsgXCIgYXQgaW5kZXggXCIgKyAodGhpcy5pbmRleCAtIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBQYXJzZXIocnVsZXMsIHN0YXJ0LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChydWxlcyBpbnN0YW5jZW9mIEdyYW1tYXIpIHtcbiAgICAgICAgICAgIHZhciBncmFtbWFyID0gcnVsZXM7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHN0YXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGdyYW1tYXIgPSBHcmFtbWFyLmZyb21Db21waWxlZChydWxlcywgc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JhbW1hciA9IGdyYW1tYXI7XG5cbiAgICAgICAgLy8gUmVhZCBvcHRpb25zXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGtlZXBIaXN0b3J5OiBmYWxzZSxcbiAgICAgICAgICAgIGxleGVyOiBncmFtbWFyLmxleGVyIHx8IG5ldyBTdHJlYW1MZXhlcixcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIChvcHRpb25zIHx8IHt9KSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXR1cCBsZXhlclxuICAgICAgICB0aGlzLmxleGVyID0gdGhpcy5vcHRpb25zLmxleGVyO1xuICAgICAgICB0aGlzLmxleGVyU3RhdGUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gU2V0dXAgYSB0YWJsZVxuICAgICAgICB2YXIgY29sdW1uID0gbmV3IENvbHVtbihncmFtbWFyLCAwKTtcbiAgICAgICAgdmFyIHRhYmxlID0gdGhpcy50YWJsZSA9IFtjb2x1bW5dO1xuXG4gICAgICAgIC8vIEkgY291bGQgYmUgZXhwZWN0aW5nIGFueXRoaW5nLlxuICAgICAgICBjb2x1bW4ud2FudHNbZ3JhbW1hci5zdGFydF0gPSBbXTtcbiAgICAgICAgY29sdW1uLnByZWRpY3QoZ3JhbW1hci5zdGFydCk7XG4gICAgICAgIC8vIFRPRE8gd2hhdCBpZiBzdGFydCBydWxlIGlzIG51bGxhYmxlP1xuICAgICAgICBjb2x1bW4ucHJvY2VzcygpO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSAwOyAvLyB0b2tlbiBpbmRleFxuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhIHJlc2VydmVkIHRva2VuIGZvciBpbmRpY2F0aW5nIGEgcGFyc2UgZmFpbFxuICAgIFBhcnNlci5mYWlsID0ge307XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLmZlZWQgPSBmdW5jdGlvbihjaHVuaykge1xuICAgICAgICB2YXIgbGV4ZXIgPSB0aGlzLmxleGVyO1xuICAgICAgICBsZXhlci5yZXNldChjaHVuaywgdGhpcy5sZXhlclN0YXRlKTtcblxuICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgIHdoaWxlICh0b2tlbiA9IGxleGVyLm5leHQoKSkge1xuICAgICAgICAgICAgLy8gV2UgYWRkIG5ldyBzdGF0ZXMgdG8gdGFibGVbY3VycmVudCsxXVxuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMudGFibGVbdGhpcy5jdXJyZW50XTtcblxuICAgICAgICAgICAgLy8gR0MgdW51c2VkIHN0YXRlc1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMua2VlcEhpc3RvcnkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy50YWJsZVt0aGlzLmN1cnJlbnQgLSAxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLmN1cnJlbnQgKyAxO1xuICAgICAgICAgICAgdmFyIG5leHRDb2x1bW4gPSBuZXcgQ29sdW1uKHRoaXMuZ3JhbW1hciwgbik7XG4gICAgICAgICAgICB0aGlzLnRhYmxlLnB1c2gobmV4dENvbHVtbik7XG5cbiAgICAgICAgICAgIC8vIEFkdmFuY2UgYWxsIHRva2VucyB0aGF0IGV4cGVjdCB0aGUgc3ltYm9sXG4gICAgICAgICAgICB2YXIgbGl0ZXJhbCA9IHRva2VuLnRleHQgIT09IHVuZGVmaW5lZCA/IHRva2VuLnRleHQgOiB0b2tlbi52YWx1ZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGxleGVyLmNvbnN0cnVjdG9yID09PSBTdHJlYW1MZXhlciA/IHRva2VuLnZhbHVlIDogdG9rZW47XG4gICAgICAgICAgICB2YXIgc2Nhbm5hYmxlID0gY29sdW1uLnNjYW5uYWJsZTtcbiAgICAgICAgICAgIGZvciAodmFyIHcgPSBzY2FubmFibGUubGVuZ3RoOyB3LS07ICkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHNjYW5uYWJsZVt3XTtcbiAgICAgICAgICAgICAgICB2YXIgZXhwZWN0ID0gc3RhdGUucnVsZS5zeW1ib2xzW3N0YXRlLmRvdF07XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGNvbnN1bWUgdGhlIHRva2VuXG4gICAgICAgICAgICAgICAgLy8gZWl0aGVyIHJlZ2V4IG9yIGxpdGVyYWxcbiAgICAgICAgICAgICAgICBpZiAoZXhwZWN0LnRlc3QgPyBleHBlY3QudGVzdCh2YWx1ZSkgOlxuICAgICAgICAgICAgICAgICAgICBleHBlY3QudHlwZSA/IGV4cGVjdC50eXBlID09PSB0b2tlbi50eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZXhwZWN0LmxpdGVyYWwgPT09IGxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGl0XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gc3RhdGUubmV4dFN0YXRlKHtkYXRhOiB2YWx1ZSwgdG9rZW46IHRva2VuLCBpc1Rva2VuOiB0cnVlLCByZWZlcmVuY2U6IG4gLSAxfSk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRDb2x1bW4uc3RhdGVzLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOZXh0LCBmb3IgZWFjaCBvZiB0aGUgcnVsZXMsIHdlIGVpdGhlclxuICAgICAgICAgICAgLy8gKGEpIGNvbXBsZXRlIGl0LCBhbmQgdHJ5IHRvIHNlZSBpZiB0aGUgcmVmZXJlbmNlIHJvdyBleHBlY3RlZCB0aGF0XG4gICAgICAgICAgICAvLyAgICAgcnVsZVxuICAgICAgICAgICAgLy8gKGIpIHByZWRpY3QgdGhlIG5leHQgbm9udGVybWluYWwgaXQgZXhwZWN0cyBieSBhZGRpbmcgdGhhdFxuICAgICAgICAgICAgLy8gICAgIG5vbnRlcm1pbmFsJ3Mgc3RhcnQgc3RhdGVcbiAgICAgICAgICAgIC8vIFRvIHByZXZlbnQgZHVwbGljYXRpb24sIHdlIGFsc28ga2VlcCB0cmFjayBvZiBydWxlcyB3ZSBoYXZlIGFscmVhZHlcbiAgICAgICAgICAgIC8vIGFkZGVkXG5cbiAgICAgICAgICAgIG5leHRDb2x1bW4ucHJvY2VzcygpO1xuXG4gICAgICAgICAgICAvLyBJZiBuZWVkZWQsIHRocm93IGFuIGVycm9yOlxuICAgICAgICAgICAgaWYgKG5leHRDb2x1bW4uc3RhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIE5vIHN0YXRlcyBhdCBhbGwhIFRoaXMgaXMgbm90IGdvb2QuXG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcih0aGlzLnJlcG9ydEVycm9yKHRva2VuKSk7XG4gICAgICAgICAgICAgICAgZXJyLm9mZnNldCA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgICAgICAgICBlcnIudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG1heWJlIHNhdmUgbGV4ZXIgc3RhdGVcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcEhpc3RvcnkpIHtcbiAgICAgICAgICAgICAgY29sdW1uLmxleGVyU3RhdGUgPSBsZXhlci5zYXZlKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbHVtbikge1xuICAgICAgICAgIHRoaXMubGV4ZXJTdGF0ZSA9IGxleGVyLnNhdmUoKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5jcmVtZW50YWxseSBrZWVwIHRyYWNrIG9mIHJlc3VsdHNcbiAgICAgICAgdGhpcy5yZXN1bHRzID0gdGhpcy5maW5pc2goKTtcblxuICAgICAgICAvLyBBbGxvdyBjaGFpbmluZywgZm9yIHdoYXRldmVyIGl0J3Mgd29ydGhcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucmVwb3J0RXJyb3IgPSBmdW5jdGlvbih0b2tlbikge1xuICAgICAgICB2YXIgbGluZXMgPSBbXTtcbiAgICAgICAgdmFyIHRva2VuRGlzcGxheSA9ICh0b2tlbi50eXBlID8gdG9rZW4udHlwZSArIFwiIHRva2VuOiBcIiA6IFwiXCIpICsgSlNPTi5zdHJpbmdpZnkodG9rZW4udmFsdWUgIT09IHVuZGVmaW5lZCA/IHRva2VuLnZhbHVlIDogdG9rZW4pO1xuICAgICAgICBsaW5lcy5wdXNoKHRoaXMubGV4ZXIuZm9ybWF0RXJyb3IodG9rZW4sIFwiU3ludGF4IGVycm9yXCIpKTtcbiAgICAgICAgbGluZXMucHVzaCgnVW5leHBlY3RlZCAnICsgdG9rZW5EaXNwbGF5ICsgJy4gSW5zdGVhZCwgSSB3YXMgZXhwZWN0aW5nIHRvIHNlZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcXG4nKTtcbiAgICAgICAgdmFyIGxhc3RDb2x1bW5JbmRleCA9IHRoaXMudGFibGUubGVuZ3RoIC0gMjtcbiAgICAgICAgdmFyIGxhc3RDb2x1bW4gPSB0aGlzLnRhYmxlW2xhc3RDb2x1bW5JbmRleF07XG4gICAgICAgIHZhciBleHBlY3RhbnRTdGF0ZXMgPSBsYXN0Q29sdW1uLnN0YXRlc1xuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRTeW1ib2wgPSBzdGF0ZS5ydWxlLnN5bWJvbHNbc3RhdGUuZG90XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFN5bWJvbCAmJiB0eXBlb2YgbmV4dFN5bWJvbCAhPT0gXCJzdHJpbmdcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gRGlzcGxheSBhIFwic3RhdGUgc3RhY2tcIiBmb3IgZWFjaCBleHBlY3RhbnQgc3RhdGVcbiAgICAgICAgLy8gLSB3aGljaCBzaG93cyB5b3UgaG93IHRoaXMgc3RhdGUgY2FtZSB0byBiZSwgc3RlcCBieSBzdGVwLiBcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBkZXJpdmF0aW9uLCB3ZSBvbmx5IGRpc3BsYXkgdGhlIGZpcnN0IG9uZS5cbiAgICAgICAgdmFyIHN0YXRlU3RhY2tzID0gZXhwZWN0YW50U3RhdGVzXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhY2tzID0gdGhpcy5idWlsZFN0YXRlU3RhY2tzKHN0YXRlLCBbXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrc1swXTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAvLyBEaXNwbGF5IGVhY2ggc3RhdGUgdGhhdCBpcyBleHBlY3RpbmcgYSB0ZXJtaW5hbCBzeW1ib2wgbmV4dC5cbiAgICAgICAgc3RhdGVTdGFja3MuZm9yRWFjaChmdW5jdGlvbihzdGF0ZVN0YWNrKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBzdGF0ZVN0YWNrWzBdO1xuICAgICAgICAgICAgdmFyIG5leHRTeW1ib2wgPSBzdGF0ZS5ydWxlLnN5bWJvbHNbc3RhdGUuZG90XTtcbiAgICAgICAgICAgIHZhciBzeW1ib2xEaXNwbGF5ID0gdGhpcy5nZXRTeW1ib2xEaXNwbGF5KG5leHRTeW1ib2wpO1xuICAgICAgICAgICAgbGluZXMucHVzaCgnQSAnICsgc3ltYm9sRGlzcGxheSArICcgYmFzZWQgb246Jyk7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlTdGF0ZVN0YWNrKHN0YXRlU3RhY2ssIGxpbmVzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICBcbiAgICAgICAgbGluZXMucHVzaChcIlwiKTtcbiAgICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUuZGlzcGxheVN0YXRlU3RhY2sgPSBmdW5jdGlvbihzdGF0ZVN0YWNrLCBsaW5lcykge1xuICAgICAgICB2YXIgbGFzdERpc3BsYXk7XG4gICAgICAgIHZhciBzYW1lRGlzcGxheUNvdW50ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdGF0ZVN0YWNrLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBzdGF0ZVN0YWNrW2pdO1xuICAgICAgICAgICAgdmFyIGRpc3BsYXkgPSBzdGF0ZS5ydWxlLnRvU3RyaW5nKHN0YXRlLmRvdCk7XG4gICAgICAgICAgICBpZiAoZGlzcGxheSA9PT0gbGFzdERpc3BsYXkpIHtcbiAgICAgICAgICAgICAgICBzYW1lRGlzcGxheUNvdW50Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzYW1lRGlzcGxheUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcgICAg4qyGIO+4jicgKyBzYW1lRGlzcGxheUNvdW50ICsgJyBtb3JlIGxpbmVzIGlkZW50aWNhbCB0byB0aGlzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNhbWVEaXNwbGF5Q291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goJyAgICAnICsgZGlzcGxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0RGlzcGxheSA9IGRpc3BsYXk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5nZXRTeW1ib2xEaXNwbGF5ID0gZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHN5bWJvbDtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJvYmplY3RcIiAmJiBzeW1ib2wubGl0ZXJhbCkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN5bWJvbC5saXRlcmFsKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm9iamVjdFwiICYmIHN5bWJvbCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgcmV0dXJuICdjaGFyYWN0ZXIgbWF0Y2hpbmcgJyArIHN5bWJvbDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm9iamVjdFwiICYmIHN5bWJvbC50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sLnR5cGUgKyAnIHRva2VuJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBzeW1ib2wgdHlwZTogJyArIHN5bWJvbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBCdWlsZHMgYSBudW1iZXIgb2YgXCJzdGF0ZSBzdGFja3NcIi4gWW91IGNhbiB0aGluayBvZiBhIHN0YXRlIHN0YWNrIGFzIHRoZSBjYWxsIHN0YWNrXG4gICAgb2YgdGhlIHJlY3Vyc2l2ZS1kZXNjZW50IHBhcnNlciB3aGljaCB0aGUgTmVhcmxleSBwYXJzZSBhbGdvcml0aG0gc2ltdWxhdGVzLlxuICAgIEEgc3RhdGUgc3RhY2sgaXMgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgb2Ygc3RhdGUgb2JqZWN0cy4gV2l0aGluIGEgXG4gICAgc3RhdGUgc3RhY2ssIHRoZSBmaXJzdCBpdGVtIG9mIHRoZSBhcnJheSB3aWxsIGJlIHRoZSBzdGFydGluZ1xuICAgIHN0YXRlLCB3aXRoIGVhY2ggc3VjY2Vzc2l2ZSBpdGVtIGluIHRoZSBhcnJheSBnb2luZyBmdXJ0aGVyIGJhY2sgaW50byBoaXN0b3J5LlxuICAgIFxuICAgIFRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgZ2l2ZW4gYSBzdGFydGluZyBzdGF0ZSBhbmQgYW4gZW1wdHkgYXJyYXkgcmVwcmVzZW50aW5nXG4gICAgdGhlIHZpc2l0ZWQgc3RhdGVzLCBhbmQgaXQgcmV0dXJucyBhbiBhcnJheSBvZiBzdGF0ZSBzdGFja3MuIFxuICAgIFxuICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5idWlsZFN0YXRlU3RhY2tzID0gZnVuY3Rpb24oc3RhdGUsIHZpc2l0ZWQpIHtcbiAgICAgICAgaWYgKHZpc2l0ZWQuaW5kZXhPZihzdGF0ZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBGb3VuZCBjeWNsZSwgcmV0dXJuIGVtcHR5IGFycmF5IChtZWFuaW5nIG5vIHN0YWNrcylcbiAgICAgICAgICAgIC8vIHRvIGVsaW1pbmF0ZSB0aGlzIHBhdGggZnJvbSB0aGUgcmVzdWx0cywgYmVjYXVzZVxuICAgICAgICAgICAgLy8gd2UgZG9uJ3Qga25vdyBob3cgdG8gZGlzcGxheSBpdCBtZWFuaW5nZnVsbHlcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUud2FudGVkQnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW1tzdGF0ZV1dO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICByZXR1cm4gc3RhdGUud2FudGVkQnkucmVkdWNlKGZ1bmN0aW9uKHN0YWNrcywgcHJldlN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2tzLmNvbmNhdCh0aGF0LmJ1aWxkU3RhdGVTdGFja3MoXG4gICAgICAgICAgICAgICAgcHJldlN0YXRlLFxuICAgICAgICAgICAgICAgIFtzdGF0ZV0uY29uY2F0KHZpc2l0ZWQpKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oc3RhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzdGF0ZV0uY29uY2F0KHN0YWNrKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLnRhYmxlW3RoaXMuY3VycmVudF07XG4gICAgICAgIGNvbHVtbi5sZXhlclN0YXRlID0gdGhpcy5sZXhlclN0YXRlO1xuICAgICAgICByZXR1cm4gY29sdW1uO1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnJlc3RvcmUgPSBmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gY29sdW1uLmluZGV4O1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBpbmRleDtcbiAgICAgICAgdGhpcy50YWJsZVtpbmRleF0gPSBjb2x1bW47XG4gICAgICAgIHRoaXMudGFibGUuc3BsaWNlKGluZGV4ICsgMSk7XG4gICAgICAgIHRoaXMubGV4ZXJTdGF0ZSA9IGNvbHVtbi5sZXhlclN0YXRlO1xuXG4gICAgICAgIC8vIEluY3JlbWVudGFsbHkga2VlcCB0cmFjayBvZiByZXN1bHRzXG4gICAgICAgIHRoaXMucmVzdWx0cyA9IHRoaXMuZmluaXNoKCk7XG4gICAgfTtcblxuICAgIC8vIG5iLiBkZXByZWNhdGVkOiB1c2Ugc2F2ZS9yZXN0b3JlIGluc3RlYWQhXG4gICAgUGFyc2VyLnByb3RvdHlwZS5yZXdpbmQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5rZWVwSGlzdG9yeSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXQgb3B0aW9uIGBrZWVwSGlzdG9yeWAgdG8gZW5hYmxlIHJld2luZGluZycpXG4gICAgICAgIH1cbiAgICAgICAgLy8gbmIuIHJlY2FsbCBjb2x1bW4gKHRhYmxlKSBpbmRpY2llcyBmYWxsIGJldHdlZW4gdG9rZW4gaW5kaWNpZXMuXG4gICAgICAgIC8vICAgICAgICBjb2wgMCAgIC0tICAgdG9rZW4gMCAgIC0tICAgY29sIDFcbiAgICAgICAgdGhpcy5yZXN0b3JlKHRoaXMudGFibGVbaW5kZXhdKTtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBwb3NzaWJsZSBwYXJzaW5nc1xuICAgICAgICB2YXIgY29uc2lkZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5ncmFtbWFyLnN0YXJ0O1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy50YWJsZVt0aGlzLnRhYmxlLmxlbmd0aCAtIDFdXG4gICAgICAgIGNvbHVtbi5zdGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgaWYgKHQucnVsZS5uYW1lID09PSBzdGFydFxuICAgICAgICAgICAgICAgICAgICAmJiB0LmRvdCA9PT0gdC5ydWxlLnN5bWJvbHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICYmIHQucmVmZXJlbmNlID09PSAwXG4gICAgICAgICAgICAgICAgICAgICYmIHQuZGF0YSAhPT0gUGFyc2VyLmZhaWwpIHtcbiAgICAgICAgICAgICAgICBjb25zaWRlcmF0aW9ucy5wdXNoKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnNpZGVyYXRpb25zLm1hcChmdW5jdGlvbihjKSB7cmV0dXJuIGMuZGF0YTsgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIFBhcnNlcjogUGFyc2VyLFxuICAgICAgICBHcmFtbWFyOiBHcmFtbWFyLFxuICAgICAgICBSdWxlOiBSdWxlLFxuICAgIH07XG5cbn0pKTtcbiIsIi8vIC5kaXJuYW1lLCAuYmFzZW5hbWUsIGFuZCAuZXh0bmFtZSBtZXRob2RzIGFyZSBleHRyYWN0ZWQgZnJvbSBOb2RlLmpzIHY4LjExLjEsXG4vLyBiYWNrcG9ydGVkIGFuZCB0cmFuc3BsaXRlZCB3aXRoIEJhYmVsLCB3aXRoIGJhY2t3YXJkcy1jb21wYXQgZml4ZXNcblxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJy4nO1xuICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgdmFyIGhhc1Jvb3QgPSBjb2RlID09PSA0NyAvKi8qLztcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcbiAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiBoYXNSb290ID8gJy8nIDogJy4nO1xuICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpIHtcbiAgICAvLyByZXR1cm4gJy8vJztcbiAgICAvLyBCYWNrd2FyZHMtY29tcGF0IGZpeDpcbiAgICByZXR1cm4gJy8nO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBiYXNlbmFtZShwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG5cbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gcGF0aCBjb21wb25lbnRcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgZW5kID0gaSArIDE7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiAnJztcbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG59XG5cbi8vIFVzZXMgYSBtaXhlZCBhcHByb2FjaCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIGFzIGV4dCBiZWhhdmlvciBjaGFuZ2VkXG4vLyBpbiBuZXcgTm9kZS5qcyB2ZXJzaW9ucywgc28gb25seSBiYXNlbmFtZSgpIGFib3ZlIGlzIGJhY2twb3J0ZWQgaGVyZVxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uIChwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBiYXNlbmFtZShwYXRoKTtcbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG4gIHZhciBzdGFydERvdCA9IC0xO1xuICB2YXIgc3RhcnRQYXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICB2YXIgcHJlRG90U3RhdGUgPSAwO1xuICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIGVuZCA9IGkgKyAxO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gNDYgLyouKi8pIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgZG90LCBtYXJrIGl0IGFzIHRoZSBzdGFydCBvZiBvdXIgZXh0ZW5zaW9uXG4gICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpXG4gICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSlcbiAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXG4gICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHxcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgICAgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgU2ltb24gTHlkZWxsXHJcbi8vIFgxMSAo4oCcTUlU4oCdKSBMaWNlbnNlZC4gKFNlZSBMSUNFTlNFLilcclxuXHJcbnZvaWQgKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcclxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgIGRlZmluZShmYWN0b3J5KVxyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpXHJcbiAgfSBlbHNlIHtcclxuICAgIHJvb3QucmVzb2x2ZVVybCA9IGZhY3RvcnkoKVxyXG4gIH1cclxufSh0aGlzLCBmdW5jdGlvbigpIHtcclxuXHJcbiAgZnVuY3Rpb24gcmVzb2x2ZVVybCgvKiAuLi51cmxzICovKSB7XHJcbiAgICB2YXIgbnVtVXJscyA9IGFyZ3VtZW50cy5sZW5ndGhcclxuXHJcbiAgICBpZiAobnVtVXJscyA9PT0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXNvbHZlVXJsIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBhcmd1bWVudDsgZ290IG5vbmUuXCIpXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGJhc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYmFzZVwiKVxyXG4gICAgYmFzZS5ocmVmID0gYXJndW1lbnRzWzBdXHJcblxyXG4gICAgaWYgKG51bVVybHMgPT09IDEpIHtcclxuICAgICAgcmV0dXJuIGJhc2UuaHJlZlxyXG4gICAgfVxyXG5cclxuICAgIHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdXHJcbiAgICBoZWFkLmluc2VydEJlZm9yZShiYXNlLCBoZWFkLmZpcnN0Q2hpbGQpXHJcblxyXG4gICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKVxyXG4gICAgdmFyIHJlc29sdmVkXHJcblxyXG4gICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IG51bVVybHM7IGluZGV4KyspIHtcclxuICAgICAgYS5ocmVmID0gYXJndW1lbnRzW2luZGV4XVxyXG4gICAgICByZXNvbHZlZCA9IGEuaHJlZlxyXG4gICAgICBiYXNlLmhyZWYgPSByZXNvbHZlZFxyXG4gICAgfVxyXG5cclxuICAgIGhlYWQucmVtb3ZlQ2hpbGQoYmFzZSlcclxuXHJcbiAgICByZXR1cm4gcmVzb2x2ZWRcclxuICB9XHJcblxyXG4gIHJldHVybiByZXNvbHZlVXJsXHJcblxyXG59KSk7XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY21wIChhLCBiKSB7XG4gICAgdmFyIHBhID0gYS5zcGxpdCgnLicpO1xuICAgIHZhciBwYiA9IGIuc3BsaXQoJy4nKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICB2YXIgbmEgPSBOdW1iZXIocGFbaV0pO1xuICAgICAgICB2YXIgbmIgPSBOdW1iZXIocGJbaV0pO1xuICAgICAgICBpZiAobmEgPiBuYikgcmV0dXJuIDE7XG4gICAgICAgIGlmIChuYiA+IG5hKSByZXR1cm4gLTE7XG4gICAgICAgIGlmICghaXNOYU4obmEpICYmIGlzTmFOKG5iKSkgcmV0dXJuIDE7XG4gICAgICAgIGlmIChpc05hTihuYSkgJiYgIWlzTmFOKG5iKSkgcmV0dXJuIC0xO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn07XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCwgMjAxNSwgMjAxNiwgMjAxNyBTaW1vbiBMeWRlbGxcbi8vIFgxMSAo4oCcTUlU4oCdKSBMaWNlbnNlZC4gKFNlZSBMSUNFTlNFLilcblxuLy8gTm90ZTogc291cmNlLW1hcC1yZXNvbHZlLmpzIGlzIGdlbmVyYXRlZCBmcm9tIHNvdXJjZS1tYXAtcmVzb2x2ZS1ub2RlLmpzIGFuZFxuLy8gc291cmNlLW1hcC1yZXNvbHZlLXRlbXBsYXRlLmpzLiBPbmx5IGVkaXQgdGhlIHR3byBsYXR0ZXIgZmlsZXMsIF9ub3RfXG4vLyBzb3VyY2UtbWFwLXJlc29sdmUuanMhXG5cbnZvaWQgKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFtcInNvdXJjZS1tYXAtdXJsXCIsIFwicmVzb2x2ZS11cmxcIl0sIGZhY3RvcnkpXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICB2YXIgc291cmNlTWFwcGluZ1VSTCA9IHJlcXVpcmUoXCJzb3VyY2UtbWFwLXVybFwiKVxuICAgIHZhciByZXNvbHZlVXJsID0gcmVxdWlyZShcInJlc29sdmUtdXJsXCIpXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHNvdXJjZU1hcHBpbmdVUkwsIHJlc29sdmVVcmwpXG4gIH0gZWxzZSB7XG4gICAgcm9vdC5zb3VyY2VNYXBSZXNvbHZlID0gZmFjdG9yeShyb290LnNvdXJjZU1hcHBpbmdVUkwsIHJvb3QucmVzb2x2ZVVybClcbiAgfVxufSh0aGlzLCBmdW5jdGlvbihzb3VyY2VNYXBwaW5nVVJMLCByZXNvbHZlVXJsKSB7XG5cbiAgZnVuY3Rpb24gY2FsbGJhY2tBc3luYyhjYWxsYmFjaywgZXJyb3IsIHJlc3VsdCkge1xuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHsgY2FsbGJhY2soZXJyb3IsIHJlc3VsdCkgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTWFwVG9KU09OKHN0cmluZywgZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShzdHJpbmcucmVwbGFjZSgvXlxcKVxcXVxcfScvLCBcIlwiKSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZXJyb3Iuc291cmNlTWFwRGF0YSA9IGRhdGFcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFN5bmMocmVhZCwgdXJsLCBkYXRhKSB7XG4gICAgdmFyIHJlYWRVcmwgPSB1cmxcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFN0cmluZyhyZWFkKHJlYWRVcmwpKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlcnJvci5zb3VyY2VNYXBEYXRhID0gZGF0YVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuXG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVNvdXJjZU1hcChjb2RlLCBjb2RlVXJsLCByZWFkLCBjYWxsYmFjaykge1xuICAgIHZhciBtYXBEYXRhXG4gICAgdHJ5IHtcbiAgICAgIG1hcERhdGEgPSByZXNvbHZlU291cmNlTWFwSGVscGVyKGNvZGUsIGNvZGVVcmwpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBjYWxsYmFja0FzeW5jKGNhbGxiYWNrLCBlcnJvcilcbiAgICB9XG4gICAgaWYgKCFtYXBEYXRhIHx8IG1hcERhdGEubWFwKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2tBc3luYyhjYWxsYmFjaywgbnVsbCwgbWFwRGF0YSlcbiAgICB9XG4gICAgdmFyIHJlYWRVcmwgPSBtYXBEYXRhLnVybFxuICAgIHJlYWQocmVhZFVybCwgZnVuY3Rpb24oZXJyb3IsIHJlc3VsdCkge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGVycm9yLnNvdXJjZU1hcERhdGEgPSBtYXBEYXRhXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcilcbiAgICAgIH1cbiAgICAgIG1hcERhdGEubWFwID0gU3RyaW5nKHJlc3VsdClcbiAgICAgIHRyeSB7XG4gICAgICAgIG1hcERhdGEubWFwID0gcGFyc2VNYXBUb0pTT04obWFwRGF0YS5tYXAsIG1hcERhdGEpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IpXG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCBtYXBEYXRhKVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlU291cmNlTWFwU3luYyhjb2RlLCBjb2RlVXJsLCByZWFkKSB7XG4gICAgdmFyIG1hcERhdGEgPSByZXNvbHZlU291cmNlTWFwSGVscGVyKGNvZGUsIGNvZGVVcmwpXG4gICAgaWYgKCFtYXBEYXRhIHx8IG1hcERhdGEubWFwKSB7XG4gICAgICByZXR1cm4gbWFwRGF0YVxuICAgIH1cbiAgICBtYXBEYXRhLm1hcCA9IHJlYWRTeW5jKHJlYWQsIG1hcERhdGEudXJsLCBtYXBEYXRhKVxuICAgIG1hcERhdGEubWFwID0gcGFyc2VNYXBUb0pTT04obWFwRGF0YS5tYXAsIG1hcERhdGEpXG4gICAgcmV0dXJuIG1hcERhdGFcbiAgfVxuXG4gIHZhciBkYXRhVXJpUmVnZXggPSAvXmRhdGE6KFteLDtdKikoO1teLDtdKikqKD86LCguKikpPyQvXG4gIHZhciBqc29uTWltZVR5cGVSZWdleCA9IC9eKD86YXBwbGljYXRpb258dGV4dClcXC9qc29uJC9cblxuICBmdW5jdGlvbiByZXNvbHZlU291cmNlTWFwSGVscGVyKGNvZGUsIGNvZGVVcmwpIHtcbiAgICB2YXIgdXJsID0gc291cmNlTWFwcGluZ1VSTC5nZXRGcm9tKGNvZGUpXG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgdmFyIGRhdGFVcmkgPSB1cmwubWF0Y2goZGF0YVVyaVJlZ2V4KVxuICAgIGlmIChkYXRhVXJpKSB7XG4gICAgICB2YXIgbWltZVR5cGUgPSBkYXRhVXJpWzFdXG4gICAgICB2YXIgbGFzdFBhcmFtZXRlciA9IGRhdGFVcmlbMl0gfHwgXCJcIlxuICAgICAgdmFyIGVuY29kZWQgPSBkYXRhVXJpWzNdIHx8IFwiXCJcbiAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICBzb3VyY2VNYXBwaW5nVVJMOiB1cmwsXG4gICAgICAgIHVybDogbnVsbCxcbiAgICAgICAgc291cmNlc1JlbGF0aXZlVG86IGNvZGVVcmwsXG4gICAgICAgIG1hcDogZW5jb2RlZFxuICAgICAgfVxuICAgICAgaWYgKCFqc29uTWltZVR5cGVSZWdleC50ZXN0KG1pbWVUeXBlKSkge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJVbnVzZWZ1bCBkYXRhIHVyaSBtaW1lIHR5cGU6IFwiICsgKG1pbWVUeXBlIHx8IFwidGV4dC9wbGFpblwiKSlcbiAgICAgICAgZXJyb3Iuc291cmNlTWFwRGF0YSA9IGRhdGFcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIGRhdGEubWFwID0gcGFyc2VNYXBUb0pTT04oXG4gICAgICAgIGxhc3RQYXJhbWV0ZXIgPT09IFwiO2Jhc2U2NFwiID8gYXRvYihlbmNvZGVkKSA6IGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVkKSxcbiAgICAgICAgZGF0YVxuICAgICAgKVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9XG5cbiAgICB2YXIgbWFwVXJsID0gcmVzb2x2ZVVybChjb2RlVXJsLCB1cmwpXG4gICAgcmV0dXJuIHtcbiAgICAgIHNvdXJjZU1hcHBpbmdVUkw6IHVybCxcbiAgICAgIHVybDogbWFwVXJsLFxuICAgICAgc291cmNlc1JlbGF0aXZlVG86IG1hcFVybCxcbiAgICAgIG1hcDogbnVsbFxuICAgIH1cbiAgfVxuXG5cblxuICBmdW5jdGlvbiByZXNvbHZlU291cmNlcyhtYXAsIG1hcFVybCwgcmVhZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG4gICAgdmFyIHBlbmRpbmcgPSBtYXAuc291cmNlcyA/IG1hcC5zb3VyY2VzLmxlbmd0aCA6IDBcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgc291cmNlc1Jlc29sdmVkOiBbXSxcbiAgICAgIHNvdXJjZXNDb250ZW50OiAgW11cbiAgICB9XG5cbiAgICBpZiAocGVuZGluZyA9PT0gMCkge1xuICAgICAgY2FsbGJhY2tBc3luYyhjYWxsYmFjaywgbnVsbCwgcmVzdWx0KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGRvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHBlbmRpbmctLVxuICAgICAgaWYgKHBlbmRpbmcgPT09IDApIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KVxuICAgICAgfVxuICAgIH1cblxuICAgIHJlc29sdmVTb3VyY2VzSGVscGVyKG1hcCwgbWFwVXJsLCBvcHRpb25zLCBmdW5jdGlvbihmdWxsVXJsLCBzb3VyY2VDb250ZW50LCBpbmRleCkge1xuICAgICAgcmVzdWx0LnNvdXJjZXNSZXNvbHZlZFtpbmRleF0gPSBmdWxsVXJsXG4gICAgICBpZiAodHlwZW9mIHNvdXJjZUNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmVzdWx0LnNvdXJjZXNDb250ZW50W2luZGV4XSA9IHNvdXJjZUNvbnRlbnRcbiAgICAgICAgY2FsbGJhY2tBc3luYyhkb25lLCBudWxsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlYWRVcmwgPSBmdWxsVXJsXG4gICAgICAgIHJlYWQocmVhZFVybCwgZnVuY3Rpb24oZXJyb3IsIHNvdXJjZSkge1xuICAgICAgICAgIHJlc3VsdC5zb3VyY2VzQ29udGVudFtpbmRleF0gPSBlcnJvciA/IGVycm9yIDogU3RyaW5nKHNvdXJjZSlcbiAgICAgICAgICBkb25lKClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVNvdXJjZXNTeW5jKG1hcCwgbWFwVXJsLCByZWFkLCBvcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIHNvdXJjZXNSZXNvbHZlZDogW10sXG4gICAgICBzb3VyY2VzQ29udGVudDogIFtdXG4gICAgfVxuXG4gICAgaWYgKCFtYXAuc291cmNlcyB8fCBtYXAuc291cmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICByZXNvbHZlU291cmNlc0hlbHBlcihtYXAsIG1hcFVybCwgb3B0aW9ucywgZnVuY3Rpb24oZnVsbFVybCwgc291cmNlQ29udGVudCwgaW5kZXgpIHtcbiAgICAgIHJlc3VsdC5zb3VyY2VzUmVzb2x2ZWRbaW5kZXhdID0gZnVsbFVybFxuICAgICAgaWYgKHJlYWQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VDb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmVzdWx0LnNvdXJjZXNDb250ZW50W2luZGV4XSA9IHNvdXJjZUNvbnRlbnRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcmVhZFVybCA9IGZ1bGxVcmxcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0LnNvdXJjZXNDb250ZW50W2luZGV4XSA9IFN0cmluZyhyZWFkKHJlYWRVcmwpKVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXN1bHQuc291cmNlc0NvbnRlbnRbaW5kZXhdID0gZXJyb3JcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgdmFyIGVuZGluZ1NsYXNoID0gL1xcLz8kL1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVTb3VyY2VzSGVscGVyKG1hcCwgbWFwVXJsLCBvcHRpb25zLCBmbikge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgdmFyIGZ1bGxVcmxcbiAgICB2YXIgc291cmNlQ29udGVudFxuICAgIHZhciBzb3VyY2VSb290XG4gICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW4gPSBtYXAuc291cmNlcy5sZW5ndGg7IGluZGV4IDwgbGVuOyBpbmRleCsrKSB7XG4gICAgICBzb3VyY2VSb290ID0gbnVsbFxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnNvdXJjZVJvb3QgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc291cmNlUm9vdCA9IG9wdGlvbnMuc291cmNlUm9vdFxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbWFwLnNvdXJjZVJvb3QgPT09IFwic3RyaW5nXCIgJiYgb3B0aW9ucy5zb3VyY2VSb290ICE9PSBmYWxzZSkge1xuICAgICAgICBzb3VyY2VSb290ID0gbWFwLnNvdXJjZVJvb3RcbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBzb3VyY2VSb290IGlzIHRoZSBlbXB0eSBzdHJpbmcsIGl0IGlzIGVxdWl2YWxlbnQgdG8gbm90IHNldHRpbmdcbiAgICAgIC8vIHRoZSBwcm9wZXJ0eSBhdCBhbGwuXG4gICAgICBpZiAoc291cmNlUm9vdCA9PT0gbnVsbCB8fCBzb3VyY2VSb290ID09PSAnJykge1xuICAgICAgICBmdWxsVXJsID0gcmVzb2x2ZVVybChtYXBVcmwsIG1hcC5zb3VyY2VzW2luZGV4XSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBzb3VyY2VSb290IGVuZHMgd2l0aCBhIHNsYXNoLCBzbyB0aGF0IGAvc2NyaXB0cy9zdWJkaXJgIGJlY29tZXNcbiAgICAgICAgLy8gYC9zY3JpcHRzL3N1YmRpci88c291cmNlPmAsIG5vdCBgL3NjcmlwdHMvPHNvdXJjZT5gLiBQb2ludGluZyB0byBhIGZpbGUgYXMgc291cmNlIHJvb3RcbiAgICAgICAgLy8gZG9lcyBub3QgbWFrZSBzZW5zZS5cbiAgICAgICAgZnVsbFVybCA9IHJlc29sdmVVcmwobWFwVXJsLCBzb3VyY2VSb290LnJlcGxhY2UoZW5kaW5nU2xhc2gsIFwiL1wiKSwgbWFwLnNvdXJjZXNbaW5kZXhdKVxuICAgICAgfVxuICAgICAgc291cmNlQ29udGVudCA9IChtYXAuc291cmNlc0NvbnRlbnQgfHwgW10pW2luZGV4XVxuICAgICAgZm4oZnVsbFVybCwgc291cmNlQ29udGVudCwgaW5kZXgpXG4gICAgfVxuICB9XG5cblxuXG4gIGZ1bmN0aW9uIHJlc29sdmUoY29kZSwgY29kZVVybCwgcmVhZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgIHZhciBtYXBVcmwgPSBjb2RlVXJsXG4gICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgc291cmNlTWFwcGluZ1VSTDogbnVsbCxcbiAgICAgICAgdXJsOiBtYXBVcmwsXG4gICAgICAgIHNvdXJjZXNSZWxhdGl2ZVRvOiBtYXBVcmwsXG4gICAgICAgIG1hcDogbnVsbFxuICAgICAgfVxuICAgICAgdmFyIHJlYWRVcmwgPSBtYXBVcmxcbiAgICAgIHJlYWQocmVhZFVybCwgZnVuY3Rpb24oZXJyb3IsIHJlc3VsdCkge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBlcnJvci5zb3VyY2VNYXBEYXRhID0gZGF0YVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcilcbiAgICAgICAgfVxuICAgICAgICBkYXRhLm1hcCA9IFN0cmluZyhyZXN1bHQpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGF0YS5tYXAgPSBwYXJzZU1hcFRvSlNPTihkYXRhLm1hcCwgZGF0YSlcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IpXG4gICAgICAgIH1cbiAgICAgICAgX3Jlc29sdmVTb3VyY2VzKGRhdGEpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlU291cmNlTWFwKGNvZGUsIGNvZGVVcmwsIHJlYWQsIGZ1bmN0aW9uKGVycm9yLCBtYXBEYXRhKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcilcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1hcERhdGEpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVsbClcbiAgICAgICAgfVxuICAgICAgICBfcmVzb2x2ZVNvdXJjZXMobWFwRGF0YSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3Jlc29sdmVTb3VyY2VzKG1hcERhdGEpIHtcbiAgICAgIHJlc29sdmVTb3VyY2VzKG1hcERhdGEubWFwLCBtYXBEYXRhLnNvdXJjZXNSZWxhdGl2ZVRvLCByZWFkLCBvcHRpb25zLCBmdW5jdGlvbihlcnJvciwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcilcbiAgICAgICAgfVxuICAgICAgICBtYXBEYXRhLnNvdXJjZXNSZXNvbHZlZCA9IHJlc3VsdC5zb3VyY2VzUmVzb2x2ZWRcbiAgICAgICAgbWFwRGF0YS5zb3VyY2VzQ29udGVudCAgPSByZXN1bHQuc291cmNlc0NvbnRlbnRcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgbWFwRGF0YSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVN5bmMoY29kZSwgY29kZVVybCwgcmVhZCwgb3B0aW9ucykge1xuICAgIHZhciBtYXBEYXRhXG4gICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgIHZhciBtYXBVcmwgPSBjb2RlVXJsXG4gICAgICBtYXBEYXRhID0ge1xuICAgICAgICBzb3VyY2VNYXBwaW5nVVJMOiBudWxsLFxuICAgICAgICB1cmw6IG1hcFVybCxcbiAgICAgICAgc291cmNlc1JlbGF0aXZlVG86IG1hcFVybCxcbiAgICAgICAgbWFwOiBudWxsXG4gICAgICB9XG4gICAgICBtYXBEYXRhLm1hcCA9IHJlYWRTeW5jKHJlYWQsIG1hcFVybCwgbWFwRGF0YSlcbiAgICAgIG1hcERhdGEubWFwID0gcGFyc2VNYXBUb0pTT04obWFwRGF0YS5tYXAsIG1hcERhdGEpXG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcERhdGEgPSByZXNvbHZlU291cmNlTWFwU3luYyhjb2RlLCBjb2RlVXJsLCByZWFkKVxuICAgICAgaWYgKCFtYXBEYXRhKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSByZXNvbHZlU291cmNlc1N5bmMobWFwRGF0YS5tYXAsIG1hcERhdGEuc291cmNlc1JlbGF0aXZlVG8sIHJlYWQsIG9wdGlvbnMpXG4gICAgbWFwRGF0YS5zb3VyY2VzUmVzb2x2ZWQgPSByZXN1bHQuc291cmNlc1Jlc29sdmVkXG4gICAgbWFwRGF0YS5zb3VyY2VzQ29udGVudCAgPSByZXN1bHQuc291cmNlc0NvbnRlbnRcbiAgICByZXR1cm4gbWFwRGF0YVxuICB9XG5cblxuXG4gIHJldHVybiB7XG4gICAgcmVzb2x2ZVNvdXJjZU1hcDogICAgIHJlc29sdmVTb3VyY2VNYXAsXG4gICAgcmVzb2x2ZVNvdXJjZU1hcFN5bmM6IHJlc29sdmVTb3VyY2VNYXBTeW5jLFxuICAgIHJlc29sdmVTb3VyY2VzOiAgICAgICByZXNvbHZlU291cmNlcyxcbiAgICByZXNvbHZlU291cmNlc1N5bmM6ICAgcmVzb2x2ZVNvdXJjZXNTeW5jLFxuICAgIHJlc29sdmU6ICAgICAgICAgICAgICByZXNvbHZlLFxuICAgIHJlc29sdmVTeW5jOiAgICAgICAgICByZXNvbHZlU3luYyxcbiAgICBwYXJzZU1hcFRvSlNPTjogICAgICAgcGFyc2VNYXBUb0pTT05cbiAgfVxuXG59KSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBTaW1vbiBMeWRlbGxcbi8vIFgxMSAo4oCcTUlU4oCdKSBMaWNlbnNlZC4gKFNlZSBMSUNFTlNFLilcblxudm9pZCAoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZmFjdG9yeSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpXG4gIH0gZWxzZSB7XG4gICAgcm9vdC5zb3VyY2VNYXBwaW5nVVJMID0gZmFjdG9yeSgpXG4gIH1cbn0odGhpcywgZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGlubmVyUmVnZXggPSAvWyNAXSBzb3VyY2VNYXBwaW5nVVJMPShbXlxccydcIl0qKS9cblxuICB2YXIgcmVnZXggPSBSZWdFeHAoXG4gICAgXCIoPzpcIiArXG4gICAgICBcIi9cXFxcKlwiICtcbiAgICAgIFwiKD86XFxcXHMqXFxyP1xcbig/Oi8vKT8pP1wiICtcbiAgICAgIFwiKD86XCIgKyBpbm5lclJlZ2V4LnNvdXJjZSArIFwiKVwiICtcbiAgICAgIFwiXFxcXHMqXCIgK1xuICAgICAgXCJcXFxcKi9cIiArXG4gICAgICBcInxcIiArXG4gICAgICBcIi8vKD86XCIgKyBpbm5lclJlZ2V4LnNvdXJjZSArIFwiKVwiICtcbiAgICBcIilcIiArXG4gICAgXCJcXFxccypcIlxuICApXG5cbiAgcmV0dXJuIHtcblxuICAgIHJlZ2V4OiByZWdleCxcbiAgICBfaW5uZXJSZWdleDogaW5uZXJSZWdleCxcblxuICAgIGdldEZyb206IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpXG4gICAgICByZXR1cm4gKG1hdGNoID8gbWF0Y2hbMV0gfHwgbWF0Y2hbMl0gfHwgXCJcIiA6IG51bGwpXG4gICAgfSxcblxuICAgIGV4aXN0c0luOiBmdW5jdGlvbihjb2RlKSB7XG4gICAgICByZXR1cm4gcmVnZXgudGVzdChjb2RlKVxuICAgIH0sXG5cbiAgICByZW1vdmVGcm9tOiBmdW5jdGlvbihjb2RlKSB7XG4gICAgICByZXR1cm4gY29kZS5yZXBsYWNlKHJlZ2V4LCBcIlwiKVxuICAgIH0sXG5cbiAgICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uKGNvZGUsIHN0cmluZykge1xuICAgICAgdmFyIG1hdGNoID0gY29kZS5tYXRjaChyZWdleClcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICByZXR1cm4gY29kZS5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyBzdHJpbmcgKyBjb2RlLnNsaWNlKG1hdGNoLmluZGV4KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvZGUgKyBzdHJpbmdcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufSkpO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaGFzTmF0aXZlTWFwID0gdHlwZW9mIE1hcCAhPT0gXCJ1bmRlZmluZWRcIjtcblxuLyoqXG4gKiBBIGRhdGEgc3RydWN0dXJlIHdoaWNoIGlzIGEgY29tYmluYXRpb24gb2YgYW4gYXJyYXkgYW5kIGEgc2V0LiBBZGRpbmcgYSBuZXdcbiAqIG1lbWJlciBpcyBPKDEpLCB0ZXN0aW5nIGZvciBtZW1iZXJzaGlwIGlzIE8oMSksIGFuZCBmaW5kaW5nIHRoZSBpbmRleCBvZiBhblxuICogZWxlbWVudCBpcyBPKDEpLiBSZW1vdmluZyBlbGVtZW50cyBmcm9tIHRoZSBzZXQgaXMgbm90IHN1cHBvcnRlZC4gT25seVxuICogc3RyaW5ncyBhcmUgc3VwcG9ydGVkIGZvciBtZW1iZXJzaGlwLlxuICovXG5mdW5jdGlvbiBBcnJheVNldCgpIHtcbiAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgdGhpcy5fc2V0ID0gaGFzTmF0aXZlTWFwID8gbmV3IE1hcCgpIDogT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cblxuLyoqXG4gKiBTdGF0aWMgbWV0aG9kIGZvciBjcmVhdGluZyBBcnJheVNldCBpbnN0YW5jZXMgZnJvbSBhbiBleGlzdGluZyBhcnJheS5cbiAqL1xuQXJyYXlTZXQuZnJvbUFycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfZnJvbUFycmF5KGFBcnJheSwgYUFsbG93RHVwbGljYXRlcykge1xuICB2YXIgc2V0ID0gbmV3IEFycmF5U2V0KCk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhQXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzZXQuYWRkKGFBcnJheVtpXSwgYUFsbG93RHVwbGljYXRlcyk7XG4gIH1cbiAgcmV0dXJuIHNldDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGhvdyBtYW55IHVuaXF1ZSBpdGVtcyBhcmUgaW4gdGhpcyBBcnJheVNldC4gSWYgZHVwbGljYXRlcyBoYXZlIGJlZW5cbiAqIGFkZGVkLCB0aGFuIHRob3NlIGRvIG5vdCBjb3VudCB0b3dhcmRzIHRoZSBzaXplLlxuICpcbiAqIEByZXR1cm5zIE51bWJlclxuICovXG5BcnJheVNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIEFycmF5U2V0X3NpemUoKSB7XG4gIHJldHVybiBoYXNOYXRpdmVNYXAgPyB0aGlzLl9zZXQuc2l6ZSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX3NldCkubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHN0cmluZyB0byB0aGlzIHNldC5cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIEFycmF5U2V0X2FkZChhU3RyLCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBzU3RyID0gaGFzTmF0aXZlTWFwID8gYVN0ciA6IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gIHZhciBpc0R1cGxpY2F0ZSA9IGhhc05hdGl2ZU1hcCA/IHRoaXMuaGFzKGFTdHIpIDogaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKTtcbiAgdmFyIGlkeCA9IHRoaXMuX2FycmF5Lmxlbmd0aDtcbiAgaWYgKCFpc0R1cGxpY2F0ZSB8fCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhU3RyKTtcbiAgfVxuICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgaWYgKGhhc05hdGl2ZU1hcCkge1xuICAgICAgdGhpcy5fc2V0LnNldChhU3RyLCBpZHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZXRbc1N0cl0gPSBpZHg7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIElzIHRoZSBnaXZlbiBzdHJpbmcgYSBtZW1iZXIgb2YgdGhpcyBzZXQ/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBBcnJheVNldF9oYXMoYVN0cikge1xuICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldC5oYXMoYVN0cik7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICAgIHJldHVybiBoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpO1xuICB9XG59O1xuXG4vKipcbiAqIFdoYXQgaXMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBzdHJpbmcgaW4gdGhlIGFycmF5P1xuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIEFycmF5U2V0X2luZGV4T2YoYVN0cikge1xuICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuX3NldC5nZXQoYVN0cik7XG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NldFtzU3RyXTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTdHIgKyAnXCIgaXMgbm90IGluIHRoZSBzZXQuJyk7XG59O1xuXG4vKipcbiAqIFdoYXQgaXMgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4P1xuICpcbiAqIEBwYXJhbSBOdW1iZXIgYUlkeFxuICovXG5BcnJheVNldC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBBcnJheVNldF9hdChhSWR4KSB7XG4gIGlmIChhSWR4ID49IDAgJiYgYUlkeCA8IHRoaXMuX2FycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheVthSWR4XTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ05vIGVsZW1lbnQgaW5kZXhlZCBieSAnICsgYUlkeCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc2V0ICh3aGljaCBoYXMgdGhlIHByb3BlciBpbmRpY2VzXG4gKiBpbmRpY2F0ZWQgYnkgaW5kZXhPZikuIE5vdGUgdGhhdCB0aGlzIGlzIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgYXJyYXkgdXNlZFxuICogZm9yIHN0b3JpbmcgdGhlIG1lbWJlcnMgc28gdGhhdCBubyBvbmUgY2FuIG1lc3Mgd2l0aCBpbnRlcm5hbCBzdGF0ZS5cbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF90b0FycmF5KCkge1xuICByZXR1cm4gdGhpcy5fYXJyYXkuc2xpY2UoKTtcbn07XG5cbmV4cG9ydHMuQXJyYXlTZXQgPSBBcnJheVNldDtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKlxuICogQmFzZWQgb24gdGhlIEJhc2UgNjQgVkxRIGltcGxlbWVudGF0aW9uIGluIENsb3N1cmUgQ29tcGlsZXI6XG4gKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nsb3N1cmUtY29tcGlsZXIvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvY29tL2dvb2dsZS9kZWJ1Z2dpbmcvc291cmNlbWFwL0Jhc2U2NFZMUS5qYXZhXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgVGhlIENsb3N1cmUgQ29tcGlsZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICogICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXG4gKiAgICB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWRcbiAqICAgIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4vYmFzZTY0Jyk7XG5cbi8vIEEgc2luZ2xlIGJhc2UgNjQgZGlnaXQgY2FuIGNvbnRhaW4gNiBiaXRzIG9mIGRhdGEuIEZvciB0aGUgYmFzZSA2NCB2YXJpYWJsZVxuLy8gbGVuZ3RoIHF1YW50aXRpZXMgd2UgdXNlIGluIHRoZSBzb3VyY2UgbWFwIHNwZWMsIHRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ24sXG4vLyB0aGUgbmV4dCBmb3VyIGJpdHMgYXJlIHRoZSBhY3R1YWwgdmFsdWUsIGFuZCB0aGUgNnRoIGJpdCBpcyB0aGVcbi8vIGNvbnRpbnVhdGlvbiBiaXQuIFRoZSBjb250aW51YXRpb24gYml0IHRlbGxzIHVzIHdoZXRoZXIgdGhlcmUgYXJlIG1vcmVcbi8vIGRpZ2l0cyBpbiB0aGlzIHZhbHVlIGZvbGxvd2luZyB0aGlzIGRpZ2l0LlxuLy9cbi8vICAgQ29udGludWF0aW9uXG4vLyAgIHwgICAgU2lnblxuLy8gICB8ICAgIHxcbi8vICAgViAgICBWXG4vLyAgIDEwMTAxMVxuXG52YXIgVkxRX0JBU0VfU0hJRlQgPSA1O1xuXG4vLyBiaW5hcnk6IDEwMDAwMFxudmFyIFZMUV9CQVNFID0gMSA8PCBWTFFfQkFTRV9TSElGVDtcblxuLy8gYmluYXJ5OiAwMTExMTFcbnZhciBWTFFfQkFTRV9NQVNLID0gVkxRX0JBU0UgLSAxO1xuXG4vLyBiaW5hcnk6IDEwMDAwMFxudmFyIFZMUV9DT05USU5VQVRJT05fQklUID0gVkxRX0JBU0U7XG5cbi8qKlxuICogQ29udmVydHMgZnJvbSBhIHR3by1jb21wbGVtZW50IHZhbHVlIHRvIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gKiBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAqICAgMSBiZWNvbWVzIDIgKDEwIGJpbmFyeSksIC0xIGJlY29tZXMgMyAoMTEgYmluYXJ5KVxuICogICAyIGJlY29tZXMgNCAoMTAwIGJpbmFyeSksIC0yIGJlY29tZXMgNSAoMTAxIGJpbmFyeSlcbiAqL1xuZnVuY3Rpb24gdG9WTFFTaWduZWQoYVZhbHVlKSB7XG4gIHJldHVybiBhVmFsdWUgPCAwXG4gICAgPyAoKC1hVmFsdWUpIDw8IDEpICsgMVxuICAgIDogKGFWYWx1ZSA8PCAxKSArIDA7XG59XG5cbi8qKlxuICogQ29udmVydHMgdG8gYSB0d28tY29tcGxlbWVudCB2YWx1ZSBmcm9tIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gKiBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAqICAgMiAoMTAgYmluYXJ5KSBiZWNvbWVzIDEsIDMgKDExIGJpbmFyeSkgYmVjb21lcyAtMVxuICogICA0ICgxMDAgYmluYXJ5KSBiZWNvbWVzIDIsIDUgKDEwMSBiaW5hcnkpIGJlY29tZXMgLTJcbiAqL1xuZnVuY3Rpb24gZnJvbVZMUVNpZ25lZChhVmFsdWUpIHtcbiAgdmFyIGlzTmVnYXRpdmUgPSAoYVZhbHVlICYgMSkgPT09IDE7XG4gIHZhciBzaGlmdGVkID0gYVZhbHVlID4+IDE7XG4gIHJldHVybiBpc05lZ2F0aXZlXG4gICAgPyAtc2hpZnRlZFxuICAgIDogc2hpZnRlZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiYXNlIDY0IFZMUSBlbmNvZGVkIHZhbHVlLlxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9lbmNvZGUoYVZhbHVlKSB7XG4gIHZhciBlbmNvZGVkID0gXCJcIjtcbiAgdmFyIGRpZ2l0O1xuXG4gIHZhciB2bHEgPSB0b1ZMUVNpZ25lZChhVmFsdWUpO1xuXG4gIGRvIHtcbiAgICBkaWdpdCA9IHZscSAmIFZMUV9CQVNFX01BU0s7XG4gICAgdmxxID4+Pj0gVkxRX0JBU0VfU0hJRlQ7XG4gICAgaWYgKHZscSA+IDApIHtcbiAgICAgIC8vIFRoZXJlIGFyZSBzdGlsbCBtb3JlIGRpZ2l0cyBpbiB0aGlzIHZhbHVlLCBzbyB3ZSBtdXN0IG1ha2Ugc3VyZSB0aGVcbiAgICAgIC8vIGNvbnRpbnVhdGlvbiBiaXQgaXMgbWFya2VkLlxuICAgICAgZGlnaXQgfD0gVkxRX0NPTlRJTlVBVElPTl9CSVQ7XG4gICAgfVxuICAgIGVuY29kZWQgKz0gYmFzZTY0LmVuY29kZShkaWdpdCk7XG4gIH0gd2hpbGUgKHZscSA+IDApO1xuXG4gIHJldHVybiBlbmNvZGVkO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIHRoZSBuZXh0IGJhc2UgNjQgVkxRIHZhbHVlIGZyb20gdGhlIGdpdmVuIHN0cmluZyBhbmQgcmV0dXJucyB0aGVcbiAqIHZhbHVlIGFuZCB0aGUgcmVzdCBvZiB0aGUgc3RyaW5nIHZpYSB0aGUgb3V0IHBhcmFtZXRlci5cbiAqL1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZGVjb2RlKGFTdHIsIGFJbmRleCwgYU91dFBhcmFtKSB7XG4gIHZhciBzdHJMZW4gPSBhU3RyLmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IDA7XG4gIHZhciBzaGlmdCA9IDA7XG4gIHZhciBjb250aW51YXRpb24sIGRpZ2l0O1xuXG4gIGRvIHtcbiAgICBpZiAoYUluZGV4ID49IHN0ckxlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbW9yZSBkaWdpdHMgaW4gYmFzZSA2NCBWTFEgdmFsdWUuXCIpO1xuICAgIH1cblxuICAgIGRpZ2l0ID0gYmFzZTY0LmRlY29kZShhU3RyLmNoYXJDb2RlQXQoYUluZGV4KyspKTtcbiAgICBpZiAoZGlnaXQgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBkaWdpdDogXCIgKyBhU3RyLmNoYXJBdChhSW5kZXggLSAxKSk7XG4gICAgfVxuXG4gICAgY29udGludWF0aW9uID0gISEoZGlnaXQgJiBWTFFfQ09OVElOVUFUSU9OX0JJVCk7XG4gICAgZGlnaXQgJj0gVkxRX0JBU0VfTUFTSztcbiAgICByZXN1bHQgPSByZXN1bHQgKyAoZGlnaXQgPDwgc2hpZnQpO1xuICAgIHNoaWZ0ICs9IFZMUV9CQVNFX1NISUZUO1xuICB9IHdoaWxlIChjb250aW51YXRpb24pO1xuXG4gIGFPdXRQYXJhbS52YWx1ZSA9IGZyb21WTFFTaWduZWQocmVzdWx0KTtcbiAgYU91dFBhcmFtLnJlc3QgPSBhSW5kZXg7XG59O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgaW50VG9DaGFyTWFwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nLnNwbGl0KCcnKTtcblxuLyoqXG4gKiBFbmNvZGUgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2Ugb2YgMCB0byA2MyB0byBhIHNpbmdsZSBiYXNlIDY0IGRpZ2l0LlxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgaWYgKDAgPD0gbnVtYmVyICYmIG51bWJlciA8IGludFRvQ2hhck1hcC5sZW5ndGgpIHtcbiAgICByZXR1cm4gaW50VG9DaGFyTWFwW251bWJlcl07XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk11c3QgYmUgYmV0d2VlbiAwIGFuZCA2MzogXCIgKyBudW1iZXIpO1xufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBzaW5nbGUgYmFzZSA2NCBjaGFyYWN0ZXIgY29kZSBkaWdpdCB0byBhbiBpbnRlZ2VyLiBSZXR1cm5zIC0xIG9uXG4gKiBmYWlsdXJlLlxuICovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICB2YXIgYmlnQSA9IDY1OyAgICAgLy8gJ0EnXG4gIHZhciBiaWdaID0gOTA7ICAgICAvLyAnWidcblxuICB2YXIgbGl0dGxlQSA9IDk3OyAgLy8gJ2EnXG4gIHZhciBsaXR0bGVaID0gMTIyOyAvLyAneidcblxuICB2YXIgemVybyA9IDQ4OyAgICAgLy8gJzAnXG4gIHZhciBuaW5lID0gNTc7ICAgICAvLyAnOSdcblxuICB2YXIgcGx1cyA9IDQzOyAgICAgLy8gJysnXG4gIHZhciBzbGFzaCA9IDQ3OyAgICAvLyAnLydcblxuICB2YXIgbGl0dGxlT2Zmc2V0ID0gMjY7XG4gIHZhciBudW1iZXJPZmZzZXQgPSA1MjtcblxuICAvLyAwIC0gMjU6IEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXG4gIGlmIChiaWdBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGJpZ1opIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gYmlnQSk7XG4gIH1cblxuICAvLyAyNiAtIDUxOiBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elxuICBpZiAobGl0dGxlQSA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBsaXR0bGVaKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIGxpdHRsZUEgKyBsaXR0bGVPZmZzZXQpO1xuICB9XG5cbiAgLy8gNTIgLSA2MTogMDEyMzQ1Njc4OVxuICBpZiAoemVybyA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBuaW5lKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIHplcm8gKyBudW1iZXJPZmZzZXQpO1xuICB9XG5cbiAgLy8gNjI6ICtcbiAgaWYgKGNoYXJDb2RlID09IHBsdXMpIHtcbiAgICByZXR1cm4gNjI7XG4gIH1cblxuICAvLyA2MzogL1xuICBpZiAoY2hhckNvZGUgPT0gc2xhc2gpIHtcbiAgICByZXR1cm4gNjM7XG4gIH1cblxuICAvLyBJbnZhbGlkIGJhc2U2NCBkaWdpdC5cbiAgcmV0dXJuIC0xO1xufTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuZXhwb3J0cy5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5leHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EID0gMjtcblxuLyoqXG4gKiBSZWN1cnNpdmUgaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaC5cbiAqXG4gKiBAcGFyYW0gYUxvdyBJbmRpY2VzIGhlcmUgYW5kIGxvd2VyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYUhpZ2ggSW5kaWNlcyBoZXJlIGFuZCBoaWdoZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IGJlaW5nIHNlYXJjaGVkIGZvci5cbiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIG5vbi1lbXB0eSBhcnJheSBiZWluZyBzZWFyY2hlZC5cbiAqIEBwYXJhbSBhQ29tcGFyZSBGdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gZWxlbWVudHMgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEuXG4gKiBAcGFyYW0gYUJpYXMgRWl0aGVyICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ2JpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiB0ZXJtaW5hdGVzIHdoZW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZTpcbiAgLy9cbiAgLy8gICAxLiBXZSBmaW5kIHRoZSBleGFjdCBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgLy9cbiAgLy8gICAyLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGJ1dCB3ZSBjYW4gcmV0dXJuIHRoZSBpbmRleCBvZlxuICAvLyAgICAgIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudC5cbiAgLy9cbiAgLy8gICAzLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGFuZCB0aGVyZSBpcyBubyBuZXh0LWNsb3Nlc3RcbiAgLy8gICAgICBlbGVtZW50IHRoYW4gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgc28gd2UgcmV0dXJuIC0xLlxuICB2YXIgbWlkID0gTWF0aC5mbG9vcigoYUhpZ2ggLSBhTG93KSAvIDIpICsgYUxvdztcbiAgdmFyIGNtcCA9IGFDb21wYXJlKGFOZWVkbGUsIGFIYXlzdGFja1ttaWRdLCB0cnVlKTtcbiAgaWYgKGNtcCA9PT0gMCkge1xuICAgIC8vIEZvdW5kIHRoZSBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgICByZXR1cm4gbWlkO1xuICB9XG4gIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAvLyBPdXIgbmVlZGxlIGlzIGdyZWF0ZXIgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICBpZiAoYUhpZ2ggLSBtaWQgPiAxKSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2gobWlkLCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpO1xuICAgIH1cblxuICAgIC8vIFRoZSBleGFjdCBuZWVkbGUgZWxlbWVudCB3YXMgbm90IGZvdW5kIGluIHRoaXMgaGF5c3RhY2suIERldGVybWluZSBpZlxuICAgIC8vIHdlIGFyZSBpbiB0ZXJtaW5hdGlvbiBjYXNlICgzKSBvciAoMikgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgdGhpbmcuXG4gICAgaWYgKGFCaWFzID09IGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQpIHtcbiAgICAgIHJldHVybiBhSGlnaCA8IGFIYXlzdGFjay5sZW5ndGggPyBhSGlnaCA6IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWlkO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBPdXIgbmVlZGxlIGlzIGxlc3MgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICBpZiAobWlkIC0gYUxvdyA+IDEpIHtcbiAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSBsb3dlciBoYWxmLlxuICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBtaWQsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICB9XG5cbiAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICByZXR1cm4gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYUxvdyA8IDAgPyAtMSA6IGFMb3c7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoIHdoaWNoIHdpbGwgYWx3YXlzIHRyeSBhbmQgcmV0dXJuXG4gKiB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgZWxlbWVudCBpZiB0aGVyZSBpcyBubyBleGFjdCBoaXQuIFRoaXMgaXMgYmVjYXVzZVxuICogbWFwcGluZ3MgYmV0d2VlbiBvcmlnaW5hbCBhbmQgZ2VuZXJhdGVkIGxpbmUvY29sIHBhaXJzIGFyZSBzaW5nbGUgcG9pbnRzLFxuICogYW5kIHRoZXJlIGlzIGFuIGltcGxpY2l0IHJlZ2lvbiBiZXR3ZWVuIGVhY2ggb2YgdGhlbSwgc28gYSBtaXNzIGp1c3QgbWVhbnNcbiAqIHRoYXQgeW91IGFyZW4ndCBvbiB0aGUgdmVyeSBzdGFydCBvZiBhIHJlZ2lvbi5cbiAqXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCB5b3UgYXJlIGxvb2tpbmcgZm9yLlxuICogQHBhcmFtIGFIYXlzdGFjayBUaGUgYXJyYXkgdGhhdCBpcyBiZWluZyBzZWFyY2hlZC5cbiAqIEBwYXJhbSBhQ29tcGFyZSBBIGZ1bmN0aW9uIHdoaWNoIHRha2VzIHRoZSBuZWVkbGUgYW5kIGFuIGVsZW1lbnQgaW4gdGhlXG4gKiAgICAgYXJyYXkgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIG5lZWRsZSBpcyBsZXNzXG4gKiAgICAgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiB0aGUgZWxlbWVudCwgcmVzcGVjdGl2ZWx5LlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICovXG5leHBvcnRzLnNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaChhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcykge1xuICBpZiAoYUhheXN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHZhciBpbmRleCA9IHJlY3Vyc2l2ZVNlYXJjaCgtMSwgYUhheXN0YWNrLmxlbmd0aCwgYU5lZWRsZSwgYUhheXN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbXBhcmUsIGFCaWFzIHx8IGV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLy8gV2UgaGF2ZSBmb3VuZCBlaXRoZXIgdGhlIGV4YWN0IGVsZW1lbnQsIG9yIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudCB0aGFuXG4gIC8vIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuIEhvd2V2ZXIsIHRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIHN1Y2hcbiAgLy8gZWxlbWVudC4gTWFrZSBzdXJlIHdlIGFsd2F5cyByZXR1cm4gdGhlIHNtYWxsZXN0IG9mIHRoZXNlLlxuICB3aGlsZSAoaW5kZXggLSAxID49IDApIHtcbiAgICBpZiAoYUNvbXBhcmUoYUhheXN0YWNrW2luZGV4XSwgYUhheXN0YWNrW2luZGV4IC0gMV0sIHRydWUpICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLS1pbmRleDtcbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn07XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTQgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgbWFwcGluZ0IgaXMgYWZ0ZXIgbWFwcGluZ0Egd2l0aCByZXNwZWN0IHRvIGdlbmVyYXRlZFxuICogcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gIC8vIE9wdGltaXplZCBmb3IgbW9zdCBjb21tb24gY2FzZVxuICB2YXIgbGluZUEgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lO1xuICB2YXIgbGluZUIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICB2YXIgY29sdW1uQSA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbjtcbiAgdmFyIGNvbHVtbkIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIHJldHVybiBsaW5lQiA+IGxpbmVBIHx8IGxpbmVCID09IGxpbmVBICYmIGNvbHVtbkIgPj0gY29sdW1uQSB8fFxuICAgICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIDw9IDA7XG59XG5cbi8qKlxuICogQSBkYXRhIHN0cnVjdHVyZSB0byBwcm92aWRlIGEgc29ydGVkIHZpZXcgb2YgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gYVxuICogcGVyZm9ybWFuY2UgY29uc2Npb3VzIG1hbm5lci4gSXQgdHJhZGVzIGEgbmVnbGliYWJsZSBvdmVyaGVhZCBpbiBnZW5lcmFsXG4gKiBjYXNlIGZvciBhIGxhcmdlIHNwZWVkdXAgaW4gY2FzZSBvZiBtYXBwaW5ncyBiZWluZyBhZGRlZCBpbiBvcmRlci5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZ0xpc3QoKSB7XG4gIHRoaXMuX2FycmF5ID0gW107XG4gIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gIC8vIFNlcnZlcyBhcyBpbmZpbXVtXG4gIHRoaXMuX2xhc3QgPSB7Z2VuZXJhdGVkTGluZTogLTEsIGdlbmVyYXRlZENvbHVtbjogMH07XG59XG5cbi8qKlxuICogSXRlcmF0ZSB0aHJvdWdoIGludGVybmFsIGl0ZW1zLiBUaGlzIG1ldGhvZCB0YWtlcyB0aGUgc2FtZSBhcmd1bWVudHMgdGhhdFxuICogYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCB0YWtlcy5cbiAqXG4gKiBOT1RFOiBUaGUgb3JkZXIgb2YgdGhlIG1hcHBpbmdzIGlzIE5PVCBndWFyYW50ZWVkLlxuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUudW5zb3J0ZWRGb3JFYWNoID1cbiAgZnVuY3Rpb24gTWFwcGluZ0xpc3RfZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKSB7XG4gICAgdGhpcy5fYXJyYXkuZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKTtcbiAgfTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHNvdXJjZSBtYXBwaW5nLlxuICpcbiAqIEBwYXJhbSBPYmplY3QgYU1hcHBpbmdcbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2FkZChhTWFwcGluZykge1xuICBpZiAoZ2VuZXJhdGVkUG9zaXRpb25BZnRlcih0aGlzLl9sYXN0LCBhTWFwcGluZykpIHtcbiAgICB0aGlzLl9sYXN0ID0gYU1hcHBpbmc7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fc29ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmxhdCwgc29ydGVkIGFycmF5IG9mIG1hcHBpbmdzLiBUaGUgbWFwcGluZ3MgYXJlIHNvcnRlZCBieVxuICogZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICpcbiAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIHJldHVybnMgaW50ZXJuYWwgZGF0YSB3aXRob3V0IGNvcHlpbmcsIGZvclxuICogcGVyZm9ybWFuY2UuIFRoZSByZXR1cm4gdmFsdWUgbXVzdCBOT1QgYmUgbXV0YXRlZCwgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzXG4gKiBhbiBpbW11dGFibGUgYm9ycm93LiBJZiB5b3Ugd2FudCB0byB0YWtlIG93bmVyc2hpcCwgeW91IG11c3QgbWFrZSB5b3VyIG93blxuICogY29weS5cbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF90b0FycmF5KCkge1xuICBpZiAoIXRoaXMuX3NvcnRlZCkge1xuICAgIHRoaXMuX2FycmF5LnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCk7XG4gICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXk7XG59O1xuXG5leHBvcnRzLk1hcHBpbmdMaXN0ID0gTWFwcGluZ0xpc3Q7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbi8vIEl0IHR1cm5zIG91dCB0aGF0IHNvbWUgKG1vc3Q/KSBKYXZhU2NyaXB0IGVuZ2luZXMgZG9uJ3Qgc2VsZi1ob3N0XG4vLyBgQXJyYXkucHJvdG90eXBlLnNvcnRgLiBUaGlzIG1ha2VzIHNlbnNlIGJlY2F1c2UgQysrIHdpbGwgbGlrZWx5IHJlbWFpblxuLy8gZmFzdGVyIHRoYW4gSlMgd2hlbiBkb2luZyByYXcgQ1BVLWludGVuc2l2ZSBzb3J0aW5nLiBIb3dldmVyLCB3aGVuIHVzaW5nIGFcbi8vIGN1c3RvbSBjb21wYXJhdG9yIGZ1bmN0aW9uLCBjYWxsaW5nIGJhY2sgYW5kIGZvcnRoIGJldHdlZW4gdGhlIFZNJ3MgQysrIGFuZFxuLy8gSklUJ2QgSlMgaXMgcmF0aGVyIHNsb3cgKmFuZCogbG9zZXMgSklUIHR5cGUgaW5mb3JtYXRpb24sIHJlc3VsdGluZyBpblxuLy8gd29yc2UgZ2VuZXJhdGVkIGNvZGUgZm9yIHRoZSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRoYW4gd291bGQgYmUgb3B0aW1hbC4gSW5cbi8vIGZhY3QsIHdoZW4gc29ydGluZyB3aXRoIGEgY29tcGFyYXRvciwgdGhlc2UgY29zdHMgb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIG9mXG4vLyBzb3J0aW5nIGluIEMrKy4gQnkgdXNpbmcgb3VyIG93biBKUy1pbXBsZW1lbnRlZCBRdWljayBTb3J0IChiZWxvdyksIHdlIGdldFxuLy8gYSB+MzUwMG1zIG1lYW4gc3BlZWQtdXAgaW4gYGJlbmNoL2JlbmNoLmh0bWxgLlxuXG4vKipcbiAqIFN3YXAgdGhlIGVsZW1lbnRzIGluZGV4ZWQgYnkgYHhgIGFuZCBgeWAgaW4gdGhlIGFycmF5IGBhcnlgLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIFRoZSBhcnJheS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpdGVtLlxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHNlY29uZCBpdGVtLlxuICovXG5mdW5jdGlvbiBzd2FwKGFyeSwgeCwgeSkge1xuICB2YXIgdGVtcCA9IGFyeVt4XTtcbiAgYXJ5W3hdID0gYXJ5W3ldO1xuICBhcnlbeV0gPSB0ZW1wO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciB3aXRoaW4gdGhlIHJhbmdlIGBsb3cgLi4gaGlnaGAgaW5jbHVzaXZlLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBsb3dcbiAqICAgICAgICBUaGUgbG93ZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGhpZ2hcbiAqICAgICAgICBUaGUgdXBwZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICovXG5mdW5jdGlvbiByYW5kb21JbnRJblJhbmdlKGxvdywgaGlnaCkge1xuICByZXR1cm4gTWF0aC5yb3VuZChsb3cgKyAoTWF0aC5yYW5kb20oKSAqIChoaWdoIC0gbG93KSkpO1xufVxuXG4vKipcbiAqIFRoZSBRdWljayBTb3J0IGFsZ29yaXRobS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwXG4gKiAgICAgICAgU3RhcnQgaW5kZXggb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gclxuICogICAgICAgIEVuZCBpbmRleCBvZiB0aGUgYXJyYXlcbiAqL1xuZnVuY3Rpb24gZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBwLCByKSB7XG4gIC8vIElmIG91ciBsb3dlciBib3VuZCBpcyBsZXNzIHRoYW4gb3VyIHVwcGVyIGJvdW5kLCB3ZSAoMSkgcGFydGl0aW9uIHRoZVxuICAvLyBhcnJheSBpbnRvIHR3byBwaWVjZXMgYW5kICgyKSByZWN1cnNlIG9uIGVhY2ggaGFsZi4gSWYgaXQgaXMgbm90LCB0aGlzIGlzXG4gIC8vIHRoZSBlbXB0eSBhcnJheSBhbmQgb3VyIGJhc2UgY2FzZS5cblxuICBpZiAocCA8IHIpIHtcbiAgICAvLyAoMSkgUGFydGl0aW9uaW5nLlxuICAgIC8vXG4gICAgLy8gVGhlIHBhcnRpdGlvbmluZyBjaG9vc2VzIGEgcGl2b3QgYmV0d2VlbiBgcGAgYW5kIGByYCBhbmQgbW92ZXMgYWxsXG4gICAgLy8gZWxlbWVudHMgdGhhdCBhcmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdCB0byB0aGUgYmVmb3JlIGl0LCBhbmRcbiAgICAvLyBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgYXJlIGdyZWF0ZXIgdGhhbiBpdCBhZnRlciBpdC4gVGhlIGVmZmVjdCBpcyB0aGF0XG4gICAgLy8gb25jZSBwYXJ0aXRpb24gaXMgZG9uZSwgdGhlIHBpdm90IGlzIGluIHRoZSBleGFjdCBwbGFjZSBpdCB3aWxsIGJlIHdoZW5cbiAgICAvLyB0aGUgYXJyYXkgaXMgcHV0IGluIHNvcnRlZCBvcmRlciwgYW5kIGl0IHdpbGwgbm90IG5lZWQgdG8gYmUgbW92ZWRcbiAgICAvLyBhZ2Fpbi4gVGhpcyBydW5zIGluIE8obikgdGltZS5cblxuICAgIC8vIEFsd2F5cyBjaG9vc2UgYSByYW5kb20gcGl2b3Qgc28gdGhhdCBhbiBpbnB1dCBhcnJheSB3aGljaCBpcyByZXZlcnNlXG4gICAgLy8gc29ydGVkIGRvZXMgbm90IGNhdXNlIE8obl4yKSBydW5uaW5nIHRpbWUuXG4gICAgdmFyIHBpdm90SW5kZXggPSByYW5kb21JbnRJblJhbmdlKHAsIHIpO1xuICAgIHZhciBpID0gcCAtIDE7XG5cbiAgICBzd2FwKGFyeSwgcGl2b3RJbmRleCwgcik7XG4gICAgdmFyIHBpdm90ID0gYXJ5W3JdO1xuXG4gICAgLy8gSW1tZWRpYXRlbHkgYWZ0ZXIgYGpgIGlzIGluY3JlbWVudGVkIGluIHRoaXMgbG9vcCwgdGhlIGZvbGxvd2luZyBob2xkXG4gICAgLy8gdHJ1ZTpcbiAgICAvL1xuICAgIC8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbcCAuLiBpXWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdC5cbiAgICAvL1xuICAgIC8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbaSsxIC4uIGotMV1gIGlzIGdyZWF0ZXIgdGhhbiB0aGUgcGl2b3QuXG4gICAgZm9yICh2YXIgaiA9IHA7IGogPCByOyBqKyspIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKGFyeVtqXSwgcGl2b3QpIDw9IDApIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgICBzd2FwKGFyeSwgaSwgaik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dhcChhcnksIGkgKyAxLCBqKTtcbiAgICB2YXIgcSA9IGkgKyAxO1xuXG4gICAgLy8gKDIpIFJlY3Vyc2Ugb24gZWFjaCBoYWxmLlxuXG4gICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBwLCBxIC0gMSk7XG4gICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBxICsgMSwgcik7XG4gIH1cbn1cblxuLyoqXG4gKiBTb3J0IHRoZSBnaXZlbiBhcnJheSBpbi1wbGFjZSB3aXRoIHRoZSBnaXZlbiBjb21wYXJhdG9yIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIEFuIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICovXG5leHBvcnRzLnF1aWNrU29ydCA9IGZ1bmN0aW9uIChhcnksIGNvbXBhcmF0b3IpIHtcbiAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCAwLCBhcnkubGVuZ3RoIC0gMSk7XG59O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGJpbmFyeVNlYXJjaCA9IHJlcXVpcmUoJy4vYmluYXJ5LXNlYXJjaCcpO1xudmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbnZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbnZhciBxdWlja1NvcnQgPSByZXF1aXJlKCcuL3F1aWNrLXNvcnQnKS5xdWlja1NvcnQ7XG5cbmZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSB1dGlsLnBhcnNlU291cmNlTWFwSW5wdXQoYVNvdXJjZU1hcCk7XG4gIH1cblxuICByZXR1cm4gc291cmNlTWFwLnNlY3Rpb25zICE9IG51bGxcbiAgICA/IG5ldyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwLCBhU291cmNlTWFwVVJMKVxuICAgIDogbmV3IEJhc2ljU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwLCBhU291cmNlTWFwVVJMKTtcbn1cblxuU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9IGZ1bmN0aW9uKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgcmV0dXJuIEJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcChhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKTtcbn1cblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8vIGBfX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmQgYF9fb3JpZ2luYWxNYXBwaW5nc2AgYXJlIGFycmF5cyB0aGF0IGhvbGQgdGhlXG4vLyBwYXJzZWQgbWFwcGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgbWFwJ3MgXCJtYXBwaW5nc1wiIGF0dHJpYnV0ZS4gVGhleVxuLy8gYXJlIGxhemlseSBpbnN0YW50aWF0ZWQsIGFjY2Vzc2VkIHZpYSB0aGUgYF9nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4vLyBgX29yaWdpbmFsTWFwcGluZ3NgIGdldHRlcnMgcmVzcGVjdGl2ZWx5LCBhbmQgd2Ugb25seSBwYXJzZSB0aGUgbWFwcGluZ3Ncbi8vIGFuZCBjcmVhdGUgdGhlc2UgYXJyYXlzIG9uY2UgcXVlcmllZCBmb3IgYSBzb3VyY2UgbG9jYXRpb24uIFdlIGp1bXAgdGhyb3VnaFxuLy8gdGhlc2UgaG9vcHMgYmVjYXVzZSB0aGVyZSBjYW4gYmUgbWFueSB0aG91c2FuZHMgb2YgbWFwcGluZ3MsIGFuZCBwYXJzaW5nXG4vLyB0aGVtIGlzIGV4cGVuc2l2ZSwgc28gd2Ugb25seSB3YW50IHRvIGRvIGl0IGlmIHdlIG11c3QuXG4vL1xuLy8gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5cyBpcyBvZiB0aGUgZm9ybTpcbi8vXG4vLyAgICAge1xuLy8gICAgICAgZ2VuZXJhdGVkTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIGdlbmVyYXRlZENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgc291cmNlOiBUaGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgdGhhdCBnZW5lcmF0ZWQgdGhpc1xuLy8gICAgICAgICAgICAgICBjaHVuayBvZiBjb2RlLFxuLy8gICAgICAgb3JpZ2luYWxMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBvcmlnaW5hbCBzeW1ib2wgd2hpY2ggZ2VuZXJhdGVkIHRoaXMgY2h1bmsgb2Zcbi8vICAgICAgICAgICAgIGNvZGUuXG4vLyAgICAgfVxuLy9cbi8vIEFsbCBwcm9wZXJ0aWVzIGV4Y2VwdCBmb3IgYGdlbmVyYXRlZExpbmVgIGFuZCBgZ2VuZXJhdGVkQ29sdW1uYCBjYW4gYmVcbi8vIGBudWxsYC5cbi8vXG4vLyBgX2dlbmVyYXRlZE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zLlxuLy9cbi8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zLlxuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IG51bGw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX2dlbmVyYXRlZE1hcHBpbmdzJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzKSB7XG4gICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gIH1cbn0pO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19vcmlnaW5hbE1hcHBpbmdzID0gbnVsbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfb3JpZ2luYWxNYXBwaW5ncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX19vcmlnaW5hbE1hcHBpbmdzKSB7XG4gICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncztcbiAgfVxufSk7XG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fY2hhcklzTWFwcGluZ1NlcGFyYXRvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgaW5kZXgpIHtcbiAgICB2YXIgYyA9IGFTdHIuY2hhckF0KGluZGV4KTtcbiAgICByZXR1cm4gYyA9PT0gXCI7XCIgfHwgYyA9PT0gXCIsXCI7XG4gIH07XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudCBfcGFyc2VNYXBwaW5nc1wiKTtcbiAgfTtcblxuU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSID0gMTtcblNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSID0gMjtcblxuU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQgPSAyO1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBlYWNoIG1hcHBpbmcgYmV0d2VlbiBhbiBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4gYW5kIGFcbiAqIGdlbmVyYXRlZCBsaW5lL2NvbHVtbiBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gKlxuICogQHBhcmFtIEZ1bmN0aW9uIGFDYWxsYmFja1xuICogICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGVhY2ggbWFwcGluZy5cbiAqIEBwYXJhbSBPYmplY3QgYUNvbnRleHRcbiAqICAgICAgICBPcHRpb25hbC4gSWYgc3BlY2lmaWVkLCB0aGlzIG9iamVjdCB3aWxsIGJlIHRoZSB2YWx1ZSBvZiBgdGhpc2AgZXZlcnlcbiAqICAgICAgICB0aW1lIHRoYXQgYGFDYWxsYmFja2AgaXMgY2FsbGVkLlxuICogQHBhcmFtIGFPcmRlclxuICogICAgICAgIEVpdGhlciBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYCBvclxuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUmAuIFNwZWNpZmllcyB3aGV0aGVyIHlvdSB3YW50IHRvXG4gKiAgICAgICAgaXRlcmF0ZSBvdmVyIHRoZSBtYXBwaW5ncyBzb3J0ZWQgYnkgdGhlIGdlbmVyYXRlZCBmaWxlJ3MgbGluZS9jb2x1bW5cbiAqICAgICAgICBvcmRlciBvciB0aGUgb3JpZ2luYWwncyBzb3VyY2UvbGluZS9jb2x1bW4gb3JkZXIsIHJlc3BlY3RpdmVseS4gRGVmYXVsdHMgdG9cbiAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYC5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmVhY2hNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZWFjaE1hcHBpbmcoYUNhbGxiYWNrLCBhQ29udGV4dCwgYU9yZGVyKSB7XG4gICAgdmFyIGNvbnRleHQgPSBhQ29udGV4dCB8fCBudWxsO1xuICAgIHZhciBvcmRlciA9IGFPcmRlciB8fCBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI7XG5cbiAgICB2YXIgbWFwcGluZ3M7XG4gICAgc3dpdGNoIChvcmRlcikge1xuICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSOlxuICAgICAgbWFwcGluZ3MgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVI6XG4gICAgICBtYXBwaW5ncyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3M7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcmRlciBvZiBpdGVyYXRpb24uXCIpO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VSb290ID0gdGhpcy5zb3VyY2VSb290O1xuICAgIG1hcHBpbmdzLm1hcChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlID09PSBudWxsID8gbnVsbCA6IHRoaXMuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgc291cmNlID0gdXRpbC5jb21wdXRlU291cmNlVVJMKHNvdXJjZVJvb3QsIHNvdXJjZSwgdGhpcy5fc291cmNlTWFwVVJMKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4sXG4gICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICBuYW1lOiBtYXBwaW5nLm5hbWUgPT09IG51bGwgPyBudWxsIDogdGhpcy5fbmFtZXMuYXQobWFwcGluZy5uYW1lKVxuICAgICAgfTtcbiAgICB9LCB0aGlzKS5mb3JFYWNoKGFDYWxsYmFjaywgY29udGV4dCk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyBhbGwgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcHJvdmlkZWQuIElmIG5vIGNvbHVtbiBpcyBwcm92aWRlZCwgcmV0dXJucyBhbGwgbWFwcGluZ3NcbiAqIGNvcnJlc3BvbmRpbmcgdG8gYSBlaXRoZXIgdGhlIGxpbmUgd2UgYXJlIHNlYXJjaGluZyBmb3Igb3IgdGhlIG5leHRcbiAqIGNsb3Nlc3QgbGluZSB0aGF0IGhhcyBhbnkgbWFwcGluZ3MuIE90aGVyd2lzZSwgcmV0dXJucyBhbGwgbWFwcGluZ3NcbiAqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGxpbmUgYW5kIGVpdGhlciB0aGUgY29sdW1uIHdlIGFyZSBzZWFyY2hpbmcgZm9yXG4gKiBvciB0aGUgbmV4dCBjbG9zZXN0IGNvbHVtbiB0aGF0IGhhcyBhbnkgb2Zmc2V0cy5cbiAqXG4gKiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IE9wdGlvbmFsLiB0aGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAgVGhlIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqXG4gKiBhbmQgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpcyByZXR1cm5lZCwgZWFjaCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yKGFBcmdzKSB7XG4gICAgdmFyIGxpbmUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKTtcblxuICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gZXhhY3QgbWF0Y2gsIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZ1xuICAgIC8vIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IG1hcHBpbmcgbGVzcyB0aGFuIHRoZSBuZWVkbGUuIEJ5XG4gICAgLy8gc2V0dGluZyBuZWVkbGUub3JpZ2luYWxDb2x1bW4gdG8gMCwgd2UgdGh1cyBmaW5kIHRoZSBsYXN0IG1hcHBpbmcgZm9yXG4gICAgLy8gdGhlIGdpdmVuIGxpbmUsIHByb3ZpZGVkIHN1Y2ggYSBtYXBwaW5nIGV4aXN0cy5cbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgc291cmNlOiB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpLFxuICAgICAgb3JpZ2luYWxMaW5lOiBsaW5lLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJywgMClcbiAgICB9O1xuXG4gICAgbmVlZGxlLnNvdXJjZSA9IHRoaXMuX2ZpbmRTb3VyY2VJbmRleChuZWVkbGUuc291cmNlKTtcbiAgICBpZiAobmVlZGxlLnNvdXJjZSA8IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgbWFwcGluZ3MgPSBbXTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKG5lZWRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxMaW5lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKGFBcmdzLmNvbHVtbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcblxuICAgICAgICAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50b1xuICAgICAgICAvLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIGZvdW5kLiBTaW5jZVxuICAgICAgICAvLyBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgIC8vIHRoZSBsaW5lIHdlIGZvdW5kLlxuICAgICAgICB3aGlsZSAobWFwcGluZyAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gb3JpZ2luYWxMaW5lKSB7XG4gICAgICAgICAgbWFwcGluZ3MucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1srK2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50b1xuICAgICAgICAvLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIHdlcmUgc2VhcmNoaW5nIGZvci5cbiAgICAgICAgLy8gU2luY2UgbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpcyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvclxuICAgICAgICAvLyB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvci5cbiAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiZcbiAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBsaW5lICYmXG4gICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID09IG9yaWdpbmFsQ29sdW1uKSB7XG4gICAgICAgICAgbWFwcGluZ3MucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1srK2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXBwaW5ncztcbiAgfTtcblxuZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIEEgQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2ggd2UgY2FuXG4gKiBxdWVyeSBmb3IgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9yaWdpbmFsIGZpbGUgcG9zaXRpb25zIGJ5IGdpdmluZyBpdCBhIGZpbGVcbiAqIHBvc2l0aW9uIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICpcbiAqIFRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgdGhlIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3JcbiAqIGFscmVhZHkgcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYywgc291cmNlIG1hcHMgaGF2ZSB0aGVcbiAqIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICpcbiAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICogICAtIHNvdXJjZXM6IEFuIGFycmF5IG9mIFVSTHMgdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAqICAgLSBuYW1lczogQW4gYXJyYXkgb2YgaWRlbnRpZmllcnMgd2hpY2ggY2FuIGJlIHJlZmVycmVuY2VkIGJ5IGluZGl2aWR1YWwgbWFwcGluZ3MuXG4gKiAgIC0gc291cmNlUm9vdDogT3B0aW9uYWwuIFRoZSBVUkwgcm9vdCBmcm9tIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSByZWxhdGl2ZS5cbiAqICAgLSBzb3VyY2VzQ29udGVudDogT3B0aW9uYWwuIEFuIGFycmF5IG9mIGNvbnRlbnRzIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gKiAgIC0gbWFwcGluZ3M6IEEgc3RyaW5nIG9mIGJhc2U2NCBWTFFzIHdoaWNoIGNvbnRhaW4gdGhlIGFjdHVhbCBtYXBwaW5ncy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKlxuICogSGVyZSBpcyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXTpcbiAqXG4gKiAgICAge1xuICogICAgICAgdmVyc2lvbiA6IDMsXG4gKiAgICAgICBmaWxlOiBcIm91dC5qc1wiLFxuICogICAgICAgc291cmNlUm9vdCA6IFwiXCIsXG4gKiAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gKiAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgIG1hcHBpbmdzOiBcIkFBLEFCOztBQkNERTtcIlxuICogICAgIH1cbiAqXG4gKiBUaGUgc2Vjb25kIHBhcmFtZXRlciwgaWYgZ2l2ZW4sIGlzIGEgc3RyaW5nIHdob3NlIHZhbHVlIGlzIHRoZSBVUkxcbiAqIGF0IHdoaWNoIHRoZSBzb3VyY2UgbWFwIHdhcyBmb3VuZC4gIFRoaXMgVVJMIGlzIHVzZWQgdG8gY29tcHV0ZSB0aGVcbiAqIHNvdXJjZXMgYXJyYXkuXG4gKlxuICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQ/cGxpPTEjXG4gKi9cbmZ1bmN0aW9uIEJhc2ljU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IHV0aWwucGFyc2VTb3VyY2VNYXBJbnB1dChhU291cmNlTWFwKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICB2YXIgc291cmNlcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXMnKTtcbiAgLy8gU2FzcyAzLjMgbGVhdmVzIG91dCB0aGUgJ25hbWVzJyBhcnJheSwgc28gd2UgZGV2aWF0ZSBmcm9tIHRoZSBzcGVjICh3aGljaFxuICAvLyByZXF1aXJlcyB0aGUgYXJyYXkpIHRvIHBsYXkgbmljZSBoZXJlLlxuICB2YXIgbmFtZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICduYW1lcycsIFtdKTtcbiAgdmFyIHNvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VSb290JywgbnVsbCk7XG4gIHZhciBzb3VyY2VzQ29udGVudCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXNDb250ZW50JywgbnVsbCk7XG4gIHZhciBtYXBwaW5ncyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ21hcHBpbmdzJyk7XG4gIHZhciBmaWxlID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnZmlsZScsIG51bGwpO1xuXG4gIC8vIE9uY2UgYWdhaW4sIFNhc3MgZGV2aWF0ZXMgZnJvbSB0aGUgc3BlYyBhbmQgc3VwcGxpZXMgdGhlIHZlcnNpb24gYXMgYVxuICAvLyBzdHJpbmcgcmF0aGVyIHRoYW4gYSBudW1iZXIsIHNvIHdlIHVzZSBsb29zZSBlcXVhbGl0eSBjaGVja2luZyBoZXJlLlxuICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICBpZiAoc291cmNlUm9vdCkge1xuICAgIHNvdXJjZVJvb3QgPSB1dGlsLm5vcm1hbGl6ZShzb3VyY2VSb290KTtcbiAgfVxuXG4gIHNvdXJjZXMgPSBzb3VyY2VzXG4gICAgLm1hcChTdHJpbmcpXG4gICAgLy8gU29tZSBzb3VyY2UgbWFwcyBwcm9kdWNlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBsaWtlIFwiLi9mb28uanNcIiBpbnN0ZWFkIG9mXG4gICAgLy8gXCJmb28uanNcIi4gIE5vcm1hbGl6ZSB0aGVzZSBmaXJzdCBzbyB0aGF0IGZ1dHVyZSBjb21wYXJpc29ucyB3aWxsIHN1Y2NlZWQuXG4gICAgLy8gU2VlIGJ1Z3ppbC5sYS8xMDkwNzY4LlxuICAgIC5tYXAodXRpbC5ub3JtYWxpemUpXG4gICAgLy8gQWx3YXlzIGVuc3VyZSB0aGF0IGFic29sdXRlIHNvdXJjZXMgYXJlIGludGVybmFsbHkgc3RvcmVkIHJlbGF0aXZlIHRvXG4gICAgLy8gdGhlIHNvdXJjZSByb290LCBpZiB0aGUgc291cmNlIHJvb3QgaXMgYWJzb2x1dGUuIE5vdCBkb2luZyB0aGlzIHdvdWxkXG4gICAgLy8gYmUgcGFydGljdWxhcmx5IHByb2JsZW1hdGljIHdoZW4gdGhlIHNvdXJjZSByb290IGlzIGEgcHJlZml4IG9mIHRoZVxuICAgIC8vIHNvdXJjZSAodmFsaWQsIGJ1dCB3aHk/PykuIFNlZSBnaXRodWIgaXNzdWUgIzE5OSBhbmQgYnVnemlsLmxhLzExODg5ODIuXG4gICAgLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gc291cmNlUm9vdCAmJiB1dGlsLmlzQWJzb2x1dGUoc291cmNlUm9vdCkgJiYgdXRpbC5pc0Fic29sdXRlKHNvdXJjZSlcbiAgICAgICAgPyB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZSlcbiAgICAgICAgOiBzb3VyY2U7XG4gICAgfSk7XG5cbiAgLy8gUGFzcyBgdHJ1ZWAgYmVsb3cgdG8gYWxsb3cgZHVwbGljYXRlIG5hbWVzIGFuZCBzb3VyY2VzLiBXaGlsZSBzb3VyY2UgbWFwc1xuICAvLyBhcmUgaW50ZW5kZWQgdG8gYmUgY29tcHJlc3NlZCBhbmQgZGVkdXBsaWNhdGVkLCB0aGUgVHlwZVNjcmlwdCBjb21waWxlclxuICAvLyBzb21ldGltZXMgZ2VuZXJhdGVzIHNvdXJjZSBtYXBzIHdpdGggZHVwbGljYXRlcyBpbiB0aGVtLiBTZWUgR2l0aHViIGlzc3VlXG4gIC8vICM3MiBhbmQgYnVnemlsLmxhLzg4OTQ5Mi5cbiAgdGhpcy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkobmFtZXMubWFwKFN0cmluZyksIHRydWUpO1xuICB0aGlzLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KHNvdXJjZXMsIHRydWUpO1xuXG4gIHRoaXMuX2Fic29sdXRlU291cmNlcyA9IHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLm1hcChmdW5jdGlvbiAocykge1xuICAgIHJldHVybiB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc291cmNlUm9vdCwgcywgYVNvdXJjZU1hcFVSTCk7XG4gIH0pO1xuXG4gIHRoaXMuc291cmNlUm9vdCA9IHNvdXJjZVJvb3Q7XG4gIHRoaXMuc291cmNlc0NvbnRlbnQgPSBzb3VyY2VzQ29udGVudDtcbiAgdGhpcy5fbWFwcGluZ3MgPSBtYXBwaW5ncztcbiAgdGhpcy5fc291cmNlTWFwVVJMID0gYVNvdXJjZU1hcFVSTDtcbiAgdGhpcy5maWxlID0gZmlsZTtcbn1cblxuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gZmluZCB0aGUgaW5kZXggb2YgYSBzb3VyY2UuICBSZXR1cm5zIC0xIGlmIG5vdFxuICogZm91bmQuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kU291cmNlSW5kZXggPSBmdW5jdGlvbihhU291cmNlKSB7XG4gIHZhciByZWxhdGl2ZVNvdXJjZSA9IGFTb3VyY2U7XG4gIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgIHJlbGF0aXZlU291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIHJlbGF0aXZlU291cmNlKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9zb3VyY2VzLmhhcyhyZWxhdGl2ZVNvdXJjZSkpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlcy5pbmRleE9mKHJlbGF0aXZlU291cmNlKTtcbiAgfVxuXG4gIC8vIE1heWJlIGFTb3VyY2UgaXMgYW4gYWJzb2x1dGUgVVJMIGFzIHJldHVybmVkIGJ5IHxzb3VyY2VzfC4gIEluXG4gIC8vIHRoaXMgY2FzZSB3ZSBjYW4ndCBzaW1wbHkgdW5kbyB0aGUgdHJhbnNmb3JtLlxuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2Fic29sdXRlU291cmNlcy5sZW5ndGg7ICsraSkge1xuICAgIGlmICh0aGlzLl9hYnNvbHV0ZVNvdXJjZXNbaV0gPT0gYVNvdXJjZSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGZyb20gYSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKlxuICogQHBhcmFtIFNvdXJjZU1hcEdlbmVyYXRvciBhU291cmNlTWFwXG4gKiAgICAgICAgVGhlIHNvdXJjZSBtYXAgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuICogQHBhcmFtIFN0cmluZyBhU291cmNlTWFwVVJMXG4gKiAgICAgICAgVGhlIFVSTCBhdCB3aGljaCB0aGUgc291cmNlIG1hcCBjYW4gYmUgZm91bmQgKG9wdGlvbmFsKVxuICogQHJldHVybnMgQmFzaWNTb3VyY2VNYXBDb25zdW1lclxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgICB2YXIgc21jID0gT2JqZWN0LmNyZWF0ZShCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5cbiAgICB2YXIgbmFtZXMgPSBzbWMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX25hbWVzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgdmFyIHNvdXJjZXMgPSBzbWMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fc291cmNlcy50b0FycmF5KCksIHRydWUpO1xuICAgIHNtYy5zb3VyY2VSb290ID0gYVNvdXJjZU1hcC5fc291cmNlUm9vdDtcbiAgICBzbWMuc291cmNlc0NvbnRlbnQgPSBhU291cmNlTWFwLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KHNtYy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbWMuc291cmNlUm9vdCk7XG4gICAgc21jLmZpbGUgPSBhU291cmNlTWFwLl9maWxlO1xuICAgIHNtYy5fc291cmNlTWFwVVJMID0gYVNvdXJjZU1hcFVSTDtcbiAgICBzbWMuX2Fic29sdXRlU291cmNlcyA9IHNtYy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gdXRpbC5jb21wdXRlU291cmNlVVJMKHNtYy5zb3VyY2VSb290LCBzLCBhU291cmNlTWFwVVJMKTtcbiAgICB9KTtcblxuICAgIC8vIEJlY2F1c2Ugd2UgYXJlIG1vZGlmeWluZyB0aGUgZW50cmllcyAoYnkgY29udmVydGluZyBzdHJpbmcgc291cmNlcyBhbmRcbiAgICAvLyBuYW1lcyB0byBpbmRpY2VzIGludG8gdGhlIHNvdXJjZXMgYW5kIG5hbWVzIEFycmF5U2V0cyksIHdlIGhhdmUgdG8gbWFrZVxuICAgIC8vIGEgY29weSBvZiB0aGUgZW50cnkgb3IgZWxzZSBiYWQgdGhpbmdzIGhhcHBlbi4gU2hhcmVkIG11dGFibGUgc3RhdGVcbiAgICAvLyBzdHJpa2VzIGFnYWluISBTZWUgZ2l0aHViIGlzc3VlICMxOTEuXG5cbiAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBhU291cmNlTWFwLl9tYXBwaW5ncy50b0FycmF5KCkuc2xpY2UoKTtcbiAgICB2YXIgZGVzdEdlbmVyYXRlZE1hcHBpbmdzID0gc21jLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgZGVzdE9yaWdpbmFsTWFwcGluZ3MgPSBzbWMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzcmNNYXBwaW5nID0gZ2VuZXJhdGVkTWFwcGluZ3NbaV07XG4gICAgICB2YXIgZGVzdE1hcHBpbmcgPSBuZXcgTWFwcGluZztcbiAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBzcmNNYXBwaW5nLmdlbmVyYXRlZExpbmU7XG4gICAgICBkZXN0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBzcmNNYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgaWYgKHNyY01hcHBpbmcuc291cmNlKSB7XG4gICAgICAgIGRlc3RNYXBwaW5nLnNvdXJjZSA9IHNvdXJjZXMuaW5kZXhPZihzcmNNYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsTGluZSA9IHNyY01hcHBpbmcub3JpZ2luYWxMaW5lO1xuICAgICAgICBkZXN0TWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IHNyY01hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgaWYgKHNyY01hcHBpbmcubmFtZSkge1xuICAgICAgICAgIGRlc3RNYXBwaW5nLm5hbWUgPSBuYW1lcy5pbmRleE9mKHNyY01hcHBpbmcubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXN0T3JpZ2luYWxNYXBwaW5ncy5wdXNoKGRlc3RNYXBwaW5nKTtcbiAgICAgIH1cblxuICAgICAgZGVzdEdlbmVyYXRlZE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgIH1cblxuICAgIHF1aWNrU29ydChzbWMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcblxuICAgIHJldHVybiBzbWM7XG4gIH07XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnc291cmNlcycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Fic29sdXRlU291cmNlcy5zbGljZSgpO1xuICB9XG59KTtcblxuLyoqXG4gKiBQcm92aWRlIHRoZSBKSVQgd2l0aCBhIG5pY2Ugc2hhcGUgLyBoaWRkZW4gY2xhc3MuXG4gKi9cbmZ1bmN0aW9uIE1hcHBpbmcoKSB7XG4gIHRoaXMuZ2VuZXJhdGVkTGluZSA9IDA7XG4gIHRoaXMuZ2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICB0aGlzLm9yaWdpbmFsTGluZSA9IG51bGw7XG4gIHRoaXMub3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICB0aGlzLm5hbWUgPSBudWxsO1xufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdmFyIGdlbmVyYXRlZExpbmUgPSAxO1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gYVN0ci5sZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgY2FjaGVkU2VnbWVudHMgPSB7fTtcbiAgICB2YXIgdGVtcCA9IHt9O1xuICAgIHZhciBvcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgdmFyIGdlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdmFyIG1hcHBpbmcsIHN0ciwgc2VnbWVudCwgZW5kLCB2YWx1ZTtcblxuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFTdHIuY2hhckF0KGluZGV4KSA9PT0gJzsnKSB7XG4gICAgICAgIGdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnLCcpIHtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtYXBwaW5nID0gbmV3IE1hcHBpbmcoKTtcbiAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRMaW5lID0gZ2VuZXJhdGVkTGluZTtcblxuICAgICAgICAvLyBCZWNhdXNlIGVhY2ggb2Zmc2V0IGlzIGVuY29kZWQgcmVsYXRpdmUgdG8gdGhlIHByZXZpb3VzIG9uZSxcbiAgICAgICAgLy8gbWFueSBzZWdtZW50cyBvZnRlbiBoYXZlIHRoZSBzYW1lIGVuY29kaW5nLiBXZSBjYW4gZXhwbG9pdCB0aGlzXG4gICAgICAgIC8vIGZhY3QgYnkgY2FjaGluZyB0aGUgcGFyc2VkIHZhcmlhYmxlIGxlbmd0aCBmaWVsZHMgb2YgZWFjaCBzZWdtZW50LFxuICAgICAgICAvLyBhbGxvd2luZyB1cyB0byBhdm9pZCBhIHNlY29uZCBwYXJzZSBpZiB3ZSBlbmNvdW50ZXIgdGhlIHNhbWVcbiAgICAgICAgLy8gc2VnbWVudCBhZ2Fpbi5cbiAgICAgICAgZm9yIChlbmQgPSBpbmRleDsgZW5kIDwgbGVuZ3RoOyBlbmQrKykge1xuICAgICAgICAgIGlmICh0aGlzLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIsIGVuZCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBhU3RyLnNsaWNlKGluZGV4LCBlbmQpO1xuXG4gICAgICAgIHNlZ21lbnQgPSBjYWNoZWRTZWdtZW50c1tzdHJdO1xuICAgICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICAgIGluZGV4ICs9IHN0ci5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VnbWVudCA9IFtdO1xuICAgICAgICAgIHdoaWxlIChpbmRleCA8IGVuZCkge1xuICAgICAgICAgICAgYmFzZTY0VkxRLmRlY29kZShhU3RyLCBpbmRleCwgdGVtcCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHRlbXAudmFsdWU7XG4gICAgICAgICAgICBpbmRleCA9IHRlbXAucmVzdDtcbiAgICAgICAgICAgIHNlZ21lbnQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlLCBidXQgbm8gbGluZSBhbmQgY29sdW1uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlIGFuZCBsaW5lLCBidXQgbm8gY29sdW1uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FjaGVkU2VnbWVudHNbc3RyXSA9IHNlZ21lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZWQgY29sdW1uLlxuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uICsgc2VnbWVudFswXTtcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgLy8gT3JpZ2luYWwgc291cmNlLlxuICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gcHJldmlvdXNTb3VyY2UgKyBzZWdtZW50WzFdO1xuICAgICAgICAgIHByZXZpb3VzU291cmNlICs9IHNlZ21lbnRbMV07XG5cbiAgICAgICAgICAvLyBPcmlnaW5hbCBsaW5lLlxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gcHJldmlvdXNPcmlnaW5hbExpbmUgKyBzZWdtZW50WzJdO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgICAgLy8gTGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgKz0gMTtcblxuICAgICAgICAgIC8vIE9yaWdpbmFsIGNvbHVtbi5cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gcHJldmlvdXNPcmlnaW5hbENvbHVtbiArIHNlZ21lbnRbM107XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBuYW1lLlxuICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gcHJldmlvdXNOYW1lICsgc2VnbWVudFs0XTtcbiAgICAgICAgICAgIHByZXZpb3VzTmFtZSArPSBzZWdtZW50WzRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdlbmVyYXRlZE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgIGlmICh0eXBlb2YgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgb3JpZ2luYWxNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KGdlbmVyYXRlZE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTtcbiAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBnZW5lcmF0ZWRNYXBwaW5ncztcblxuICAgIHF1aWNrU29ydChvcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG9yaWdpbmFsTWFwcGluZ3M7XG4gIH07XG5cbi8qKlxuICogRmluZCB0aGUgbWFwcGluZyB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgaHlwb3RoZXRpY2FsIFwibmVlZGxlXCIgbWFwcGluZyB0aGF0XG4gKiB3ZSBhcmUgc2VhcmNoaW5nIGZvciBpbiB0aGUgZ2l2ZW4gXCJoYXlzdGFja1wiIG9mIG1hcHBpbmdzLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9maW5kTWFwcGluZyhhTmVlZGxlLCBhTWFwcGluZ3MsIGFMaW5lTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbHVtbk5hbWUsIGFDb21wYXJhdG9yLCBhQmlhcykge1xuICAgIC8vIFRvIHJldHVybiB0aGUgcG9zaXRpb24gd2UgYXJlIHNlYXJjaGluZyBmb3IsIHdlIG11c3QgZmlyc3QgZmluZCB0aGVcbiAgICAvLyBtYXBwaW5nIGZvciB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHRoZW4gcmV0dXJuIHRoZSBvcHBvc2l0ZSBwb3NpdGlvbiBpdFxuICAgIC8vIHBvaW50cyB0by4gQmVjYXVzZSB0aGUgbWFwcGluZ3MgYXJlIHNvcnRlZCwgd2UgY2FuIHVzZSBiaW5hcnkgc2VhcmNoIHRvXG4gICAgLy8gZmluZCB0aGUgYmVzdCBtYXBwaW5nLlxuXG4gICAgaWYgKGFOZWVkbGVbYUxpbmVOYW1lXSA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdMaW5lIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthTGluZU5hbWVdKTtcbiAgICB9XG4gICAgaWYgKGFOZWVkbGVbYUNvbHVtbk5hbWVdIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29sdW1uIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthQ29sdW1uTmFtZV0pO1xuICAgIH1cblxuICAgIHJldHVybiBiaW5hcnlTZWFyY2guc2VhcmNoKGFOZWVkbGUsIGFNYXBwaW5ncywgYUNvbXBhcmF0b3IsIGFCaWFzKTtcbiAgfTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBsYXN0IGNvbHVtbiBmb3IgZWFjaCBnZW5lcmF0ZWQgbWFwcGluZy4gVGhlIGxhc3QgY29sdW1uIGlzXG4gKiBpbmNsdXNpdmUuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbXB1dGVDb2x1bW5TcGFucyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NvbXB1dGVDb2x1bW5TcGFucygpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgLy8gTWFwcGluZ3MgZG8gbm90IGNvbnRhaW4gYSBmaWVsZCBmb3IgdGhlIGxhc3QgZ2VuZXJhdGVkIGNvbHVtbnQuIFdlXG4gICAgICAvLyBjYW4gY29tZSB1cCB3aXRoIGFuIG9wdGltaXN0aWMgZXN0aW1hdGUsIGhvd2V2ZXIsIGJ5IGFzc3VtaW5nIHRoYXRcbiAgICAgIC8vIG1hcHBpbmdzIGFyZSBjb250aWd1b3VzIChpLmUuIGdpdmVuIHR3byBjb25zZWN1dGl2ZSBtYXBwaW5ncywgdGhlXG4gICAgICAvLyBmaXJzdCBtYXBwaW5nIGVuZHMgd2hlcmUgdGhlIHNlY29uZCBvbmUgc3RhcnRzKS5cbiAgICAgIGlmIChpbmRleCArIDEgPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5leHRNYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXggKyAxXTtcblxuICAgICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gbmV4dE1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC0gMTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgbGFzdCBtYXBwaW5nIGZvciBlYWNoIGxpbmUgc3BhbnMgdGhlIGVudGlyZSBsaW5lLlxuICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gSW5maW5pdHk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgbmVlZGxlLFxuICAgICAgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MsXG4gICAgICBcImdlbmVyYXRlZExpbmVcIixcbiAgICAgIFwiZ2VuZXJhdGVkQ29sdW1uXCIsXG4gICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkLFxuICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgKTtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuYXQoc291cmNlKTtcbiAgICAgICAgICBzb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwodGhpcy5zb3VyY2VSb290LCBzb3VyY2UsIHRoaXMuX3NvdXJjZU1hcFVSTCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbmFtZScsIG51bGwpO1xuICAgICAgICBpZiAobmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5hdChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbExpbmUnLCBudWxsKSxcbiAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbENvbHVtbicsIG51bGwpLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc291cmNlOiBudWxsLFxuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgIG5hbWU6IG51bGxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcl9oYXNDb250ZW50c09mQWxsU291cmNlcygpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnQubGVuZ3RoID49IHRoaXMuX3NvdXJjZXMuc2l6ZSgpICYmXG4gICAgICAhdGhpcy5zb3VyY2VzQ29udGVudC5zb21lKGZ1bmN0aW9uIChzYykgeyByZXR1cm4gc2MgPT0gbnVsbDsgfSk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gKiBhdmFpbGFibGUuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIG51bGxPbk1pc3NpbmcpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRTb3VyY2VJbmRleChhU291cmNlKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbaW5kZXhdO1xuICAgIH1cblxuICAgIHZhciByZWxhdGl2ZVNvdXJjZSA9IGFTb3VyY2U7XG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICByZWxhdGl2ZVNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCByZWxhdGl2ZVNvdXJjZSk7XG4gICAgfVxuXG4gICAgdmFyIHVybDtcbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGxcbiAgICAgICAgJiYgKHVybCA9IHV0aWwudXJsUGFyc2UodGhpcy5zb3VyY2VSb290KSkpIHtcbiAgICAgIC8vIFhYWDogZmlsZTovLyBVUklzIGFuZCBhYnNvbHV0ZSBwYXRocyBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IgZm9yXG4gICAgICAvLyBtYW55IHVzZXJzLiBXZSBjYW4gaGVscCB0aGVtIG91dCB3aGVuIHRoZXkgZXhwZWN0IGZpbGU6Ly8gVVJJcyB0b1xuICAgICAgLy8gYmVoYXZlIGxpa2UgaXQgd291bGQgaWYgdGhleSB3ZXJlIHJ1bm5pbmcgYSBsb2NhbCBIVFRQIHNlcnZlci4gU2VlXG4gICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04ODU1OTcuXG4gICAgICB2YXIgZmlsZVVyaUFic1BhdGggPSByZWxhdGl2ZVNvdXJjZS5yZXBsYWNlKC9eZmlsZTpcXC9cXC8vLCBcIlwiKTtcbiAgICAgIGlmICh1cmwuc2NoZW1lID09IFwiZmlsZVwiXG4gICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoZmlsZVVyaUFic1BhdGgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihmaWxlVXJpQWJzUGF0aCldXG4gICAgICB9XG5cbiAgICAgIGlmICgoIXVybC5wYXRoIHx8IHVybC5wYXRoID09IFwiL1wiKVxuICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKFwiL1wiICsgcmVsYXRpdmVTb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihcIi9cIiArIHJlbGF0aXZlU291cmNlKV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHJlY3Vyc2l2ZWx5IGZyb21cbiAgICAvLyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IuIEluIHRoYXQgY2FzZSwgd2VcbiAgICAvLyBkb24ndCB3YW50IHRvIHRocm93IGlmIHdlIGNhbid0IGZpbmQgdGhlIHNvdXJjZSAtIHdlIGp1c3Qgd2FudCB0b1xuICAgIC8vIHJldHVybiBudWxsLCBzbyB3ZSBwcm92aWRlIGEgZmxhZyB0byBleGl0IGdyYWNlZnVsbHkuXG4gICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgcmVsYXRpdmVTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlclxuICogICAgIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyk7XG4gICAgc291cmNlID0gdGhpcy5fZmluZFNvdXJjZUluZGV4KHNvdXJjZSk7XG4gICAgaWYgKHNvdXJjZSA8IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBvcmlnaW5hbExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICBuZWVkbGUsXG4gICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICApO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gbmVlZGxlLnNvdXJjZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgIH07XG4gIH07XG5cbmV4cG9ydHMuQmFzaWNTb3VyY2VNYXBDb25zdW1lciA9IEJhc2ljU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQW4gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaFxuICogd2UgY2FuIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbi4gSXQgZGlmZmVycyBmcm9tIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5cbiAqIHRoYXQgaXQgdGFrZXMgXCJpbmRleGVkXCIgc291cmNlIG1hcHMgKGkuZS4gb25lcyB3aXRoIGEgXCJzZWN0aW9uc1wiIGZpZWxkKSBhc1xuICogaW5wdXQuXG4gKlxuICogVGhlIGZpcnN0IHBhcmFtZXRlciBpcyBhIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3IgYWxyZWFkeVxuICogcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYyBmb3IgaW5kZXhlZCBzb3VyY2UgbWFwcywgdGhleVxuICogaGF2ZSB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKlxuICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICogICAtIHNlY3Rpb25zOiBBIGxpc3Qgb2Ygc2VjdGlvbiBkZWZpbml0aW9ucy5cbiAqXG4gKiBFYWNoIHZhbHVlIHVuZGVyIHRoZSBcInNlY3Rpb25zXCIgZmllbGQgaGFzIHR3byBmaWVsZHM6XG4gKiAgIC0gb2Zmc2V0OiBUaGUgb2Zmc2V0IGludG8gdGhlIG9yaWdpbmFsIHNwZWNpZmllZCBhdCB3aGljaCB0aGlzIHNlY3Rpb25cbiAqICAgICAgIGJlZ2lucyB0byBhcHBseSwgZGVmaW5lZCBhcyBhbiBvYmplY3Qgd2l0aCBhIFwibGluZVwiIGFuZCBcImNvbHVtblwiXG4gKiAgICAgICBmaWVsZC5cbiAqICAgLSBtYXA6IEEgc291cmNlIG1hcCBkZWZpbml0aW9uLiBUaGlzIHNvdXJjZSBtYXAgY291bGQgYWxzbyBiZSBpbmRleGVkLFxuICogICAgICAgYnV0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cbiAqXG4gKiBJbnN0ZWFkIG9mIHRoZSBcIm1hcFwiIGZpZWxkLCBpdCdzIGFsc28gcG9zc2libGUgdG8gaGF2ZSBhIFwidXJsXCIgZmllbGRcbiAqIHNwZWNpZnlpbmcgYSBVUkwgdG8gcmV0cmlldmUgYSBzb3VyY2UgbWFwIGZyb20sIGJ1dCB0aGF0J3MgY3VycmVudGx5XG4gKiB1bnN1cHBvcnRlZC5cbiAqXG4gKiBIZXJlJ3MgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF0sIGJ1dFxuICogbW9kaWZpZWQgdG8gb21pdCBhIHNlY3Rpb24gd2hpY2ggdXNlcyB0aGUgXCJ1cmxcIiBmaWVsZC5cbiAqXG4gKiAge1xuICogICAgdmVyc2lvbiA6IDMsXG4gKiAgICBmaWxlOiBcImFwcC5qc1wiLFxuICogICAgc2VjdGlvbnM6IFt7XG4gKiAgICAgIG9mZnNldDoge2xpbmU6MTAwLCBjb2x1bW46MTB9LFxuICogICAgICBtYXA6IHtcbiAqICAgICAgICB2ZXJzaW9uIDogMyxcbiAqICAgICAgICBmaWxlOiBcInNlY3Rpb24uanNcIixcbiAqICAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gKiAgICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gKiAgICAgICAgbWFwcGluZ3M6IFwiQUFBQSxFOztBQkNERTtcIlxuICogICAgICB9XG4gKiAgICB9XSxcbiAqICB9XG4gKlxuICogVGhlIHNlY29uZCBwYXJhbWV0ZXIsIGlmIGdpdmVuLCBpcyBhIHN0cmluZyB3aG9zZSB2YWx1ZSBpcyB0aGUgVVJMXG4gKiBhdCB3aGljaCB0aGUgc291cmNlIG1hcCB3YXMgZm91bmQuICBUaGlzIFVSTCBpcyB1c2VkIHRvIGNvbXB1dGUgdGhlXG4gKiBzb3VyY2VzIGFycmF5LlxuICpcbiAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0I2hlYWRpbmc9aC41MzVlczN4ZXByZ3RcbiAqL1xuZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSB1dGlsLnBhcnNlU291cmNlTWFwSW5wdXQoYVNvdXJjZU1hcCk7XG4gIH1cblxuICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgdmFyIHNlY3Rpb25zID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc2VjdGlvbnMnKTtcblxuICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgdmFyIGxhc3RPZmZzZXQgPSB7XG4gICAgbGluZTogLTEsXG4gICAgY29sdW1uOiAwXG4gIH07XG4gIHRoaXMuX3NlY3Rpb25zID0gc2VjdGlvbnMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgaWYgKHMudXJsKSB7XG4gICAgICAvLyBUaGUgdXJsIGZpZWxkIHdpbGwgcmVxdWlyZSBzdXBwb3J0IGZvciBhc3luY2hyb25pY2l0eS5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8xNlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwb3J0IGZvciB1cmwgZmllbGQgaW4gc2VjdGlvbnMgbm90IGltcGxlbWVudGVkLicpO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0ID0gdXRpbC5nZXRBcmcocywgJ29mZnNldCcpO1xuICAgIHZhciBvZmZzZXRMaW5lID0gdXRpbC5nZXRBcmcob2Zmc2V0LCAnbGluZScpO1xuICAgIHZhciBvZmZzZXRDb2x1bW4gPSB1dGlsLmdldEFyZyhvZmZzZXQsICdjb2x1bW4nKTtcblxuICAgIGlmIChvZmZzZXRMaW5lIDwgbGFzdE9mZnNldC5saW5lIHx8XG4gICAgICAgIChvZmZzZXRMaW5lID09PSBsYXN0T2Zmc2V0LmxpbmUgJiYgb2Zmc2V0Q29sdW1uIDwgbGFzdE9mZnNldC5jb2x1bW4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3Rpb24gb2Zmc2V0cyBtdXN0IGJlIG9yZGVyZWQgYW5kIG5vbi1vdmVybGFwcGluZy4nKTtcbiAgICB9XG4gICAgbGFzdE9mZnNldCA9IG9mZnNldDtcblxuICAgIHJldHVybiB7XG4gICAgICBnZW5lcmF0ZWRPZmZzZXQ6IHtcbiAgICAgICAgLy8gVGhlIG9mZnNldCBmaWVsZHMgYXJlIDAtYmFzZWQsIGJ1dCB3ZSB1c2UgMS1iYXNlZCBpbmRpY2VzIHdoZW5cbiAgICAgICAgLy8gZW5jb2RpbmcvZGVjb2RpbmcgZnJvbSBWTFEuXG4gICAgICAgIGdlbmVyYXRlZExpbmU6IG9mZnNldExpbmUgKyAxLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG9mZnNldENvbHVtbiArIDFcbiAgICAgIH0sXG4gICAgICBjb25zdW1lcjogbmV3IFNvdXJjZU1hcENvbnN1bWVyKHV0aWwuZ2V0QXJnKHMsICdtYXAnKSwgYVNvdXJjZU1hcFVSTClcbiAgICB9XG4gIH0pO1xufVxuXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBzb3VyY2VzLnB1c2godGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlc1tqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VzO1xuICB9XG59KTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlclxuICogICAgIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS4gIFRoZSBjb2x1bW5cbiAqICAgICBudW1iZXIgaXMgMC1iYXNlZC5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICAvLyBGaW5kIHRoZSBzZWN0aW9uIGNvbnRhaW5pbmcgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbiB3ZSdyZSB0cnlpbmcgdG8gbWFwXG4gICAgLy8gdG8gYW4gb3JpZ2luYWwgcG9zaXRpb24uXG4gICAgdmFyIHNlY3Rpb25JbmRleCA9IGJpbmFyeVNlYXJjaC5zZWFyY2gobmVlZGxlLCB0aGlzLl9zZWN0aW9ucyxcbiAgICAgIGZ1bmN0aW9uKG5lZWRsZSwgc2VjdGlvbikge1xuICAgICAgICB2YXIgY21wID0gbmVlZGxlLmdlbmVyYXRlZExpbmUgLSBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lO1xuICAgICAgICBpZiAoY21wKSB7XG4gICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgIH0pO1xuICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbc2VjdGlvbkluZGV4XTtcblxuICAgIGlmICghc2VjdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIG5hbWU6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3Rpb24uY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICBsaW5lOiBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtXG4gICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICBjb2x1bW46IG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmVcbiAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgOiAwKSxcbiAgICAgIGJpYXM6IGFBcmdzLmJpYXNcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWN0aW9ucy5ldmVyeShmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHMuY29uc3VtZXIuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKTtcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAqIGF2YWlsYWJsZS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIHZhciBjb250ZW50ID0gc2VjdGlvbi5jb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIHRydWUpO1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlclxuICogICAgIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuIFxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgICAgVGhlIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIC8vIE9ubHkgY29uc2lkZXIgdGhpcyBzZWN0aW9uIGlmIHRoZSByZXF1ZXN0ZWQgc291cmNlIGlzIGluIHRoZSBsaXN0IG9mXG4gICAgICAvLyBzb3VyY2VzIG9mIHRoZSBjb25zdW1lci5cbiAgICAgIGlmIChzZWN0aW9uLmNvbnN1bWVyLl9maW5kU291cmNlSW5kZXgodXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSkgPT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGdlbmVyYXRlZFBvc2l0aW9uID0gc2VjdGlvbi5jb25zdW1lci5nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncyk7XG4gICAgICBpZiAoZ2VuZXJhdGVkUG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWRQb3NpdGlvbi5jb2x1bW4gK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmVcbiAgICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgICA6IDApXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuICAgICAgdmFyIHNlY3Rpb25NYXBwaW5ncyA9IHNlY3Rpb24uY29uc3VtZXIuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWN0aW9uTWFwcGluZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSBzZWN0aW9uTWFwcGluZ3Nbal07XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IHNlY3Rpb24uY29uc3VtZXIuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBzb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290LCBzb3VyY2UsIHRoaXMuX3NvdXJjZU1hcFVSTCk7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuXG4gICAgICAgIHZhciBuYW1lID0gbnVsbDtcbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSkge1xuICAgICAgICAgIG5hbWUgPSBzZWN0aW9uLmNvbnN1bWVyLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBtYXBwaW5ncyBjb21pbmcgZnJvbSB0aGUgY29uc3VtZXIgZm9yIHRoZSBzZWN0aW9uIGhhdmVcbiAgICAgICAgLy8gZ2VuZXJhdGVkIHBvc2l0aW9ucyByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIHNlY3Rpb24sIHNvIHdlXG4gICAgICAgIC8vIG5lZWQgdG8gb2Zmc2V0IHRoZW0gdG8gYmUgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb25jYXRlbmF0ZWRcbiAgICAgICAgLy8gZ2VuZXJhdGVkIGZpbGUuXG4gICAgICAgIHZhciBhZGp1c3RlZE1hcHBpbmcgPSB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbWFwcGluZy5nZW5lcmF0ZWRMaW5lXG4gICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgIDogMCksXG4gICAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhZGp1c3RlZE1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHF1aWNrU29ydCh0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgIHF1aWNrU29ydCh0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gIH07XG5cbmV4cG9ydHMuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyID0gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgYmFzZTY0VkxRID0gcmVxdWlyZSgnLi9iYXNlNjQtdmxxJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbnZhciBNYXBwaW5nTGlzdCA9IHJlcXVpcmUoJy4vbWFwcGluZy1saXN0JykuTWFwcGluZ0xpc3Q7XG5cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhlIFNvdXJjZU1hcEdlbmVyYXRvciByZXByZXNlbnRzIGEgc291cmNlIG1hcCB3aGljaCBpc1xuICogYmVpbmcgYnVpbHQgaW5jcmVtZW50YWxseS4gWW91IG1heSBwYXNzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGZpbGU6IFRoZSBmaWxlbmFtZSBvZiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqICAgLSBzb3VyY2VSb290OiBBIHJvb3QgZm9yIGFsbCByZWxhdGl2ZSBVUkxzIGluIHRoaXMgc291cmNlIG1hcC5cbiAqL1xuZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKSB7XG4gIGlmICghYUFyZ3MpIHtcbiAgICBhQXJncyA9IHt9O1xuICB9XG4gIHRoaXMuX2ZpbGUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2ZpbGUnLCBudWxsKTtcbiAgdGhpcy5fc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICB0aGlzLl9za2lwVmFsaWRhdGlvbiA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc2tpcFZhbGlkYXRpb24nLCBmYWxzZSk7XG4gIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbWFwcGluZ3MgPSBuZXcgTWFwcGluZ0xpc3QoKTtcbiAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbn1cblxuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IgYmFzZWQgb24gYSBTb3VyY2VNYXBDb25zdW1lclxuICpcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLmZyb21Tb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIpIHtcbiAgICB2YXIgc291cmNlUm9vdCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VSb290O1xuICAgIHZhciBnZW5lcmF0b3IgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKHtcbiAgICAgIGZpbGU6IGFTb3VyY2VNYXBDb25zdW1lci5maWxlLFxuICAgICAgc291cmNlUm9vdDogc291cmNlUm9vdFxuICAgIH0pO1xuICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgdmFyIG5ld01hcHBpbmcgPSB7XG4gICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbmV3TWFwcGluZy5zb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3TWFwcGluZy5vcmlnaW5hbCA9IHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLm5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZ2VuZXJhdG9yLmFkZE1hcHBpbmcobmV3TWFwcGluZyk7XG4gICAgfSk7XG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIHNvdXJjZVJlbGF0aXZlID0gc291cmNlRmlsZTtcbiAgICAgIGlmIChzb3VyY2VSb290ICE9PSBudWxsKSB7XG4gICAgICAgIHNvdXJjZVJlbGF0aXZlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFnZW5lcmF0b3IuX3NvdXJjZXMuaGFzKHNvdXJjZVJlbGF0aXZlKSkge1xuICAgICAgICBnZW5lcmF0b3IuX3NvdXJjZXMuYWRkKHNvdXJjZVJlbGF0aXZlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgZ2VuZXJhdG9yLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfTtcblxuLyoqXG4gKiBBZGQgYSBzaW5nbGUgbWFwcGluZyBmcm9tIG9yaWdpbmFsIHNvdXJjZSBsaW5lIGFuZCBjb2x1bW4gdG8gdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIGZvciB0aGlzIHNvdXJjZSBtYXAgYmVpbmcgY3JlYXRlZC4gVGhlIG1hcHBpbmdcbiAqIG9iamVjdCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGdlbmVyYXRlZDogQW4gb2JqZWN0IHdpdGggdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zLlxuICogICAtIG9yaWdpbmFsOiBBbiBvYmplY3Qgd2l0aCB0aGUgb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSAocmVsYXRpdmUgdG8gdGhlIHNvdXJjZVJvb3QpLlxuICogICAtIG5hbWU6IEFuIG9wdGlvbmFsIG9yaWdpbmFsIHRva2VuIG5hbWUgZm9yIHRoaXMgbWFwcGluZy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hZGRNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FkZE1hcHBpbmcoYUFyZ3MpIHtcbiAgICB2YXIgZ2VuZXJhdGVkID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdnZW5lcmF0ZWQnKTtcbiAgICB2YXIgb3JpZ2luYWwgPSB1dGlsLmdldEFyZyhhQXJncywgJ29yaWdpbmFsJywgbnVsbCk7XG4gICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJywgbnVsbCk7XG4gICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhhQXJncywgJ25hbWUnLCBudWxsKTtcblxuICAgIGlmICghdGhpcy5fc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlTWFwcGluZyhnZW5lcmF0ZWQsIG9yaWdpbmFsLCBzb3VyY2UsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgc291cmNlID0gU3RyaW5nKHNvdXJjZSk7XG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgICAgaWYgKCF0aGlzLl9uYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX21hcHBpbmdzLmFkZCh7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogZ2VuZXJhdGVkLmNvbHVtbixcbiAgICAgIG9yaWdpbmFsTGluZTogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5saW5lLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwuY29sdW1uLFxuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBuYW1lOiBuYW1lXG4gICAgfSk7XG4gIH07XG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgdmFyIHNvdXJjZSA9IGFTb3VyY2VGaWxlO1xuICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5fc291cmNlUm9vdCwgc291cmNlKTtcbiAgICB9XG5cbiAgICBpZiAoYVNvdXJjZUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgY29udGVudCB0byB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgX3NvdXJjZXNDb250ZW50cyBtYXAgaWYgdGhlIHByb3BlcnR5IGlzIG51bGwuXG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV0gPSBhU291cmNlQ29udGVudDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBzb3VyY2UgZmlsZSBmcm9tIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgIC8vIElmIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcCBpcyBlbXB0eSwgc2V0IHRoZSBwcm9wZXJ0eSB0byBudWxsLlxuICAgICAgZGVsZXRlIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX3NvdXJjZXNDb250ZW50cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIG1hcHBpbmdzIG9mIGEgc3ViLXNvdXJjZS1tYXAgZm9yIGEgc3BlY2lmaWMgc291cmNlIGZpbGUgdG8gdGhlXG4gKiBzb3VyY2UgbWFwIGJlaW5nIGdlbmVyYXRlZC4gRWFjaCBtYXBwaW5nIHRvIHRoZSBzdXBwbGllZCBzb3VyY2UgZmlsZSBpc1xuICogcmV3cml0dGVuIHVzaW5nIHRoZSBzdXBwbGllZCBzb3VyY2UgbWFwLiBOb3RlOiBUaGUgcmVzb2x1dGlvbiBmb3IgdGhlXG4gKiByZXN1bHRpbmcgbWFwcGluZ3MgaXMgdGhlIG1pbmltaXVtIG9mIHRoaXMgbWFwIGFuZCB0aGUgc3VwcGxpZWQgbWFwLlxuICpcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZC5cbiAqIEBwYXJhbSBhU291cmNlRmlsZSBPcHRpb25hbC4gVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZS5cbiAqICAgICAgICBJZiBvbWl0dGVkLCBTb3VyY2VNYXBDb25zdW1lcidzIGZpbGUgcHJvcGVydHkgd2lsbCBiZSB1c2VkLlxuICogQHBhcmFtIGFTb3VyY2VNYXBQYXRoIE9wdGlvbmFsLiBUaGUgZGlybmFtZSBvZiB0aGUgcGF0aCB0byB0aGUgc291cmNlIG1hcFxuICogICAgICAgIHRvIGJlIGFwcGxpZWQuIElmIHJlbGF0aXZlLCBpdCBpcyByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwQ29uc3VtZXIuXG4gKiAgICAgICAgVGhpcyBwYXJhbWV0ZXIgaXMgbmVlZGVkIHdoZW4gdGhlIHR3byBzb3VyY2UgbWFwcyBhcmVuJ3QgaW4gdGhlIHNhbWVcbiAqICAgICAgICBkaXJlY3RvcnksIGFuZCB0aGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkIGNvbnRhaW5zIHJlbGF0aXZlIHNvdXJjZVxuICogICAgICAgIHBhdGhzLiBJZiBzbywgdGhvc2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIG5lZWQgdG8gYmUgcmV3cml0dGVuXG4gKiAgICAgICAgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hcHBseVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIsIGFTb3VyY2VGaWxlLCBhU291cmNlTWFwUGF0aCkge1xuICAgIHZhciBzb3VyY2VGaWxlID0gYVNvdXJjZUZpbGU7XG4gICAgLy8gSWYgYVNvdXJjZUZpbGUgaXMgb21pdHRlZCwgd2Ugd2lsbCB1c2UgdGhlIGZpbGUgcHJvcGVydHkgb2YgdGhlIFNvdXJjZU1hcFxuICAgIGlmIChhU291cmNlRmlsZSA9PSBudWxsKSB7XG4gICAgICBpZiAoYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1NvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgcmVxdWlyZXMgZWl0aGVyIGFuIGV4cGxpY2l0IHNvdXJjZSBmaWxlLCAnICtcbiAgICAgICAgICAnb3IgdGhlIHNvdXJjZSBtYXBcXCdzIFwiZmlsZVwiIHByb3BlcnR5LiBCb3RoIHdlcmUgb21pdHRlZC4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBzb3VyY2VGaWxlID0gYVNvdXJjZU1hcENvbnN1bWVyLmZpbGU7XG4gICAgfVxuICAgIHZhciBzb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICAvLyBNYWtlIFwic291cmNlRmlsZVwiIHJlbGF0aXZlIGlmIGFuIGFic29sdXRlIFVybCBpcyBwYXNzZWQuXG4gICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgfVxuICAgIC8vIEFwcGx5aW5nIHRoZSBTb3VyY2VNYXAgY2FuIGFkZCBhbmQgcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIHNvdXJjZXMgYW5kXG4gICAgLy8gdGhlIG5hbWVzIGFycmF5LlxuICAgIHZhciBuZXdTb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgdmFyIG5ld05hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgICAvLyBGaW5kIG1hcHBpbmdzIGZvciB0aGUgXCJzb3VyY2VGaWxlXCJcbiAgICB0aGlzLl9tYXBwaW5ncy51bnNvcnRlZEZvckVhY2goZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gc291cmNlRmlsZSAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGl0IGNhbiBiZSBtYXBwZWQgYnkgdGhlIHNvdXJjZSBtYXAsIHRoZW4gdXBkYXRlIHRoZSBtYXBwaW5nLlxuICAgICAgICB2YXIgb3JpZ2luYWwgPSBhU291cmNlTWFwQ29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3JpZ2luYWwuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDb3B5IG1hcHBpbmdcbiAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgICAgICBpZiAob3JpZ2luYWwubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgIW5ld1NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgbmV3U291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICBpZiAobmFtZSAhPSBudWxsICYmICFuZXdOYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgbmV3TmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuXG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5fc291cmNlcyA9IG5ld1NvdXJjZXM7XG4gICAgdGhpcy5fbmFtZXMgPSBuZXdOYW1lcztcblxuICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnRzIG9mIGFwcGxpZWQgbWFwLlxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuLyoqXG4gKiBBIG1hcHBpbmcgY2FuIGhhdmUgb25lIG9mIHRoZSB0aHJlZSBsZXZlbHMgb2YgZGF0YTpcbiAqXG4gKiAgIDEuIEp1c3QgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAqICAgMi4gVGhlIEdlbmVyYXRlZCBwb3NpdGlvbiwgb3JpZ2luYWwgcG9zaXRpb24sIGFuZCBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIDMuIEdlbmVyYXRlZCBhbmQgb3JpZ2luYWwgcG9zaXRpb24sIG9yaWdpbmFsIHNvdXJjZSwgYXMgd2VsbCBhcyBhIG5hbWVcbiAqICAgICAgdG9rZW4uXG4gKlxuICogVG8gbWFpbnRhaW4gY29uc2lzdGVuY3ksIHdlIHZhbGlkYXRlIHRoYXQgYW55IG5ldyBtYXBwaW5nIGJlaW5nIGFkZGVkIGZhbGxzXG4gKiBpbiB0byBvbmUgb2YgdGhlc2UgY2F0ZWdvcmllcy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3ZhbGlkYXRlTWFwcGluZyhhR2VuZXJhdGVkLCBhT3JpZ2luYWwsIGFTb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYU5hbWUpIHtcbiAgICAvLyBXaGVuIGFPcmlnaW5hbCBpcyB0cnV0aHkgYnV0IGhhcyBlbXB0eSB2YWx1ZXMgZm9yIC5saW5lIGFuZCAuY29sdW1uLFxuICAgIC8vIGl0IGlzIG1vc3QgbGlrZWx5IGEgcHJvZ3JhbW1lciBlcnJvci4gSW4gdGhpcyBjYXNlIHdlIHRocm93IGEgdmVyeVxuICAgIC8vIHNwZWNpZmljIGVycm9yIG1lc3NhZ2UgdG8gdHJ5IHRvIGd1aWRlIHRoZW0gdGhlIHJpZ2h0IHdheS5cbiAgICAvLyBGb3IgZXhhbXBsZTogaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvcG9seW1lci1idW5kbGVyL3B1bGwvNTE5XG4gICAgaWYgKGFPcmlnaW5hbCAmJiB0eXBlb2YgYU9yaWdpbmFsLmxpbmUgIT09ICdudW1iZXInICYmIHR5cGVvZiBhT3JpZ2luYWwuY29sdW1uICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnb3JpZ2luYWwubGluZSBhbmQgb3JpZ2luYWwuY29sdW1uIGFyZSBub3QgbnVtYmVycyAtLSB5b3UgcHJvYmFibHkgbWVhbnQgdG8gb21pdCAnICtcbiAgICAgICAgICAgICd0aGUgb3JpZ2luYWwgbWFwcGluZyBlbnRpcmVseSBhbmQgb25seSBtYXAgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbi4gSWYgc28sIHBhc3MgJyArXG4gICAgICAgICAgICAnbnVsbCBmb3IgdGhlIG9yaWdpbmFsIG1hcHBpbmcgaW5zdGVhZCBvZiBhbiBvYmplY3Qgd2l0aCBlbXB0eSBvciBudWxsIHZhbHVlcy4nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgJiYgIWFPcmlnaW5hbCAmJiAhYVNvdXJjZSAmJiAhYU5hbWUpIHtcbiAgICAgIC8vIENhc2UgMS5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICAgICAgJiYgYU9yaWdpbmFsICYmICdsaW5lJyBpbiBhT3JpZ2luYWwgJiYgJ2NvbHVtbicgaW4gYU9yaWdpbmFsXG4gICAgICAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgJiYgYU9yaWdpbmFsLmxpbmUgPiAwICYmIGFPcmlnaW5hbC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICYmIGFTb3VyY2UpIHtcbiAgICAgIC8vIENhc2VzIDIgYW5kIDMuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1hcHBpbmc6ICcgKyBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGdlbmVyYXRlZDogYUdlbmVyYXRlZCxcbiAgICAgICAgc291cmNlOiBhU291cmNlLFxuICAgICAgICBvcmlnaW5hbDogYU9yaWdpbmFsLFxuICAgICAgICBuYW1lOiBhTmFtZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIHRvIHRoZSBzdHJlYW0gb2YgYmFzZSA2NCBWTFFzXG4gKiBzcGVjaWZpZWQgYnkgdGhlIHNvdXJjZSBtYXAgZm9ybWF0LlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9zZXJpYWxpemVNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXJpYWxpemVNYXBwaW5ncygpIHtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZExpbmUgPSAxO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBuZXh0O1xuICAgIHZhciBtYXBwaW5nO1xuICAgIHZhciBuYW1lSWR4O1xuICAgIHZhciBzb3VyY2VJZHg7XG5cbiAgICB2YXIgbWFwcGluZ3MgPSB0aGlzLl9tYXBwaW5ncy50b0FycmF5KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBtYXBwaW5nID0gbWFwcGluZ3NbaV07XG4gICAgICBuZXh0ID0gJydcblxuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgd2hpbGUgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgbmV4dCArPSAnOyc7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBpZiAoIXV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZywgbWFwcGluZ3NbaSAtIDFdKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHQgKz0gJywnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbik7XG4gICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2VJZHggPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUoc291cmNlSWR4IC0gcHJldmlvdXNTb3VyY2UpO1xuICAgICAgICBwcmV2aW91c1NvdXJjZSA9IHNvdXJjZUlkeDtcblxuICAgICAgICAvLyBsaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWQgaW4gU291cmNlTWFwIHNwZWMgdmVyc2lvbiAzXG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c09yaWdpbmFsTGluZSk7XG4gICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmUgLSAxO1xuXG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbENvbHVtbik7XG4gICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgIG5hbWVJZHggPSB0aGlzLl9uYW1lcy5pbmRleE9mKG1hcHBpbmcubmFtZSk7XG4gICAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG5hbWVJZHggLSBwcmV2aW91c05hbWUpO1xuICAgICAgICAgIHByZXZpb3VzTmFtZSA9IG5hbWVJZHg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9IG5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KGFTb3VyY2VzLCBhU291cmNlUm9vdCkge1xuICAgIHJldHVybiBhU291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoYVNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKGFTb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHV0aWwudG9TZXRTdHJpbmcoc291cmNlKTtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fc291cmNlc0NvbnRlbnRzLCBrZXkpXG4gICAgICAgID8gdGhpcy5fc291cmNlc0NvbnRlbnRzW2tleV1cbiAgICAgICAgOiBudWxsO1xuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4vKipcbiAqIEV4dGVybmFsaXplIHRoZSBzb3VyY2UgbWFwLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvSlNPTiA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b0pTT04oKSB7XG4gICAgdmFyIG1hcCA9IHtcbiAgICAgIHZlcnNpb246IHRoaXMuX3ZlcnNpb24sXG4gICAgICBzb3VyY2VzOiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgIG5hbWVzOiB0aGlzLl9uYW1lcy50b0FycmF5KCksXG4gICAgICBtYXBwaW5nczogdGhpcy5fc2VyaWFsaXplTWFwcGluZ3MoKVxuICAgIH07XG4gICAgaWYgKHRoaXMuX2ZpbGUgIT0gbnVsbCkge1xuICAgICAgbWFwLmZpbGUgPSB0aGlzLl9maWxlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBtYXAuc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgIG1hcC5zb3VyY2VzQ29udGVudCA9IHRoaXMuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQobWFwLnNvdXJjZXMsIG1hcC5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xuICB9O1xuXG4vKipcbiAqIFJlbmRlciB0aGUgc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQgdG8gYSBzdHJpbmcuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCkpO1xuICB9O1xuXG5leHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IFNvdXJjZU1hcEdlbmVyYXRvcjtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIFNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vLyBNYXRjaGVzIGEgV2luZG93cy1zdHlsZSBgXFxyXFxuYCBuZXdsaW5lIG9yIGEgYFxcbmAgbmV3bGluZSB1c2VkIGJ5IGFsbCBvdGhlclxuLy8gb3BlcmF0aW5nIHN5c3RlbXMgdGhlc2UgZGF5cyAoY2FwdHVyaW5nIHRoZSByZXN1bHQpLlxudmFyIFJFR0VYX05FV0xJTkUgPSAvKFxccj9cXG4pLztcblxuLy8gTmV3bGluZSBjaGFyYWN0ZXIgY29kZSBmb3IgY2hhckNvZGVBdCgpIGNvbXBhcmlzb25zXG52YXIgTkVXTElORV9DT0RFID0gMTA7XG5cbi8vIFByaXZhdGUgc3ltYm9sIGZvciBpZGVudGlmeWluZyBgU291cmNlTm9kZWBzIHdoZW4gbXVsdGlwbGUgdmVyc2lvbnMgb2Zcbi8vIHRoZSBzb3VyY2UtbWFwIGxpYnJhcnkgYXJlIGxvYWRlZC4gVGhpcyBNVVNUIE5PVCBDSEFOR0UgYWNyb3NzXG4vLyB2ZXJzaW9ucyFcbnZhciBpc1NvdXJjZU5vZGUgPSBcIiQkJGlzU291cmNlTm9kZSQkJFwiO1xuXG4vKipcbiAqIFNvdXJjZU5vZGVzIHByb3ZpZGUgYSB3YXkgdG8gYWJzdHJhY3Qgb3ZlciBpbnRlcnBvbGF0aW5nL2NvbmNhdGVuYXRpbmdcbiAqIHNuaXBwZXRzIG9mIGdlbmVyYXRlZCBKYXZhU2NyaXB0IHNvdXJjZSBjb2RlIHdoaWxlIG1haW50YWluaW5nIHRoZSBsaW5lIGFuZFxuICogY29sdW1uIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgc291cmNlIGNvZGUuXG4gKlxuICogQHBhcmFtIGFMaW5lIFRoZSBvcmlnaW5hbCBsaW5lIG51bWJlci5cbiAqIEBwYXJhbSBhQ29sdW1uIFRoZSBvcmlnaW5hbCBjb2x1bW4gbnVtYmVyLlxuICogQHBhcmFtIGFTb3VyY2UgVGhlIG9yaWdpbmFsIHNvdXJjZSdzIGZpbGVuYW1lLlxuICogQHBhcmFtIGFDaHVua3MgT3B0aW9uYWwuIEFuIGFycmF5IG9mIHN0cmluZ3Mgd2hpY2ggYXJlIHNuaXBwZXRzIG9mXG4gKiAgICAgICAgZ2VuZXJhdGVkIEpTLCBvciBvdGhlciBTb3VyY2VOb2Rlcy5cbiAqIEBwYXJhbSBhTmFtZSBUaGUgb3JpZ2luYWwgaWRlbnRpZmllci5cbiAqL1xuZnVuY3Rpb24gU291cmNlTm9kZShhTGluZSwgYUNvbHVtbiwgYVNvdXJjZSwgYUNodW5rcywgYU5hbWUpIHtcbiAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICB0aGlzLnNvdXJjZUNvbnRlbnRzID0ge307XG4gIHRoaXMubGluZSA9IGFMaW5lID09IG51bGwgPyBudWxsIDogYUxpbmU7XG4gIHRoaXMuY29sdW1uID0gYUNvbHVtbiA9PSBudWxsID8gbnVsbCA6IGFDb2x1bW47XG4gIHRoaXMuc291cmNlID0gYVNvdXJjZSA9PSBudWxsID8gbnVsbCA6IGFTb3VyY2U7XG4gIHRoaXMubmFtZSA9IGFOYW1lID09IG51bGwgPyBudWxsIDogYU5hbWU7XG4gIHRoaXNbaXNTb3VyY2VOb2RlXSA9IHRydWU7XG4gIGlmIChhQ2h1bmtzICE9IG51bGwpIHRoaXMuYWRkKGFDaHVua3MpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBTb3VyY2VOb2RlIGZyb20gZ2VuZXJhdGVkIGNvZGUgYW5kIGEgU291cmNlTWFwQ29uc3VtZXIuXG4gKlxuICogQHBhcmFtIGFHZW5lcmF0ZWRDb2RlIFRoZSBnZW5lcmF0ZWQgY29kZVxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwIGZvciB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAqIEBwYXJhbSBhUmVsYXRpdmVQYXRoIE9wdGlvbmFsLiBUaGUgcGF0aCB0aGF0IHJlbGF0aXZlIHNvdXJjZXMgaW4gdGhlXG4gKiAgICAgICAgU291cmNlTWFwQ29uc3VtZXIgc2hvdWxkIGJlIHJlbGF0aXZlIHRvLlxuICovXG5Tb3VyY2VOb2RlLmZyb21TdHJpbmdXaXRoU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV9mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcChhR2VuZXJhdGVkQ29kZSwgYVNvdXJjZU1hcENvbnN1bWVyLCBhUmVsYXRpdmVQYXRoKSB7XG4gICAgLy8gVGhlIFNvdXJjZU5vZGUgd2Ugd2FudCB0byBmaWxsIHdpdGggdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgLy8gYW5kIHRoZSBTb3VyY2VNYXBcbiAgICB2YXIgbm9kZSA9IG5ldyBTb3VyY2VOb2RlKCk7XG5cbiAgICAvLyBBbGwgZXZlbiBpbmRpY2VzIG9mIHRoaXMgYXJyYXkgYXJlIG9uZSBsaW5lIG9mIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgICAvLyB3aGlsZSBhbGwgb2RkIGluZGljZXMgYXJlIHRoZSBuZXdsaW5lcyBiZXR3ZWVuIHR3byBhZGphY2VudCBsaW5lc1xuICAgIC8vIChzaW5jZSBgUkVHRVhfTkVXTElORWAgY2FwdHVyZXMgaXRzIG1hdGNoKS5cbiAgICAvLyBQcm9jZXNzZWQgZnJhZ21lbnRzIGFyZSBhY2Nlc3NlZCBieSBjYWxsaW5nIGBzaGlmdE5leHRMaW5lYC5cbiAgICB2YXIgcmVtYWluaW5nTGluZXMgPSBhR2VuZXJhdGVkQ29kZS5zcGxpdChSRUdFWF9ORVdMSU5FKTtcbiAgICB2YXIgcmVtYWluaW5nTGluZXNJbmRleCA9IDA7XG4gICAgdmFyIHNoaWZ0TmV4dExpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsaW5lQ29udGVudHMgPSBnZXROZXh0TGluZSgpO1xuICAgICAgLy8gVGhlIGxhc3QgbGluZSBvZiBhIGZpbGUgbWlnaHQgbm90IGhhdmUgYSBuZXdsaW5lLlxuICAgICAgdmFyIG5ld0xpbmUgPSBnZXROZXh0TGluZSgpIHx8IFwiXCI7XG4gICAgICByZXR1cm4gbGluZUNvbnRlbnRzICsgbmV3TGluZTtcblxuICAgICAgZnVuY3Rpb24gZ2V0TmV4dExpbmUoKSB7XG4gICAgICAgIHJldHVybiByZW1haW5pbmdMaW5lc0luZGV4IDwgcmVtYWluaW5nTGluZXMubGVuZ3RoID9cbiAgICAgICAgICAgIHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXgrK10gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIHBvc2l0aW9uIG9mIFwicmVtYWluaW5nTGluZXNcIlxuICAgIHZhciBsYXN0R2VuZXJhdGVkTGluZSA9IDEsIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuXG4gICAgLy8gVGhlIGdlbmVyYXRlIFNvdXJjZU5vZGVzIHdlIG5lZWQgYSBjb2RlIHJhbmdlLlxuICAgIC8vIFRvIGV4dHJhY3QgaXQgY3VycmVudCBhbmQgbGFzdCBtYXBwaW5nIGlzIHVzZWQuXG4gICAgLy8gSGVyZSB3ZSBzdG9yZSB0aGUgbGFzdCBtYXBwaW5nLlxuICAgIHZhciBsYXN0TWFwcGluZyA9IG51bGw7XG5cbiAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIGlmIChsYXN0TWFwcGluZyAhPT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBhZGQgdGhlIGNvZGUgZnJvbSBcImxhc3RNYXBwaW5nXCIgdG8gXCJtYXBwaW5nXCI6XG4gICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZXJlIGlzIGEgbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgLy8gQXNzb2NpYXRlIGZpcnN0IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgICAvLyBUaGUgcmVtYWluaW5nIGNvZGUgaXMgYWRkZWQgd2l0aG91dCBtYXBwaW5nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgICAvLyBBc3NvY2lhdGUgdGhlIGNvZGUgYmV0d2VlbiBcImxhc3RHZW5lcmF0ZWRDb2x1bW5cIiBhbmRcbiAgICAgICAgICAvLyBcIm1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXCIgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XSB8fCAnJztcbiAgICAgICAgICB2YXIgY29kZSA9IG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIGNvZGUpO1xuICAgICAgICAgIC8vIE5vIG1vcmUgcmVtYWluaW5nIGNvZGUsIGNvbnRpbnVlXG4gICAgICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gV2UgYWRkIHRoZSBnZW5lcmF0ZWQgY29kZSB1bnRpbCB0aGUgZmlyc3QgbWFwcGluZ1xuICAgICAgLy8gdG8gdGhlIFNvdXJjZU5vZGUgd2l0aG91dCBhbnkgbWFwcGluZy5cbiAgICAgIC8vIEVhY2ggbGluZSBpcyBhZGRlZCBhcyBzZXBhcmF0ZSBzdHJpbmcuXG4gICAgICB3aGlsZSAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgbm9kZS5hZGQoc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0R2VuZXJhdGVkQ29sdW1uIDwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pIHtcbiAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF0gfHwgJyc7XG4gICAgICAgIG5vZGUuYWRkKG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikpO1xuICAgICAgICByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgIH1cbiAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICB9LCB0aGlzKTtcbiAgICAvLyBXZSBoYXZlIHByb2Nlc3NlZCBhbGwgbWFwcGluZ3MuXG4gICAgaWYgKHJlbWFpbmluZ0xpbmVzSW5kZXggPCByZW1haW5pbmdMaW5lcy5sZW5ndGgpIHtcbiAgICAgIGlmIChsYXN0TWFwcGluZykge1xuICAgICAgICAvLyBBc3NvY2lhdGUgdGhlIHJlbWFpbmluZyBjb2RlIGluIHRoZSBjdXJyZW50IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgfVxuICAgICAgLy8gYW5kIGFkZCB0aGUgcmVtYWluaW5nIGxpbmVzIHdpdGhvdXQgYW55IG1hcHBpbmdcbiAgICAgIG5vZGUuYWRkKHJlbWFpbmluZ0xpbmVzLnNwbGljZShyZW1haW5pbmdMaW5lc0luZGV4KS5qb2luKFwiXCIpKTtcbiAgICB9XG5cbiAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50IGludG8gU291cmNlTm9kZVxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhUmVsYXRpdmVQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5qb2luKGFSZWxhdGl2ZVBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBub2RlO1xuXG4gICAgZnVuY3Rpb24gYWRkTWFwcGluZ1dpdGhDb2RlKG1hcHBpbmcsIGNvZGUpIHtcbiAgICAgIGlmIChtYXBwaW5nID09PSBudWxsIHx8IG1hcHBpbmcuc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9kZS5hZGQoY29kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc291cmNlID0gYVJlbGF0aXZlUGF0aFxuICAgICAgICAgID8gdXRpbC5qb2luKGFSZWxhdGl2ZVBhdGgsIG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgIDogbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIG5vZGUuYWRkKG5ldyBTb3VyY2VOb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcubmFtZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBBZGQgYSBjaHVuayBvZiBnZW5lcmF0ZWQgSlMgdG8gdGhpcyBzb3VyY2Ugbm9kZS5cbiAqXG4gKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2FkZChhQ2h1bmspIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgIGFDaHVuay5mb3JFYWNoKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgdGhpcy5hZGQoY2h1bmspO1xuICAgIH0sIHRoaXMpO1xuICB9XG4gIGVsc2UgaWYgKGFDaHVua1tpc1NvdXJjZU5vZGVdIHx8IHR5cGVvZiBhQ2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoYUNodW5rKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goYUNodW5rKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXCIgKyBhQ2h1bmtcbiAgICApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYSBjaHVuayBvZiBnZW5lcmF0ZWQgSlMgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGlzIHNvdXJjZSBub2RlLlxuICpcbiAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3ByZXBlbmQoYUNodW5rKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICBmb3IgKHZhciBpID0gYUNodW5rLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy5wcmVwZW5kKGFDaHVua1tpXSk7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGFDaHVua1tpc1NvdXJjZU5vZGVdIHx8IHR5cGVvZiBhQ2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0aGlzLmNoaWxkcmVuLnVuc2hpZnQoYUNodW5rKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBKUyBzbmlwcGV0cyBpbiB0aGlzIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi4gVGhlXG4gKiB3YWxraW5nIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmNlIGZvciBlYWNoIHNuaXBwZXQgb2YgSlMgYW5kIGlzIHBhc3NlZCB0aGF0XG4gKiBzbmlwcGV0IGFuZCB0aGUgaXRzIG9yaWdpbmFsIGFzc29jaWF0ZWQgc291cmNlJ3MgbGluZS9jb2x1bW4gbG9jYXRpb24uXG4gKlxuICogQHBhcmFtIGFGbiBUaGUgdHJhdmVyc2FsIGZ1bmN0aW9uLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gU291cmNlTm9kZV93YWxrKGFGbikge1xuICB2YXIgY2h1bms7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY2h1bmsgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgIGlmIChjaHVua1tpc1NvdXJjZU5vZGVdKSB7XG4gICAgICBjaHVuay53YWxrKGFGbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGNodW5rICE9PSAnJykge1xuICAgICAgICBhRm4oY2h1bmssIHsgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZSxcbiAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIExpa2UgYFN0cmluZy5wcm90b3R5cGUuam9pbmAgZXhjZXB0IGZvciBTb3VyY2VOb2Rlcy4gSW5zZXJ0cyBgYVN0cmAgYmV0d2VlblxuICogZWFjaCBvZiBgdGhpcy5jaGlsZHJlbmAuXG4gKlxuICogQHBhcmFtIGFTZXAgVGhlIHNlcGFyYXRvci5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfam9pbihhU2VwKSB7XG4gIHZhciBuZXdDaGlsZHJlbjtcbiAgdmFyIGk7XG4gIHZhciBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgaWYgKGxlbiA+IDApIHtcbiAgICBuZXdDaGlsZHJlbiA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW4tMTsgaSsrKSB7XG4gICAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgICAgbmV3Q2hpbGRyZW4ucHVzaChhU2VwKTtcbiAgICB9XG4gICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICB0aGlzLmNoaWxkcmVuID0gbmV3Q2hpbGRyZW47XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlIG9uIHRoZSB2ZXJ5IHJpZ2h0LW1vc3Qgc291cmNlIHNuaXBwZXQuIFVzZWZ1bFxuICogZm9yIHRyaW1taW5nIHdoaXRlc3BhY2UgZnJvbSB0aGUgZW5kIG9mIGEgc291cmNlIG5vZGUsIGV0Yy5cbiAqXG4gKiBAcGFyYW0gYVBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gcmVwbGFjZS5cbiAqIEBwYXJhbSBhUmVwbGFjZW1lbnQgVGhlIHRoaW5nIHRvIHJlcGxhY2UgdGhlIHBhdHRlcm4gd2l0aC5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUucmVwbGFjZVJpZ2h0ID0gZnVuY3Rpb24gU291cmNlTm9kZV9yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkge1xuICB2YXIgbGFzdENoaWxkID0gdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICBpZiAobGFzdENoaWxkW2lzU291cmNlTm9kZV0pIHtcbiAgICBsYXN0Q2hpbGQucmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiBsYXN0Q2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdID0gbGFzdENoaWxkLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKCcnLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGZvciBhIHNvdXJjZSBmaWxlLiBUaGlzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIFNvdXJjZU1hcEdlbmVyYXRvclxuICogaW4gdGhlIHNvdXJjZXNDb250ZW50IGZpZWxkLlxuICpcbiAqIEBwYXJhbSBhU291cmNlRmlsZSBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlXG4gKiBAcGFyYW0gYVNvdXJjZUNvbnRlbnQgVGhlIGNvbnRlbnQgb2YgdGhlIHNvdXJjZSBmaWxlXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VOb2RlX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgdGhpcy5zb3VyY2VDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKGFTb3VyY2VGaWxlKV0gPSBhU291cmNlQ29udGVudDtcbiAgfTtcblxuLyoqXG4gKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgU291cmNlTm9kZXMuIFRoZSB3YWxraW5nIGZ1bmN0aW9uIGlzIGNhbGxlZCBmb3IgZWFjaFxuICogc291cmNlIGZpbGUgY29udGVudCBhbmQgaXMgcGFzc2VkIHRoZSBmaWxlbmFtZSBhbmQgc291cmNlIGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIGFGbiBUaGUgdHJhdmVyc2FsIGZ1bmN0aW9uLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrU291cmNlQ29udGVudHMgPVxuICBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGtTb3VyY2VDb250ZW50cyhhRm4pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV1baXNTb3VyY2VOb2RlXSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLndhbGtTb3VyY2VDb250ZW50cyhhRm4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzb3VyY2VzID0gT2JqZWN0LmtleXModGhpcy5zb3VyY2VDb250ZW50cyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFGbih1dGlsLmZyb21TZXRTdHJpbmcoc291cmNlc1tpXSksIHRoaXMuc291cmNlQ29udGVudHNbc291cmNlc1tpXV0pO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlLiBXYWxrcyBvdmVyIHRoZSB0cmVlXG4gKiBhbmQgY29uY2F0ZW5hdGVzIGFsbCB0aGUgdmFyaW91cyBzbmlwcGV0cyB0b2dldGhlciB0byBvbmUgc3RyaW5nLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmcoKSB7XG4gIHZhciBzdHIgPSBcIlwiO1xuICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgc3RyICs9IGNodW5rO1xuICB9KTtcbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUgYWxvbmcgd2l0aCBhIHNvdXJjZVxuICogbWFwLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZ1dpdGhTb3VyY2VNYXAgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nV2l0aFNvdXJjZU1hcChhQXJncykge1xuICB2YXIgZ2VuZXJhdGVkID0ge1xuICAgIGNvZGU6IFwiXCIsXG4gICAgbGluZTogMSxcbiAgICBjb2x1bW46IDBcbiAgfTtcbiAgdmFyIG1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpO1xuICB2YXIgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICB2YXIgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbExpbmUgPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsQ29sdW1uID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbE5hbWUgPSBudWxsO1xuICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rLCBvcmlnaW5hbCkge1xuICAgIGdlbmVyYXRlZC5jb2RlICs9IGNodW5rO1xuICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT09IG51bGxcbiAgICAgICAgJiYgb3JpZ2luYWwubGluZSAhPT0gbnVsbFxuICAgICAgICAmJiBvcmlnaW5hbC5jb2x1bW4gIT09IG51bGwpIHtcbiAgICAgIGlmKGxhc3RPcmlnaW5hbFNvdXJjZSAhPT0gb3JpZ2luYWwuc291cmNlXG4gICAgICAgICB8fCBsYXN0T3JpZ2luYWxMaW5lICE9PSBvcmlnaW5hbC5saW5lXG4gICAgICAgICB8fCBsYXN0T3JpZ2luYWxDb2x1bW4gIT09IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTmFtZSAhPT0gb3JpZ2luYWwubmFtZSkge1xuICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgIH0sXG4gICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgIGxhc3RPcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgbGFzdE9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgbGFzdE9yaWdpbmFsTmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaWR4ID0gMCwgbGVuZ3RoID0gY2h1bmsubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICBpZiAoY2h1bmsuY2hhckNvZGVBdChpZHgpID09PSBORVdMSU5FX0NPREUpIHtcbiAgICAgICAgZ2VuZXJhdGVkLmxpbmUrKztcbiAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbiA9IDA7XG4gICAgICAgIC8vIE1hcHBpbmdzIGVuZCBhdCBlb2xcbiAgICAgICAgaWYgKGlkeCArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlbmVyYXRlZC5jb2x1bW4rKztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB0aGlzLndhbGtTb3VyY2VDb250ZW50cyhmdW5jdGlvbiAoc291cmNlRmlsZSwgc291cmNlQ29udGVudCkge1xuICAgIG1hcC5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpO1xuICB9KTtcblxuICByZXR1cm4geyBjb2RlOiBnZW5lcmF0ZWQuY29kZSwgbWFwOiBtYXAgfTtcbn07XG5cbmV4cG9ydHMuU291cmNlTm9kZSA9IFNvdXJjZU5vZGU7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbi8qKlxuICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBwYXJhbWV0ZXIvb3B0aW9uc1xuICogb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gYXJncyBUaGUgb2JqZWN0IHdlIGFyZSBleHRyYWN0aW5nIHZhbHVlcyBmcm9tXG4gKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2UgYXJlIGdldHRpbmcuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIEFuIG9wdGlvbmFsIHZhbHVlIHRvIHJldHVybiBpZiB0aGUgcHJvcGVydHkgaXMgbWlzc2luZ1xuICogZnJvbSB0aGUgb2JqZWN0LiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQgYW5kIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nLCBhblxuICogZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gKi9cbmZ1bmN0aW9uIGdldEFyZyhhQXJncywgYU5hbWUsIGFEZWZhdWx0VmFsdWUpIHtcbiAgaWYgKGFOYW1lIGluIGFBcmdzKSB7XG4gICAgcmV0dXJuIGFBcmdzW2FOYW1lXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgcmV0dXJuIGFEZWZhdWx0VmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhTmFtZSArICdcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LicpO1xuICB9XG59XG5leHBvcnRzLmdldEFyZyA9IGdldEFyZztcblxudmFyIHVybFJlZ2V4cCA9IC9eKD86KFtcXHcrXFwtLl0rKTopP1xcL1xcLyg/OihcXHcrOlxcdyspQCk/KFtcXHcuLV0qKSg/OjooXFxkKykpPyguKikkLztcbnZhciBkYXRhVXJsUmVnZXhwID0gL15kYXRhOi4rXFwsLiskLztcblxuZnVuY3Rpb24gdXJsUGFyc2UoYVVybCkge1xuICB2YXIgbWF0Y2ggPSBhVXJsLm1hdGNoKHVybFJlZ2V4cCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNjaGVtZTogbWF0Y2hbMV0sXG4gICAgYXV0aDogbWF0Y2hbMl0sXG4gICAgaG9zdDogbWF0Y2hbM10sXG4gICAgcG9ydDogbWF0Y2hbNF0sXG4gICAgcGF0aDogbWF0Y2hbNV1cbiAgfTtcbn1cbmV4cG9ydHMudXJsUGFyc2UgPSB1cmxQYXJzZTtcblxuZnVuY3Rpb24gdXJsR2VuZXJhdGUoYVBhcnNlZFVybCkge1xuICB2YXIgdXJsID0gJyc7XG4gIGlmIChhUGFyc2VkVXJsLnNjaGVtZSkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLnNjaGVtZSArICc6JztcbiAgfVxuICB1cmwgKz0gJy8vJztcbiAgaWYgKGFQYXJzZWRVcmwuYXV0aCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLmF1dGggKyAnQCc7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwuaG9zdCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLmhvc3Q7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwucG9ydCkge1xuICAgIHVybCArPSBcIjpcIiArIGFQYXJzZWRVcmwucG9ydFxuICB9XG4gIGlmIChhUGFyc2VkVXJsLnBhdGgpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5wYXRoO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5leHBvcnRzLnVybEdlbmVyYXRlID0gdXJsR2VuZXJhdGU7XG5cbi8qKlxuICogTm9ybWFsaXplcyBhIHBhdGgsIG9yIHRoZSBwYXRoIHBvcnRpb24gb2YgYSBVUkw6XG4gKlxuICogLSBSZXBsYWNlcyBjb25zZWN1dGl2ZSBzbGFzaGVzIHdpdGggb25lIHNsYXNoLlxuICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICcuJyBwYXJ0cy5cbiAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnPGRpcj4vLi4nIHBhcnRzLlxuICpcbiAqIEJhc2VkIG9uIGNvZGUgaW4gdGhlIE5vZGUuanMgJ3BhdGgnIGNvcmUgbW9kdWxlLlxuICpcbiAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciB1cmwgdG8gbm9ybWFsaXplLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemUoYVBhdGgpIHtcbiAgdmFyIHBhdGggPSBhUGF0aDtcbiAgdmFyIHVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgaWYgKHVybCkge1xuICAgIGlmICghdXJsLnBhdGgpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG4gICAgcGF0aCA9IHVybC5wYXRoO1xuICB9XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpO1xuXG4gIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoL1xcLysvKTtcbiAgZm9yICh2YXIgcGFydCwgdXAgPSAwLCBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwID4gMCkge1xuICAgICAgaWYgKHBhcnQgPT09ICcnKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBwYXJ0IGlzIGJsYW5rIGlmIHRoZSBwYXRoIGlzIGFic29sdXRlLiBUcnlpbmcgdG8gZ29cbiAgICAgICAgLy8gYWJvdmUgdGhlIHJvb3QgaXMgYSBuby1vcC4gVGhlcmVmb3JlIHdlIGNhbiByZW1vdmUgYWxsICcuLicgcGFydHNcbiAgICAgICAgLy8gZGlyZWN0bHkgYWZ0ZXIgdGhlIHJvb3QuXG4gICAgICAgIHBhcnRzLnNwbGljZShpICsgMSwgdXApO1xuICAgICAgICB1cCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMik7XG4gICAgICAgIHVwLS07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhdGggPSBwYXJ0cy5qb2luKCcvJyk7XG5cbiAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgcGF0aCA9IGlzQWJzb2x1dGUgPyAnLycgOiAnLic7XG4gIH1cblxuICBpZiAodXJsKSB7XG4gICAgdXJsLnBhdGggPSBwYXRoO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZSh1cmwpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5cbi8qKlxuICogSm9pbnMgdHdvIHBhdGhzL1VSTHMuXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBqb2luZWQgd2l0aCB0aGUgcm9vdC5cbiAqXG4gKiAtIElmIGFQYXRoIGlzIGEgVVJMIG9yIGEgZGF0YSBVUkksIGFQYXRoIGlzIHJldHVybmVkLCB1bmxlc3MgYVBhdGggaXMgYVxuICogICBzY2hlbWUtcmVsYXRpdmUgVVJMOiBUaGVuIHRoZSBzY2hlbWUgb2YgYVJvb3QsIGlmIGFueSwgaXMgcHJlcGVuZGVkXG4gKiAgIGZpcnN0LlxuICogLSBPdGhlcndpc2UgYVBhdGggaXMgYSBwYXRoLiBJZiBhUm9vdCBpcyBhIFVSTCwgdGhlbiBpdHMgcGF0aCBwb3J0aW9uXG4gKiAgIGlzIHVwZGF0ZWQgd2l0aCB0aGUgcmVzdWx0IGFuZCBhUm9vdCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlIHRoZSByZXN1bHRcbiAqICAgaXMgcmV0dXJuZWQuXG4gKiAgIC0gSWYgYVBhdGggaXMgYWJzb2x1dGUsIHRoZSByZXN1bHQgaXMgYVBhdGguXG4gKiAgIC0gT3RoZXJ3aXNlIHRoZSB0d28gcGF0aHMgYXJlIGpvaW5lZCB3aXRoIGEgc2xhc2guXG4gKiAtIEpvaW5pbmcgZm9yIGV4YW1wbGUgJ2h0dHA6Ly8nIGFuZCAnd3d3LmV4YW1wbGUuY29tJyBpcyBhbHNvIHN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gam9pbihhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuICBpZiAoYVBhdGggPT09IFwiXCIpIHtcbiAgICBhUGF0aCA9IFwiLlwiO1xuICB9XG4gIHZhciBhUGF0aFVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgdmFyIGFSb290VXJsID0gdXJsUGFyc2UoYVJvb3QpO1xuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdCA9IGFSb290VXJsLnBhdGggfHwgJy8nO1xuICB9XG5cbiAgLy8gYGpvaW4oZm9vLCAnLy93d3cuZXhhbXBsZS5vcmcnKWBcbiAgaWYgKGFQYXRoVXJsICYmICFhUGF0aFVybC5zY2hlbWUpIHtcbiAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgIGFQYXRoVXJsLnNjaGVtZSA9IGFSb290VXJsLnNjaGVtZTtcbiAgICB9XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFQYXRoVXJsKTtcbiAgfVxuXG4gIGlmIChhUGF0aFVybCB8fCBhUGF0aC5tYXRjaChkYXRhVXJsUmVnZXhwKSkge1xuICAgIHJldHVybiBhUGF0aDtcbiAgfVxuXG4gIC8vIGBqb2luKCdodHRwOi8vJywgJ3d3dy5leGFtcGxlLmNvbScpYFxuICBpZiAoYVJvb3RVcmwgJiYgIWFSb290VXJsLmhvc3QgJiYgIWFSb290VXJsLnBhdGgpIHtcbiAgICBhUm9vdFVybC5ob3N0ID0gYVBhdGg7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgfVxuXG4gIHZhciBqb2luZWQgPSBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJ1xuICAgID8gYVBhdGhcbiAgICA6IG5vcm1hbGl6ZShhUm9vdC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIGFQYXRoKTtcblxuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdFVybC5wYXRoID0gam9pbmVkO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gIH1cbiAgcmV0dXJuIGpvaW5lZDtcbn1cbmV4cG9ydHMuam9pbiA9IGpvaW47XG5cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uIChhUGF0aCkge1xuICByZXR1cm4gYVBhdGguY2hhckF0KDApID09PSAnLycgfHwgdXJsUmVnZXhwLnRlc3QoYVBhdGgpO1xufTtcblxuLyoqXG4gKiBNYWtlIGEgcGF0aCByZWxhdGl2ZSB0byBhIFVSTCBvciBhbm90aGVyIHBhdGguXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBtYWRlIHJlbGF0aXZlIHRvIGFSb290LlxuICovXG5mdW5jdGlvbiByZWxhdGl2ZShhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuXG4gIGFSb290ID0gYVJvb3QucmVwbGFjZSgvXFwvJC8sICcnKTtcblxuICAvLyBJdCBpcyBwb3NzaWJsZSBmb3IgdGhlIHBhdGggdG8gYmUgYWJvdmUgdGhlIHJvb3QuIEluIHRoaXMgY2FzZSwgc2ltcGx5XG4gIC8vIGNoZWNraW5nIHdoZXRoZXIgdGhlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlIHBhdGggd29uJ3Qgd29yay4gSW5zdGVhZCwgd2VcbiAgLy8gbmVlZCB0byByZW1vdmUgY29tcG9uZW50cyBmcm9tIHRoZSByb290IG9uZSBieSBvbmUsIHVudGlsIGVpdGhlciB3ZSBmaW5kXG4gIC8vIGEgcHJlZml4IHRoYXQgZml0cywgb3Igd2UgcnVuIG91dCBvZiBjb21wb25lbnRzIHRvIHJlbW92ZS5cbiAgdmFyIGxldmVsID0gMDtcbiAgd2hpbGUgKGFQYXRoLmluZGV4T2YoYVJvb3QgKyAnLycpICE9PSAwKSB7XG4gICAgdmFyIGluZGV4ID0gYVJvb3QubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgb25seSBwYXJ0IG9mIHRoZSByb290IHRoYXQgaXMgbGVmdCBpcyB0aGUgc2NoZW1lIChpLmUuIGh0dHA6Ly8sXG4gICAgLy8gZmlsZTovLy8sIGV0Yy4pLCBvbmUgb3IgbW9yZSBzbGFzaGVzICgvKSwgb3Igc2ltcGx5IG5vdGhpbmcgYXQgYWxsLCB3ZVxuICAgIC8vIGhhdmUgZXhoYXVzdGVkIGFsbCBjb21wb25lbnRzLCBzbyB0aGUgcGF0aCBpcyBub3QgcmVsYXRpdmUgdG8gdGhlIHJvb3QuXG4gICAgYVJvb3QgPSBhUm9vdC5zbGljZSgwLCBpbmRleCk7XG4gICAgaWYgKGFSb290Lm1hdGNoKC9eKFteXFwvXSs6XFwvKT9cXC8qJC8pKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgKytsZXZlbDtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB3ZSBhZGQgYSBcIi4uL1wiIGZvciBlYWNoIGNvbXBvbmVudCB3ZSByZW1vdmVkIGZyb20gdGhlIHJvb3QuXG4gIHJldHVybiBBcnJheShsZXZlbCArIDEpLmpvaW4oXCIuLi9cIikgKyBhUGF0aC5zdWJzdHIoYVJvb3QubGVuZ3RoICsgMSk7XG59XG5leHBvcnRzLnJlbGF0aXZlID0gcmVsYXRpdmU7XG5cbnZhciBzdXBwb3J0c051bGxQcm90byA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gISgnX19wcm90b19fJyBpbiBvYmopO1xufSgpKTtcblxuZnVuY3Rpb24gaWRlbnRpdHkgKHMpIHtcbiAgcmV0dXJuIHM7XG59XG5cbi8qKlxuICogQmVjYXVzZSBiZWhhdmlvciBnb2VzIHdhY2t5IHdoZW4geW91IHNldCBgX19wcm90b19fYCBvbiBvYmplY3RzLCB3ZVxuICogaGF2ZSB0byBwcmVmaXggYWxsIHRoZSBzdHJpbmdzIGluIG91ciBzZXQgd2l0aCBhbiBhcmJpdHJhcnkgY2hhcmFjdGVyLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL3B1bGwvMzEgYW5kXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8zMFxuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5mdW5jdGlvbiB0b1NldFN0cmluZyhhU3RyKSB7XG4gIGlmIChpc1Byb3RvU3RyaW5nKGFTdHIpKSB7XG4gICAgcmV0dXJuICckJyArIGFTdHI7XG4gIH1cblxuICByZXR1cm4gYVN0cjtcbn1cbmV4cG9ydHMudG9TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogdG9TZXRTdHJpbmc7XG5cbmZ1bmN0aW9uIGZyb21TZXRTdHJpbmcoYVN0cikge1xuICBpZiAoaXNQcm90b1N0cmluZyhhU3RyKSkge1xuICAgIHJldHVybiBhU3RyLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuIGFTdHI7XG59XG5leHBvcnRzLmZyb21TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogZnJvbVNldFN0cmluZztcblxuZnVuY3Rpb24gaXNQcm90b1N0cmluZyhzKSB7XG4gIGlmICghcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBzLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoIDwgOSAvKiBcIl9fcHJvdG9fX1wiLmxlbmd0aCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMSkgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSAyKSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDMpICE9PSAxMTEgLyogJ28nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNCkgIT09IDExNiAvKiAndCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA1KSAhPT0gMTExIC8qICdvJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDYpICE9PSAxMTQgLyogJ3InICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNykgIT09IDExMiAvKiAncCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA4KSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDkpICE9PSA5NSAgLyogJ18nICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDEwOyBpID49IDA7IGktLSkge1xuICAgIGlmIChzLmNoYXJDb2RlQXQoaSkgIT09IDM2IC8qICckJyAqLykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2hlcmUgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4sIGJ1dCBkaWZmZXJlbnQgZ2VuZXJhdGVkXG4gKiBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYSBtYXBwaW5nIHdpdGggYVxuICogc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gIHZhciBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG59XG5leHBvcnRzLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zID0gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnM7XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGRlZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBpbmRpY2VzIHdoZXJlXG4gKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uLCBidXQgZGlmZmVyZW50XG4gKiBzb3VyY2UvbmFtZS9vcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYVxuICogbWFwcGluZyB3aXRoIGEgc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZDtcblxuZnVuY3Rpb24gc3RyY21wKGFTdHIxLCBhU3RyMikge1xuICBpZiAoYVN0cjEgPT09IGFTdHIyKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoYVN0cjEgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMTsgLy8gYVN0cjIgIT09IG51bGxcbiAgfVxuXG4gIGlmIChhU3RyMiA9PT0gbnVsbCkge1xuICAgIHJldHVybiAtMTsgLy8gYVN0cjEgIT09IG51bGxcbiAgfVxuXG4gIGlmIChhU3RyMSA+IGFTdHIyKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGluZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBzdHJpbmdzIHdoZXJlXG4gKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZDtcblxuLyoqXG4gKiBTdHJpcCBhbnkgSlNPTiBYU1NJIGF2b2lkYW5jZSBwcmVmaXggZnJvbSB0aGUgc3RyaW5nIChhcyBkb2N1bWVudGVkXG4gKiBpbiB0aGUgc291cmNlIG1hcHMgc3BlY2lmaWNhdGlvbiksIGFuZCB0aGVuIHBhcnNlIHRoZSBzdHJpbmcgYXNcbiAqIEpTT04uXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU291cmNlTWFwSW5wdXQoc3RyKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKHN0ci5yZXBsYWNlKC9eXFwpXX0nW15cXG5dKlxcbi8sICcnKSk7XG59XG5leHBvcnRzLnBhcnNlU291cmNlTWFwSW5wdXQgPSBwYXJzZVNvdXJjZU1hcElucHV0O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIFVSTCBvZiBhIHNvdXJjZSBnaXZlbiB0aGUgdGhlIHNvdXJjZSByb290LCB0aGUgc291cmNlJ3NcbiAqIFVSTCwgYW5kIHRoZSBzb3VyY2UgbWFwJ3MgVVJMLlxuICovXG5mdW5jdGlvbiBjb21wdXRlU291cmNlVVJMKHNvdXJjZVJvb3QsIHNvdXJjZVVSTCwgc291cmNlTWFwVVJMKSB7XG4gIHNvdXJjZVVSTCA9IHNvdXJjZVVSTCB8fCAnJztcblxuICBpZiAoc291cmNlUm9vdCkge1xuICAgIC8vIFRoaXMgZm9sbG93cyB3aGF0IENocm9tZSBkb2VzLlxuICAgIGlmIChzb3VyY2VSb290W3NvdXJjZVJvb3QubGVuZ3RoIC0gMV0gIT09ICcvJyAmJiBzb3VyY2VVUkxbMF0gIT09ICcvJykge1xuICAgICAgc291cmNlUm9vdCArPSAnLyc7XG4gICAgfVxuICAgIC8vIFRoZSBzcGVjIHNheXM6XG4gICAgLy8gICBMaW5lIDQ6IEFuIG9wdGlvbmFsIHNvdXJjZSByb290LCB1c2VmdWwgZm9yIHJlbG9jYXRpbmcgc291cmNlXG4gICAgLy8gICBmaWxlcyBvbiBhIHNlcnZlciBvciByZW1vdmluZyByZXBlYXRlZCB2YWx1ZXMgaW4gdGhlXG4gICAgLy8gICDigJxzb3VyY2Vz4oCdIGVudHJ5LiAgVGhpcyB2YWx1ZSBpcyBwcmVwZW5kZWQgdG8gdGhlIGluZGl2aWR1YWxcbiAgICAvLyAgIGVudHJpZXMgaW4gdGhlIOKAnHNvdXJjZeKAnSBmaWVsZC5cbiAgICBzb3VyY2VVUkwgPSBzb3VyY2VSb290ICsgc291cmNlVVJMO1xuICB9XG5cbiAgLy8gSGlzdG9yaWNhbGx5LCBTb3VyY2VNYXBDb25zdW1lciBkaWQgbm90IHRha2UgdGhlIHNvdXJjZU1hcFVSTCBhc1xuICAvLyBhIHBhcmFtZXRlci4gIFRoaXMgbW9kZSBpcyBzdGlsbCBzb21ld2hhdCBzdXBwb3J0ZWQsIHdoaWNoIGlzIHdoeVxuICAvLyB0aGlzIGNvZGUgYmxvY2sgaXMgY29uZGl0aW9uYWwuICBIb3dldmVyLCBpdCdzIHByZWZlcmFibGUgdG8gcGFzc1xuICAvLyB0aGUgc291cmNlIG1hcCBVUkwgdG8gU291cmNlTWFwQ29uc3VtZXIsIHNvIHRoYXQgdGhpcyBmdW5jdGlvblxuICAvLyBjYW4gaW1wbGVtZW50IHRoZSBzb3VyY2UgVVJMIHJlc29sdXRpb24gYWxnb3JpdGhtIGFzIG91dGxpbmVkIGluXG4gIC8vIHRoZSBzcGVjLiAgVGhpcyBibG9jayBpcyBiYXNpY2FsbHkgdGhlIGVxdWl2YWxlbnQgb2Y6XG4gIC8vICAgIG5ldyBVUkwoc291cmNlVVJMLCBzb3VyY2VNYXBVUkwpLnRvU3RyaW5nKClcbiAgLy8gLi4uIGV4Y2VwdCBpdCBhdm9pZHMgdXNpbmcgVVJMLCB3aGljaCB3YXNuJ3QgYXZhaWxhYmxlIGluIHRoZVxuICAvLyBvbGRlciByZWxlYXNlcyBvZiBub2RlIHN0aWxsIHN1cHBvcnRlZCBieSB0aGlzIGxpYnJhcnkuXG4gIC8vXG4gIC8vIFRoZSBzcGVjIHNheXM6XG4gIC8vICAgSWYgdGhlIHNvdXJjZXMgYXJlIG5vdCBhYnNvbHV0ZSBVUkxzIGFmdGVyIHByZXBlbmRpbmcgb2YgdGhlXG4gIC8vICAg4oCcc291cmNlUm9vdOKAnSwgdGhlIHNvdXJjZXMgYXJlIHJlc29sdmVkIHJlbGF0aXZlIHRvIHRoZVxuICAvLyAgIFNvdXJjZU1hcCAobGlrZSByZXNvbHZpbmcgc2NyaXB0IHNyYyBpbiBhIGh0bWwgZG9jdW1lbnQpLlxuICBpZiAoc291cmNlTWFwVVJMKSB7XG4gICAgdmFyIHBhcnNlZCA9IHVybFBhcnNlKHNvdXJjZU1hcFVSTCk7XG4gICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInNvdXJjZU1hcFVSTCBjb3VsZCBub3QgYmUgcGFyc2VkXCIpO1xuICAgIH1cbiAgICBpZiAocGFyc2VkLnBhdGgpIHtcbiAgICAgIC8vIFN0cmlwIHRoZSBsYXN0IHBhdGggY29tcG9uZW50LCBidXQga2VlcCB0aGUgXCIvXCIuXG4gICAgICB2YXIgaW5kZXggPSBwYXJzZWQucGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgcGFyc2VkLnBhdGggPSBwYXJzZWQucGF0aC5zdWJzdHJpbmcoMCwgaW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc291cmNlVVJMID0gam9pbih1cmxHZW5lcmF0ZShwYXJzZWQpLCBzb3VyY2VVUkwpO1xuICB9XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZShzb3VyY2VVUkwpO1xufVxuZXhwb3J0cy5jb21wdXRlU291cmNlVVJMID0gY29tcHV0ZVNvdXJjZVVSTDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRS50eHQgb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1jb25zdW1lcicpLlNvdXJjZU1hcENvbnN1bWVyO1xuZXhwb3J0cy5Tb3VyY2VOb2RlID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW5vZGUnKS5Tb3VyY2VOb2RlO1xuIiwidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBTaW1vbiBMeWRlbGxcclxuLy8gWDExICjigJxNSVTigJ0pIExpY2Vuc2VkLiAoU2VlIExJQ0VOU0UuKVxyXG5cclxudmFyIHBhdGggPSByZXF1aXJlKFwicGF0aFwiKVxyXG5cclxuXCJ1c2Ugc3RyaWN0XCJcclxuXHJcbmZ1bmN0aW9uIHVyaXgoYVBhdGgpIHtcclxuICBpZiAocGF0aC5zZXAgPT09IFwiXFxcXFwiKSB7XHJcbiAgICByZXR1cm4gYVBhdGhcclxuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpXHJcbiAgICAgIC5yZXBsYWNlKC9eW2Etel06XFwvPy9pLCBcIi9cIilcclxuICB9XHJcbiAgcmV0dXJuIGFQYXRoXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gdXJpeFxyXG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJpbXBvcnQgeyBUeXBlIH0gZnJvbSBcIi4uL2NvbXBpbGVyL3R5cGVzL0FsbFR5cGVzXCJcbmltcG9ydCB7QW55VHlwZSwgQm9vbGVhblR5cGUsIEZ1bmN0aW9uVHlwZSwgTnVtYmVyVHlwZSwgT2JqZWN0VHlwZSwgU3RyaW5nVHlwZSwgVHlwZVJlZmVyZW5jZVR5cGUsIFZvaWRUeXBlLCBBcnJheVR5cGUsIExpdGVyYWxUeXBlVHlwZSwgVHVwbGVUeXBlLCBVbmlvblR5cGV9IGZyb20gXCIuLi9jb21waWxlci90eXBlcy9BbGxUeXBlc1wiXG5pbXBvcnQge1N5bWJvbE1ldGFkYXRhLCBDbGFzc01ldGFkYXRhLCBGaWxlTWV0YWRhdGEsIFByb2dyYW1NZXRhZGF0YX0gZnJvbSBcIi4uL2NvbXBpbGVyL21ldGFkYXRhL0FsbE1ldGFkYXRhXCJcblxuZXhwb3J0IGxldCBldmVyeXRoaW5nID0gbmV3IFByb2dyYW1NZXRhZGF0YShuZXcgTWFwPHN0cmluZywgRmlsZU1ldGFkYXRhPihbW1wic3JjL2V4Y21kcy50c1wiLCBuZXcgRmlsZU1ldGFkYXRhKG5ldyBNYXA8c3RyaW5nLCBDbGFzc01ldGFkYXRhPihbXSksIG5ldyBNYXA8c3RyaW5nLCBTeW1ib2xNZXRhZGF0YT4oW1tcImdldE5hdGl2ZVZlcnNpb25cIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiXCIsIG5ldyBGdW5jdGlvblR5cGUoW10sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgdHJ1ZSldLFxuW1wiZ2V0UnNzTGlua3NcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiXCIsIG5ldyBGdW5jdGlvblR5cGUoW10sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBBcnJheVR5cGUobmV3IE9iamVjdFR5cGUobmV3IE1hcDxzdHJpbmcsIFR5cGU+KFtbXCJ0eXBlXCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCJ1cmxcIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcInRpdGxlXCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldXSksIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCB0cnVlKV0sXG5bXCJyc3NleGVjXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkV4ZWN1dGUgW1tyc3NjbWRdXSBmb3IgYW4gcnNzIGxpbmsuXFxuXFxuSWYgYHVybGAgaXMgdW5kZWZpbmVkLCBUcmlkYWN0eWwgd2lsbCBsb29rIGZvciByc3MgbGlua3MgaW4gdGhlIGN1cnJlbnRcXG5wYWdlLiBJZiBpdCBkb2Vzbid0IGZpbmQgYW55LCBpdCB3aWxsIGRpc3BsYXkgYW4gZXJyb3IgbWVzc2FnZS4gSWYgaXQgZmluZHNcXG5tdWx0aXBsZSB1cmxzLCBpdCB3aWxsIG9mZmVyIGNvbXBsZXRpb25zIGluIG9yZGVyIGZvciB5b3UgdG8gc2VsZWN0IHRoZSBsaW5rXFxueW91J3JlIGludGVyZXN0ZWQgaW4uIElmIGEgc2luZ2xlIHJzcyBmZWVkIGlzIGZvdW5kLCBpdCB3aWxsIGF1dG9tYXRpY2FsbHlcXG5iZSBzZWxlY3RlZC5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSxuZXcgU3RyaW5nVHlwZShmYWxzZSwgdHJ1ZSksbmV3IEFycmF5VHlwZShuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCB0cnVlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiZmlsbGlucHV0XCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkZpbGxzIHRoZSBlbGVtZW50IG1hdGNoZWQgYnkgYHNlbGVjdG9yYCB3aXRoIGNvbnRlbnQgYW5kIGZhbGxzIGJhY2sgdG8gdGhlIGxhc3QgdXNlZCBpbnB1dCBpZiB0aGUgZWxlbWVudCBjYW4ndCBiZSBmb3VuZC4gWW91IHByb2JhYmx5IGRvbid0IHdhbnQgdGhpczsgaXQncyB1c2VkIGludGVybmFsbHkgZm9yIFtbZWRpdG9yXV0uXFxuXFxuVGhhdCBzYWlkLCBgYmluZCBncyBmaWxsaW5wdXQgbnVsbCBbVHJpZGFjdHlsXShodHRwczovL2FkZG9ucy5tb3ppbGxhLm9yZy9lbi1VUy9maXJlZm94L2FkZG9uL3RyaWRhY3R5bC12aW0vKSBpcyBteSBmYXZvdXJpdGUgYWRkLW9uYCBjb3VsZCBwcm9iYWJseSBjb21lIGluIGhhbmR5LlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLG5ldyBBcnJheVR5cGUobmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgdHJ1ZSwgZmFsc2UpXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiZ2V0SW5wdXRcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBUeXBlUmVmZXJlbmNlVHlwZShcIkhUTUxFbGVtZW50XCIsIFtdLCBmYWxzZSwgZmFsc2UpXSwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgdHJ1ZSldLFxuW1wiZ2V0aW5wdXRcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiXCIsIG5ldyBGdW5jdGlvblR5cGUoW10sIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIHRydWUpXSxcbltcImdldElucHV0U2VsZWN0b3JcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiXCIsIG5ldyBGdW5jdGlvblR5cGUoW10sIG5ldyBBbnlUeXBlKHRydWUsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgdHJ1ZSldLFxuW1wiYWRkVHJpZGFjdHlsRWRpdG9yQ2xhc3NcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgdHJ1ZSldLFxuW1wicmVtb3ZlVHJpZGFjdHlsRWRpdG9yQ2xhc3NcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgdHJ1ZSldLFxuW1wiZWRpdG9yXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIk9wZW5zIHlvdXIgZmF2b3VyaXRlIGVkaXRvciAod2hpY2ggaXMgY3VycmVudGx5IGdWaW0pIGFuZCBmaWxscyB0aGUgbGFzdCB1c2VkIGlucHV0IHdpdGggd2hhdGV2ZXIgeW91IHdyaXRlIGludG8gdGhhdCBmaWxlLlxcbioqUmVxdWlyZXMgdGhhdCB0aGUgbmF0aXZlIG1lc3NlbmdlciBpcyBpbnN0YWxsZWQsIHNlZSBbW25hdGl2ZV1dIGFuZCBbW2luc3RhbGxuYXRpdmVdXSoqLlxcblxcblVzZXMgdGhlIGBlZGl0b3JjbWRgIGNvbmZpZyBvcHRpb24sIGRlZmF1bHQgPSBgYXV0b2AgbG9va3MgdGhyb3VnaCBhIGxpc3QgZGVmaW5lZCBpbiBsaWIvbmF0aXZlLnRzIHRyeSBmaW5kIGEgc2Vuc2libGUgY29tYmluYXRpb24uIElmIGl0J3MgYSBiaXQgc2xvdywgb3IgY2hvb3NlcyB0aGUgd3JvbmcgZWRpdG9yLCBvciBnaXZlcyB1cCBjb21wbGV0ZWx5LCBzZXQgZWRpdG9yY21kIHRvIHNvbWV0aGluZyB5b3Ugd2FudC4gVGhlIGNvbW1hbmQgbXVzdCBzdGF5IGluIHRoZSBmb3JlZ3JvdW5kIHVudGlsIHRoZSBlZGl0b3IgZXhpdHMuXFxuXFxuVGhlIGVkaXRvcmNtZCBuZWVkcyB0byBhY2NlcHQgYSBmaWxlbmFtZSwgc3RheSBpbiB0aGUgZm9yZWdyb3VuZCB3aGlsZSBpdCdzIGVkaXRlZCwgc2F2ZSB0aGUgZmlsZSBhbmQgZXhpdC4gQnkgZGVmYXVsdCB0aGUgZmlsZW5hbWUgaXMgYWRkZWQgdG8gdGhlIGVuZCBvZiBlZGl0b3JjbWQsIGlmIHlvdSByZXF1aXJlIGNvbnRyb2wgb3ZlciB0aGUgcG9zaXRpb24gb2YgdGhhdCBhcmd1bWVudCwgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgJWYgaW4gZWRpdG9yY21kIGlzIHJlcGxhY2VkIHdpdGggdGhlIGZpbGVuYW1lLiAlbCwgaWYgaXQgZXhpc3RzLCBpcyByZXBsYWNlZCB3aXRoIHRoZSBsaW5lIG51bWJlciBvZiB0aGUgY3Vyc29yIGFuZCAlYyB3aXRoIHRoZSBjb2x1bW4gbnVtYmVyLiBGb3IgZXhhbXBsZTpcXG5gYGBcXG5zZXQgZWRpdG9yY21kIHRlcm1pbmF0b3IgLXUgLWUgXFxcInZpbSAlZiAtYyAnbm9ybWFsICVsRyVjbCdcXFwiXFxuYGBgXFxuXFxuWW91J3JlIHByb2JhYmx5IGJldHRlciBvZmYgdXNpbmcgdGhlIGRlZmF1bHQgaW5zZXJ0IG1vZGUgYmluZCBvZiBgPEMtaT5gIChDdHJsLWkpIHRvIGFjY2VzcyB0aGlzLlxcblxcblRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHR1cGxlIGNvbnRhaW5pbmcgdGhlIHBhdGggdG8gdGhlIGZpbGUgdGhhdCB3YXMgb3BlbmVkIGJ5IHRoZSBlZGl0b3IgYW5kIGl0cyBjb250ZW50LiBUaGlzIGVuYWJsZXMgY3JlYXRpbmcgY29tbWFuZHMgc3VjaCBhcyB0aGUgZm9sbG93aW5nIG9uZSwgd2hpY2ggZGVsZXRlcyB0aGUgdGVtcG9yYXJ5IGZpbGUgY3JlYXRlZCBieSB0aGUgZWRpdG9yOlxcbmBgYFxcbmFsaWFzIGVkaXRvcl9ybSBjb21wb3NpdGUgZWRpdG9yIHwganNiIC1wIHRyaS5uYXRpdmUucnVuKGBybSAtZiAnJHtKU19BUkdbMF19J2ApXFxuYmluZCAtLW1vZGU9aW5zZXJ0IDxDLWk+IGVkaXRvcl9ybVxcbmJpbmQgLS1tb2RlPWlucHV0IDxDLWk+IGVkaXRvcl9ybVxcbmBgYFwiLCBuZXcgRnVuY3Rpb25UeXBlKFtdLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgQXJyYXlUeXBlKG5ldyBBbnlUeXBlKHRydWUsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJndWlzZXRfcXVpZXRcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiTGlrZSBbW2d1aXNldF1dIGJ1dCBxdWlldGVyLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiZ3Vpc2V0XCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkNoYW5nZSB3aGljaCBwYXJ0cyBvZiB0aGUgRmlyZWZveCB1c2VyIGludGVyZmFjZSBhcmUgc2hvd24uICoqTkI6IFRoaXMgZmVhdHVyZSBpcyBleHBlcmltZW50YWwgYW5kIG1pZ2h0IGJyZWFrIHN0dWZmLioqXFxuXFxuTWlnaHQgbWFuZ2xlIHlvdXIgdXNlckNocm9tZS4gUmVxdWlyZXMgbmF0aXZlIG1lc3NlbmdlciwgYW5kIHlvdSBtdXN0IHJlc3RhcnQgRmlyZWZveCBlYWNoIHRpbWUgdG8gc2VlIGFueSBjaGFuZ2VzICh0aGlzIGNhbiBiZSBkb25lIHVzaW5nIFtbcmVzdGFydF1dKS4gPCEtLSAodW5sZXNzIHlvdSBlbmFibGUgYWRkb24gZGVidWdnaW5nIGFuZCByZWZyZXNoIHVzaW5nIHRoZSBicm93c2VyIHRvb2xib3gpIC0tPlxcblxcbkFsc28gZmxpcHMgdGhlIHByZWZlcmVuY2UgYHRvb2xraXQubGVnYWN5VXNlclByb2ZpbGVDdXN0b21pemF0aW9ucy5zdHlsZXNoZWV0c2AgdG8gdHJ1ZSBzbyB0aGF0IEZGIHdpbGwgcmVhZCB5b3VyIHVzZXJDaHJvbWUuXFxuXFxuVmlldyBhdmFpbGFibGUgcnVsZXMgYW5kIG9wdGlvbnMgW2hlcmVdKC9zdGF0aWMvZG9jcy9tb2R1bGVzL19zcmNfbGliX2Nzc191dGlsXy5odG1sI3BvdGVudGlhbHJ1bGVzKSBhbmQgW2hlcmVdKC9zdGF0aWMvZG9jcy9tb2R1bGVzL19zcmNfbGliX2Nzc191dGlsXy5odG1sI21ldGFydWxlcykuXFxuXFxuRXhhbXBsZSB1c2FnZTogYGd1aXNldCBndWkgbm9uZWAsIGBndWlzZXQgZ3VpIGZ1bGxgLCBgZ3Vpc2V0IHRhYnMgYXV0b2hpZGVgLlxcblxcblNvbWUgb2YgdGhlIGF2YWlsYWJsZSBvcHRpb25zOlxcblxcbi0gZ3VpXFxuICAgICAgLSBmdWxsXFxuICAgICAgLSBub25lXFxuXFxuLSB0YWJzXFxuICAgICAgLSBhbHdheXNcXG4gICAgICAtIGF1dG9oaWRlXFxuXFxuLSBuYXZiYXJcXG4gICAgICAtIGFsd2F5c1xcbiAgICAgIC0gYXV0b2hpZGVcXG4gICAgICAtIG5vbmVcXG5cXG4tIGhvdmVybGluayAodGhlIGxpdHRsZSBsaW5rIHRoYXQgYXBwZWFycyB3aGVuIHlvdSBob3ZlciBvdmVyIGEgbGluaylcXG4gICAgICAtIG5vbmVcXG4gICAgICAtIGxlZnRcXG4gICAgICAtIHJpZ2h0XFxuICAgICAgLSB0b3AtbGVmdFxcbiAgICAgIC0gdG9wLXJpZ2h0XFxuXFxuLSBzdGF0dXNwYW5lbCAoaG92ZXJsaW5rICsgdGhlIGluZGljYXRvciB0aGF0IGFwcGVhcnMgd2hlbiBhIHdlYnNpdGUgaXMgbG9hZGluZylcXG4gICAgICAtIG5vbmVcXG4gICAgICAtIGxlZnRcXG4gICAgICAtIHJpZ2h0XFxuICAgICAgLSB0b3AtbGVmdFxcbiAgICAgIC0gdG9wLXJpZ2h0XFxuXFxuSWYgeW91IHdhbnQgdG8gdXNlIGd1aXNldCBpbiB5b3VyIHRyaWRhY3R5bHJjLCB5b3UgbWlnaHQgd2FudCB0byB1c2UgW1tndWlzZXRfcXVpZXRdXSBpbnN0ZWFkLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiY3NzcGFyc2VcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBBcnJheVR5cGUobmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgdHJ1ZSwgZmFsc2UpXSwgbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIHRydWUpXSxcbltcImxvYWR0aGVtZVwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJcIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBBbnlUeXBlKHRydWUsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIHRydWUpXSxcbltcInVubG9hZHRoZW1lXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCB0cnVlKV0sXG5bXCJjb2xvdXJzY2hlbWVcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiQ2hhbmdlcyB0aGUgY3VycmVudCB0aGVtZS5cXG5cXG5JZiBUSEVNRU5BTUUgaXMgYW55IG9mIHRoZSB0aGVtZXMgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIFtUcmlkYWN0eWwgcmVwb10oaHR0cHM6Ly9naXRodWIuY29tL3RyaWRhY3R5bC90cmlkYWN0eWwvdHJlZS9tYXN0ZXIvc3JjL3N0YXRpYy90aGVtZXMpIChlLmcuICdkYXJrJyksIHRoZSB0aGVtZSB3aWxsIGJlIGxvYWRlZCBmcm9tIFRyaWRhY3R5bCdzIGludGVybmFsIHN0b3JhZ2UuXFxuXFxuSWYgVEhFTUVOQU1FIGlzIHNldCB0byBhbnkgb3RoZXIgdmFsdWUsIFRyaWRhY3R5bCB3aWxsIGF0dGVtcHQgdG8gdXNlIGl0cyBuYXRpdmUgYmluYXJ5IChzZWUgW1tuYXRpdmVdXSkgaW4gb3JkZXIgdG8gbG9hZCBhIENTUyBmaWxlIG5hbWVkIFRIRU1FTkFNRSBmcm9tIGRpc2suIFRoZSBDU1MgZmlsZSBoYXMgdG8gYmUgaW4gYSBkaXJlY3RvcnkgbmFtZWQgXFxcInRoZW1lc1xcXCIgYW5kIHRoaXMgZGlyZWN0b3J5IGhhcyB0byBiZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkgYXMgeW91ciB0cmlkYWN0eWxyYy5cXG5cXG5Ob3RlIHRoYXQgdGhlIHRoZW1lIG5hbWUgc2hvdWxkIE5PVCBjb250YWluIGFueSBkb3QuXFxuXFxuRXhhbXBsZTogYDpjb2xvdXJzY2hlbWUgbXlzdXBlcnRoZW1lYFxcbk9uIGxpbnV4LCB0aGlzIHdpbGwgbG9hZCB+Ly5jb25maWcvdHJpZGFjdHlsL3RoZW1lcy9teXN1cGVydGhlbWUuY3NzXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wic2V0cHJlZlwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJXcml0ZSBhIHNldHRpbmcgdG8geW91ciB1c2VyLmpzIGZpbGUuXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksbmV3IEFycmF5VHlwZShuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCB0cnVlLCBmYWxzZSldLCBuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJmaXhhbW9fcXVpZXRcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiTGlrZSBbW2ZpeGFtb11dIGJ1dCBxdWlldGVyLlxcblxcbk5vdyBwdXJlbHkgYSBwbGFjZWJvIGFzIFtbZml4YW1vXV0gaGFzIGJlZW4gcmVtb3ZlZC5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IEFueVR5cGUodHJ1ZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImZpeGFtb1wiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJVc2VkIHRvIHNpbXBseSBzZXRcXG5gYGBqc1xcbiAgXFxcInByaXZhY3kucmVzaXN0RmluZ2VycHJpbnRpbmcuYmxvY2tfbW96QWRkb25NYW5hZ2VyXFxcIjp0cnVlXFxuICBcXFwiZXh0ZW5zaW9ucy53ZWJleHRlbnNpb25zLnJlc3RyaWN0ZWREb21haW5zXFxcIjpcXFwiXFxcIlxcbmBgYFxcbmluIGFib3V0OmNvbmZpZyB2aWEgdXNlci5qcyBzbyB0aGF0IFRyaWRhY3R5bCAoYW5kIG90aGVyIGV4dGVuc2lvbnMhKSBjYW4gYmUgdXNlZCBvbiBhZGRvbnMubW96aWxsYS5vcmcgYW5kIG90aGVyIHNpdGVzLlxcblxcblJlbW92ZWQgYXQgdGhlIHJlcXVlc3Qgb2YgdGhlIEZpcmVmb3ggU2VjdXJpdHkgdGVhbS4gUmVwbGFjZW1lbnRzIGV4aXN0IGluIG91ciBleGVtcGxhciBSQyBmaWxlLlxcblxcblJlcXVpcmVzIGBuYXRpdmVgIGFuZCBhIGByZXN0YXJ0YC5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wibmF0aXZlb3BlblwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJVc2VzIHRoZSBuYXRpdmUgbWVzc2VuZ2VyIHRvIG9wZW4gVVJMcy5cXG5cXG4qKkJlICpzZXJpb3VzbHkqIGNhcmVmdWwgd2l0aCB0aGlzOioqXFxuXFxuMS4gdGhlIGltcGxlbWVudGF0aW9uIGJhc2ljYWxseSBleGVjcyBgZmlyZWZveCAtLW5ldy10YWIgPHlvdXIgc2hlbGwgZXNjYXBlZCBzdHJpbmcgaGVyZT5gXFxuMi4geW91IGNhbiB1c2UgaXQgdG8gb3BlbiBhbnkgVVJMIHlvdSBjYW4gb3BlbiBpbiB0aGUgRmlyZWZveCBhZGRyZXNzIGJhcixcXG4gICAgaW5jbHVkaW5nIG9uZXMgdGhhdCBtaWdodCBjYXVzZSBzaWRlIGVmZmVjdHMgKGZpcmVmb3ggZG9lcyBub3QgZ3VhcmFudGVlXFxuICAgIHRoYXQgYWJvdXQ6IHBhZ2VzIGlnbm9yZSBxdWVyeSBzdHJpbmdzKS5cXG5cXG5Zb3UndmUgYmVlbiB3YXJuZWQuXFxuXFxuVGhpcyB1c2VzIHRoZSBbW2Jyb3dzZXJdXSBzZXR0aW5nIHRvIGtub3cgd2hpY2ggYmluYXJ5IHRvIGNhbGwuIElmIHlvdSBuZWVkIHRvIHBhc3MgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gZmlyZWZveCAoZS5nLiAnLS1uZXctd2luZG93JyksIG1ha2Ugc3VyZSB0aGV5IGFwcGVhciBiZWZvcmUgdGhlIHVybC5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IEFycmF5VHlwZShuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCB0cnVlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJleGNsYWltXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlJ1biBjb21tYW5kIGluIC9iaW4vc2ggKHVubGVzcyB5b3UncmUgb24gV2luZG93cyksIGFuZCBwcmludCB0aGUgb3V0cHV0IGluIHRoZSBjb21tYW5kIGxpbmUuIE5vbi16ZXJvIGV4aXQgY29kZXMgYW5kIHN0ZGVyciBhcmUgaWdub3JlZCwgY3VycmVudGx5LlxcblxcblJlcXVpcmVzIHRoZSBuYXRpdmUgbWVzc2VuZ2VyLCBvYnZpb3VzbHkuXFxuXFxuSWYgeW91IHdhbnQgdG8gdXNlIGEgZGlmZmVyZW50IHNoZWxsLCBqdXN0IHByZXBlbmQgeW91ciBjb21tYW5kIHdpdGggd2hhdGV2ZXIgdGhlIGludm9jYXRpb24gaXMgYW5kIGtlZXAgaW4gbWluZCB0aGF0IG1vc3Qgc2hlbGxzIHJlcXVpcmUgcXVvdGVzIGFyb3VuZCB0aGUgY29tbWFuZCB0byBiZSBleGVjdXRlZCwgZS5nLiBgOmV4Y2xhaW0geG9uc2ggLWMgXFxcIjErMlxcXCJgLlxcblxcbkFsaWFzZWQgdG8gYCFgIGJ1dCB0aGUgZXhjbGFtYXRpb24gbWFyayAqKm11c3QgYmUgZm9sbG93ZWQgd2l0aCBhIHNwYWNlKiouXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBBcnJheVR5cGUobmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgdHJ1ZSwgZmFsc2UpXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiZXhjbGFpbV9xdWlldFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJMaWtlIGV4Y2xhaW0sIGJ1dCB3aXRob3V0IGFueSBvdXRwdXQgdG8gdGhlIGNvbW1hbmQgbGluZS5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IEFycmF5VHlwZShuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCB0cnVlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wibmF0aXZlXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlRlbGxzIHlvdSBpZiB0aGUgbmF0aXZlIG1lc3NlbmdlciBpcyBpbnN0YWxsZWQgYW5kIGl0cyB2ZXJzaW9uLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtdLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJuYXRpdmVpbnN0YWxsXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlNpbXBseSBjb3BpZXMgXFxcImN1cmwgLWZzU2wgaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3RyaWRhY3R5bC90cmlkYWN0eWwvbWFzdGVyL25hdGl2ZS9pbnN0YWxsLnNoIHwgYmFzaFxcXCIgdG8gdGhlIGNsaXBib2FyZCBhbmQgdGVsbHMgdGhlIHVzZXIgdG8gcnVuIGl0LlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtdLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJta3RyaWRhY3R5bHJjXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIldyaXRlcyBjdXJyZW50IGNvbmZpZyB0byBhIGZpbGUuXFxuXFxuV2l0aCBubyBhcmd1bWVudHMgc3VwcGxpZWQgdGhlIGV4Y21kIHdpbGwgdHJ5IHRvIGZpbmQgYW4gYXBwcm9wcmlhdGVcXG5jb25maWcgcGF0aCBhbmQgd3JpdGUgdGhlIHJjIGZpbGUgdG8gdGhlcmUuIEFueSBhcmd1bWVudCBnaXZlbiB0byB0aGVcXG5leGNtZCBleGNsdWRpbmcgdGhlIGAtZmAgZmxhZyB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBwYXRoIHRvIHdyaXRlIHRoZSByY1xcbmZpbGUgdG8gcmVsYXRpdmUgdG8gdGhlIG5hdGl2ZSBtZXNzZW5nZXIncyBsb2NhdGlvbiAoYH4vLmxvY2FsL3NoYXJlL3RyaWRhY3R5bC9gKS4gQnkgZGVmYXVsdCwgaXQgc2lsZW50bHkgcmVmdXNlcyB0byBvdmVyd3JpdGUgZXhpc3RpbmcgZmlsZXMuXFxuXFxuVGhlIFJDIGZpbGUgd2lsbCBiZSBzcGxpdCBpbnRvIHNlY3Rpb25zIHRoYXQgd2lsbCBiZSBjcmVhdGVkIGlmIGEgY29uZmlnXFxucHJvcGVydHkgaXMgZGlzY292ZXJlZCB3aXRoaW4gb25lIG9mIHRoZW06XFxuLSBHZW5lcmFsIHNldHRpbmdzXFxuLSBCaW5kc1xcbi0gQWxpYXNlc1xcbi0gQXV0b2NtZHNcXG4tIEF1dG9jb250YWluZXJzXFxuLSBMb2dnaW5nXFxuXFxuTm90ZTpcXG4tIFN1YmNvbmZpZyBwYXRocyBmYWxsIGJhY2sgdG8gdXNpbmcgYGpzIHRyaS5jb25maWcuc2V0KGtleTogb2JqKWAgbm90YXRpb24uXFxuLSBUaGlzIG1ldGhvZCBpcyBhbHNvIHVzZWQgYXMgYSBmYWxsYmFjayBtZWNoYW5pc20gZm9yIG9iamVjdHMgdGhhdCBkaWRuJ3QgaGl0XFxuICBhbnkgb2YgdGhlIGhldXJpc3RpY3MuXFxuXFxuQXZhaWxhYmxlIGZsYWdzOlxcbi0gYC1mYCB3aWxsIG92ZXJ3cml0ZSB0aGUgY29uZmlnIGZpbGUgaWYgaXQgZXhpc3RzLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgQXJyYXlUeXBlKG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIHRydWUsIGZhbHNlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBBbnlUeXBlKHRydWUsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJzb3VyY2VcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiUnVucyBhbiBSQyBmaWxlIGZyb20gZGlzay5cXG5cXG5JZiBubyBhcmd1bWVudCBnaXZlbiwgaXQgd2lsbCB0cnkgdG8gb3BlbiB+Ly50cmlkYWN0eWxyYywgfi8uY29uZmlnL3RyaWRhY3R5bC90cmlkYWN0eWxyYyBvciAkWERHX0NPTkZJR19IT01FL3RyaWRhY3R5bC90cmlkYWN0eWxyYyBpbiByZXZlcnNlIG9yZGVyLiBZb3UgbWF5IHVzZSBhIGBfYCBpbiBwbGFjZSBvZiBhIGxlYWRpbmcgYC5gIGlmIHlvdSB3aXNoLCBlLmcsIGlmIHlvdSB1c2UgV2luZG93cy5cXG5cXG5PbiBXaW5kb3dzLCB0aGUgYH5gIGV4cGFuZHMgdG8gYCVVU0VSUFJPRklMRSVgLlxcblxcblRoZSBSQyBmaWxlIGlzIGp1c3QgYSBidW5jaCBvZiBUcmlkYWN0eWwgZXhjbWRzIChpLmUsIHRoZSBzdHVmZiBvbiB0aGlzIGhlbHAgcGFnZSkuIFNldHRpbmdzIHBlcnNpc3QgaW4gbG9jYWwgc3RvcmFnZTsgYWRkIGBzYW5pdGlzZSB0cmlkYWN0eWxsb2NhbCB0cmlkYWN0eWxzeW5jYCB0byBtYWtlIGl0IG1vcmUgVmltIGxpa2UuIFRoZXJlJ3MgYW4gW2V4YW1wbGUgZmlsZV0oaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NtY2FpbmUvdHJpZGFjdHlsL21hc3Rlci8udHJpZGFjdHlscmMpIGlmIHlvdSB3YW50IGl0LlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgQXJyYXlUeXBlKG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIHRydWUsIGZhbHNlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInNvdXJjZV9xdWlldFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJTYW1lIGFzIFtbc291cmNlXV0gYnV0IHN1cHByZXNzZXMgYWxsIGVycm9yc1wiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgQXJyYXlUeXBlKG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIHRydWUsIGZhbHNlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInVwZGF0ZW5hdGl2ZVwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJVcGRhdGVzIHRoZSBuYXRpdmUgbWVzc2VuZ2VyIGlmIGl0IGlzIGluc3RhbGxlZCwgdXNpbmcgb3VyIEdpdEh1YiByZXBvLiBUaGlzIGlzIHJ1biBldmVyeSB0aW1lIFRyaWRhY3R5bCBpcyB1cGRhdGVkLlxcblxcbklmIHlvdSB3YW50IHRvIGRpc2FibGUgdGhpcywgb3IgcG9pbnQgaXQgdG8geW91ciBvd24gbmF0aXZlIG1lc3NlbmdlciwgZWRpdCB0aGUgYG5hdGl2ZWluc3RhbGxjbWRgIHNldHRpbmcuXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBCb29sZWFuVHlwZShmYWxzZSwgdHJ1ZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJyZXN0YXJ0XCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlJlc3RhcnRzIGZpcmVmb3ggd2l0aCB0aGUgc2FtZSBjb21tYW5kbGluZSBhcmd1bWVudHMuXFxuXFxuV2FybmluZzogVGhpcyBjYW4ga2lsbCB5b3VyIHRhYnMsIGVzcGVjaWFsbHkgaWYgeW91IDpyZXN0YXJ0IHNldmVyYWwgdGltZXNcXG5pbiBhIHJvd1wiLCBuZXcgRnVuY3Rpb25UeXBlKFtdLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJzYXZlYXNcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiRG93bmxvYWQgdGhlIGN1cnJlbnQgZG9jdW1lbnQuXFxuXFxuSWYgeW91IGhhdmUgdGhlIG5hdGl2ZSBtZXNzZW5nZXIgdj49MC4xLjkgaW5zdGFsbGVkLCB0aGUgZnVuY3Rpb24gYWNjZXB0cyBvbmUgb3B0aW9uYWwgYXJndW1lbnQsIGZpbGVuYW1lLCB3aGljaCBjYW4gYmU6XFxuLSBBbiBhYnNvbHV0ZSBwYXRoXFxuLSBBIHBhdGggc3RhcnRpbmcgd2l0aCB+LCB3aGljaCB3aWxsIGJlIGV4cGFuZGVkIHRvIHlvdXIgaG9tZSBkaXJlY3RvcnlcXG4tIEEgcmVsYXRpdmUgcGF0aCwgcmVsYXRpdmUgdG8gdGhlIG5hdGl2ZSBtZXNzZW5nZXIgZXhlY3V0YWJsZSAoZS5nLiB+Ly5sb2NhbC9zaGFyZS90cmlkYWN0eWwgb24gbGludXgpLlxcbklmIGZpbGVuYW1lIGlzIG5vdCBnaXZlbiwgYSBkb3dubG9hZCBkaWFsb2d1ZSB3aWxsIGJlIG9wZW5lZC4gSWYgZmlsZW5hbWUgaXMgYSBkaXJlY3RvcnksIHRoZSBmaWxlIHdpbGwgYmUgc2F2ZWQgaW5zaWRlIG9mIGl0LCBpdHMgbmFtZSBiZWluZyBpbmZlcnJlZCBmcm9tIHRoZSBVUkwuIElmIHRoZSBkaXJlY3RvcmllcyBtZW50aW9uZWQgaW4gdGhlIHBhdGggZG8gbm90IGV4aXN0IG9yIGlmIGEgZmlsZSBhbHJlYWR5IGV4aXN0cyBhdCB0aGlzIHBhdGgsIHRoZSBmaWxlIHdpbGwgYmUga2VwdCBpbiB5b3VyIGRvd25sb2FkcyBmb2xkZXIgYW5kIGFuIGVycm9yIG1lc3NhZ2Ugd2lsbCBiZSBnaXZlbi5cXG5cXG4qKk5CKio6IGlmIGEgbm9uLWRlZmF1bHQgc2F2ZSBsb2NhdGlvbiBpcyBjaG9zZW4sIEZpcmVmb3gncyBkb3dubG9hZCBtYW5hZ2VyIHdpbGwgc2F5IHRoZSBmaWxlIGlzIG1pc3NpbmcuIEl0IGlzIG5vdCAtIGl0IGlzIHdoZXJlIHlvdSBhc2tlZCBpdCB0byBiZSBzYXZlZC5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IEFycmF5VHlwZShuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCB0cnVlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1widGFiU2V0QWN0aXZlXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgTnVtYmVyVHlwZShmYWxzZSwgZmFsc2UpXSwgbmV3IEFueVR5cGUodHJ1ZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCB0cnVlKV0sXG5bXCJnZXRKdW1wUGFnZUlkXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlRoaXMgaXMgdXNlZCBhcyBhbiBJRCBmb3IgdGhlIGN1cnJlbnQgcGFnZSBpbiB0aGUganVtcGxpc3QuXFxuSXQgaGFzIGEgcG90ZW50aWFsbHkgY29uZnVzaW5nIGJlaGF2aW9yOiBpZiB5b3UgdmlzaXQgc2l0ZSBBLCB0aGVuIHNpdGUgQiwgdGhlbiB2aXNpdCBzaXRlIEEgYWdhaW4sIHRoZSBqdW1wbGlzdCB0aGF0IHdhcyBjcmVhdGVkIGZvciB5b3VyIGZpcnN0IHZpc2l0IG9uIEEgd2lsbCBiZSByZS11c2VkIGZvciB5b3VyIHNlY29uZCB2aXNpdC5cXG5BbiBpZGVhbCBzb2x1dGlvbiB3b3VsZCBiZSB0byBoYXZlIGEgY291bnRlciB0aGF0IGlzIGluY3JlbWVudGVkIGV2ZXJ5IHRpbWUgYSBuZXcgcGFnZSBpcyB2aXNpdGVkIHdpdGhpbiB0aGUgdGFiIGFuZCB1c2UgdGhhdCBhcyB0aGUgcmV0dXJuIHZhbHVlIGZvciBnZXRKdW1wUGFnZUlkIGJ1dCB0aGlzIGRvZXNuJ3Qgc2VlbSB0byBiZSB0cml2aWFsIHRvIGltcGxlbWVudC5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbXSwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgdHJ1ZSldLFxuW1wic2F2ZUp1bXBzXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIHRydWUpXSxcbltcImN1ckp1bXBzXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlJldHVybnMgYSBwcm9taXNlIGZvciBhbiBvYmplY3QgY29udGFpbmluZyB0aGUganVtcGxpc3Qgb2YgYWxsIHBhZ2VzIGFjY2Vzc2VkIGluIHRoZSBjdXJyZW50IHRhYi5cXG5UaGUga2V5cyBvZiB0aGUgb2JqZWN0IGN1cnJlbnRseSBhcmUgdGhlIHBhZ2UncyBVUkwsIGhvd2V2ZXIgdGhpcyBtaWdodCBjaGFuZ2Ugc29tZSBkYXkuIFVzZSBbW2dldEp1bXBQYWdlSWRdXSB0byBhY2Nlc3MgdGhlIGp1bXBsaXN0IG9mIGEgc3BlY2lmaWMgcGFnZS5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IEFueVR5cGUodHJ1ZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgdHJ1ZSldLFxuW1wianVtcG5leHRcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiQ2FsbHMgW1tqdW1wcHJldl1dKC1uKVwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgTnVtYmVyVHlwZShmYWxzZSwgdHJ1ZSldLCBuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImp1bXBwcmV2XCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlNpbWlsYXIgdG8gUGVudGFkYWN0eWwgb3IgdmltJ3MganVtcCBsaXN0LlxcblxcbldoZW4geW91IHNjcm9sbCBvbiBhIHBhZ2UsIGVpdGhlciBieSB1c2luZyB0aGUgbW91c2Ugb3IgVHJpZGFjdHlsJ3Mga2V5IGJpbmRpbmdzLCB5b3VyIHBvc2l0aW9uIGluIHRoZSBwYWdlIHdpbGwgYmUgc2F2ZWQgYWZ0ZXIganVtcGRlbGF5IG1pbGxpc2Vjb25kcyAoYDpnZXQganVtcGRlbGF5YCB0byBrbm93IGhvdyBtYW55IG1pbGxpc2Vjb25kcyB0aGF0IGlzKS4gSWYgeW91IHNjcm9sbCBhZ2FpbiwgeW91J2xsIGJlIGFibGUgdG8gZ28gYmFjayB0byB5b3VyIHByZXZpb3VzIHBvc2l0aW9uIGJ5IHVzaW5nIGA6anVtcHByZXYgMWAuIElmIHlvdSBuZWVkIHRvIGdvIGZvcndhcmQgaW4gdGhlIGp1bXBsaXN0LCB1c2UgYDpqdW1wcHJldiAtMWAuXFxuXFxuS25vd24gYnVnOiBUcmlkYWN0eWwgd2lsbCB1c2UgdGhlIHNhbWUganVtcGxpc3QgZm9yIG11bHRpcGxlIHZpc2l0cyB0byBhIHNhbWUgd2Vic2l0ZSBpbiB0aGUgc2FtZSB0YWIsIHNlZSBbZ2l0aHViIGlzc3VlIDgzNF0oaHR0cHM6Ly9naXRodWIuY29tL3RyaWRhY3R5bC90cmlkYWN0eWwvaXNzdWVzLzgzNCkuXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBOdW1iZXJUeXBlKGZhbHNlLCB0cnVlKV0sIG5ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiYWRkSnVtcFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJDYWxsZWQgb24gJ3Njcm9sbCcgZXZlbnRzLlxcbklmIHlvdSB3YW50IHRvIGhhdmUgYSBmdW5jdGlvbiB0aGF0IG1vdmVzIHdpdGhpbiB0aGUgcGFnZSBidXQgZG9lc24ndCBhZGQgYVxcbmxvY2F0aW9uIHRvIHRoZSBqdW1wbGlzdCwgbWFrZSBzdXJlIHRvIHNldCBKVU1QRUQgdG8gdHJ1ZSBiZWZvcmUgbW92aW5nXFxuYXJvdW5kLlxcblRoZSBzZXRUaW1lb3V0IGNhbGwgaXMgcmVxdWlyZWQgYmVjYXVzZSBzb21ldGltZXMgYSB1c2VyIHdhbnRzIHRvIG1vdmVcXG5zb21ld2hlcmUgYnkgcHJlc3NpbmcgJ2onIG11bHRpcGxlIHRpbWVzIGFuZCB3ZSBkb24ndCB3YW50IHRvIGFkZCB0aGVcXG5pbi1iZXR3ZWVuIGxvY2F0aW9ucyB0byB0aGUganVtcCBsaXN0XCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlVJRXZlbnRcIiwgW10sIGZhbHNlLCBmYWxzZSldLCBuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgdHJ1ZSldLFxuW1widW5mb2N1c1wiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJCbHVyICh1bmZvY3VzKSB0aGUgYWN0aXZlIGVsZW1lbnRcIiwgbmV3IEZ1bmN0aW9uVHlwZShbXSwgbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJzY3JvbGxweFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJTY3JvbGxzIHRoZSB3aW5kb3cgb3IgYW55IHNjcm9sbGFibGUgY2hpbGQgZWxlbWVudCBieSBhIHBpeGVscyBvbiB0aGUgaG9yaXpvbnRhbCBheGlzIGFuZCBiIHBpeGVscyBvbiB0aGUgdmVydGljYWwgYXhpcy5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IE51bWJlclR5cGUoZmFsc2UsIGZhbHNlKSxuZXcgTnVtYmVyVHlwZShmYWxzZSwgZmFsc2UpXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wic2Nyb2xsdG9cIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiSWYgdHdvIG51bWJlcnMgYXJlIGdpdmVuLCB0cmVhdCBhcyB4IGFuZCB5IHZhbHVlcyB0byBnaXZlIHRvIHdpbmRvdy5zY3JvbGxUb1xcbklmIG9uZSBudW1iZXIgaXMgZ2l2ZW4sIHNjcm9sbCB0byB0aGF0IHBlcmNlbnRhZ2UgYWxvbmcgYSBjaG9zZW4gYXhpcywgZGVmYXVsdGluZyB0byB0aGUgeS1heGlzLiBJZiB0aGUgbnVtYmVyIGhhcyAnYycgYXBwZW5kZWQgdG8gaXQsIGl0IHdpbGwgYmUgaW50ZXJwcmV0ZWQgaW4gcmFkaWFucy5cXG5cXG5Ob3RlIHRoYXQgaWYgYGFgIGlzIDAgb3IgMTAwIGFuZCBpZiB0aGUgZG9jdW1lbnQgaXMgbm90IHNjcm9sbGFibGUgaW4gdGhlIGdpdmVuIGRpcmVjdGlvbiwgVHJpZGFjdHlsIHdpbGwgYXR0ZW1wdCB0byBzY3JvbGwgdGhlIGZpcnN0IHNjcm9sbGFibGUgZWxlbWVudCB1bnRpbCBpdCByZWFjaGVzIHRoZSB2ZXJ5IGJvdHRvbSBvZiB0aGF0IGVsZW1lbnQuXFxuXFxuRXhhbXBsZXM6XFxuXFxuLSBgc2Nyb2xsdG8gNTBgIC0+IHNjcm9sbCBoYWxmd2F5IGRvd24gdGhlIHBhZ2UuXFxuLSBgc2Nyb2xsdG8gMy4xNGNgIC0+IHNjcm9sbCBhcHByb3hpbWF0ZWx5IDQ5Ljk3NDY1MjEzJSBvZiB0aGUgd2F5IGRvd24gdGhlIHBhZ2UuXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBVbmlvblR5cGUoW25ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksXG5uZXcgTnVtYmVyVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSxuZXcgVW5pb25UeXBlKFtuZXcgTnVtYmVyVHlwZShmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcInhcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJ5XCIsIGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgdHJ1ZSldLCBuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInNjcm9sbGxpbmVcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiU2Nyb2xscyB0aGUgZG9jdW1lbnQgb2YgaXRzIGZpcnN0IHNjcm9sbGFibGUgY2hpbGQgZWxlbWVudCBieSBuIGxpbmVzLlxcblxcblRoZSBoZWlnaHQgb2YgYSBsaW5lIGlzIGRlZmluZWQgYnkgdGhlIHNpdGUncyBDU1MuIElmIFRyaWRhY3R5bCBjYW4ndCBnZXQgaXQsIGl0J2xsIGRlZmF1bHQgdG8gMjIgcGl4ZWxzLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgTnVtYmVyVHlwZShmYWxzZSwgdHJ1ZSldLCBuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInNjcm9sbHBhZ2VcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiU2Nyb2xscyB0aGUgZG9jdW1lbnQgYnkgbiBwYWdlcy5cXG5cXG5UaGUgaGVpZ2h0IG9mIGEgcGFnZSBpcyB0aGUgY3VycmVudCBoZWlnaHQgb2YgdGhlIHdpbmRvdy5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IE51bWJlclR5cGUoZmFsc2UsIHRydWUpXSwgbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJmaW5kXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlJ1ZGltZW50YXJ5IGZpbmQgbW9kZSwgbGVmdCB1bmJvdW5kIGJ5IGRlZmF1bHQgYXMgd2UgZG9uJ3QgY3VycmVudGx5IHN1cHBvcnQgYGluY3NlYXJjaGAuIFN1Z2dlc3RlZCBiaW5kczpcXG5cXG4gICAgIGJpbmQgLyBmaWxsY21kbGluZSBmaW5kXFxuICAgICBiaW5kID8gZmlsbGNtZGxpbmUgZmluZCAtP1xcbiAgICAgYmluZCBuIGZpbmRuZXh0IDFcXG4gICAgIGJpbmQgTiBmaW5kbmV4dCAtMVxcbiAgICAgYmluZCAsPFNwYWNlPiBub2hsc2VhcmNoXFxuXFxuQXJndW1lbnQ6IEEgc3RyaW5nIHlvdSB3YW50IHRvIHNlYXJjaCBmb3IuXFxuXFxuVGhpcyBmdW5jdGlvbiBhY2NlcHRzIHR3byBmbGFnczogYC0/YCB0byBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIHJhdGhlciB0aGFuIHRoZSB0b3AgYW5kIGAtOiBuYCB0byBqdW1wIGRpcmVjdGx5IHRvIHRoZSBudGggbWF0Y2guXFxuXFxuVGhlIGJlaGF2aW9yIG9mIHRoaXMgZnVuY3Rpb24gaXMgYWZmZWN0ZWQgYnkgdGhlIGZvbGxvd2luZyBzZXR0aW5nOlxcblxcbmBmaW5kY2FzZWA6IGVpdGhlciBcXFwic21hcnRcXFwiLCBcXFwic2Vuc2l0aXZlXFxcIiBvciBcXFwiaW5zZW5zaXRpdmVcXFwiLiBJZiBcXFwic21hcnRcXFwiLCBmaW5kIHdpbGwgYmUgY2FzZS1zZW5zaXRpdmUgaWYgdGhlIHBhdHRlcm4gY29udGFpbnMgdXBwZXJjYXNlIGxldHRlcnMuXFxuXFxuS25vd24gYnVnczogZmluZCB3aWxsIGN1cnJlbnRseSBoYXBwaWx5IGp1bXAgdG8gYSBub24tdmlzaWJsZSBlbGVtZW50LCBhbmQgcHJlc3NpbmcgbiBvciBOIHdpdGhvdXQgaGF2aW5nIHNlYXJjaGVkIGZvciBhbnl0aGluZyB3aWxsIGNhdXNlIGFuIGVycm9yLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgQXJyYXlUeXBlKG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIHRydWUsIGZhbHNlKV0sIG5ldyBBbnlUeXBlKHRydWUsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImZpbmRuZXh0XCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkp1bXAgdG8gdGhlIG5leHQgc2VhcmNoZWQgcGF0dGVybi5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IE51bWJlclR5cGUoZmFsc2UsIHRydWUpXSwgbmV3IEFueVR5cGUodHJ1ZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiY2xlYXJzZWFyY2hoaWdobGlnaHRcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiXCIsIG5ldyBGdW5jdGlvblR5cGUoW10sIG5ldyBBbnlUeXBlKHRydWUsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImhpc3RvcnlcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBOdW1iZXJUeXBlKGZhbHNlLCBmYWxzZSldLCBuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgdHJ1ZSldLFxuW1wiZm9yd2FyZFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJOYXZpZ2F0ZSBmb3J3YXJkIG9uZSBwYWdlIGluIGhpc3RvcnkuXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBOdW1iZXJUeXBlKGZhbHNlLCB0cnVlKV0sIG5ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiYmFja1wiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJOYXZpZ2F0ZSBiYWNrIG9uZSBwYWdlIGluIGhpc3RvcnkuXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBOdW1iZXJUeXBlKGZhbHNlLCB0cnVlKV0sIG5ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wicmVsb2FkXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlJlbG9hZCB0aGUgbmV4dCBuIHRhYnMsIHN0YXJ0aW5nIHdpdGggYWN0aXZlVGFiLCBwb3NzaWJseSBieXBhc3NpbmdDYWNoZVwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgTnVtYmVyVHlwZShmYWxzZSwgdHJ1ZSksbmV3IEJvb2xlYW5UeXBlKGZhbHNlLCB0cnVlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInJlbG9hZGFsbFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJSZWxvYWRzIGFsbCB0YWJzLCBieXBhc3NpbmcgdGhlIGNhY2hlIGlmIGhhcmQgaXMgc2V0IHRvIHRydWVcIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IEJvb2xlYW5UeXBlKGZhbHNlLCB0cnVlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInJlbG9hZGFsbGJ1dFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJSZWxvYWRzIGFsbCB0YWJzIGV4Y2VwdCB0aGUgY3VycmVudCBvbmUsIGJ5cGFzc2luZyB0aGUgY2FjaGUgaWYgaGFyZCBpcyBzZXQgdG8gdHJ1ZVwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgQm9vbGVhblR5cGUoZmFsc2UsIHRydWUpXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wicmVsb2FkaGFyZFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJSZWxvYWQgdGhlIG5leHQgbiB0YWJzLCBzdGFydGluZyB3aXRoIGFjdGl2ZVRhYi4gYnlwYXNzIGNhY2hlIGZvciBhbGxcIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IE51bWJlclR5cGUoZmFsc2UsIHRydWUpXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wib3BlblwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJPcGVuIGEgbmV3IHBhZ2UgaW4gdGhlIGN1cnJlbnQgdGFiLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgQXJyYXlUeXBlKG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIHRydWUsIGZhbHNlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImJtYXJrc1wiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJXb3JrcyBleGFjdGx5IGxpa2UgW1tvcGVuXV0sIGJ1dCBvbmx5IHN1Z2dlc3RzIGJvb2ttYXJrcy5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSxuZXcgQXJyYXlUeXBlKG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIHRydWUsIGZhbHNlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBBbnlUeXBlKHRydWUsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJvcGVuX3F1aWV0XCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkxpa2UgW1tvcGVuXV0gYnV0IGRvZXNuJ3QgbWFrZSBhIG5ldyBlbnRyeSBpbiBoaXN0b3J5LlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgQXJyYXlUeXBlKG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIHRydWUsIGZhbHNlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBBbnlUeXBlKHRydWUsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJ1cmwyYXJnc1wiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJJZiB0aGUgdXJsIG9mIHRoZSBjdXJyZW50IGRvY3VtZW50IG1hdGNoZXMgb25lIG9mIHlvdXIgc2VhcmNoIGVuZ2luZXMsIHdpbGwgY29udmVydCBpdCB0byBhIGxpc3Qgb2YgYXJndW1lbnRzIHRoYXQgb3Blbi90YWJvcGVuIHdpbGwgdW5kZXJzdGFuZC4gSWYgdGhlIHVybCBkb2Vzbid0IG1hdGNoIGFueSBzZWFyY2ggZW5naW5lLCByZXR1cm5zIHRoZSB1cmwgd2l0aG91dCBtb2RpZmljYXRpb25zLlxcblxcbkZvciBleGFtcGxlLCBpZiB5b3UgaGF2ZSBzZWFyY2h1cmxzLmdpIHNldCB0byBcXFwiaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9zZWFyY2g/cT0lcyZ0Ym09aXNjaFxcXCIsIHVzaW5nIHRoaXMgZnVuY3Rpb24gb24gYSBwYWdlIHlvdSBvcGVuZWQgdXNpbmcgXFxcImdpIGJ1dHRlcmZsaWVzXFxcIiB3aWxsIHJldHVybiBcXFwiZ2kgYnV0dGVyZmxpZXNcXFwiLlxcblxcblRoaXMgaXMgdXNlZnVsIHdoZW4gY29tYmluZWQgd2l0aCBmaWxsY21kbGluZSwgZm9yIGV4YW1wbGUgbGlrZSB0aGlzOiBgYmluZCBPIGNvbXBvc2l0ZSB1cmwyYXJncyB8IGZpbGxjbWRsaW5lIG9wZW5gLlxcblxcbk5vdGUgdGhhdCB0aGlzIG1pZ2h0IGJyZWFrIHdpdGggc2VhcmNoIGVuZ2luZXMgdGhhdCByZWRpcmVjdCB5b3UgdG8gb3RoZXIgcGFnZXMvYWRkIEdFVCBwYXJhbWV0ZXJzIHRoYXQgZG8gbm90IGV4aXN0IGluIHlvdXIgc2VhcmNodXJsLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtdLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInJlbW92ZVNvdXJjZVwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJcIiwgbmV3IEZ1bmN0aW9uVHlwZShbXSwgbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIHRydWUpXSxcbltcInZpZXdzb3VyY2VcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiRGlzcGxheSB0aGUgKEhUTUwpIHNvdXJjZSBvZiB0aGUgY3VycmVudCBwYWdlLlxcblxcbkJlaGF2aW91ciBjYW4gYmUgY2hhbmdlZCBieSB0aGUgJ3ZpZXdzb3VyY2UnIHNldHRpbmcuXFxuXFxuSWYgdGhlICd2aWV3c291cmNlJyBzZXR0aW5nIGlzIHNldCB0byAnZGVmYXVsdCcgcmF0aGVyIHRoYW4gJ3RyaWRhY3R5bCcsXFxudGhlIHVybCB0aGUgc291cmNlIG9mIHdoaWNoIHNob3VsZCBiZSBkaXNwbGF5ZWQgY2FuIGJlIGdpdmVuIGFzIGFyZ3VtZW50Llxcbk90aGVyd2lzZSwgdGhlIHNvdXJjZSBvZiB0aGUgY3VycmVudCBkb2N1bWVudCB3aWxsIGJlIGRpc3BsYXllZC5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IFN0cmluZ1R5cGUoZmFsc2UsIHRydWUpXSwgbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJob21lXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkdvIHRvIHRoZSBob21lcGFnZXMgeW91IGhhdmUgc2V0IHdpdGggYHNldCBob21lcGFnZXMgW1xcXCJ1cmwxXFxcIiwgXFxcInVybDJcXFwiXWAuXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBVbmlvblR5cGUoW25ldyBMaXRlcmFsVHlwZVR5cGUoXCJmYWxzZVwiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcInRydWVcIiwgZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCB0cnVlKV0sIG5ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiaGVscFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJTaG93IHRoaXMgcGFnZS5cXG5cXG5gOmhlbHAgc29tZXRoaW5nYCBqdW1wcyB0byB0aGUgZW50cnkgZm9yIHNvbWV0aGluZy4gU29tZXRoaW5nIGNhbiBiZSBhbiBleGNtZCwgYW4gYWxpYXMgZm9yIGFuIGV4Y21kLCBhIGJpbmRpbmcgb3IgYSBzZXR0aW5nLlxcblxcbk9uIHRoZSBleCBjb21tYW5kIHBhZ2UsIHRoZSBcXFwibm1hcHNcXFwiIGxpc3QgaXMgYSBsaXN0IG9mIGFsbCB0aGUgYmluZGluZ3MgZm9yIHRoZSBjb21tYW5kIHlvdSdyZSBzZWVpbmcgYW5kIHRoZSBcXFwiZXhhbGlhc2VzXFxcIiBsaXN0IGxpc3RzIGFsbCBpdHMgYWxpYXNlcy5cXG5cXG5JZiB0aGVyZSdzIGEgY29uZmxpY3QgKGUuZy4geW91IGhhdmUgYSBcXFwiZ29cXFwiIGJpbmRpbmcgdGhhdCBkb2VzIHNvbWV0aGluZywgYSBcXFwiZ29cXFwiIGV4Y21kIHRoYXQgZG9lcyBzb21ldGhpbmcgZWxzZSBhbmQgYSBcXFwiZ29cXFwiIHNldHRpbmcgdGhhdCBkb2VzIGEgdGhpcmQgdGhpbmcpLCB0aGUgYmluZGluZyBpcyBjaG9zZW4gZmlyc3QsIHRoZW4gdGhlIHNldHRpbmcsIHRoZW4gdGhlIGV4Y21kLiBJbiBzdWNoIHNpdHVhdGlvbnMsIGlmIHlvdSB3YW50IHRvIGxldCBUcmlkYWN0eWwga25vdyB5b3UncmUgbG9va2luZyBmb3Igc29tZXRoaW5nIHNwZWNmaWMsIHlvdSBjYW4gc3BlY2lmeSB0aGUgZm9sbG93aW5nIGZsYWdzIGFzIGZpcnN0IGFyZ3VtZW50czpcXG5cXG5gLWFgOiBsb29rIGZvciBhbiBhbGlhc1xcbmAtYmA6IGxvb2sgZm9yIGEgYmluZGluZ1xcbmAtZWA6IGxvb2sgZm9yIGFuIGV4IGNvbW1hbmRcXG5gLXNgOiBsb29rIGZvciBhIHNldHRpbmdcXG5cXG5JZiB0aGUga2V5d29yZCB5b3UgZ2F2ZSB0byBgOmhlbHBgIGlzIGFjdHVhbGx5IGFuIGFsaWFzIGZvciBhIGNvbXBvc2l0ZSBjb21tYW5kIChzZWUgW1tjb21wb3NpdGVdXSkgLCB5b3Ugd2lsbCBiZSB0YWtlbiB0byB0aGUgaGVscCBzZWN0aW9uIGZvciB0aGUgZmlyc3QgY29tbWFuZCBvZiB0aGUgcGlwZWxpbmUuIFlvdSB3aWxsIGJlIGFibGUgdG8gc2VlIHRoZSB3aG9sZSBwaXBlbGluZSBieSBob3ZlcmluZyB5b3VyIG1vdXNlIG92ZXIgdGhlIGFsaWFzIGluIHRoZSBcXFwiZXhhbGlhc2VzXFxcIiBsaXN0LiBVbmZvcnR1bmF0ZWx5IHRoZXJlIGN1cnJlbnRseSBpcyBubyB3YXkgdG8gZGlzcGxheSB0aGVzZSBIVE1MIHRvb2x0aXBzIGZyb20gdGhlIGtleWJvYXJkLlxcblxcbmUuZy4gYDpoZWxwIGJpbmRgXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBBcnJheVR5cGUobmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgdHJ1ZSwgZmFsc2UpXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1widHV0b3JcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiU3RhcnQgdGhlIHR1dG9yaWFsXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBTdHJpbmdUeXBlKGZhbHNlLCB0cnVlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImNyZWRpdHNcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiRGlzcGxheSBUcmlkYWN0eWwncyBjb250cmlidXRvcnMgaW4gb3JkZXIgb2YgY29tbWl0cyBpbiBhIHVzZXItZnJpZW5kbHkgZmFzaGlvblwiLCBuZXcgRnVuY3Rpb25UeXBlKFtdLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJub19tb3VzZV9tb2RlXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkNvdmVyIHRoZSBjdXJyZW50IHBhZ2UgaW4gYW4gb3ZlcmxheSB0byBwcmV2ZW50IGNsaWNraW5nIG9uIGxpbmtzIHdpdGggdGhlIG1vdXNlIHRvIGZvcmNlIHlvdXJzZWxmIHRvIHVzZSBoaW50IG1vZGUuIEdldCByaWQgb2YgaXQgYnkgcmVsb2FkaW5nIHRoZSBwYWdlLlxcblxcblN1Z2dlc3RlZCB1c2FnZTogYGF1dG9jbWQgRG9jTG9hZCAuKiBub19tb3VzZV9tb2RlYFxcblxcblxcXCJUaGVyZSBpcyBubyBtb3VzZVxcXCIuXCIsIG5ldyBGdW5jdGlvblR5cGUoW10sIG5ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wibmVvX21vdXNlX21vZGVcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiTWF0cml4IHZhcmlhbnQgb2YgW1tub19tb3VzZV9tb2RlXV1cXG5cXG5cXFwiVGhlcmUgaXMgbm8gbW91c2VcXFwiLlxcblxcbkNvaW5jaWRlbnRhbGx5IGFkZGVkIHRvIFRyaWRhY3R5bCBhdCB0aGUgc2FtZSB0aW1lIGFzIHdlIHJlYWNoZWQgMTMzNyBzdGFycyBvbiBHaXRIdWIuXCIsIG5ldyBGdW5jdGlvblR5cGUoW10sIG5ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wic25vd19tb3VzZV9tb2RlXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkNocmlzdG1hcyB2YXJpYW50IG9mIFtbbm9fbW91c2VfbW9kZV1dIChpZiB5b3UgbGl2ZSBpbiAkREVGQVVMVCBoZW1pc3BoZXJlKS5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbXSwgbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJmaW5kUmVsTGlua1wiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJcIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUmVnRXhwXCIsIFtdLCBmYWxzZSwgZmFsc2UpXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiSFRNTEFuY2hvckVsZW1lbnRcIiwgW10sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIHRydWUpXSxcbltcInNlbGVjdExhc3RcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJIVE1MRWxlbWVudFwiLCBbXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgdHJ1ZSldLFxuW1wiZm9sbG93cGFnZVwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJGaW5kIGEgbGlrZWx5IG5leHQvcHJldmlvdXMgbGluayBhbmQgZm9sbG93IGl0XFxuXFxuSWYgYSBsaW5rIG9yIGFuY2hvciBlbGVtZW50IHdpdGggcmVsPXJlbCBleGlzdHMsIHVzZSB0aGF0LCBvdGhlcndpc2UgZmFsbCBiYWNrIHRvOlxcblxcbiAgICAxKSBmaW5kIHRoZSBsYXN0IGFuY2hvciBvbiB0aGUgcGFnZSB3aXRoIGlubmVyVGV4dCBtYXRjaGluZyB0aGUgYXBwcm9wcmlhdGUgYGZvbGxvd3BhZ2VwYXR0ZXJuYC5cXG4gICAgMikgY2FsbCBbW3VybGluY3JlbWVudF1dIHdpdGggMSBvciAtMVxcblxcbklmIHlvdSB3YW50IHRvIHN1cHBvcnQgZS5nLiBGcmVuY2g6XFxuXFxuYGBgXFxuc2V0IGZvbGxvd3BhZ2VwYXR0ZXJucy5uZXh0IF4obmV4dHxuZXdlcnxwcm9jaGFpbilcXFxcYnzCu3w+PlxcbnNldCBmb2xsb3dwYWdlcGF0dGVybnMucHJldiBeKHByZXYoaW91cyk/fG9sZGVyfHByw6ljw6lkZW50KVxcXFxifMKrfDw8XFxuYGBgXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBVbmlvblR5cGUoW25ldyBMaXRlcmFsVHlwZVR5cGUoXCJuZXh0XCIsIGZhbHNlLCBmYWxzZSksXG5uZXcgTGl0ZXJhbFR5cGVUeXBlKFwicHJldlwiLCBmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIHRydWUpXSwgbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJ1cmxpbmNyZW1lbnRcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiSW5jcmVtZW50IHRoZSBjdXJyZW50IHRhYiBVUkxcIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IE51bWJlclR5cGUoZmFsc2UsIHRydWUpXSwgbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJ1cmxyb290XCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkdvIHRvIHRoZSByb290IGRvbWFpbiBvZiB0aGUgY3VycmVudCBVUkxcIiwgbmV3IEZ1bmN0aW9uVHlwZShbXSwgbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJ1cmxwYXJlbnRcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiR28gdG8gdGhlIHBhcmVudCBVUkwgb2YgdGhlIGN1cnJlbnQgdGFiJ3MgVVJMXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBOdW1iZXJUeXBlKGZhbHNlLCB0cnVlKV0sIG5ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1widXJsbW9kaWZ5XCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIk9wZW4gYSBVUkwgbWFkZSBieSBtb2RpZnlpbmcgdGhlIGN1cnJlbnQgVVJMXFxuXFxuVGhlcmUgYXJlIHNldmVyYWwgbW9kZXM6XFxuXFxuKiBUZXh0IHJlcGxhY2UgbW9kZTogICBgdXJsbW9kaWZ5IC10IDxvbGQ+IDxuZXc+YFxcblxcbiAgIFJlcGxhY2VzIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiB0aGUgdGV4dCBgb2xkYCB3aXRoIGBuZXdgLlxcbiAgICAgICogYGh0dHA6Ly9leGFtcGxlLmNvbWAgLT4gKGAtdCBleGEgcGV0YWApIC0+IGBodHRwOi8vcGV0YW1wbGUuY29tYFxcblxcbiogUmVnZXggcmVwbGFjbWVudCBtb2RlOiBgdXJsbW9kaWZ5IC1yIDxyZWdleHA+IDxuZXc+IFtmbGFnc11gXFxuXFxuICAgUmVwbGFjZXMgdGhlIGZpcnN0IG1hdGNoIG9mIHRoZSBgcmVnZXhwYCB3aXRoIGBuZXdgLiBZb3UgY2FuIHVzZVxcbiAgIGZsYWdzIGBpYCBhbmQgYGdgIHRvIG1hdGNoIGNhc2UtaW5zZW5zaXRpdmVseSBhbmQgdG8gbWF0Y2hcXG4gICBhbGwgaW5zdGFuY2VzIHJlc3BlY3RpdmVseVxcbiAgICAgICogYGh0dHA6Ly9leGFtcGxlLmNvbWAgLT4gKGAtciBbZWFdIFggZ2ApIC0+IGBodHRwOi8vWHhYbXBsWC5jb21gXFxuXFxuKiBRdWVyeSBzZXQgbW9kZTogYHVybG1vZGlmeSAtcyA8cXVlcnk+IDx2YWx1ZT5gXFxuXFxuICAgU2V0cyB0aGUgdmFsdWUgb2YgYSBxdWVyeSB0byBiZSBhIHNwZWNpZmljIG9uZS4gSWYgdGhlIHF1ZXJ5IGFscmVhZHlcXG4gICBleGlzdHMsIGl0IHdpbGwgYmUgcmVwbGFjZWQuXFxuICAgICAgKiBgaHR0cDovL2UuY29tP2lkPWFiY2AgLT4gKGAtcyBmb28gYmFyYCkgLT4gYGh0dHA6Ly9lLmNvbT9pZD1hYmMmZm9vPWJhclxcblxcbiogUXVlcnkgcmVwbGFjZSBtb2RlOiBgdXJsbW9kaWZ5IC1xIDxxdWVyeT4gPG5ld192YWw+YFxcblxcbiAgIFJlcGxhY2UgdGhlIHZhbHVlIG9mIGEgcXVlcnkgd2l0aCBhIG5ldyBvbmU6XFxuICAgICAgKiBgaHR0cDovL2UuY29tP2lkPWZvb2AgLT4gKGAtcSBpZCBiYXJgKSAtPiBgaHR0cDovL2UuY29tP2lkPWJhclxcblxcbiogUXVlcnkgZGVsZXRlIG1vZGU6IGB1cmxtb2RpZnkgLVEgPHF1ZXJ5PmBcXG5cXG4gICBEZWxldGVzIHRoZSBnaXZlbiBxdWVyeSAoYW5kIHRoZSB2YWx1ZSBpZiBhbnkpOlxcbiAgICAgICogYGh0dHA6Ly9lLmNvbT9pZD1mb28mcGFnZT0xYCAtPiAoYC1RIGlkYCkgLT4gYGh0dHA6Ly9lLmNvbT9wYWdlPTFgXFxuXFxuKiBHcmFmdCBtb2RlOiBgdXJsbW9kaWZ5IC1nIDxncmFmdF9wb2ludD4gPG5ld19wYXRoX3RhaWw+YFxcblxcbiAgIFxcXCJHcmFmdHNcXFwiIGEgbmV3IHRhaWwgb24gdGhlIFVSTCBwYXRoLCBwb3NzaWJseSByZW1vdmluZyBzb21lIG9mIHRoZSBvbGRcXG4gICB0YWlsLiBHcmFmdCBwb2ludCBpbmRpY2F0ZXMgd2hlcmUgdGhlIG9sZCBVUkwgaXMgdHJ1bmNhdGVkIGJlZm9yZSBhZGRpbmdcXG4gICB0aGUgbmV3IHBhdGguXFxuXFxuICAgKiBgZ3JhZnRfcG9pbnRgID49IDAgY291bnRzIHBhdGggbGV2ZWxzLCBzdGFydGluZyBmcm9tIHRoZSBsZWZ0XFxuICAgKGJlZ2lubmluZykuIDAgd2lsbCBhcHBlbmQgZnJvbSB0aGUgXFxcInJvb3RcXFwiLCBhbmQgbm8gZXhpc3RpbmcgcGF0aCB3aWxsXFxuICAgcmVtYWluLCAxIHdpbGwga2VlcCBvbmUgcGF0aCBsZXZlbCwgYW5kIHNvIG9uLlxcbiAgICogYGdyYWZ0X3BvaW50YCA8IDAgY291bnRzIGZyb20gdGhlIHJpZ2h0IChpLmUuIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnRcXG4gICBwYXRoKS4gLTEgd2lsbCBhcHBlbmQgdG8gdGhlIGV4aXN0aW5nIHBhdGgsIC0yIHdpbGwgcmVtb3ZlIHRoZSBsYXN0IHBhdGhcXG4gICBsZXZlbCwgYW5kIHNvIG9uLlxcblxcbiAgIGBgYHRleHRcXG4gICBodHRwOi8vd2Vic2l0ZS5jb20vdGhpcy9pcy90aGUvcGF0aC9jb21wb25lbnRcXG4gICBHcmFmdCBwb2ludDogICAgICAgXiAgICBeICBeICAgXiAgICBeICAgICAgICBeXFxuICAgRnJvbSBsZWZ0OiAgICAgICAgIDAgICAgMSAgMiAgIDMgICAgNCAgICAgICAgNVxcbiAgIEZyb20gcmlnaHQ6ICAgICAgIC02ICAgLTUgLTQgIC0zICAgLTIgICAgICAgLTFcXG4gICBgYGBcXG5cXG4gICBFeGFtcGxlczpcXG5cXG4gICAqIGBodHRwOi8vZS5jb20vaXNzdWVzLzQyYCAtPiAoYC1nIDAgZm9vYCkgLT4gYGh0dHA6Ly9lLmNvbS9mb29gXFxuICAgKiBgaHR0cDovL2UuY29tL2lzc3Vlcy80MmAgLT4gKGAtZyAxIGZvb2ApIC0+IGBodHRwOi8vZS5jb20vaXNzdWVzL2Zvb2BcXG4gICAqIGBodHRwOi8vZS5jb20vaXNzdWVzLzQyYCAtPiAoYC1nIC0xIGZvb2ApIC0+IGBodHRwOi8vZS5jb20vaXNzdWVzLzQyL2Zvb2BcXG4gICAqIGBodHRwOi8vZS5jb20vaXNzdWVzLzQyYCAtPiAoYC1nIC0yIGZvb2ApIC0+IGBodHRwOi8vZS5jb20vaXNzdWVzL2Zvb2BcIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IFVuaW9uVHlwZShbbmV3IExpdGVyYWxUeXBlVHlwZShcIi10XCIsIGZhbHNlLCBmYWxzZSksXG5uZXcgTGl0ZXJhbFR5cGVUeXBlKFwiLXJcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCItc1wiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcIi1xXCIsIGZhbHNlLCBmYWxzZSksXG5uZXcgTGl0ZXJhbFR5cGVUeXBlKFwiLVFcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCItZ1wiLCBmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSxuZXcgQXJyYXlUeXBlKG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIHRydWUsIGZhbHNlKV0sIG5ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiZ2V0dXJsc2ZvcmxpbmtzXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlJldHVybnMgdGhlIHVybCBvZiBsaW5rcyB0aGF0IGhhdmUgYSBtYXRjaGluZyByZWwuXFxuXFxuRG9uJ3QgYmluZCB0byB0aGlzOiBpdCdzIGFuIGludGVybmFsIGZ1bmN0aW9uLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIHRydWUpXSxcbltcInpvb21cIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiU2V0cyB0aGUgY3VycmVudCBwYWdlJ3Mgem9vbSBsZXZlbCBhbnl3aGVyZSBiZXR3ZWVuIDMwJSBhbmQgMzAwJS5cXG5cXG5JZiB5b3Ugb3ZlcnNob290IHRoZSBsZXZlbCB3aGlsZSB1c2luZyByZWxhdGl2ZSBhZGp1c3RtZW50cyBpLmUuIGxldmVsID4gMzAwJSBvciBsZXZlbCA8IDMwJVxcbnRoZSB6b29tIGxldmVsIHdpbGwgYmUgc2V0IHRvIGl0J3MgbWF4aW11bSBvciBtaW5pbXVtIHBvc2l0aW9uLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgTnVtYmVyVHlwZShmYWxzZSwgdHJ1ZSksbmV3IFN0cmluZ1R5cGUoZmFsc2UsIHRydWUpXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wicmVhZGVyXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIk9wZW5zIHRoZSBjdXJyZW50IHBhZ2UgaW4gRmlyZWZveCdzIHJlYWRlciBtb2RlLlxcbllvdSBjdXJyZW50bHkgY2Fubm90IHVzZSBUcmlkYWN0eWwgd2hpbGUgaW4gcmVhZGVyIG1vZGUuXCIsIG5ldyBGdW5jdGlvblR5cGUoW10sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImxvYWRhdWNtZHNcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBVbmlvblR5cGUoW25ldyBMaXRlcmFsVHlwZVR5cGUoXCJEb2NTdGFydFwiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcIkRvY0xvYWRcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJEb2NFbmRcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJUYWJFbnRlclwiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcIlRhYkxlZnRcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJGdWxsc2NyZWVuRW50ZXJcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJGdWxsc2NyZWVuTGVmdFwiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcIkZ1bGxzY3JlZW5DaGFuZ2VcIiwgZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIHRydWUpXSxcbltcImZvY3VzaW5wdXRcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiRm9jdXMgdGhlIGxhc3QgdXNlZCBpbnB1dCBvbiB0aGUgcGFnZVwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgVW5pb25UeXBlKFtuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLFxubmV3IE51bWJlclR5cGUoZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSldLCBuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImNoYW5nZWxpc3RqdW1wXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkZvY3VzIHRoZSB0YWIgd2hpY2ggY29udGFpbnMgdGhlIGxhc3QgZm9jdXNzZWQgaW5wdXQgZWxlbWVudC4gSWYgeW91J3JlIGx1Y2t5LCBpdCB3aWxsIGZvY3VzIHRoZSByaWdodCBpbnB1dCwgdG9vLlxcblxcbkN1cnJlbnRseSBqdXN0IGdvZXMgdG8gdGhlIGxhc3QgZm9jdXNzZWQgaW5wdXQ7IGJlaW5nIGFibGUgdG8ganVtcCBmb3J3YXJkcyBhbmQgYmFja3dhcmRzIGlzIHBsYW5uZWQuXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBOdW1iZXJUeXBlKGZhbHNlLCB0cnVlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImZvY3VzYnlpZFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJcIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIG5ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCB0cnVlKV0sXG5bXCJ0YWJJbmRleFNldEFjdGl2ZVwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJTd2l0Y2ggdG8gdGhlIHRhYiBieSBpbmRleCAocG9zaXRpb24gb24gdGFiIGJhciksIHdyYXBwaW5nIHJvdW5kLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgVW5pb25UeXBlKFtuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLFxubmV3IE51bWJlclR5cGUoZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCB0cnVlKV0sXG5bXCJ0YWJuZXh0XCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlN3aXRjaCB0byB0aGUgbmV4dCB0YWIsIHdyYXBwaW5nIHJvdW5kLlxcblxcbklmIGluY3JlbWVudCBpcyBzcGVjaWZpZWQsIG1vdmUgdGhhdCBtYW55IHRhYnMgZm9yd2FyZHMuXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBOdW1iZXJUeXBlKGZhbHNlLCB0cnVlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBBbnlUeXBlKHRydWUsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJ0YWJuZXh0X2d0XCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlN3aXRjaCB0byB0aGUgbmV4dCB0YWIsIHdyYXBwaW5nIHJvdW5kLlxcblxcbklmIGFuIGluZGV4IGlzIHNwZWNpZmllZCwgZ28gdG8gdGhlIHRhYiB3aXRoIHRoYXQgbnVtYmVyICh0aGlzIG1pbWljcyB0aGVcXG5iZWhhdmlvdXIgb2YgYHtjb3VudH1ndGAgaW4gdmltLCBleGNlcHQgdGhhdCB0aGlzIGNvbW1hbmQgd2lsbCBhY2NlcHQgYVxcbmNvdW50IHRoYXQgaXMgb3V0IG9mIGJvdW5kcyAoYW5kIHdpbGwgbW9kIGl0IHNvIHRoYXQgaXQgaXMgd2l0aGluIGJvdW5kcyBhc1xcbnBlciBbW3RhYm1vdmVdXSwgZXRjKSkuXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBOdW1iZXJUeXBlKGZhbHNlLCB0cnVlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInRhYnByZXZcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiU3dpdGNoIHRvIHRoZSBwcmV2aW91cyB0YWIsIHdyYXBwaW5nIHJvdW5kLlxcblxcbklmIGluY3JlbWVudCBpcyBzcGVjaWZpZWQsIG1vdmUgdGhhdCBtYW55IHRhYnMgYmFja3dhcmRzLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgTnVtYmVyVHlwZShmYWxzZSwgdHJ1ZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1widGFib3BlblwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJMaWtlIFtbb3Blbl1dLCBidXQgaW4gYSBuZXcgdGFiLiBJZiBubyBhZGRyZXNzIGlzIGdpdmVuLCBpdCB3aWxsIG9wZW4gdGhlIG5ld3RhYiBwYWdlLCB3aGljaCBjYW4gYmUgc2V0IHdpdGggYHNldCBuZXd0YWIgW3VybF1gXFxuXFxuVXNlIHRoZSBgLWNgIGZsYWcgZm9sbG93ZWQgYnkgYSBjb250YWluZXIgbmFtZSB0byBvcGVuIGEgdGFiIGluIHNhaWQgY29udGFpbmVyLiBUcmlkYWN0eWwgd2lsbCB0cnkgdG8gZnV6enkgbWF0Y2ggYSBuYW1lIGlmIGFuIGV4YWN0IG1hdGNoIGlzIG5vdCBmb3VuZC4gSWYgYW55IGF1dG9jb250YWluZXIgZGlyZWN0aXZlcyBhcmUgY29uZmlndXJlZCBhbmQgLWMgaXMgbm90IHNldCwgVHJpZGFjdHlsIHdpbGwgdHJ5IHRvIHVzZSB0aGUgcmlnaHQgY29udGFpbmVyIGF1dG9tYXRpY2FsbHkgdXNpbmcgeW91ciBjb25maWd1cmF0aW9ucy5cXG5Vc2UgdGhlIGAtYmAgZmxhZyB0byBvcGVuIHRoZSB0YWIgaW4gdGhlIGJhY2tncm91bmQuXFxuVGhlc2UgdHdvIGNhbiBiZSBjb21iaW5lZCBpbiBhbnkgb3JkZXIsIGJ1dCBuZWVkIHRvIGJlIHBsYWNlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnRzLlxcblxcblVubGlrZSBGaXJlZm94J3MgQ3RybC10IHNob3J0Y3V0LCB0aGlzIG9wZW5zIHRhYnMgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlXFxuY3VycmVudGx5IGFjdGl2ZSB0YWIgcmF0aGVyIHRoYW4gYXQgdGhlIGVuZCBvZiB0aGUgdGFiIGxpc3QgYmVjYXVzZSB0aGF0IGlzXFxudGhlIGF1dGhvcnMnIHByZWZlcmVuY2UuXFxuXFxuSWYgeW91IHdvdWxkIHJhdGhlciB0aGUgRmlyZWZveCBiZWhhdmlvdXIgYHNldCB0YWJvcGVucG9zIGxhc3RgLiBUaGlzXFxucHJlZmVyZW5jZSBhbHNvIGFmZmVjdHMgdGhlIGNsaXBib2FyZCwgcXVpY2ttYXJrcywgaG9tZSwgaGVscCwgZXRjLlxcblxcbklmIHlvdSB3b3VsZCByYXRoZXIgdGhlIFVSTCBiZSBvcGVuZWQgYXMgaWYgeW91J2QgbWlkZGxlIGNsaWNrZWQgaXQsIGBzZXRcXG50YWJvcGVucG9zIHJlbGF0ZWRgLlxcblxcbkhpbnRpbmcgaXMgY29udHJvbGxlZCBieSBgcmVsYXRlZG9wZW5wb3NgXFxuXFxuQWxzbyBzZWUgdGhlIFtbc2VhcmNoZW5naW5lXV0gYW5kIFtbc2VhcmNodXJsc11dIHNldHRpbmdzLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgQXJyYXlUeXBlKG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIHRydWUsIGZhbHNlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBBbnlUeXBlKHRydWUsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJpZEZyb21JbmRleFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJSZXNvbHZlIGEgdGFiIGluZGV4IHRvIHRoZSB0YWIgaWQgb2YgdGhlIGNvcnJlc3BvbmRpbmcgdGFiIGluIHRoaXMgd2luZG93LlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgVW5pb25UeXBlKFtuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLFxubmV3IE51bWJlclR5cGUoZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCB0cnVlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBOdW1iZXJUeXBlKGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCB0cnVlKV0sXG5bXCJ0YWJvbmx5XCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkNsb3NlIGFsbCBvdGhlciB0YWJzIGluIHRoaXMgd2luZG93XCIsIG5ldyBGdW5jdGlvblR5cGUoW10sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInRhYmR1cGxpY2F0ZVwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJEdXBsaWNhdGUgYSB0YWIuXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBOdW1iZXJUeXBlKGZhbHNlLCB0cnVlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInRhYmRldGFjaFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJEZXRhY2ggYSB0YWIsIG9wZW5pbmcgaXQgaW4gYSBuZXcgd2luZG93LlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgTnVtYmVyVHlwZShmYWxzZSwgdHJ1ZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJnZXRTb3J0ZWRXaW5UYWJzXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkdldCBsaXN0IG9mIHRhYnMgc29ydGVkIGJ5IG1vc3QgcmVjZW50IHVzZVwiLCBuZXcgRnVuY3Rpb25UeXBlKFtdLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgQXJyYXlUeXBlKG5ldyBBbnlUeXBlKHRydWUsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIHRydWUpXSxcbltcImZ1bGxzY3JlZW5cIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiVG9nZ2xlIGZ1bGxzY3JlZW4gc3RhdGVcIiwgbmV3IEZ1bmN0aW9uVHlwZShbXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1widGFiY2xvc2VcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiQ2xvc2UgYSB0YWIuXFxuXFxuS25vd24gYnVnOiBhdXRvY29tcGxldGlvbiB3aWxsIG1ha2UgaXQgaW1wb3NzaWJsZSB0byBjbG9zZSBtb3JlIHRoYW4gb25lIHRhYiBhdCBvbmNlIGlmIHRoZSBsaXN0IG9mIG51bWJlcnMgbG9va3MgZW5vdWdoIGxpa2UgYW4gb3BlbiB0YWIncyB0aXRsZSBvciBVUkwuXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBBcnJheVR5cGUobmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgdHJ1ZSwgZmFsc2UpXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1widGFiY2xvc2VhbGx0b3JpZ2h0XCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkNsb3NlIGFsbCB0YWJzIHRvIHRoZSByaWdodCBvZiB0aGUgY3VycmVudCBvbmVcIiwgbmV3IEZ1bmN0aW9uVHlwZShbXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1widGFiY2xvc2VhbGx0b2xlZnRcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiQ2xvc2UgYWxsIHRhYnMgdG8gdGhlIGxlZnQgb2YgdGhlIGN1cnJlbnQgb25lXCIsIG5ldyBGdW5jdGlvblR5cGUoW10sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInVuZG9cIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiUmVzdG9yZSB0aGUgbW9zdCByZWNlbnRseSBjbG9zZWQgaXRlbS5cXG5UaGUgZGVmYXVsdCBiZWhhdmlvdXIgaXMgdG8gcmVzdG9yZSB0aGUgbW9zdCByZWNlbnRseSBjbG9zZWQgdGFiIGluIHRoZVxcbmN1cnJlbnQgd2luZG93IHVubGVzcyB0aGUgbW9zdCByZWNlbnRseSBjbG9zZWQgaXRlbSBpcyBhIHdpbmRvdy5cXG5cXG5TdXBwbHlpbmcgZWl0aGVyIFxcXCJ0YWJcXFwiIG9yIFxcXCJ3aW5kb3dcXFwiIGFzIGFuIGFyZ3VtZW50IHdpbGwgc3BlY2lmaWNhbGx5IG9ubHlcXG5yZXN0b3JlIGFuIGl0ZW0gb2YgdGhlIHNwZWNpZmllZCB0eXBlLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgU3RyaW5nVHlwZShmYWxzZSwgdHJ1ZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgTnVtYmVyVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInRhYm1vdmVcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiTW92ZSB0aGUgY3VycmVudCB0YWIgdG8gYmUganVzdCBpbiBmcm9udCBvZiB0aGUgaW5kZXggc3BlY2lmaWVkLlxcblxcbktub3duIGJ1ZzogVGhpcyBzdXBwb3J0cyByZWxhdGl2ZSBtb3ZlbWVudCB3aXRoIGB0YWJtb3ZlICtwb3NgIGFuZCBgdGFibW92ZSAtcG9zYCwgYnV0IGF1dG9jb21wbGV0ZSBkb2Vzbid0IGtub3cgdGhhdCB5ZXQgYW5kIHdpbGwgb3ZlcnJpZGUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIGluZGV4ZXMuXFxuXFxuUHV0IGEgc3BhY2UgaW4gZnJvbnQgb2YgdGFibW92ZSBpZiB5b3Ugd2FudCB0byBkaXNhYmxlIGNvbXBsZXRpb24gYW5kIGhhdmUgdGhlIHJlbGF0aXZlIGluZGV4ZXMgYXQgdGhlIGNvbW1hbmQgbGluZS5cXG5cXG5CaW5kcyBhcmUgdW5hZmZlY3RlZC5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IFN0cmluZ1R5cGUoZmFsc2UsIHRydWUpXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wicGluXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlBpbiB0aGUgY3VycmVudCB0YWJcIiwgbmV3IEZ1bmN0aW9uVHlwZShbXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wibXV0ZVwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJNdXRlIGN1cnJlbnQgdGFiIG9yIGFsbCB0YWJzLlxcblxcblBhc3NpbmcgXFxcImFsbFxcXCIgdG8gdGhlIGV4Y21kIHdpbGwgb3BlcmF0ZSBvbiAgdGhlIG11dGUgc3RhdGUgb2YgYWxsIHRhYnMuXFxuUGFzc2luZyBcXFwidW5tdXRlXFxcIiB0byB0aGUgZXhjbWQgd2lsbCB1bm11dGUuXFxuUGFzc2luZyBcXFwidG9nZ2xlXFxcIiB0byB0aGUgZXhjbWQgd2lsbCB0b2dnbGUgdGhlIHN0YXRlIG9mIGBicm93c2VyLnRhYnMudGFiLk11dGVkSW5mb2BcIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IEFycmF5VHlwZShuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCB0cnVlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJ3aW5vcGVuXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkxpa2UgW1t0YWJvcGVuXV0sIGJ1dCBpbiBhIG5ldyB3aW5kb3cuXFxuXFxuYHdpbm9wZW4gLXByaXZhdGUgWy4uLl1gIHdpbGwgb3BlbiB0aGUgcmVzdWx0IGluIGEgcHJpdmF0ZSB3aW5kb3cgKGFuZCB3b24ndCBzdG9yZSB0aGUgY29tbWFuZCBpbiB5b3VyIGV4LWhpc3RvcnkgOykgKS5cXG5cXG5gd2lub3BlbiAtcG9wdXAgWy4uLl1gIHdpbGwgb3BlbiBpdCBpbiBhIHBvcHVwIHdpbmRvdy4gWW91IGNhbiBjb21iaW5lIHRoZSB0d28gZm9yIGEgcHJpdmF0ZSBwb3B1cC5cXG5cXG5FeGFtcGxlOiBgd2lub3BlbiAtcG9wdXAgLXByaXZhdGUgZGRnLmdnYFwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgQXJyYXlUeXBlKG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIHRydWUsIGZhbHNlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBBbnlUeXBlKHRydWUsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJ3aW5jbG9zZVwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJDbG9zZSBhIHRhYi5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IEFycmF5VHlwZShuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCB0cnVlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgQXJyYXlUeXBlKG5ldyBBbnlUeXBlKHRydWUsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJxYWxsXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkNsb3NlIGFsbCB3aW5kb3dzXCIsIG5ldyBGdW5jdGlvblR5cGUoW10sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImNvbnRhaW5lcmNsb3NlXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkNsb3NlcyBhbGwgdGFicyBvcGVuIGluIHRoZSBzYW1lIGNvbnRhaW5lciBhY3Jvc3MgYWxsIHdpbmRvd3MuXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJjb250YWluZXJjcmVhdGVcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiQ3JlYXRlcyBhIG5ldyBjb250YWluZXIuIE5vdGUgdGhhdCBjb250YWluZXIgbmFtZXMgbXVzdCBiZSB1bmlxdWUgYW5kIHRoYXQgdGhlIGNoZWNrcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZS5cXG5cXG5GdXJ0aGVyIHJlYWRpbmcgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvQWRkLW9ucy9XZWJFeHRlbnNpb25zL0FQSS9jb250ZXh0dWFsSWRlbnRpdGllcy9Db250ZXh0dWFsSWRlbnRpdHlcXG5cXG5FeGFtcGxlIHVzYWdlOlxcbiAgICAtIGA6Y29udGFpbmVyY3JlYXRlIHRyaWRhY3R5bCBncmVlbiBkb2xsYXJgXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksbmV3IFN0cmluZ1R5cGUoZmFsc2UsIHRydWUpLG5ldyBTdHJpbmdUeXBlKGZhbHNlLCB0cnVlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImNvbnRhaW5lcmRlbGV0ZVwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJEZWxldGUgYSBjb250YWluZXIuIENsb3NlcyBhbGwgdGFicyBhc3NvY2lhdGVkIHdpdGggdGhhdCBjb250YWluZXIgYmVmb3JlaGFuZC4gTm90ZTogY29udGFpbmVyIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiY29udGFpbmVydXBkYXRlXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlVwZGF0ZSBhIGNvbnRhaW5lcidzIGluZm9ybWF0aW9uLiBOb3RlIHRoYXQgbm9uZSBvZiB0aGUgcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwgYW5kIHRoYXQgY29udGFpbmVyIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlLlxcblxcbkV4YW1wbGUgdXNhZ2U6XFxuXFxuLSBDaGFuZ2luZyB0aGUgY29udGFpbmVyIG5hbWU6IGA6Y29udGFpbmVydXBkYXRlIGJhbmtpbmcgYmxvY2tjaGFpbiBncmVlbiBkb2xsYXJgXFxuXFxuLSBDaGFuZ2luZyB0aGUgY29udGFpbmVyIGljb246IGA6Y29udGFpbmVydXBkYXRlIGJhbmtpbmcgYmFua2luZyBncmVlbiBicmllZmNhc2VgXFxuXFxuLSBDaGFuZ2luZyB0aGUgY29udGFpbmVyIGNvbG9yOiBgOmNvbnRhaW5lcnVwZGF0ZSBiYW5raW5nIGJhbmtpbmcgcHVycGxlIGRvbGxhcmBcIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSxuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInZpZXdjb250YWluZXJzXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlNob3dzIGEgbGlzdCBvZiB0aGUgY3VycmVudCBjb250YWluZXJzIGluIEZpcmVmb3gncyBuYXRpdmUgSlNPTiB2aWV3ZXIgaW4gdGhlIGN1cnJlbnQgdGFiLlxcblxcbk5COiBUcmlkYWN0eWwgY2Fubm90IHJ1biBvbiB0aGlzIHBhZ2UhXCIsIG5ldyBGdW5jdGlvblR5cGUoW10sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInZlcnNpb25cIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiXCIsIG5ldyBGdW5jdGlvblR5cGUoW10sIG5ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wibW9kZVwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJTd2l0Y2ggbW9kZS5cXG5cXG5Gb3Igbm93IHlvdSBwcm9iYWJseSBzaG91bGRuJ3QgbWFudWFsbHkgc3dpdGNoIHRvIG90aGVyIG1vZGVzIHRoYW4gYG5vcm1hbGAgYW5kIGBpZ25vcmVgLiBNYWtlIHN1cmUgeW91J3JlIGF3YXJlIG9mIHRoZSBrZXkgYmluZGluZ3MgKGlnbm9yZW1hcHMpIHRoYXQgd2lsbCBhbGxvdyB5b3UgdG8gZ28gY29tZSBiYWNrIHRvIG5vcm1hbCBtb2RlIGZyb20gaWdub3JlIG1vZGUgYmVmb3JlIHlvdSBydW4gYDptb2RlIGlnbm9yZWAgb3RoZXJ3aXNlIHlvdSdyZSBnb2luZyB0byBoYXZlIGEgaGFyZCB0aW1lIHJlLWVuYWJsaW5nIFRyaWRhY3R5bC5cXG5cXG5FeGFtcGxlOlxcbiAgICAgLSBgbW9kZSBpZ25vcmVgIHRvIGlnbm9yZSBhbG1vc3QgYWxsIGtleXMuXFxuXFxuSWYgeW91J3JlIGxvb2tpbmcgZm9yIGEgd2F5IHRvIHRlbXBvcmFyaWx5IGRpc2FibGUgVHJpZGFjdHlsLCBgbW9kZSBpZ25vcmVgIG1pZ2h0IGJlIHdoYXQgeW91J3JlIGxvb2tpbmcgZm9yLlxcblxcbk5vdGUgdGhhdCB3aGVuIGluIGlnbm9yZSBtb2RlLCBUcmlkYWN0eWwgd2lsbCBub3Qgc3dpdGNoIHRvIGluc2VydCBtb2RlIHdoZW4gZm9jdXNpbmcgdGV4dCBhcmVhcy9pbnB1dHMuIFRoaXMgaXMgYnkgZGVzaWduLlxcblxcbioqTmV3IGZlYXR1cmU6KiogeW91IGNhbiBhZGQgbW9kZXMgYXMgc2ltcGx5IGFzIGFkZGluZyBiaW5kcyB3aXRoIGBiaW5kIC0tbW9kZT1bbmV3bW9kZW5hbWVdYCBhbmQgdGhlbiBlbnRlciB0aGUgbW9kZSB3aXRoIGBtb2RlIFtuZXdtb2RlbmFtZV1gLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSldLCBuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImdldG5leHR0YWJzXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgTnVtYmVyVHlwZShmYWxzZSwgZmFsc2UpLG5ldyBOdW1iZXJUeXBlKGZhbHNlLCB0cnVlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBBcnJheVR5cGUobmV3IEFueVR5cGUodHJ1ZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgdHJ1ZSldLFxuW1wicmVwZWF0XCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlJlcGVhdHMgYSBgY21kYCBgbmAgdGltZXMuXFxuSWYgYGNtZGAgZG9lc24ndCBleGlzdCwgcmUtZXhlY3V0ZXMgdGhlIGxhc3QgZXhzdHIgdGhhdCB3YXMgZXhlY3V0ZWQgaW4gdGhlIHRhYi5cXG5FeGVjdXRlcyB0aGUgY29tbWFuZCBvbmNlIGlmIGBuYCBpc24ndCBkZWZpbmVkIGVpdGhlci5cXG5cXG5UaGlzIHJlLWV4ZWN1dGVzIHRoZSBsYXN0ICpleHN0ciosIG5vdCB0aGUgbGFzdCAqZXhjbWQqLiBTb21lIGV4Y21kcyBvcGVyYXRlIGludGVybmFsbHkgYnkgY29uc3RydWN0aW5nIGFuZCBldmFsdWF0aW5nIGV4c3Rycywgb3RoZXJzIGJ5IGRpcmVjdGx5IGludm9raW5nIGV4Y21kcyB3aXRob3V0IGdvaW5nIHRocm91Z2ggdGhlIGV4c3RyIHBhcnNlci4gRm9yIGV4YW1wbGUsIGF1Y21kcyBhbmQga2V5YmluZGluZ3MgZXZhbHVhdGUgZXhzdHJzIGFuZCBhcmUgcmVwZWF0YWJsZSwgd2hpbGUgY29tbWFuZHMgbGlrZSBgOmJtYXJrc2AgZGlyZWN0bHkgaW52b2tlIGA6dGFib3BlbmAgYW5kIHlvdSdsbCByZXBlYXQgdGhlIGA6Ym1hcmtzYCByYXRoZXIgdGhhbiB0aGUgaW50ZXJuYWwgYDp0YWJvcGVuYC5cXG5cXG5JdCdzIGRpZmZpY3VsdCB0byBleGVjdXRlIHRoaXMgaW4gdGhlIGJhY2tncm91bmQgc2NyaXB0IChgOmpzYmAsIGA6cnVuX2V4Y21kYCwgYDphdXRvY21kIFRyaVN0YXJ0YCwgYDpzb3VyY2VgKSwgYnV0IGlmIHlvdSB5b3UgZG8sIGl0IHdpbGwgcmUtZXhlY3V0ZSB0aGUgbGFzdCBleHN0ciB0aGF0IHdhcyBleGVjdXRlZCBpbiB0aGUgYmFja2dyb3VuZCBzY3JpcHQuIFdoYXQgdGhpcyBtYXkgaGF2ZSBiZWVuIGlzIHVucHJlZGljdGFibGUgYW5kIG5vdCBwcmVjaXNlbHkgZW5jb3VyYWdlZC5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IE51bWJlclR5cGUoZmFsc2UsIHRydWUpLG5ldyBBcnJheVR5cGUobmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgdHJ1ZSwgZmFsc2UpXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiY29tcG9zaXRlXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlNwbGl0IGBjbWRzYCBvbiBwaXBlcyAofCkgYW5kIHRyZWF0IGVhY2ggYXMgaXRzIG93biBjb21tYW5kLiBSZXR1cm4gdmFsdWVzIGFyZSBwYXNzZWQgYXMgdGhlIGxhc3QgYXJndW1lbnQgb2YgdGhlIG5leHQgZXggY29tbWFuZCwgZS5nLFxcblxcbmBjb21wb3NpdGUgZWNobyB5ZXMgfCBmaWxsY21kbGluZWAgYmVjb21lcyBgZmlsbGNtZGxpbmUgeWVzYC4gQSBtb3JlIGNvbXBsaWNhdGVkIGV4YW1wbGUgaXMgdGhlIGV4IGFsaWFzLCBgY29tbWFuZCBjdXJyZW50X3VybCBjb21wb3NpdGUgZ2V0X2N1cnJlbnRfdXJsIHwgZmlsbGNtZGxpbmVfbm90cmFpbCBgLCB3aGljaCBpcyB1c2VkIGluLCBlLmcuIGBiaW5kIFQgY3VycmVudF91cmwgdGFib3BlbmAuXFxuXFxuV29ya2Fyb3VuZDogdGhpcyBzaG91bGQgY2xlYXJseSBiZSBpbiB0aGUgcGFyc2VyLCBidXQgd2UgaGF2ZW4ndCBjb21lIHVwIHdpdGggYSBnb29kIHdheSB0byBkZWFsIHdpdGggfHMgaW4gVVJMcywgc2VhcmNoIHRlcm1zLCBldGMuIHlldC5cXG5cXG5gY21kc2AgYXJlIGFsc28gc3BsaXQgd2l0aCBzZW1pY29sb25zICg7KSBhbmQgZG9uJ3QgcGFzcyB0aGluZ3MgYWxvbmcgdG8gZWFjaCBvdGhlci5cXG5cXG5JZiB5b3Ugd2lzaCB0byBoYXZlIGEgY29tbWFuZCB0aGF0IGhhcyBzZW1pLWNvbG9ucyBpbiBpdCAoZS5nLiBzb21lIEphdmFTY3JpcHQgb3IgYGhpbnQgLTtgKSwgZmlyc3QgYmluZCBhIFtbY29tbWFuZF1dIHRvIGl0LiBGb3IgZXhhbXBsZSwgYGNvbW1hbmQgaGludF9mb2N1cyAtO2AsIGFuZCB0aGVuIGBjb21wb3NpdGUgaGludF9mb2N1czsgIXMgeGRvdG9vbCBrZXkgTWVudWAuXFxuXFxuVGhlIGJlaGF2aW91ciBvZiBjb21iaW5pbmcgOyBhbmQgfCBpbiB0aGUgc2FtZSBjb21wb3NpdGUgY29tbWFuZCBpcyBsZWZ0IGFzIGFuIGV4ZXJjaXNlIGZvciB0aGUgcmVhZGVyLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgQXJyYXlUeXBlKG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIHRydWUsIGZhbHNlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBBbnlUeXBlKHRydWUsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJzaGVsbGVzY2FwZVwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJFc2NhcGUgY29tbWFuZCBmb3Igc2FmZSB1c2UgaW4gc2hlbGwgd2l0aCBjb21wb3NpdGUuIEUuZzogYGNvbXBvc2l0ZSBqcyBNQUxJQ0lPVVNfV0VCU0lURV9GVU5DVElPTigpIHwgc2hlbGxlc2NhcGUgfCBleGNsYWltIGxzYFwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgQXJyYXlUeXBlKG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIHRydWUsIGZhbHNlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBBbnlUeXBlKHRydWUsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJzbGVlcFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJTbGVlcCB0aW1lX21zIG1pbGxpc2Vjb25kcy5cXG5UaGlzIGlzIHByb2JhYmx5IG9ubHkgdXNlZnVsIGZvciBjb21wb3NpdGUgY29tbWFuZHMgdGhhdCBuZWVkIHRvIHdhaXQgdW50aWwgdGhlIHByZXZpb3VzIGFzeW5jaHJvbm91cyBjb21tYW5kIGhhcyBmaW5pc2hlZCBydW5uaW5nLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgTnVtYmVyVHlwZShmYWxzZSwgZmFsc2UpXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wic2hvd2NtZGxpbmVcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBCb29sZWFuVHlwZShmYWxzZSwgdHJ1ZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIHRydWUpXSxcbltcImhpZGVjbWRsaW5lXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtdLCBuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgdHJ1ZSldLFxuW1wiZmlsbGNtZGxpbmVcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiU2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBjb21tYW5kbGluZSB0byBzdHJpbmcgKndpdGgqIGEgdHJhaWxpbmcgc3BhY2VcIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IEFycmF5VHlwZShuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCB0cnVlLCBmYWxzZSldLCBuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJmaWxsY21kbGluZV9ub3RyYWlsXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlNldCB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgY29tbWFuZGxpbmUgdG8gc3RyaW5nICp3aXRob3V0KiBhIHRyYWlsaW5nIHNwYWNlXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBBcnJheVR5cGUobmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgdHJ1ZSwgZmFsc2UpXSwgbmV3IEFueVR5cGUodHJ1ZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiZmlsbGNtZGxpbmVfbm9mb2N1c1wiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJTaG93IGFuZCBmaWxsIHRoZSBjb21tYW5kIGxpbmUgd2l0aG91dCBmb2N1c2luZyBpdFwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgQXJyYXlUeXBlKG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIHRydWUsIGZhbHNlKV0sIG5ldyBBbnlUeXBlKHRydWUsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImZpbGxjbWRsaW5lX3RtcFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJTaG93cyBzdHIgaW4gdGhlIGNvbW1hbmQgbGluZSBmb3IgbXMgbWlsbGlzZWNvbmRzLiBSZWNvbW1lbmRlZCBkdXJhdGlvbjogMzAwMG1zLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgTnVtYmVyVHlwZShmYWxzZSwgZmFsc2UpLG5ldyBBcnJheVR5cGUobmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgdHJ1ZSwgZmFsc2UpXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IEFueVR5cGUodHJ1ZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInlhbmtcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiQ29weSBjb250ZW50IHRvIGNsaXBib2FyZCB3aXRob3V0IGZlZWRiYWNrLiBVc2UgYGNsaXBib2FyZCB5YW5rYCBmb3IgaW50ZXJhY3RpdmUgdXNlLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgQXJyYXlUeXBlKG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIHRydWUsIGZhbHNlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBBcnJheVR5cGUobmV3IEFueVR5cGUodHJ1ZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInNldGNsaXBcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiQ29waWVzIGEgc3RyaW5nIHRvIHRoZSBjbGlwYm9hcmQvc2VsZWN0aW9uIGJ1ZmZlciBkZXBlbmRpbmcgb24gdGhlIHVzZXIncyBwcmVmZXJlbmNlc1wiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgQXJyYXlUeXBlKG5ldyBBbnlUeXBlKHRydWUsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIHRydWUpXSxcbltcImdldGNsaXBcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiRmV0Y2hlcyB0aGUgY29udGVudCBvZiB0aGUgY2xpcGJvYXJkL3NlbGVjdGlvbiBidWZmZXIgZGVwZW5kaW5nIG9uIHVzZXIncyBwcmVmZXJlbmNlc1xcblxcbkV4cG9zZWQgZm9yIHVzZSB3aXRoIFtbY29tcG9zaXRlXV0sIGUuZy4gYGNvbXBvc2l0ZSBnZXRjbGlwIHwgZmlsbGNtZGxpbmVgXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBVbmlvblR5cGUoW25ldyBMaXRlcmFsVHlwZVR5cGUoXCJjbGlwYm9hcmRcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJzZWxlY3Rpb25cIiwgZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCB0cnVlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBBbnlUeXBlKHRydWUsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJjbGlwYm9hcmRcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiVXNlIHRoZSBzeXN0ZW0gY2xpcGJvYXJkLlxcblxcbklmIGBleGNtZCA9PT0gXFxcIm9wZW5cXFwiYCwgY2FsbCBbW29wZW5dXSB3aXRoIHRoZSBjb250ZW50cyBvZiB0aGUgY2xpcGJvYXJkLiBTaW1pbGFybHkgZm9yIFtbdGFib3Blbl1dLlxcblxcbklmIGBleGNtZCA9PT0gXFxcInlhbmtcXFwiYCwgY29weSB0aGUgY3VycmVudCBVUkwsIG9yIGlmIGdpdmVuLCB0aGUgdmFsdWUgb2YgdG9ZYW5rLCBpbnRvIHRoZSBzeXN0ZW0gY2xpcGJvYXJkLlxcblxcbklmIGBleGNtZCA9PT0gXFxcInlhbmtjYW5vblxcXCJgLCBjb3B5IHRoZSBjYW5vbmljYWwgVVJMIG9mIHRoZSBjdXJyZW50IHBhZ2UgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2UgY29weSB0aGUgY3VycmVudCBVUkwuXFxuXFxuSWYgYGV4Y21kID09PSBcXFwieWFua3Nob3J0XFxcImAsIGNvcHkgdGhlIHNob3J0bGluayB2ZXJzaW9uIG9mIHRoZSBjdXJyZW50IFVSTCwgYW5kIGZhbGwgYmFjayB0byB0aGUgY2Fub25pY2FsIHRoZW4gYWN0dWFsIFVSTC4gS25vd24gdG8gd29yayBvbiBodHRwczovL3lhbmtzaG9ydC5uZW9jaXRpZXMub3JnLy5cXG5cXG5JZiBgZXhjbWQgPT09IFxcXCJ5YW5rdGl0bGVcXFwiYCwgY29weSB0aGUgdGl0bGUgb2YgdGhlIG9wZW4gcGFnZS5cXG5cXG5JZiBgZXhjbWQgPT09IFxcXCJ5YW5rbWRcXFwiYCwgY29weSB0aGUgdGl0bGUgYW5kIHVybCBvZiB0aGUgb3BlbiBwYWdlIGZvcm1hdHRlZCBpbiBNYXJrZG93biBmb3IgZWFzeSB1c2Ugb24gc2l0ZXMgc3VjaCBhcyByZWRkaXQuXFxuXFxuSWYgeW91J3JlIG9uIExpbnV4IGFuZCB0aGUgbmF0aXZlIG1lc3NlbmdlciBpcyBpbnN0YWxsZWQsIFRyaWRhY3R5bCB3aWxsIGNhbGwgYW4gZXh0ZXJuYWwgYmluYXJ5IChlaXRoZXIgeGNsaXAgb3IgeHNlbCkgdG8gcmVhZCBvciB3cml0ZSB0byB5b3VyIFggc2VsZWN0aW9uIGJ1ZmZlci4gSWYgeW91IHdhbnQgYW5vdGhlciBwcm9ncmFtIHRvIGJlIHVzZWQsIHNldCBcXFwiZXh0ZXJuYWxjbGlwYm9hcmRjbWRcXFwiIHRvIGl0cyBuYW1lIGFuZCBtYWtlIHN1cmUgaXQgaGFzIHRoZSBzYW1lIGludGVyZmFjZSBhcyB4c2VsL3hjbGlwIChcXFwiLWlcXFwiL1xcXCItb1xcXCIgYW5kIHJlYWRpbmcgZnJvbSBzdGRpbikuXFxuXFxuV2hlbiBkb2luZyBhIHJlYWQgb3BlcmF0aW9uIChpLmUuIG9wZW4gb3IgdGFib3BlbiksIGlmIFxcXCJwdXRmcm9tXFxcIiBpcyBzZXQgdG8gXFxcInNlbGVjdGlvblxcXCIsIHRoZSBYIHNlbGVjdGlvbiBidWZmZXIgd2lsbCBiZSByZWFkIGluc3RlYWQgb2YgdGhlIGNsaXBib2FyZC4gU2V0IFxcXCJwdXRmcm9tXFxcIiB0byBcXFwiY2xpcGJvYXJkXFxcIiB0byB1c2UgdGhlIGNsaXBib2FyZC5cXG5cXG5XaGVuIGRvaW5nIGEgd3JpdGUgb3BlcmF0aW9uLCBpZiBcXFwieWFua3RvXFxcIiBpcyBzZXQgdG8gXFxcInNlbGVjdGlvblxcXCIsIG9ubHkgdGhlIFggc2VsZWN0aW9uIGJ1ZmZlciB3aWxsIGJlIHdyaXR0ZW4gdG8uIElmIFxcXCJ5YW5rdG9cXFwiIGlzIHNldCB0byBcXFwiYm90aFxcXCIsIGJvdGggdGhlIFggc2VsZWN0aW9uIGFuZCB0aGUgY2xpcGJvYXJkIHdpbGwgYmUgd3JpdHRlbiB0by4gSWYgXFxcInlhbmt0b1xcXCIgaXMgc2V0IHRvIFxcXCJjbGlwYm9hcmRcXFwiLCBvbmx5IHRoZSBjbGlwYm9hcmQgd2lsbCBiZSB3cml0dGVuIHRvLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgVW5pb25UeXBlKFtuZXcgTGl0ZXJhbFR5cGVUeXBlKFwib3BlblwiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcInlhbmtcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJ5YW5rc2hvcnRcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJ5YW5rY2Fub25cIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJ5YW5rdGl0bGVcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJ5YW5rbWRcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJ4c2VscGFzdGVcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJ0YWJvcGVuXCIsIGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgdHJ1ZSksbmV3IEFycmF5VHlwZShuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCB0cnVlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJ0YWJcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiQ2hhbmdlIGFjdGl2ZSB0YWIuXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBVbmlvblR5cGUoW25ldyBOdW1iZXJUeXBlKGZhbHNlLCBmYWxzZSksXG5uZXcgTGl0ZXJhbFR5cGVUeXBlKFwiI1wiLCBmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInRhYmFsbFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJDaGFuZ2UgYWN0aXZlIHRhYi5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBBbnlUeXBlKHRydWUsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJjb21tYW5kXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlNpbWlsYXIgdG8gdmltJ3MgYDpjb21tYW5kYC4gTWFwcyBvbmUgZXgtbW9kZSBjb21tYW5kIHRvIGFub3RoZXIuXFxuSWYgY29tbWFuZCBhbHJlYWR5IGV4aXN0cywgdGhpcyB3aWxsIG92ZXJyaWRlIGl0LCBhbmQgYW55IG5ldyBjb21tYW5kc1xcbmFkZGVkIGluIGEgZnV0dXJlIHJlbGVhc2Ugd2lsbCBiZSBTSUxFTlRMWSBvdmVycmlkZGVuLiBBbGlhc2VzIGFyZVxcbmV4cGFuZGVkIHJlY3Vyc2l2ZWx5LlxcblxcbkV4YW1wbGVzOlxcbiAgLSBgY29tbWFuZCB0IHRhYm9wZW5gXFxuICAtIGBjb21tYW5kIHRuIHRhYm5leHRfZ3RgXFxuICA9IGBjb21tYW5kIGhlbGxvIHRgIFRoaXMgd2lsbCBleHBhbmQgcmVjdXJzaXZlbHkgaW50byAnaGVsbG8nLT4ndGFib3BlbidcXG5cXG5Ob3RlIHRoYXQgdGhpcyBpcyBvbmx5IGZvciBleGNtZC0+ZXhjbWQgbWFwcGluZ3MuIFRvIG1hcCBhIG5vcm1hbC1tb2RlXFxuY29tbWFuZCB0byBhbiBleGNvbW1hbmQsIHNlZSBbW2JpbmRdXS5cXG5cXG5TZWUgYWxzbzpcXG4gIC0gW1tjb21jbGVhcl1dXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksbmV3IEFycmF5VHlwZShuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCB0cnVlLCBmYWxzZSldLCBuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJjb21jbGVhclwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJTaW1pbGFyIHRvIHZpbSdzIGBjb21jbGVhcmAgY29tbWFuZC4gQ2xlYXJzIGFuIGV4Y21kIGFsaWFzIGRlZmluZWQgYnlcXG5gY29tbWFuZGAuXFxuXFxuRm9yIGV4YW1wbGU6IGBjb21jbGVhciBoZWxsb3dvcmxkYCB3aWxsIHJldmVyc2UgYW55IGNoYW5nZXMgY2F1c2VkXFxuYnkgYGNvbW1hbmQgaGVsbG93b3JsZCB4eHhgXFxuXFxuU2VlIGFsc286XFxuICAtIFtbY29tbWFuZF1dXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInBhcnNlX2JpbmRfYXJnc1wiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJcIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IEFycmF5VHlwZShuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCB0cnVlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJiaW5kX2FyZ3NcIiwgW10sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIHRydWUpXSxcbltcImJpbmRcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiQmluZCBhIHNlcXVlbmNlIG9mIGtleXMgdG8gYW4gZXhjbWQgb3IgdmlldyBib3VuZCBzZXF1ZW5jZS5cXG5cXG5UaGlzIGlzIGFuIGVhc2llci10by1pbXBsZW1lbnQgYm9kZ2Ugd2hpbGUgd2Ugd29yayBvbiB2aW0tc3R5bGUgbWFwcy5cXG5cXG5FeGFtcGxlczpcXG5cXG4gICAgLSBgYmluZCBHIGZpbGxjbWRsaW5lIHRhYm9wZW4gZ29vZ2xlYFxcbiAgICAtIGBiaW5kIEQgY29tcG9zaXRlIHRhYmNsb3NlIHwgdGFiICNgIC0+IGNsb3NlIGN1cnJlbnQgdGFiIGFuZCBzd2l0Y2ggdG8gbW9zdCByZWNlbnQgcHJldmlvdXMgdGFiXFxuICAgIC0gYGJpbmQgaiBzY3JvbGxsaW5lIDIwYFxcbiAgICAtIGBiaW5kIEYgaGludCAtYmBcXG5cXG5Zb3UgY2FuIHZpZXcgYmluZHMgYnkgb21pdHRpbmcgdGhlIGNvbW1hbmQgbGluZTpcXG5cXG4gICAgLSBgYmluZCBqYFxcbiAgICAtIGBiaW5kIGtgXFxuXFxuWW91IGNhbiBiaW5kIHRvIG1vZGlmaWVycyBhbmQgc3BlY2lhbCBrZXlzIGJ5IGVuY2xvc2luZyB0aGVtIHdpdGggYW5nbGUgYnJhY2tldHMsIGZvciBleGFtcGxlIGBiaW5kIDxDLVxcXFw+eiBmdWxsc2NyZWVuYCwgYHVuYmluZCA8RjE+YCAoYSBmYXZvdXJpdGUgb2YgcGVvcGxlIHdobyB1c2UgVHJlZVN0eWxlVGFicyA6KSApLCBvciBgYmluZCA8QmFja3NwYWNlPiBmb3J3YXJkYC5cXG5cXG5Nb2RpZmllcnMgYXJlIHRydW5jYXRlZCB0byBhIHNpbmdsZSBjaGFyYWN0ZXIsIHNvIEN0cmwgLT4gQywgQWx0IC0+IEEsIGFuZCBTaGlmdCAtPiBTLiBTaGlmdCBpcyBhIGJpdCBzcGVjaWFsIGFzIGl0IGlzIG9ubHkgcmVxdWlyZWQgaWYgU2hpZnQgZG9lcyBub3QgY2hhbmdlIHRoZSBrZXkgaW5wdXR0ZWQsIGUuZy4gYDxTLUFycm93RG93bj5gIGlzIE9LLCBidXQgYDxTLWE+YCBzaG91bGQganVzdCBiZSBgQWAuXFxuXFxuWW91IGNhbiB2aWV3IGFsbCBzcGVjaWFsIGtleSBuYW1lcyBoZXJlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXkvS2V5X1ZhbHVlc1xcblxcblVzZSBbW2NvbXBvc2l0ZV1dIGlmIHlvdSB3YW50IHRvIGV4ZWN1dGUgbXVsdGlwbGUgZXhjbWRzLiBVc2VcXG5bW2ZpbGxjbWRsaW5lXV0gdG8gcHV0IGEgc3RyaW5nIGluIHRoZSBjbWRsaW5lIGFuZCBmb2N1cyB0aGUgY21kbGluZVxcbihvdGhlcndpc2UgdGhlIHN0cmluZyBpcyBleGVjdXRlZCBpbW1lZGlhdGVseSkuXFxuXFxuWW91IGNhbiBiaW5kIHRvIG90aGVyIG1vZGVzIHdpdGggYGJpbmQgLS1tb2RlPXtpbnNlcnR8aWdub3JlfG5vcm1hbHxpbnB1dHxleHxoaW50fSAuLi5gLCBlLmcsIGBiaW5kIC0tbW9kZT1pbnNlcnQgZW1hY3MgcWFsbGAgKE5COiB1bmxpa2UgdmltLCBhbGwgcHJlY2VlZGluZyBjaGFyYWN0ZXJzIHdpbGwgbm90IGJlIGlucHV0KSwgb3IgYGJpbmQgLS1tb2RlPWhpbnQgPEMtWz4gaGludC5yZXNldGAuXFxuXFxuQSBsaXN0IG9mIGVkaXRvciBmdW5jdGlvbnMgY2FuIGJlIGZvdW5kXFxuW2hlcmVdKC9zdGF0aWMvZG9jcy9tb2R1bGVzL19zcmNfbGliX2VkaXRvcl8uaHRtbCkuXFxuXFxuU2VlIGFsc286XFxuXFxuICAgIC0gW1t1bmJpbmRdXVxcbiAgICAtIFtbcmVzZXRdXVwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgQXJyYXlUeXBlKG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIHRydWUsIGZhbHNlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImJpbmR1cmxcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiTGlrZSBbW2JpbmRdXSBidXQgZm9yIGEgc3BlY2lmaWMgdXJsIHBhdHRlcm4gKGFsc28gc2VlIFtbc2V0dXJsXV0pLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSxuZXcgQXJyYXlUeXBlKG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIHRydWUsIGZhbHNlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImtleW1hcFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJNYWtlcyBvbmUga2V5IGVxdWl2YWxlbnQgdG8gYW5vdGhlciBmb3IgdGhlIHB1cnBvc2VzIG9mIG1vc3Qgb2Ygb3VyIHBhcnNlcnMuIFVzZWZ1bCBmb3IgaW50ZXJuYXRpb25hbCBrZXlib2FyZCBsYXlvdXRzLlxcblxcbmUuZyxcXG4gICAgIGtleW1hcCDEmSBlXFxuXFxuU2VlIGA6aGVscCBrZXl0cmFuc2xhdGVtb2Rlc2AgdG8gZW5hYmxlIGtleW1hcHMgaW4gbW9kZXMgb3RoZXIgdGhhbiBub3JtYWwgbW9kZS5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSxuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJzZWFyY2hzZXRrZXl3b3JkXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtdLCBuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgdHJ1ZSldLFxuW1widmFsaWRhdGVTZXRBcmdzXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlZhbGlkYXRlcyBhcmd1bWVudHMgZm9yIHNldC9zZXR1cmxcIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSxuZXcgQXJyYXlUeXBlKG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSldLCBuZXcgQXJyYXlUeXBlKG5ldyBBbnlUeXBlKHRydWUsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgdHJ1ZSldLFxuW1wic2V0dXJsXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlVzYWdlOiBgc2V0dXJsIFtwYXR0ZXJuXSBrZXkgdmFsdWVzYFwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksbmV3IEFycmF5VHlwZShuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCB0cnVlLCBmYWxzZSldLCBuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJzZXRcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiU2V0IGEga2V5IHZhbHVlIHBhaXIgaW4gY29uZmlnLlxcblxcblVzZSB0byBzZXQgYW55IHN0cmluZyB2YWx1ZXMgZm91bmQgW2hlcmVdKC9zdGF0aWMvZG9jcy9jbGFzc2VzL19zcmNfbGliX2NvbmZpZ18uZGVmYXVsdF9jb25maWcuaHRtbCkuXFxuXFxuZS5nLlxcbiAgICBzZXQgc2VhcmNodXJscy5nb29nbGUgaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9zZWFyY2g/cT1cXG4gICAgc2V0IGxvZ2dpbmcubWVzc2FnaW5nIGluZm9cXG5cXG5JZiBubyB2YWx1ZSBpcyBnaXZlbiwgdGhlIHZhbHVlIG9mIHRoZSBvZiB0aGUga2V5IHdpbGwgYmUgZGlzcGxheWVkXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksbmV3IEFycmF5VHlwZShuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCB0cnVlLCBmYWxzZSldLCBuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJhdXRvY21kXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlNldCBhdXRvY21kcyB0byBydW4gd2hlbiBjZXJ0YWluIGV2ZW50cyBoYXBwZW4uXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSxuZXcgQXJyYXlUeXBlKG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIHRydWUsIGZhbHNlKV0sIG5ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiYXV0b2NvbnRhaW5cIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiQXV0b21hdGljYWxseSBvcGVuIGEgZG9tYWluIGFuZCBhbGwgaXRzIHN1YmRvbWFpbnMgaW4gYSBzcGVjaWZpZWQgY29udGFpbmVyLlxcblxcbkZvciBkZWNsYXJpbmcgY29udGFpbmVycyB0aGF0IGRvIG5vdCB5ZXQgZXhpc3QsIGNvbnNpZGVyIHVzaW5nIGBhdWNvbnNjcmVhdGVjb250YWluZXIgdHJ1ZWAgaW4geW91ciB0cmlkYWN0eWxyYy5cXG5UaGlzIGFsbG93cyB0cmlkYWN0eWwgdG8gYXV0b21hdGljYWxseSBjcmVhdGUgY29udGFpbmVycyBmcm9tIHlvdXIgYXV0b2NvbnRhaW4gZGlyZWN0aXZlcy4gTm90ZSB0aGF0IHRoZXkgd2lsbCBiZSByYW5kb20gaWNvbnMgYW5kIGNvbG9ycy5cXG5cXG4qKiBOQjogVGhpcyBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSwgaWYgeW91IGVuY291bnRlciBpc3N1ZXMgcGxlYXNlIGNyZWF0ZSBhbiBpc3N1ZSBvbiBnaXRodWIuICoqXFxuXFxuVGhlIGRvbWFpbiBpcyBwYXNzZWQgdGhyb3VnaCBhcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzbyB0aGVyZSBhcmUgYSBmZXcgZ290Y2hhcyB0byBiZSBhd2FyZSBvZjpcXG4qIFVuZXNjYXBlZCBwZXJpb2RzIHdpbGwgbWF0Y2ggKmFueXRoaW5nKi4gYGF1dG9jb250YWluIGdvb2dsZS5jby51ayB3b3JrYCB3aWxsIG1hdGNoIGBnb29nbGUhY28kdWtgLiBFc2NhcGUgeW91ciBwZXJpb2RzIG9yIGFjY2VwdCB0aGF0IHlvdSBtaWdodCBnZXQgc29tZSBmYWxzZSBwb3NpdGl2ZXMuXFxuKiBZb3UgY2FuIHVzZSByZWdleCBpbiB5b3VyIGRvbWFpbiBwYXR0ZXJuLiBgYXV0b2NvbnRhaW4gZ29vZ2xlXFxcXCwoY29cXFxcLnVrfGNvbSkgd29ya2Agd2lsbCBtYXRjaCBlaXRoZXIgYGdvb2dsZS5jby51a2Agb3IgYGdvb2dsZS5jb21gLlxcblxcblRoaXMgKnNob3VsZCogbm93IHBlYWNlZnVsbHkgY29leGlzdCB3aXRoIHRoZSBUZW1wb3JhcnkgQ29udGFpbmVycyBhbmQgTXVsdGktQWNjb3VudCBDb250YWluZXJzIGFkZG9ucy4gRG8gbm90IHRydXN0IHRoaXMgY2xhaW0uIElmIGEgZmlnaHQgc3RhcnRzIHRoZSBwYXJ0aWNpcGFudHMgd2lsbCB0cnkgdG8gb3BlbiBpbmZpbml0ZSB0YWJzLiBJdCBpcyAqc3Ryb25nbHkqIHJlY29tbWVuZGVkIHRoYXQgeW91IHVzZSBhIHRyaWRhY3R5bHJjIHNvIHRoYXQgeW91IGNhbiBhYm9ydCBhIHNvcmNlcm9yJ3MtYXBwcmVudGljZSBzY2VuYXJpbyBieSBraWxsaW5nIGZpcmVmb3gsIGNvbW1lbnRpbmcgb3V0IGFsbCBvZiBhdXRvY29udGFpbmVyIGRpcmVjdGl2ZXMgaW4geW91ciByYyBmaWxlLCBhbmQgcmVzdGFydGluZyBmaXJlZm94IHRvIGNsZWFuIHVwIHRoZSBtZXNzLiBUaGVyZSBhcmUgYSBudW1iZXIgb2Ygc3RyYW5nZSBiZWhhdmlvcnMgcmVzdWx0aW5nIGZyb20gbGltaXRlZCBjb29yZGluYXRpb24gYmV0d2VlbiBleHRlbnNpb25zLiBSZWRpcmVjdHMgY2FuIGJlIHBhcnRpY3VsYXJseSBzdXJwcmlzaW5nOyBmb3IgZXhhbXBsZSwgd2l0aCBgOmF1dG9jb250YWluIHdpbGwtcmVkaXJlY3QuZXhhbXBsZS5vcmcgZXhhbXBsZWAgc2V0IGFuZCBgd2lsbC1yZWRpcmVjdC5leGFtcGxlLm9yZ2AgcmVkaXJlY3RpbmcgdG8gYHJlZGlyZWN0ZWQuZXhhbXBsZS5vcmdgLCBuYXZpZ2F0aW5nIHRvIGB3aWxsLXJlZGlyZWN0LmV4YW1wbGUub3JnYCB3aWxsIHJlc3VsdCBpbiB0aGUgbmV3IHRhYiBiZWluZyBpbiB0aGUgYGV4YW1wbGVgIGNvbnRhaW5lciB1bmRlciBzb21lIGNvbmRpdGlvbnMgYW5kIGluIHRoZSBgZmlyZWZveC1kZWZhdWx0YCBjb250YWluZXIgdW5kZXIgb3RoZXJzLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImF1dG9jbWRkZWxldGVcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiUmVtb3ZlIGF1dG9jbWRzXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIG5ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiYmxhY2tsaXN0YWRkXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkhlbHBlciBmdW5jdGlvbiB0byBwdXQgVHJpZGFjdHlsIGludG8gaWdub3JlIG1vZGUgb24gdGhlIHByb3ZpZGVkIFVSTC5cXG5cXG5TaW1wbHkgY3JlYXRlcyBhIERvY1N0YXJ0IFtbYXV0b2NtZF1dIHRoYXQgcnVucyBgbW9kZSBpZ25vcmVgLlxcblxcbkR1ZSB0byBhIFRyaWRhY3R5bCBidWcsIHRoZSBvbmx5IHdheSB0byByZW1vdmUgdGhlc2UgcnVsZXMgb25jZSB0aGV5IGFyZSBzZXQgaXMgdG8gZGVsZXRlIGFsbCBvZiB5b3VyIGF1dG9jbWRzIHdpdGggYHVuc2V0IGF1dG9jbWRzYC5cXG5cXG5JZiB5b3UncmUgbG9va2luZyBmb3IgYSB3YXkgdG8gdGVtcG9yYXJpbHkgZGlzYWJsZSBUcmlkYWN0eWwsIHRoaXMgbWlnaHQgYmUgd2hhdCB5b3UncmUgbG9va2luZyBmb3IuXFxuXFxuPCEtLSB0aGlzIHNob3VsZCBwcm9iYWJseSBiZSBtb3ZlZCB0byBhbiBleCBhbGlhcyBvbmNlIGNvbmZpZ3VyYXRpb24gaGFzIGJldHRlciBoZWxwIC0tIT5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIG5ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1widW5iaW5kXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlVuYmluZCBhIHNlcXVlbmNlIG9mIGtleXMgc28gdGhhdCB0aGV5IGRvIG5vdGhpbmcgYXQgYWxsLlxcblxcblNlZSBhbHNvOlxcblxcbiAgICAtIFtbYmluZF1dXFxuICAgIC0gW1tyZXNldF1dXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBBcnJheVR5cGUobmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgdHJ1ZSwgZmFsc2UpXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IEFueVR5cGUodHJ1ZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInVuYmluZHVybFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJVbmJpbmQgYSBzZXF1ZW5jZSBvZiBrZXlzIHlvdSBoYXZlIHNldCB3aXRoIFtbYmluZHVybF1dLiBOb3RlIHRoYXQgdGhpcyAqKmtpbGxzKiogYSBiaW5kLCB3aGljaCBtZWFucyBUcmlkYWN0eWwgd2lsbCBwYXNzIGl0IHRvIHRoZSBwYWdlIG9uIGBwYXR0ZXJuYC4gSWYgaW5zdGVhZCB5b3Ugd2FudCB0byB1c2UgdGhlIGRlZmF1bHQgc2V0dGluZyBhZ2FpbiwgdXNlIFtbcmVzZXR1cmxdXS5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSxuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wicmVzZXRcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiUmVzdG9yZXMgYSBzZXF1ZW5jZSBvZiBrZXlzIHRvIHRoZWlyIGRlZmF1bHQgdmFsdWUuXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBBbnlUeXBlKHRydWUsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJyZXNldHVybFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJSZXN0b3JlcyBhIHNlcXVlbmNlIG9mIGtleXMgdG8gdGhlaXIgdmFsdWUgaW4gdGhlIGdsb2JhbCBjb25maWcgZm9yIGEgc3BlY2lmaWMgVVJMLlxcblxcblNlZSBhbHNvOlxcbiAgLSBbW2JpbmRdXVxcbiAgLSBbW3VuYmluZF1dXFxuICAtIFtbcmVzZXRdXVxcbiAgLSBbW2JpbmR1cmxdXVxcbiAgLSBbW3VuYmluZHVybF1dXFxuICAtIFtbc2V0dXJsXV1cXG4gIC0gW1t1bnNldHVybF1dXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSxuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IEFueVR5cGUodHJ1ZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInNhbml0aXNlXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkRlbGV0ZXMgdmFyaW91cyBwcml2YWN5LXJlbGF0ZWQgaXRlbXMuXFxuXFxuVGhlIGxpc3Qgb2YgcG9zc2libGUgYXJndW1lbnRzIGNhbiBiZSBmb3VuZCBoZXJlOlxcbmh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL0FkZC1vbnMvV2ViRXh0ZW5zaW9ucy9BUEkvYnJvd3NpbmdEYXRhL0RhdGFUeXBlU2V0XFxuXFxuQWRkaXRpb25hbCwgdHJpZGFjdHlsLXNwZWNpZmljIGFyZ3VtZW50cyBhcmU6XFxuLSBjb21tYW5kbGluZTogUmVtb3ZlcyB0aGUgaW4tbWVtb3J5IGNvbW1hbmRsaW5lIGhpc3RvcnkuXFxuLSB0cmlkYWN0eWxsb2NhbDogUmVtb3ZlcyBhbGwgdHJpZGFjdHlsIHN0b3JhZ2UgbG9jYWwgdG8gdGhpcyBtYWNoaW5lLiBVc2UgaXQgd2l0aFxcbiAgICBjb21tYW5kbGluZSBpZiB5b3Ugd2FudCB0byBkZWxldGUgeW91ciBjb21tYW5kbGluZSBoaXN0b3J5Llxcbi0gdHJpZGFjdHlsc3luYzogUmVtb3ZlcyBhbGwgdHJpZGFjdHlsIHN0b3JhZ2UgYXNzb2NpYXRlZCB3aXRoIHlvdXIgRmlyZWZveCBBY2NvdW50IChpLmUsIGFsbCB1c2VyIGNvbmZpZ3VyYXRpb24sIGJ5IGRlZmF1bHQpLlxcblRoZXNlIGFyZ3VtZW50cyBhcmVuJ3QgYWZmZWN0ZWQgYnkgdGhlIHRpbWVzcGFuIHBhcmFtZXRlci5cXG5cXG5UaW1lc3BhbiBwYXJhbWV0ZXI6XFxuLXQgWzAtOV0rKG18aHxkfHcpXFxuXFxuRXhhbXBsZXM6XFxuXFxuLSBgc2FuaXRpc2UgYWxsYCAtPiBEZWxldGVzIGV2ZXJ5dGhpbmdcXG4tIGBzYW5pdGlzZSBoaXN0b3J5YCAtPiBEZWxldGVzIGFsbCBoaXN0b3J5XFxuLSBgc2FuaXRpc2UgY29tbWFuZGxpbmUgdHJpZGFjdHlsbG9jYWwgdHJpZGFjdHlsc3luY2AgLT4gRGVsZXRlcyBldmVyeSBiaXQgb2YgZGF0YSBUcmlkYWN0eWwgaG9sZHNcXG4tIGBzYW5pdGlzZSBjb29raWVzIC10IDNkYCAtPiBEZWxldGVzIGNvb2tpZXMgdGhhdCB3ZXJlIHNldCBkdXJpbmcgdGhlIGxhc3QgdGhyZWUgZGF5cy5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IEFycmF5VHlwZShuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCB0cnVlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJxdWlja21hcmtcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiQmluZCBhIHF1aWNrbWFyayBmb3IgdGhlIGN1cnJlbnQgVVJMIG9yIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIFVSTHMgdG8gYSBrZXkgb24gdGhlIGtleWJvYXJkLlxcblxcbkFmdGVyd2FyZHMgdXNlIGdvW2tleV0sIGduW2tleV0sIG9yIGd3W2tleV0gdG8gW1tvcGVuXV0sIFtbdGFib3Blbl1dLCBvclxcbltbd2lub3Blbl1dIHRoZSBVUkwgcmVzcGVjdGl2ZWx5LlxcblxcbkV4YW1wbGU6XFxuLSBgcXVpY2ttYXJrIG0gaHR0cHM6Ly9tYWlsLmdvb2dsZS5jb20vbWFpbC91LzAvI2luYm94YFwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLG5ldyBBcnJheVR5cGUobmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgdHJ1ZSwgZmFsc2UpXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiZ2V0XCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlB1dHMgdGhlIGNvbnRlbnRzIG9mIGNvbmZpZyB2YWx1ZSB3aXRoIGtleXMgYGtleXNgIGludG8gdGhlIGNvbW1hbmRsaW5lIGFuZCB0aGUgYmFja2dyb3VuZCBwYWdlIGNvbnNvbGVcXG5cXG5JdCdzIGEgYml0IHJ1YmJpc2gsIGJ1dCB3ZSBkb24ndCBoYXZlIGEgZ29vZCB3YXkgdG8gcHJvdmlkZSBmZWVkYmFjayB0byB0aGUgY29tbWFuZGxpbmUgeWV0LlxcblxcbllvdSBjYW4gdmlldyB0aGUgbG9nIGVudHJ5IGluIHRoZSBicm93c2VyIGNvbnNvbGUgKEN0cmwtU2hpZnQtaikuXFxuXFxuRm9yIGV4YW1wbGUsIHlvdSBtaWdodCB0cnkgYGdldCBubWFwc2AgdG8gc2VlIGFsbCBvZiB5b3VyIGN1cnJlbnQgYmluZHMuXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBBcnJheVR5cGUobmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgdHJ1ZSwgZmFsc2UpXSwgbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJ2aWV3Y29uZmlnXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIk9wZW5zIHRoZSBjdXJyZW50IGNvbmZpZ3VyYXRpb24gaW4gRmlyZWZveCdzIG5hdGl2ZSBKU09OIHZpZXdlciBpbiB0aGUgY3VycmVudCB0YWIuXFxuXFxuTkI6IFRyaWRhY3R5bCBjYW5ub3QgcnVuIG9uIHRoaXMgcGFnZSFcIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IFN0cmluZ1R5cGUoZmFsc2UsIHRydWUpXSwgbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJ1bnNldHVybFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJSZXNldCBhIHNpdGUtc3BlY2lmaWMgc2V0dGluZy5cXG5cXG51c2FnZTogYHVuc2V0dXJsIFtwYXR0ZXJuXSBrZXlgXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIG5ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1widW5zZXRcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiUmVzZXQgYSBjb25maWcgc2V0dGluZyB0byBkZWZhdWx0XCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBBcnJheVR5cGUobmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgdHJ1ZSwgZmFsc2UpXSwgbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJoaW50XCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkhpbnQgYSBwYWdlLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgU3RyaW5nVHlwZShmYWxzZSwgdHJ1ZSksbmV3IFN0cmluZ1R5cGUoZmFsc2UsIHRydWUpLG5ldyBBcnJheVR5cGUobmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgdHJ1ZSwgZmFsc2UpXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IEFueVR5cGUodHJ1ZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInJvdDEzXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlBlcmZvcm0gcm90MTMuXFxuXFxuVHJhbnNmb3JtcyBhbGwgdGV4dCBub2RlcyBpbiB0aGUgY3VycmVudCB0YWIgdmlhIHJvdDEzLiBPbmx5IGNoYXJhY3RlcnMgaW5cXG50aGUgQVNDSUkgcmFuZ2UgYXJlIGNvbnNpZGVyZWQuXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBOdW1iZXJUeXBlKGZhbHNlLCBmYWxzZSldLCBuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInJ1bl9leHN0clwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJIYWNreSBleCBzdHJpbmcgcGFyc2VyLlxcblxcblVzZSBpdCBmb3IgZmlyZS1hbmQtZm9yZ2V0IHJ1bm5pbmcgb2YgYmFja2dyb3VuZCBjb21tYW5kcyBpbiBjb250ZW50LlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgQXJyYXlUeXBlKG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIHRydWUsIGZhbHNlKV0sIG5ldyBBbnlUeXBlKHRydWUsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImdvYmJsZVwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJJbml0aWFsaXplIGdvYmJsZSBtb2RlLlxcblxcbkl0IHdpbGwgcmVhZCBgbkNoYXJzYCBpbnB1dCBrZXlzLCBhcHBlbmQgdGhlbSB0byBgZW5kQ21kYCBhbmQgZXhlY3V0ZSB0aGF0XFxuc3RyaW5nLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgTnVtYmVyVHlwZShmYWxzZSwgZmFsc2UpLG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJ0c3NSZWFkRnJvbUNzc1wiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJSZWFkIHRleHQgY29udGVudCBvZiBlbGVtZW50cyBtYXRjaGluZyB0aGUgZ2l2ZW4gc2VsZWN0b3JcIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIG5ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1widHRzcmVhZFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJSZWFkIHRoZSBnaXZlbiB0ZXh0IHVzaW5nIHRoZSBicm93c2VyJ3MgdGV4dCB0byBzcGVlY2ggZnVuY3Rpb25hbGl0eSBhbmRcXG50aGUgc2V0dGluZ3MgY3VycmVudGx5IHNldFwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgVW5pb25UeXBlKFtuZXcgTGl0ZXJhbFR5cGVUeXBlKFwiLXRcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCItY1wiLCBmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSxuZXcgQXJyYXlUeXBlKG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIHRydWUsIGZhbHNlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInR0c3ZvaWNlc1wiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJTaG93IGEgbGlzdCBvZiB0aGUgdm9pY2VzIGF2YWlsYWJsZSB0byB0aGUgVFRTIHN5c3RlbS4gVGhlc2UgY2FuIGJlXFxuc2V0IGluIHRoZSBjb25maWcgdXNpbmcgYHR0c3ZvaWNlYFwiLCBuZXcgRnVuY3Rpb25UeXBlKFtdLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJ0dHNjb250cm9sXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkNhbmNlbCBjdXJyZW50IHJlYWRpbmcgYW5kIGNsZWFyIHBlbmRpbmcgcXVldWVcXG5cXG5Bcmd1bWVudHM6XFxuICAgLSBzdG9wOiAgICBjYW5jZWwgY3VycmVudCBhbmQgcGVuZGluZyB1dHRlcmFuY2VzXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJidWlsZEZpbHRlckNvbmZpZ3NcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiQnVpbGQgYSBzZXQgb2YgRmlsdGVyQ29uZmlncyBmcm9tIGEgbGlzdCBvZiBodW1hbi1pbnB1dCBmaWx0ZXJcXG5zcGVjcy5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IEFycmF5VHlwZShuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpXSwgbmV3IEFycmF5VHlwZShuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIHRydWUpXSxcbltcInBlcmZkdW1wXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkR1bXAgdGhlIHJhdyBqc29uIGZvciBvdXIgcGVyZm9ybWFuY2UgY291bnRlcnMuIEZpbHRlcnMgd2l0aFxcbnRyYWlsaW5nIHNsYXNoZXMgYXJlIGNsYXNzIG5hbWVzLCA6c3RhcnQgfCA6ZW5kIHwgOm1lYXN1cmUgc3BlY2lmeVxcbndoYXQgdHlwZSBvZiBzYW1wbGUgdG8gcGFzcyB0aHJvdWdoLCBhbmQgYWxsIG90aGVycyBhcmUgZnVuY3Rpb25cXG5uYW1lcy4gQWxsIGZpbHRlcnMgbXVzdCBtYXRjaCBmb3IgYSBzYW1wbGUgdG8gYmUgZHVtcGVkLlxcblxcblRyaWRhY3R5bCBkb2VzIG5vdCBjb2xsZWN0IHBlcmZvcm1hbmNlIGluZm9ybWF0aW9uIGJ5IGRlZmF1bHQuIFRvXFxuZ2V0IHRoaXMgZGF0YSB5b3UnbGwgaGF2ZSB0byBzZXQgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9uXFxuYHBlcmZjb3VudGVyc2AgdG8gYFxcXCJ0cnVlXFxcImAuIFlvdSBtYXkgYWxzbyB3YW50IHRvIGV4YW1pbmUgdGhlIHZhbHVlXFxub2YgYHBlcmZzYW1wbGVzYC5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IEFycmF5VHlwZShuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCB0cnVlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJwZXJmaGlzdG9ncmFtXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlByZXR0eS1wcmludCBhIGhpc3RvZ3JhbSBvZiBleGVjdXRpb24gZHVyYXRpb25zIGZvciB5b3UuIEFyZ3VtZW50c1xcbmFyZSBhcyBhYm92ZSwgd2l0aCB0aGUgYWRkaXRpb24gdGhhdCB0aGlzIGF1dG9tYXRpY2FsbHkgZmlsdGVycyB0b1xcbmNvdW50ZXIgc2FtcGxlcyBvZiB0eXBlIDptZWFzdXJlLlxcblxcbk5vdGUgdGhhdCB0aGlzIHdpbGwgZGlzcGxheSBpdHMgb3V0cHV0IGJ5IG9wZW5pbmcgYSBkYXRhOiB1cmwgd2l0aFxcbnRleHQgaW4gdGhlIHBsYWNlIG9mIHlvdXIgY3VycmVudCB0YWIuXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBBcnJheVR5cGUobmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgdHJ1ZSwgZmFsc2UpXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiYm1hcmtcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiQWRkIG9yIHJlbW92ZSBhIGJvb2ttYXJrLlxcblxcbk9wdGlvbmFsbHksIHlvdSBtYXkgZ2l2ZSB0aGUgYm9va21hcmsgYSB0aXRsZS4gSWYgbm8gVVJMIGlzIGdpdmVuLCBhIGJvb2ttYXJrIGlzIGFkZGVkIGZvciB0aGUgY3VycmVudCBwYWdlLlxcblxcbklmIGEgYm9va21hcmsgYWxyZWFkeSBleGlzdHMgZm9yIHRoZSBVUkwsIGl0IGlzIHJlbW92ZWQsIGV2ZW4gaWYgYSB0aXRsZSBpcyBnaXZlbi5cXG5cXG5Eb2VzIG5vdCBzdXBwb3J0IGNyZWF0aW9uIG9mIGZvbGRlcnM6IHlvdSdsbCBuZWVkIHRvIHVzZSB0aGUgRmlyZWZveCBtZW51cyBmb3IgdGhhdC5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IFN0cmluZ1R5cGUoZmFsc2UsIHRydWUpLG5ldyBBcnJheVR5cGUobmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgdHJ1ZSwgZmFsc2UpXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiZWNob1wiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJcIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IEFycmF5VHlwZShuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCB0cnVlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImpzXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkxldHMgeW91IGV4ZWN1dGUgSmF2YVNjcmlwdCBpbiB0aGUgcGFnZSBjb250ZXh0LiBJZiB5b3Ugd2FudCB0byBnZXQgdGhlIHJlc3VsdCBiYWNrLCB1c2UgYGNvbXBvc2l0ZSBqcyAuLi4gfCBmaWxsY21kbGluZWBcXG5cXG5Tb21lIG9mIFRyaWRhY3R5bCdzIGZ1bmN0aW9ucyBhcmUgYWNjZXNzaWJsZSBoZXJlIHZpYSB0aGUgYHRyaWAgb2JqZWN0LiBKdXN0IGRvIGBjb25zb2xlLmxvZyh0cmkpYCBpbiB0aGUgd2ViIGNvbnNvbGUgb24gdGhlIG5ldyB0YWIgcGFnZSB0byBzZWUgd2hhdCdzIGF2YWlsYWJsZS5cXG5cXG5JZiB5b3Ugd2FudCB0byBwaXBlIGFuIGFyZ3VtZW50IHRvIGBqc2AsIHlvdSBuZWVkIHRvIHVzZSB0aGUgXFxcIi1wXFxcIiBmbGFnIGFuZCB0aGVuIHVzZSB0aGUgSlNfQVJHIGdsb2JhbCB2YXJpYWJsZSwgZS5nOlxcblxcbmBjb21wb3NpdGUgZ2V0X2N1cnJlbnRfdXJsIHwganMgLXAgYWxlcnQoSlNfQVJHKWBcIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IEFycmF5VHlwZShuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCB0cnVlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wianNiXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkxldHMgeW91IGV4ZWN1dGUgSmF2YVNjcmlwdCBpbiB0aGUgYmFja2dyb3VuZCBjb250ZXh0LiBBbGwgdGhlIGhlbHAgZnJvbSBbW2pzXV0gYXBwbGllcy4gR2l2ZXMgeW91IGEgZGlmZmVyZW50IGB0cmlgIG9iamVjdC5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IEFycmF5VHlwZShuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCB0cnVlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiaXNzdWVcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiT3BlbnMgYSBuZXcgdGFiIHRoZSB1cmwgb2Ygd2hpY2ggaXMgXFxcImh0dHBzOi8vZ2l0aHViLmNvbS90cmlkYWN0eWwvdHJpZGFjdHlsL2lzc3Vlcy9uZXdcXFwiIGFuZCBhdXRvbWF0aWNhbGx5IGZpbGwgYWRkIHRyaWRhY3R5bCwgZmlyZWZveCBhbmQgb3MgdmVyc2lvbiB0byB0aGUgaXNzdWUuXCIsIG5ldyBGdW5jdGlvblR5cGUoW10sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBBbnlUeXBlKHRydWUsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJ1cGRhdGVjaGVja1wiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJDaGVja3MgaWYgdGhlcmUgYXJlIGFueSBzdGFibGUgdXBkYXRlcyBhdmFpbGFibGUgZm9yIFRyaWRhY3R5bC5cXG5cXG5SZWxhdGVkIHNldHRpbmdzOlxcblxcbi0gYHVwZGF0ZS5uYWcgPSB0cnVlIHwgZmFsc2VgIC0gY2hlY2tzIGZvciB1cGRhdGVzIG9uIFRyaWRhY3R5bCBzdGFydC5cXG4tIGB1cGRhdGUubmFnd2FpdCA9IDdgIC0gd2FpdHMgNyBkYXlzIGJlZm9yZSBuYWdnaW5nIHlvdSB0byB1cGRhdGUuXFxuLSBgdXBkYXRlLmNoZWNraW50ZXJ2YWxzZWNzID0gODY0MDBgIC0gd2FpdHMgMjQgaG91cnMgYmV0d2VlbiBjaGVja2luZyBmb3IgYW4gdXBkYXRlLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgVW5pb25UeXBlKFtuZXcgTGl0ZXJhbFR5cGVUeXBlKFwibWFudWFsXCIsIGZhbHNlLCBmYWxzZSksXG5uZXcgTGl0ZXJhbFR5cGVUeXBlKFwiYXV0b19wb2xpdGVcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJhdXRvX2ltcG9saXRlXCIsIGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgdHJ1ZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgQm9vbGVhblR5cGUoZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJrZXlmZWVkXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkZlZWQgc29tZSBrZXlzIHRvIFRyaWRhY3R5bCdzIHBhcnNlci4gRS5nLiBga2V5ZmVlZCBqa2pramtqa2pramtqa2pramtqa2pramtqa2pramtqa2pramtqa2pramtqamtqYC5cXG5cXG5OQjpcXG5cXG4tIERvZXMgX25vdF8gZnVuY3Rpb24gbGlrZSBWaW0ncyBub3JlbWFwIC0gYGJpbmQgaiBrZXlmZWVkIGpgIHdpbGwgY2F1c2UgYW4gaW5maW5pdGUgbG9vcC5cXG4tIERvZXNuJ3Qgd29yayBpbiBleG1vZGUgLSBpLmUuIGBrZXlmZWVkIHQ8Q1I+YCB3b24ndCB3b3JrLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldXSkpXSxcbltcInNyYy9saWIvY29uZmlnLnRzXCIsIG5ldyBGaWxlTWV0YWRhdGEobmV3IE1hcDxzdHJpbmcsIENsYXNzTWV0YWRhdGE+KFtbXCJkZWZhdWx0X2NvbmZpZ1wiLCBuZXcgQ2xhc3NNZXRhZGF0YShuZXcgTWFwPHN0cmluZywgU3ltYm9sTWV0YWRhdGE+KFtbXCJjb25maWd2ZXJzaW9uXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkludGVybmFsIHZlcnNpb24gbnVtYmVyIFRyaWRhY3R5bCB1c2VzIHRvIGtub3cgd2hldGhlciBpdCBuZWVkcyB0byB1cGRhdGUgZnJvbSBvbGQgdmVyc2lvbnMgb2YgdGhlIGNvbmZpZ3VyYXRpb24uXFxuXFxuQ2hhbmdpbmcgdGhpcyBtaWdodCBkbyB3ZWlyZCBzdHVmZi5cIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInN1YmNvbmZpZ3NcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiSW50ZXJuYWwgZmllbGQgdG8gaGFuZGxlIHNpdGUtc3BlY2lmaWMgY29uZmlncy4gVXNlIDpzZXR1cmwvOnVuc2V0dXJsIHRvIGNoYW5nZSB0aGVzZSB2YWx1ZXMuXCIsIG5ldyBPYmplY3RUeXBlKG5ldyBNYXA8c3RyaW5nLCBUeXBlPihbW1wiXCIsIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcImRlZmF1bHRfY29uZmlnXCIsIFtdLCBmYWxzZSwgZmFsc2UpXV0pLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wicHJpb3JpdHlcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiSW50ZXJuYWwgZmllbGQgdG8gaGFuZGxlIHNpdGUtc3BlY2lmaWMgY29uZmlnIHByaW9yaXRpZXMuIFVzZSA6c2V0dXJsLzp1bnNldHVybCB0byBjaGFuZ2UgdGhpcyB2YWx1ZS5cIiwgbmV3IE51bWJlclR5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImV4bWFwc1wiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJleG1hcHMgY29udGFpbnMgYWxsIG9mIHRoZSBiaW5kaW5ncyBmb3IgdGhlIGNvbW1hbmQgbGluZS5cXG5Zb3UgY2FuIG9mIGNvdXJzZSBiaW5kIHJlZ3VsYXIgZXggY29tbWFuZHMgYnV0IGFsc28gW2VkaXRvciBmdW5jdGlvbnNdKC9zdGF0aWMvZG9jcy9tb2R1bGVzL19zcmNfbGliX2VkaXRvcl8uaHRtbCkgYW5kIFtjb21tYW5kbGluZS1zcGVjaWZpYyBmdW5jdGlvbnNdKC9zdGF0aWMvZG9jcy9tb2R1bGVzL19zcmNfY29tbWFuZGxpbmVfZnJhbWVfLmh0bWwpLlwiLCBuZXcgT2JqZWN0VHlwZShuZXcgTWFwPHN0cmluZywgVHlwZT4oW1tcIjxFbnRlcj5cIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcIjxDLWo+XCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCI8Qy1tPlwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgW1wiPEVzY2FwZT5cIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcIjxBcnJvd1VwPlwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgW1wiPEFycm93RG93bj5cIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcIjxDLWE+XCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCI8Qy1lPlwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgW1wiPEMtdT5cIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcIjxDLWs+XCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCI8Qy1jPlwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgW1wiPEMtZj5cIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcIjxUYWI+XCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCI8Uy1UYWI+XCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCI8U3BhY2U+XCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldXSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJpZ25vcmVtYXBzXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcImlnbm9yZW1hcHMgY29udGFpbiBhbGwgb2YgdGhlIGJpbmRpbmdzIGZvciBcXFwiaWdub3JlIG1vZGVcXFwiLlxcblxcblRoZXkgY29uc2lzdCBvZiBrZXkgc2VxdWVuY2VzIG1hcHBlZCB0byBleCBjb21tYW5kcy5cIiwgbmV3IE9iamVjdFR5cGUobmV3IE1hcDxzdHJpbmcsIFR5cGU+KFtbXCI8Uy1JbnNlcnQ+XCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCI8Q0EtRXNjYXBlPlwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgW1wiPENBLWA+XCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCI8Uy1Fc2NhcGU+XCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCI8Qy1ePlwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgW1wiPEMtNj5cIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV1dKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImltYXBzXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcImltYXBzIGNvbnRhaW4gYWxsIG9mIHRoZSBiaW5kaW5ncyBmb3IgXFxcImluc2VydCBtb2RlXFxcIi5cXG5cXG5PbiB0b3Agb2YgcmVndWxhciBleCBjb21tYW5kcywgeW91IGNhbiBhbHNvIGJpbmQgW2VkaXRvciBmdW5jdGlvbnNdKC9zdGF0aWMvZG9jcy9tb2R1bGVzL19zcmNfbGliX2VkaXRvcl8uaHRtbCkgaW4gaW5zZXJ0IG1vZGUuXFxuXFxuVGhleSBjb25zaXN0IG9mIGtleSBzZXF1ZW5jZXMgbWFwcGVkIHRvIGV4IGNvbW1hbmRzLlwiLCBuZXcgT2JqZWN0VHlwZShuZXcgTWFwPHN0cmluZywgVHlwZT4oW1tcIjxFc2NhcGU+XCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCI8Qy1bPlwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgW1wiPEMtaT5cIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcIjxDQS1Fc2NhcGU+XCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCI8Q0EtYD5cIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcIjxDLTY+XCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCI8Qy1ePlwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgW1wiPFMtRXNjYXBlPlwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXV0pLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiaW5wdXRtYXBzXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcImlucHV0bWFwcyBjb250YWluIGFsbCBvZiB0aGUgYmluZGluZ3MgZm9yIFxcXCJpbnB1dCBtb2RlXFxcIi5cXG5cXG5PbiB0b3Agb2YgcmVndWxhciBleCBjb21tYW5kcywgeW91IGNhbiBhbHNvIGJpbmQgW2VkaXRvciBmdW5jdGlvbnNdKC9zdGF0aWMvZG9jcy9tb2R1bGVzL19zcmNfbGliX2VkaXRvcl8uaHRtbCkgaW4gaW5wdXQgbW9kZS5cXG5cXG5UaGV5IGNvbnNpc3Qgb2Yga2V5IHNlcXVlbmNlcyBtYXBwZWQgdG8gZXggY29tbWFuZHMuXCIsIG5ldyBBbnlUeXBlKHRydWUsIGZhbHNlKSwgZmFsc2UpXSxcbltcIm5tYXBzXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIm5tYXBzIGNvbnRhaW4gYWxsIG9mIHRoZSBiaW5kaW5ncyBmb3IgXFxcIm5vcm1hbCBtb2RlXFxcIi5cXG5cXG5UaGV5IGNvbnNpc3Qgb2Yga2V5IHNlcXVlbmNlcyBtYXBwZWQgdG8gZXggY29tbWFuZHMuXCIsIG5ldyBPYmplY3RUeXBlKG5ldyBNYXA8c3RyaW5nLCBUeXBlPihbW1wiPEEtcD5cIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcIjxBLW0+XCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCI8RjE+XCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCJvXCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCJPXCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCJ3XCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCJXXCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCJ0XCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCJdXVwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgW1wiW1tcIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcIltjXCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCJdY1wiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgW1wiPEMteD5cIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcIjxDLWE+XCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCJUXCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCJ5eVwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgW1wieXNcIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcIjxTQS1BcnJvd1VwPjxTQS1BcnJvd1VwPjxTQS1BcnJvd0Rvd24+PFNBLUFycm93RG93bj48U0EtQXJyb3dMZWZ0PjxTQS1BcnJvd1JpZ2h0PjxTQS1BcnJvd0xlZnQ+PFNBLUFycm93UmlnaHQ+YmFcIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV1dKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImhpbnRtYXBzXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlwiLCBuZXcgT2JqZWN0VHlwZShuZXcgTWFwPHN0cmluZywgVHlwZT4oW1tcIjxCYWNrc3BhY2U+XCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCI8RXNjYXBlPlwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgW1wiPFRhYj5cIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcIjxTLVRhYj5cIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcIjxBcnJvd1VwPlwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgW1wiPEFycm93RG93bj5cIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcIjxBcnJvd0xlZnQ+XCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCI8QXJyb3dSaWdodD5cIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcIjxFbnRlcj5cIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcIjxTcGFjZT5cIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV1dKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImxlYXZlZ2l0aHViYWxvbmVcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiV2hldGhlciB0byBhbGxvdyBwYWdlcyAobm90IG5lY2Vzc2FyaWx5IGdpdGh1YikgdG8gb3ZlcnJpZGUgYC9gLCB3aGljaCBpcyBhIGRlZmF1bHQgRmlyZWZveCBiaW5kaW5nLlwiLCBuZXcgVW5pb25UeXBlKFtuZXcgTGl0ZXJhbFR5cGVUeXBlKFwiZmFsc2VcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJ0cnVlXCIsIGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiYmxhY2tsaXN0a2V5c1wiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJXaGljaCBrZXlzIHRvIHByb3RlY3QgZnJvbSBwYWdlcyB0aGF0IHRyeSB0byBvdmVycmlkZSB0aGVtLiBSZXF1aXJlcyBbW2xlYXZlZ2l0aHViYWxvbmVdXSB0byBiZSBzZXQgdG8gZmFsc2UuXCIsIG5ldyBBcnJheVR5cGUobmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImF1dG9jbWRzXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkF1dG9jb21tYW5kcyB0aGF0IHJ1biB3aGVuIGNlcnRhaW4gZXZlbnRzIGhhcHBlbiwgYW5kIG90aGVyIGNvbmRpdGlvbnMgYXJlIG1ldC5cXG5cXG5SZWxhdGVkIGV4IGNvbW1hbmQ6IGBhdXRvY21kYC5cIiwgbmV3IE9iamVjdFR5cGUobmV3IE1hcDxzdHJpbmcsIFR5cGU+KFtbXCJEb2NTdGFydFwiLCBuZXcgT2JqZWN0VHlwZShuZXcgTWFwPHN0cmluZywgVHlwZT4oW10pLCBmYWxzZSwgZmFsc2UpXSwgW1wiRG9jTG9hZFwiLCBuZXcgT2JqZWN0VHlwZShuZXcgTWFwPHN0cmluZywgVHlwZT4oW1tcIl5odHRwczovL2dpdGh1Yi5jb20vdHJpZGFjdHlsL3RyaWRhY3R5bC9pc3N1ZXMvbmV3JFwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXV0pLCBmYWxzZSwgZmFsc2UpXSwgW1wiRG9jRW5kXCIsIG5ldyBPYmplY3RUeXBlKG5ldyBNYXA8c3RyaW5nLCBUeXBlPihbXSksIGZhbHNlLCBmYWxzZSldLCBbXCJUcmlTdGFydFwiLCBuZXcgT2JqZWN0VHlwZShuZXcgTWFwPHN0cmluZywgVHlwZT4oW1tcIi4qXCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldXSksIGZhbHNlLCBmYWxzZSldLCBbXCJUYWJFbnRlclwiLCBuZXcgT2JqZWN0VHlwZShuZXcgTWFwPHN0cmluZywgVHlwZT4oW10pLCBmYWxzZSwgZmFsc2UpXSwgW1wiVGFiTGVmdFwiLCBuZXcgT2JqZWN0VHlwZShuZXcgTWFwPHN0cmluZywgVHlwZT4oW10pLCBmYWxzZSwgZmFsc2UpXSwgW1wiRnVsbHNjcmVlbkNoYW5nZVwiLCBuZXcgT2JqZWN0VHlwZShuZXcgTWFwPHN0cmluZywgVHlwZT4oW10pLCBmYWxzZSwgZmFsc2UpXSwgW1wiRnVsbHNjcmVlbkVudGVyXCIsIG5ldyBPYmplY3RUeXBlKG5ldyBNYXA8c3RyaW5nLCBUeXBlPihbXSksIGZhbHNlLCBmYWxzZSldLCBbXCJGdWxsc2NyZWVuTGVmdFwiLCBuZXcgT2JqZWN0VHlwZShuZXcgTWFwPHN0cmluZywgVHlwZT4oW10pLCBmYWxzZSwgZmFsc2UpXV0pLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wia2V5dHJhbnNsYXRlbWFwXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIk1hcCBmb3IgdHJhbnNsYXRpbmcga2V5cyBkaXJlY3RseSBpbnRvIG90aGVyIGtleXMgaW4gbm9ybWFsLWlzaCBtb2Rlcy4gRm9yIGV4YW1wbGUsIGlmIHlvdSBoYXZlIGFuIGVudHJ5IGluIHRoaXMgY29uZmlnIG9wdGlvbiBtYXBwaW5nIGDQv2AgdG8gYGdgLCB0aGVuIHlvdSBjb3VsZCB0eXBlIGDQv9C/YCBpbnN0ZWFkIG9mIGBnZ2Agb3IgYNC/aWAgaW5zdGVhZCBvZiBgZ2lgIG9yIGA70L9gIGluc3RlYWQgb2YgYDtnYC4gVGhpcyBpcyBwcmltYXJpbHkgdXNlZnVsIGZvciBpbnRlcm5hdGlvbmFsIHVzZXJzIHdobyBkb24ndCB3YW50IHRvIGRlYWwgd2l0aCByZWJ1aWxkaW5nIHRoZWlyIGJpbmRpbmdzIGV2ZXJ5IHRpbWUgdHJpZGFjdHlsIHNoaXBzIGEgbmV3IGRlZmF1bHQga2V5YmluZC4gSXQncyBub3QgYXMgZ29vZCBhcyBzaGlwcGluZyBwcm9wZXJseSBpbnRlcm5hdGlvbmFsaXplZCBzZXRzIG9mIGRlZmF1bHQgYmluZGluZ3MsIGJ1dCBpdCdzIHByb2JhYmx5IGFzIGNsb3NlIGFzIHdlJ3JlIGdvaW5nIHRvIGdldCBvbiBhIHNtYWxsIG9wZW4tc291cmNlIHByb2plY3QgbGlrZSB0aGlzLlxcblxcbk5vdGUgdGhhdCB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCBhbGxvdyB5b3UgdG8gXFxcImNoYWluXFxcIiBrZXlzLCBmb3IgZXhhbXBsZSwgXFxcImFcXFwiPT5cXFwiYlxcXCIgYW5kIFxcXCJiXFxcIj0+XFxcImNcXFwiIGZvciBcXFwiYVxcXCI9PlxcXCJjXFxcIi4gWW91IGNhbiwgaG93ZXZlciwgc3dhcCBvciByb3RhdGUga2V5cywgc28gXFxcImFcXFwiPT5cXFwiYlxcXCIgYW5kIFxcXCJiXFxcIj0+XFxcImFcXFwiIHdpbGwgd29yayB0aGUgd2F5IHlvdSdkIGV4cGVjdCwgYXMgd2lsbCBcXFwiYVxcXCI9PlxcXCJiXFxcIiBhbmQgXFxcImJcXFwiPT5cXFwiY1xcXCIgYW5kIFxcXCJjXFxcIj0+XFxcImFcXFwiLlwiLCBuZXcgT2JqZWN0VHlwZShuZXcgTWFwPHN0cmluZywgVHlwZT4oW10pLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wia2V5dHJhbnNsYXRlbW9kZXNcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiV2hldGhlciB0byB1c2UgdGhlIGtleXRyYW5zbGF0ZW1hcCBpbiB2YXJpb3VzIG1hcHMuXCIsIG5ldyBPYmplY3RUeXBlKG5ldyBNYXA8c3RyaW5nLCBUeXBlPihbW1wiXCIsIG5ldyBVbmlvblR5cGUoW25ldyBMaXRlcmFsVHlwZVR5cGUoXCJmYWxzZVwiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcInRydWVcIiwgZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSldXSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJhdXRvY29udGFpblwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJBdXRvbWF0aWNhbGx5IHBsYWNlIHRoZXNlIHNpdGVzIGluIHRoZSBuYW1lZCBjb250YWluZXIuXFxuXFxuRWFjaCBrZXkgY29ycmVzcG9uZHMgdG8gYSBVUkwgZnJhZ21lbnQgd2hpY2gsIGlmIGNvbnRhaW5lZCB3aXRoaW4gdGhlIHBhZ2UgVVJMLCB0aGUgc2l0ZSB3aWxsIGJlIG9wZW5lZCBpbiBhIGNvbnRhaW5lciB0YWIgaW5zdGVhZC5cIiwgbmV3IEFueVR5cGUodHJ1ZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiZXhhbGlhc2VzXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkFsaWFzZXMgZm9yIHRoZSBjb21tYW5kbGluZS5cXG5cXG5Zb3UgY2FuIG1ha2UgYSBuZXcgb25lIHdpdGggYGNvbW1hbmQgYWxpYXMgZXgtY29tbWFuZGAuXCIsIG5ldyBPYmplY3RUeXBlKG5ldyBNYXA8c3RyaW5nLCBUeXBlPihbW1wiYWxpYXNcIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcImF1XCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCJhdWNvblwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgW1wiYXVkZWxcIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcImF1ZGVsZXRlXCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCJiXCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCJjbHNoXCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCJub2hsc2VhcmNoXCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCJub2hcIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcIm9cIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcIndcIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcInRcIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcInRhYm5ld1wiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgW1widGFibVwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgW1widGFib1wiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgW1wibXB2c2FmZVwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXV0pLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiZm9sbG93cGFnZXBhdHRlcm5zXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlVzZWQgYnkgYF1dYCBhbmQgYFtbYCB0byBsb29rIGZvciBsaW5rcyBjb250YWluaW5nIHRoZXNlIHdvcmRzLlxcblxcbkVkaXQgdGhlc2UgaWYgeW91IHdhbnQgdG8gYWRkLCBlLmcuIG90aGVyIGxhbmd1YWdlIHN1cHBvcnQuXCIsIG5ldyBPYmplY3RUeXBlKG5ldyBNYXA8c3RyaW5nLCBUeXBlPihbW1wibmV4dFwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgW1wicHJldlwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXV0pLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wic2VhcmNoZW5naW5lXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlRoZSBkZWZhdWx0IHNlYXJjaCBlbmdpbmUgdXNlZCBieSBgb3BlbiBzZWFyY2hgLiBJZiBlbXB0eSBzdHJpbmcsIHlvdXIgYnJvd3NlcidzIGRlZmF1bHQgc2VhcmNoIGVuZ2luZSB3aWxsIGJlIHVzZWQuIElmIHNldCB0byBzb21ldGhpbmcsIFRyaWRhY3R5bCB3aWxsIGZpcnN0IGxvb2sgYXQgeW91ciBbW3NlYXJjaHVybHNdXSBhbmQgdGhlbiBhdCB0aGUgc2VhcmNoIGVuZ2luZXMgZm9yIHdoaWNoIHlvdSBoYXZlIGRlZmluZWQgYSBrZXl3b3JkIG9uIGBhYm91dDpwcmVmZXJlbmNlcyNzZWFyY2hgLlwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wic2VhcmNodXJsc1wiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJEZWZpbml0aW9ucyBvZiBzZWFyY2ggZW5naW5lcyBmb3IgdXNlIHZpYSBgb3BlbiBba2V5d29yZF1gLlxcblxcbmAlc2Agd2lsbCBiZSByZXBsYWNlZCB3aXRoIHlvdXIgd2hvbGUgcXVlcnkgYW5kIGAlczFgLCBgJXMyYCwgLi4uLCBgJXNuYCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIGZpcnN0LCBzZWNvbmQgYW5kIG50aCB3b3JkIG9mIHlvdXIgcXVlcnkuIElmIHRoZXJlIGFyZSBub25lIG9mIHRoZXNlIHBhdHRlcm5zIGluIHlvdXIgc2VhcmNoIHVybHMsIHlvdXIgcXVlcnkgd2lsbCBzaW1wbHkgYmUgYXBwZW5kZWQgdG8gdGhlIHNlYXJjaHVybC5cXG5cXG5FeGFtcGxlczpcXG4tIFdoZW4gcnVubmluZyBgb3BlbiBnaSBjdXRlIHB1cHBpZXNgLCB3aXRoIGEgYGdpYCBzZWFyY2h1cmwgZGVmaW5lZCB3aXRoIGBzZXQgc2VhcmNodXJscy5naSBodHRwczovL3d3dy5nb29nbGUuY29tL3NlYXJjaD9xPSVzJnRibT1pc2NoYCwgdHJpZGFjdHlsIHdpbGwgbmF2aWdhdGUgdG8gYGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vc2VhcmNoP3E9Y3V0ZSBwdXBwaWVzJnRibT1pc2NoYC5cXG4tIFdoZW4gcnVubmluZyBgdGFib3BlbiB0cmFuc2xhdGUgZW4gamEgVHJpZGFjdHlsYCwgd2l0aCBhIGB0cmFuc2xhdGVgIHNlYXJjaHVybCBkZWZpbmVkIHdpdGggYHNldCBzZWFyY2h1cmxzLnRyYW5zbGF0ZSBodHRwczovL3RyYW5zbGF0ZS5nb29nbGUuY29tLyN2aWV3PWhvbWUmb3A9dHJhbnNsYXRlJnNsPSVzMSZ0bD0lczImdGV4dD0lczNgLCB0cmlkYWN0eWwgd2lsbCBuYXZpZ2F0ZSB0byBgaHR0cHM6Ly90cmFuc2xhdGUuZ29vZ2xlLmNvbS8jdmlldz1ob21lJm9wPXRyYW5zbGF0ZSZzbD1lbiZ0bD1qYSZ0ZXh0PVRyaWRhY3R5bGAuXCIsIG5ldyBPYmplY3RUeXBlKG5ldyBNYXA8c3RyaW5nLCBUeXBlPihbW1wiZ29vZ2xlXCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCJnb29nbGVsdWNreVwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgW1wic2Nob2xhclwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgW1wiZ29vZ2xldWtcIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcImJpbmdcIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcImR1Y2tkdWNrZ29cIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcInlhaG9vXCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCJ0d2l0dGVyXCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCJ3aWtpcGVkaWFcIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcInlvdXR1YmVcIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcImFtYXpvblwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpXSwgW1wiYW1hem9udWtcIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKV0sIFtcInF3YW50XCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldXSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJuZXd0YWJcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiVVJMIHRoZSBuZXd0YWIgd2lsbCByZWRpcmVjdCB0by5cXG5cXG5BbGwgdXN1YWwgcnVsZXMgYWJvdXQgdGhpbmdzIHlvdSBjYW4gb3BlbiB3aXRoIGBvcGVuYCBhcHBseSwgd2l0aCB0aGUgY2F2ZWF0IHRoYXQgeW91J2xsIGdldCBpbnRlcmVzdGluZyByZXN1bHRzIGlmIHlvdSB0cnkgdG8gdXNlIHNvbWV0aGluZyB0aGF0IG5lZWRzIGBuYXRpdmVvcGVuYDogc28gZG9uJ3QgdHJ5IGBhYm91dDpuZXd0YWJgLlwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1widmlld3NvdXJjZVwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJXaGV0aGVyIGA6dmlld3NvdXJjZWAgd2lsbCB1c2Ugb3VyIG93biBwYWdlIHRoYXQgeW91IGNhbiB1c2UgVHJpZGFjdHlsIGJpbmRzIG9uLCBvciBGaXJlZm94J3MgZGVmYXVsdCB2aWV3ZXIsIHdoaWNoIHlvdSBjYW5ub3QgdXNlIFRyaWRhY3R5bCBvbi5cIiwgbmV3IFVuaW9uVHlwZShbbmV3IExpdGVyYWxUeXBlVHlwZShcInRyaWRhY3R5bFwiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcImRlZmF1bHRcIiwgZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJzdG9yYWdlbG9jXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIldoaWNoIHN0b3JhZ2UgdG8gdXNlLiBTeW5jIHN0b3JhZ2Ugd2lsbCBzeW5jaHJvbmlzZSB5b3VyIHNldHRpbmdzIHZpYSB5b3VyIEZpcmVmb3ggQWNjb3VudC5cIiwgbmV3IFVuaW9uVHlwZShbbmV3IExpdGVyYWxUeXBlVHlwZShcInN5bmNcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJsb2NhbFwiLCBmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImhvbWVwYWdlc1wiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJQYWdlcyBvcGVuZWQgd2l0aCBgZ0hgLiBJbiBvcmRlciB0byBzZXQgdGhpcyB2YWx1ZSwgdXNlIGA6c2V0IGhvbWVwYWdlcyBbXFxcImV4YW1wbGUub3JnXFxcIiwgXFxcImV4YW1wbGUubmV0XFxcIiwgXFxcImV4YW1wbGUuY29tXFxcIl1gIGFuZCBzbyBvbi5cIiwgbmV3IEFycmF5VHlwZShuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiaGludGNoYXJzXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkNoYXJhY3RlcnMgdG8gdXNlIGluIGhpbnQgbW9kZS5cXG5cXG5UaGV5IGFyZSB1c2VkIHByZWZlcmVudGlhbGx5IGZyb20gbGVmdCB0byByaWdodC5cIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImhpbnRmaWx0ZXJtb2RlXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlRoZSB0eXBlIG9mIGhpbnRpbmcgdG8gdXNlLiBgdmltcGVyYXRvcmAgd2lsbCBhbGxvdyB5b3UgdG8gZmlsdGVyIGxpbmtzIGJhc2VkIG9uIHRoZWlyIG5hbWVzIGJ5IHR5cGluZyBub24taGludCBjaGFycy4gSXQgaXMgcmVjb21tZW5kZWQgdGhhdCB5b3UgdXNlIHRoaXMgaW4gY29uanVjdGlvbiB3aXRoIHRoZSBbW2hpbnRjaGFyc11dIHNldHRpbmcsIHdoaWNoIHlvdSBzaG91bGQgcHJvYmFibHkgc2V0IHRvIGUuZywgYDU0MzIxNjc4OTBgLiDCtHZpbXBlcmF0b3ItcmVmbG93wrQgYWRkaXRpb25hbGx5IHVwZGF0ZXMgdGhlIGhpbnQgbGFiZWxzIGFmdGVyIGZpbHRlcmluZy5cIiwgbmV3IFVuaW9uVHlwZShbbmV3IExpdGVyYWxUeXBlVHlwZShcInNpbXBsZVwiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcInZpbXBlcmF0b3JcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJ2aW1wZXJhdG9yLXJlZmxvd1wiLCBmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImhpbnRuYW1lc1wiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJXaGV0aGVyIHRvIG9wdGltaXNlIGZvciB0aGUgc2hvcnRlc3QgcG9zc2libGUgbmFtZXMgZm9yIGVhY2ggaGludCwgb3IgdG8gdXNlIGEgc2ltcGxlIG51bWVyaWNhbCBvcmRlcmluZy4gSWYgc2V0IHRvIGBudW1lcmljYCwgb3ZlcnJpZGVzIGBoaW50Y2hhcnNgIHNldHRpbmcuXCIsIG5ldyBVbmlvblR5cGUoW25ldyBMaXRlcmFsVHlwZVR5cGUoXCJzaG9ydFwiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcIm51bWVyaWNcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJ1bmlmb3JtXCIsIGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiaGludHVwcGVyY2FzZVwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJXaGV0aGVyIHRvIGRpc3BsYXkgdGhlIG5hbWVzIGZvciBoaW50cyBpbiB1cHBlcmNhc2UuXCIsIG5ldyBVbmlvblR5cGUoW25ldyBMaXRlcmFsVHlwZVR5cGUoXCJmYWxzZVwiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcInRydWVcIiwgZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJoaW50ZGVsYXlcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiVGhlIGRlbGF5IGluIG1pbGxpc2Vjb25kcyBpbiBgdmltcGVyYXRvcmAgc3R5bGUgaGludCBtb2RlcyBhZnRlciBzZWxlY3RpbmcgYSBoaW50IGJlZm9yZSB5b3UgYXJlIHJldHVybmVkIHRvIG5vcm1hbCBtb2RlLlxcblxcblRoZSBwb2ludCBvZiB0aGlzIGlzIHRvIHByZXZlbnQgYWNjaWRlbnRhbCBleGVjdXRpb24gb2Ygbm9ybWFsIG1vZGUgYmluZHMgZHVlIHRvIHBlb3BsZSB0eXBpbmcgbW9yZSB0aGFuIGlzIG5lY2Vzc2FyeSB0byBjaG9vc2UgYSBoaW50LlwiLCBuZXcgTnVtYmVyVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiYWxsb3dhdXRvZm9jdXNcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiQ29udHJvbHMgd2hldGhlciB0aGUgcGFnZSBjYW4gZm9jdXMgZWxlbWVudHMgZm9yIHlvdSB2aWEganNcXG5cXG5OQjogd2lsbCBicmVhayBmYW5jeSBlZGl0b3JzIHN1Y2ggYXMgQ29kZU1pcnJvciBvbiBKdXB5dGVyLiBTaW1wbHkgdXNlIGBzZXR1cmxgIHRvIHdoaXRlbGlzdCBwYWdlcyB5b3UgbmVlZCBpdCBvbi5cXG5cXG5CZXN0IHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBicm93c2VyLmF1dG9mb2N1cyBpbiBgYWJvdXQ6Y29uZmlnYFwiLCBuZXcgVW5pb25UeXBlKFtuZXcgTGl0ZXJhbFR5cGVUeXBlKFwiZmFsc2VcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJ0cnVlXCIsIGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wicHJldmVudGF1dG9mb2N1c2phY2toYW1tZXJcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiVXNlcyBhIGxvb3AgdG8gcHJldmVudCBmb2N1cyB1bnRpbCB5b3UgaW50ZXJhY3Qgd2l0aCBhIHBhZ2UuIE9ubHkgcmVjb21tZW5kZWQgZm9yIHVzZSB2aWEgYHNldHVybGAgZm9yIHByb2JsZW1hdGljIHNpdGVzIGFzIGl0IGNhbiBiZSBhIGxpdHRsZSBoZWF2eSBvbiBDUFUgaWYgcnVubmluZyBvbiBhbGwgdGFicy4gU2hvdWxkIGJlIHVzZWQgaW4gY29uanVjdGlvbiB3aXRoIFtbYWxsb3dhdXRvZm9jdXNdXVwiLCBuZXcgVW5pb25UeXBlKFtuZXcgTGl0ZXJhbFR5cGVUeXBlKFwiZmFsc2VcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJ0cnVlXCIsIGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wibmV3dGFiZm9jdXNcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiQ29udHJvbHMgd2hldGhlciB0aGUgbmV3dGFiIGZvY3VzZXMgb24gdHJpZGFjdHlsJ3MgbmV3dGFiIHBhZ2Ugb3IgdGhlIGZpcmVmb3ggdXJsYmFyLlxcblxcblRvIGdldCBGRiBkZWZhdWx0IGJlaGF2aW91ciwgdXNlIFxcXCJ1cmxiYXJcXFwiLlwiLCBuZXcgVW5pb25UeXBlKFtuZXcgTGl0ZXJhbFR5cGVUeXBlKFwicGFnZVwiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcInVybGJhclwiLCBmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInNtb290aHNjcm9sbFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJXaGV0aGVyIHRvIHVzZSBUcmlkYWN0eWwncyAoYmFkKSBzbW9vdGggc2Nyb2xsaW5nLlwiLCBuZXcgVW5pb25UeXBlKFtuZXcgTGl0ZXJhbFR5cGVUeXBlKFwiZmFsc2VcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJ0cnVlXCIsIGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wic2Nyb2xsZHVyYXRpb25cIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiSG93IHZpc2NvdXMgeW91IHdhbnQgc21vb3RoIHNjcm9sbGluZyB0byBmZWVsLlwiLCBuZXcgTnVtYmVyVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1widGFib3BlbnBvc1wiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJXaGVyZSB0byBvcGVuIHRhYnMgb3BlbmVkIHdpdGggYHRhYm9wZW5gIC0gdG8gdGhlIHJpZ2h0IG9mIHRoZSBjdXJyZW50IHRhYiwgb3IgYXQgdGhlIGVuZCBvZiB0aGUgdGFicy5cIiwgbmV3IFVuaW9uVHlwZShbbmV3IExpdGVyYWxUeXBlVHlwZShcIm5leHRcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJsYXN0XCIsIGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wicmVsYXRlZG9wZW5wb3NcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiV2hlcmUgdG8gb3BlbiB0YWJzIG9wZW5lZCB3aXRoIGhpbnRpbmcgLSBhcyBpZiBpdCBoYWQgYmVlbiBtaWRkbGUgY2xpY2tlZCwgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjdXJyZW50IHRhYiwgb3IgYXQgdGhlIGVuZCBvZiB0aGUgdGFicy5cIiwgbmV3IFVuaW9uVHlwZShbbmV3IExpdGVyYWxUeXBlVHlwZShcIm5leHRcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJsYXN0XCIsIGZhbHNlLCBmYWxzZSksXG5uZXcgTGl0ZXJhbFR5cGVUeXBlKFwicmVsYXRlZFwiLCBmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInR0c3ZvaWNlXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlRoZSBuYW1lIG9mIHRoZSB2b2ljZSB0byB1c2UgZm9yIHRleHQtdG8tc3BlZWNoLiBZb3UgY2FuIGdldCB0aGUgbGlzdCBvZiBpbnN0YWxsZWQgdm9pY2VzIGJ5IHJ1bm5pbmcgdGhlIGZvbGxvd2luZyBzbmlwcGV0OiBganMgYWxlcnQod2luZG93LnNwZWVjaFN5bnRoZXNpcy5nZXRWb2ljZXMoKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBcXFwiIFxcXCIgKyBiLm5hbWUpKWBcIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInR0c3ZvbHVtZVwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJDb250cm9scyB0ZXh0LXRvLXNwZWVjaCB2b2x1bWUuIEhhcyB0byBiZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuXCIsIG5ldyBOdW1iZXJUeXBlKGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJ0dHNyYXRlXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkNvbnRyb2xzIHRleHQtdG8tc3BlZWNoIHNwZWVkLiBIYXMgdG8gYmUgYSBudW1iZXIgYmV0d2VlbiAwLjEgYW5kIDEwLlwiLCBuZXcgTnVtYmVyVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1widHRzcGl0Y2hcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiQ29udHJvbHMgdGV4dC10by1zcGVlY2ggcGl0Y2guIEhhcyB0byBiZSBiZXR3ZWVuIDAgYW5kIDIuXCIsIG5ldyBOdW1iZXJUeXBlKGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJnaW1vZGVcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiSWYgbmV4dGlucHV0LCA8VGFiPiBhZnRlciBnaSBicmluZ3Mgc2VsZWN0cyB0aGUgbmV4dCBpbnB1dFxcblxcbklmIGZpcmVmb3gsIDxUYWI+IHNlbGVjdHMgdGhlIG5leHQgc2VsZWN0YWJsZSBlbGVtZW50LCBlLmcuIGEgbGlua1wiLCBuZXcgVW5pb25UeXBlKFtuZXcgTGl0ZXJhbFR5cGVUeXBlKFwibmV4dGlucHV0XCIsIGZhbHNlLCBmYWxzZSksXG5uZXcgTGl0ZXJhbFR5cGVUeXBlKFwiZmlyZWZveFwiLCBmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImN1cnNvcnBvc1wiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJEZWNpZGVzIHdoZXJlIHRvIHBsYWNlIHRoZSBjdXJzb3Igd2hlbiBzZWxlY3Rpbmcgbm9uLWVtcHR5IGlucHV0IGZpZWxkc1wiLCBuZXcgVW5pb25UeXBlKFtuZXcgTGl0ZXJhbFR5cGVUeXBlKFwiYmVnaW5uaW5nXCIsIGZhbHNlLCBmYWxzZSksXG5uZXcgTGl0ZXJhbFR5cGVUeXBlKFwiZW5kXCIsIGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1widGhlbWVcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiVGhlIHRoZW1lIHRvIHVzZS5cXG5cXG5QZXJtaXR0ZWQgdmFsdWVzOiBydW4gYDpjb21wb3NpdGUganMgdHJpLnN0eWxpbmcuVEhFTUVTIHwgZmlsbGNtZGxpbmVgIHRvIGZpbmQgb3V0LlwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiY3VzdG9tdGhlbWVzXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlN0b3JhZ2UgZm9yIGN1c3RvbSB0aGVtZXNcXG5cXG5NYXBzIHRoZW1lIG5hbWVzIHRvIENTUy4gUHJlZG9taW5hbnRseSB1c2VkIGF1dG9tYXRpY2FsbHkgYnkgW1tjb2xvdXJzY2hlbWVdXSB0byBzdG9yZSB0aGVtZXMgcmVhZCBmcm9tIGRpc2ssIGFzIGRvY3VtZW50ZWQgYnkgW1tjb2xvdXJzY2hlbWVdXS4gU2V0dGluZyB0aGlzIG1hbnVhbGx5IGlzIHVudGVzdGVkIGJ1dCBtaWdodCB3b3JrIHByb3ZpZGVkIHRoYXQgW1tjb2xvdXJzY2hlbWVdXSBpcyB0aGVuIHVzZWQgdG8gY2hhbmdlIHRoZSB0aGVtZSB0byB0aGUgcmlnaHQgdGhlbWUgbmFtZS5cIiwgbmV3IE9iamVjdFR5cGUobmV3IE1hcDxzdHJpbmcsIFR5cGU+KFtdKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcIm1vZGVpbmRpY2F0b3JcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiV2hldGhlciB0byBkaXNwbGF5IHRoZSBtb2RlIGluZGljYXRvciBvciBub3QuXCIsIG5ldyBVbmlvblR5cGUoW25ldyBMaXRlcmFsVHlwZVR5cGUoXCJmYWxzZVwiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcInRydWVcIiwgZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJqdW1wZGVsYXlcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiTWlsbGlzZWNvbmRzIGJlZm9yZSByZWdpc3RlcmluZyBhIHNjcm9sbCBpbiB0aGUganVtcGxpc3RcIiwgbmV3IE51bWJlclR5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImxvZ2dpbmdcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiTG9nZ2luZyBsZXZlbHMuIFVubGVzcyB5b3UncmUgZGVidWdnaW5nIFRyaWRhY3R5bCwgaXQncyB1bmxpa2VseSB5b3UnbGwgZXZlciBuZWVkIHRvIGNoYW5nZSB0aGVzZS5cIiwgbmV3IE9iamVjdFR5cGUobmV3IE1hcDxzdHJpbmcsIFR5cGU+KFtbXCJcIiwgbmV3IFVuaW9uVHlwZShbbmV3IExpdGVyYWxUeXBlVHlwZShcIm5ldmVyXCIsIGZhbHNlLCBmYWxzZSksXG5uZXcgTGl0ZXJhbFR5cGVUeXBlKFwiZXJyb3JcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJ3YXJuaW5nXCIsIGZhbHNlLCBmYWxzZSksXG5uZXcgTGl0ZXJhbFR5cGVUeXBlKFwiaW5mb1wiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcImRlYnVnXCIsIGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpXV0pLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wibm9pZnJhbWVcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiRGlzYWJsZXMgdGhlIGNvbW1hbmRsaW5lIGlmcmFtZS4gRGFuZ2Vyb3VzIHNldHRpbmcsIHVzZSBbW3NldHVybF1dIHRvIHNldCBpdC4gSWYgeW91IGV2ZXIgc2V0IHRoaXMgc2V0dGluZyB0byBcXFwidHJ1ZVxcXCIgZ2xvYmFsbHkgYW5kIHRoZW4gd2FudCB0byBzZXQgaXQgdG8gZmFsc2UgYWdhaW4sIHlvdSBjYW4gZG8gdGhpcyBieSBvcGVuaW5nIFRyaWRhY3R5bCdzIHByZWZlcmVuY2VzIHBhZ2UgZnJvbSBhYm91dDphZGRvbnMuXCIsIG5ldyBVbmlvblR5cGUoW25ldyBMaXRlcmFsVHlwZVR5cGUoXCJmYWxzZVwiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcInRydWVcIiwgZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJub2lmcmFtZW9uXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlwiLCBuZXcgQXJyYXlUeXBlKG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJlZGl0b3JjbWRcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiSW5zZXJ0IC8gaW5wdXQgbW9kZSBlZGl0LWluLSRFRElUT1IgY29tbWFuZCB0byBydW5cXG5UaGlzIGhhcyB0byBiZSBhIGNvbW1hbmQgdGhhdCBzdGF5cyBpbiB0aGUgZm9yZWdyb3VuZCBmb3IgdGhlIHdob2xlIGVkaXRpbmcgc2Vzc2lvblxcblxcXCJhdXRvXFxcIiB3aWxsIGF0dGVtcHQgdG8gZmluZCBhIHNhbmUgZWRpdG9yIGluIHlvdXIgcGF0aC5cXG5QbGVhc2Ugc2VuZCB5b3VyIHJlcXVlc3RzIHRvIGhhdmUgeW91ciBmYXZvdXJpdGUgdGVybWluYWwgbW92ZWQgZnVydGhlciB1cCB0aGUgbGlzdCB0byAvZGV2L251bGwuXFxuICAgICAgICAgIChidXQgd2UgYXJlIHByb2JhYmx5IGhhcHB5IHRvIGFkZCB5b3VyIHRlcm1pbmFsIHRvIHRoZSBsaXN0IGlmIGl0IGlzbid0IGFscmVhZHkgdGhlcmUuKVxcblxcbkV4YW1wbGUgdmFsdWVzOlxcbi0gbGludXg6IGB4dGVybSAtZSB2aW1gXFxuLSB3aW5kb3dzOiBgc3RhcnQgY21kLmV4ZSAvYyBcXFxcXFxcInZpbVxcXFxcXFwiYC5cXG5cXG5BbHNvIHNlZSBbOmVkaXRvcl0oL3N0YXRpYy9kb2NzL21vZHVsZXMvX3NyY19leGNtZHNfLmh0bWwjZWRpdG9yKS5cIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInJzc2NtZFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJDb21tYW5kIHRoYXQgc2hvdWxkIGJlIHJ1biBieSB0aGUgW1tyc3NleGVjXV0gZXggY29tbWFuZC4gSGFzIHRoZVxcbmZvbGxvd2luZyBmb3JtYXQ6XFxuLSAldTogdXJsXFxuLSAldDogdGl0bGVcXG4tICV5OiB0eXBlIChyc3MsIGF0b20sIHhtbC4uLilcXG5XYXJuaW5nOiBUaGlzIGlzIGEgdmVyeSBsYXJnZSBmb290Z3VuLiAldSB3aWxsIGJlIGluc2VydGVkIHdpdGhvdXQgYW55XFxua2luZCBvZiBlc2NhcGluZywgaGVuY2UgeW91IG11c3Qgb2JleSB0aGUgZm9sbG93aW5nIHJ1bGVzIGlmIHlvdSBjYXJlXFxuYWJvdXQgc2VjdXJpdHk6XFxuLSBEbyBub3QgdXNlIGEgY29tcG9zaXRlIGNvbW1hbmQuIElmIHlvdSBuZWVkIGEgY29tcG9zaXRlIGNvbW1hbmQsXFxuY3JlYXRlIGFuIGFsaWFzLlxcbi0gRG8gbm90IHVzZSBganNgIG9yIGBqc2JgLiBJZiB5b3UgbmVlZCB0byB1c2UgdGhlbSwgY3JlYXRlIGFuIGFsaWFzLlxcbi0gRG8gbm90IGluc2VydCBhbnkgJXUsICV0IG9yICV5IGluIHNoZWxsIGNvbW1hbmRzIHJ1biBieSB0aGUgbmF0aXZlXFxubWVzc2VuZ2VyLiBVc2UgcGlwZXMgaW5zdGVhZC5cXG5cXG5IZXJlJ3MgYW4gZXhhbXBsZSBvZiBob3cgdG8gc2F2ZSBhbiByc3MgdXJsIGluIGEgZmlsZSBvbiB5b3VyIGRpc2tcXG5zYWZlbHk6XFxuYGFsaWFzIHNhdmVfcnNzIGpzYiAtcCB0cmkubmF0aXZlLnJ1bihcXFwiY2F0ID4+IH4vLmNvbmZpZy5uZXdzYm9hdC91cmxzXFxcIiwgSlNfQVJHKWBcXG5gc2V0IHJzc2NtZCBzYXZlX3JzcyAldWBcXG5UaGlzIGlzIHNhZmUgYmVjYXVzZSB0aGUgdXJsIGlzIHBhc3NlZCB0byBqc2IgYXMgYW4gYXJndW1lbnQgcmF0aGVyIHRoYW5cXG5iZWluZyBleHBhbmRlZCBpbnNpZGUgb2YgdGhlIHN0cmluZyBpdCB3aWxsIGV4ZWN1dGUgYW5kIGJlY2F1c2UgaXQgaXNcXG5waXBlZCB0byB0aGUgc2hlbGwgY29tbWFuZCByYXRoZXIgdGhhbiBiZWluZyBleHBhbmRlZCBpbnNpZGUgb2YgaXQuXCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJicm93c2VyXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlRoZSBicm93c2VyIGV4ZWN1dGFibGUgdG8gbG9vayBmb3IgaW4gY29tbWFuZHMgc3VjaCBhcyBgcmVzdGFydGAuIE5vdCBhcyBtYWQgYXMgaXQgc2VlbXMgaWYgeW91IGhhdmUgbXVsdGlwbGUgdmVyc2lvbnMgb2YgRmlyZWZveC4uLlwiLCBuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wieWFua3RvXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIldoaWNoIGNsaXBib2FyZCB0byBzdG9yZSBpdGVtcyBpbi4gUmVxdWlyZXMgdGhlIG5hdGl2ZSBtZXNzZW5nZXIgdG8gYmUgaW5zdGFsbGVkLlwiLCBuZXcgVW5pb25UeXBlKFtuZXcgTGl0ZXJhbFR5cGVUeXBlKFwiY2xpcGJvYXJkXCIsIGZhbHNlLCBmYWxzZSksXG5uZXcgTGl0ZXJhbFR5cGVUeXBlKFwic2VsZWN0aW9uXCIsIGZhbHNlLCBmYWxzZSksXG5uZXcgTGl0ZXJhbFR5cGVUeXBlKFwiYm90aFwiLCBmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInB1dGZyb21cIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiV2hpY2ggY2xpcGJvYXJkIHRvIHJldHJpZXZlIGl0ZW1zIGZyb20uIFJlcXVpcmVzIHRoZSBuYXRpdmUgbWVzc2VuZ2VyIHRvIGJlIGluc3RhbGxlZC5cXG5cXG5QZXJtaXR0ZWQgdmFsdWVzOiBgY2xpcGJvYXJkYCwgb3IgYHNlbGVjdGlvbmAuXCIsIG5ldyBVbmlvblR5cGUoW25ldyBMaXRlcmFsVHlwZVR5cGUoXCJjbGlwYm9hcmRcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJzZWxlY3Rpb25cIiwgZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJleHRlcm5hbGNsaXBib2FyZGNtZFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJDbGlwYm9hcmQgY29tbWFuZCB0byB0cnkgdG8gZ2V0IHRoZSBzZWxlY3Rpb24gZnJvbSAoZS5nLiBgeHNlbGAgb3IgYHhjbGlwYClcIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcIm5hdGl2ZWluc3RhbGxjbWRcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiU2V0IHRoaXMgdG8gc29tZXRoaW5nIHdlaXJkIGlmIHlvdSB3YW50IHRvIGhhdmUgZnVuIGV2ZXJ5IHRpbWUgVHJpZGFjdHlsIHRyaWVzIHRvIHVwZGF0ZSBpdHMgbmF0aXZlIG1lc3Nlbmdlci5cXG5cXG4lVEFHIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB5b3VyIHZlcnNpb24gb2YgVHJpZGFjdHlsIGZvciBzdGFibGUgYnVpbGRzLCBvciBcXFwibWFzdGVyXFxcIiBmb3IgYmV0YSBidWlsZHNcIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcIndpbl9uYXRpdmVpbnN0YWxsY21kXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlNldCB0aGlzIHRvIHNvbWV0aGluZyB3ZWlyZCBpZiB5b3Ugd2FudCB0byBoYXZlIGZ1biBldmVyeSB0aW1lIFRyaWRhY3R5bCB0cmllcyB0byB1cGRhdGUgaXRzIG5hdGl2ZSBtZXNzZW5nZXIuXFxuXFxuUmVwbGFjZXMgJVdJTlRBRyB3aXRoIFxcXCItVGFnICRUUklfVkVSU0lPTlxcXCIsIHNpbWlsYXJseSB0byBbW25hdGl2ZWluc3RhbGxjbWRdXS5cIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInVwZGF0ZVwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJVc2VkIGJ5IDp1cGRhdGVjaGVjayBhbmQgcmVsYXRlZCBidWlsdC1pbiBmdW5jdGlvbmFsaXR5IHRvIGF1dG9tYXRpY2FsbHkgY2hlY2sgZm9yIHVwZGF0ZXMgYW5kIHByb21wdCB1c2VycyB0byB1cGdyYWRlLlwiLCBuZXcgT2JqZWN0VHlwZShuZXcgTWFwPHN0cmluZywgVHlwZT4oW1tcIm5hZ1wiLCBuZXcgQm9vbGVhblR5cGUoZmFsc2UsIGZhbHNlKV0sIFtcIm5hZ3dhaXRcIiwgbmV3IE51bWJlclR5cGUoZmFsc2UsIGZhbHNlKV0sIFtcImxhc3RuYWdnZWR2ZXJzaW9uXCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCJsYXN0Y2hlY2t0aW1lXCIsIG5ldyBOdW1iZXJUeXBlKGZhbHNlLCBmYWxzZSldLCBbXCJjaGVja2ludGVydmFsc2Vjc1wiLCBuZXcgTnVtYmVyVHlwZShmYWxzZSwgZmFsc2UpXV0pLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wicHJvZmlsZWRpclwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJQcm9maWxlIGRpcmVjdG9yeSB0byB1c2Ugd2l0aCBuYXRpdmUgbWVzc2VuZ2VyIHdpdGggZS5nLCBgZ3Vpc2V0YC5cIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInRhYm9wZW5jb250YWluZXJhd2FyZVwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJJZiBlbmFibGVkLCB0YWJvcGVuIG9wZW5zIGEgbmV3IHRhYiBpbiB0aGUgY3VycmVudGx5IGFjdGl2ZSB0YWIncyBjb250YWluZXIuXCIsIG5ldyBVbmlvblR5cGUoW25ldyBMaXRlcmFsVHlwZVR5cGUoXCJmYWxzZVwiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcInRydWVcIiwgZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJjb250YWluZXJpbmRpY2F0b3JcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiSWYgbW9vZGVpbmRpY2F0b3IgaXMgZW5hYmxlZCwgY29udGFpbmVyaW5kaWNhdG9yIHdpbGwgY29sb3IgdGhlIGJvcmRlciBvZiB0aGUgbW9kZSBpbmRpY2F0b3Igd2l0aCB0aGUgY29udGFpbmVyIGNvbG9yLlwiLCBuZXcgVW5pb25UeXBlKFtuZXcgTGl0ZXJhbFR5cGVUeXBlKFwiZmFsc2VcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJ0cnVlXCIsIGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiYXVjb25jcmVhdGVjb250YWluZXJcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiQXV0b2NvbnRhaW4gZGlyZWN0aXZlcyBjcmVhdGUgYSBjb250YWluZXIgaWYgaXQgZG9lc24ndCBleGlzdCBhbHJlYWR5LlwiLCBuZXcgVW5pb25UeXBlKFtuZXcgTGl0ZXJhbFR5cGVUeXBlKFwiZmFsc2VcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJ0cnVlXCIsIGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiaGlzdG9yeXJlc3VsdHNcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiTnVtYmVyIG9mIG1vc3QgcmVjZW50IHJlc3VsdHMgdG8gYXNrIEZpcmVmb3ggZm9yLiBXZSBkaXNwbGF5IHRoZSB0b3AgMjAgb3Igc28gbW9zdCBmcmVxdWVudGx5IHZpc2l0ZWQgb25lcy5cIiwgbmV3IE51bWJlclR5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImJtYXJrd2VpZ2h0XCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIldoZW4gZGlzcGxheWluZyBib29rbWFya3MgaW4gaGlzdG9yeSBjb21wbGV0aW9ucywgaG93IG1hbnkgcGFnZSB2aWV3cyB0byBwcmV0ZW5kIHRoZXkgaGF2ZS5cIiwgbmV3IE51bWJlclR5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImZpbmRyZXN1bHRzXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIk51bWJlciBvZiByZXN1bHRzIHRoYXQgc2hvdWxkIGJlIHNob3duIGluIGNvbXBsZXRpb25zLiAtMSBmb3IgdW5saW1pdGVkXCIsIG5ldyBOdW1iZXJUeXBlKGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJmaW5kY29udGV4dGxlblwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJOdW1iZXIgb2YgY2hhcmFjdGVycyB0byB1c2UgYXMgY29udGV4dCBmb3IgdGhlIG1hdGNoZXMgc2hvd24gaW4gY29tcGxldGlvbnNcIiwgbmV3IE51bWJlclR5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImZpbmRjYXNlXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIldoZXRoZXIgZmluZCBzaG91bGQgYmUgY2FzZS1zZW5zaXRpdmVcIiwgbmV3IFVuaW9uVHlwZShbbmV3IExpdGVyYWxUeXBlVHlwZShcInNtYXJ0XCIsIGZhbHNlLCBmYWxzZSksXG5uZXcgTGl0ZXJhbFR5cGVUeXBlKFwic2Vuc2l0aXZlXCIsIGZhbHNlLCBmYWxzZSksXG5uZXcgTGl0ZXJhbFR5cGVUeXBlKFwiaW5zZW5zaXRpdmVcIiwgZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJpbmNzZWFyY2hcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiV2hldGhlciBUcmlkYWN0eWwgc2hvdWxkIGp1bXAgdG8gdGhlIGZpcnN0IG1hdGNoIHdoZW4gdXNpbmcgYDpmaW5kYFwiLCBuZXcgVW5pb25UeXBlKFtuZXcgTGl0ZXJhbFR5cGVUeXBlKFwiZmFsc2VcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJ0cnVlXCIsIGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wibWluaW5jc2VhcmNobGVuXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkhvdyBtYW55IGNoYXJhY3RlcnMgc2hvdWxkIGJlIHR5cGVkIGJlZm9yZSB0cmlnZ2VyaW5nIGluY3NlYXJjaC9jb21wbGV0aW9uc1wiLCBuZXcgTnVtYmVyVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiY3NwXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkNoYW5nZSB0aGlzIHRvIFxcXCJjbG9iYmVyXFxcIiB0byBydWluIHRoZSBcXFwiQ29udGVudCBTZWN1cml0eSBQb2xpY3lcXFwiIG9mIGFsbCBzaXRlcyBhIGJpdCBhbmQgbWFrZSBUcmlkYWN0eWwgcnVuIGEgYml0IGJldHRlciBvbiBzb21lIG9mIHRoZW0sIGUuZy4gcmF3LmdpdGh1YipcIiwgbmV3IFVuaW9uVHlwZShbbmV3IExpdGVyYWxUeXBlVHlwZShcInVudG91Y2hlZFwiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcImNsb2JiZXJcIiwgZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJ3b3JkcGF0dGVyblwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJKYXZhU2NyaXB0IFJlZ0V4cCB1c2VkIHRvIHJlY29nbml6ZSB3b3JkcyBpbiB0ZXh0LiogZnVuY3Rpb25zIChlLmcuIHRleHQudHJhbnNwb3NlX3dvcmRzKS4gU2hvdWxkIG1hdGNoIGFueSBjaGFyYWN0ZXIgYmVsb25naW5nIHRvIGEgd29yZC5cIiwgbmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInBlcmZjb3VudGVyc1wiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJBY3RpdmF0ZSB0cmlkYWN0eWwncyBwZXJmb3JtYW5jZSBjb3VudGVycy4gVGhlc2UgaGF2ZSBhXFxubWVhc3VyYWJsZSBwZXJmb3JtYW5jZSBpbXBhY3QsIHNpbmNlIGV2ZXJ5IHNhbXBsZSBpcyBhIGZld1xcbmh1bmRyZWQgYnl0ZXMgYW5kIHdlIHNhbXBsZSB0cmlkYWN0eWwgZGVuc2VseSwgYnV0IHRoZXkncmUgZ29vZFxcbndoZW4geW91J3JlIHRyeWluZyB0byBvcHRpbWl6ZSB0aGluZ3MuXCIsIG5ldyBVbmlvblR5cGUoW25ldyBMaXRlcmFsVHlwZVR5cGUoXCJmYWxzZVwiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcInRydWVcIiwgZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJwZXJmc2FtcGxlc1wiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJIb3cgbWFueSBzYW1wbGVzIHRvIHN0b3JlIGZyb20gdGhlIHBlcmYgY291bnRlcnMuXFxuXFxuRWFjaCBwZXJmb3JtYW5jZSBlbnRyeSBpcyB0d28gbnVtYmVycyAoMTYgYnl0ZXMpLCBhbiBlbnRyeVR5cGVcXG5vZiBlaXRoZXIgXFxcIm1hcmtcXFwiIG9yIFxcXCJtZWFzdXJlXFxcIiAoanMgc3RyaW5ncyBhcmUgdXRmLTE2IGFkIHdlIGhhdmVcXG50d28gbWFya3MgZm9yIGVhY2ggbWVhc3VyZSwgc28gYW1vcnRpemUgdG8gYWJvdXQgMTAgYnl0ZXMgcGVyXFxuZW50cnkpLCBhbmQgYSBzdHJpbmcgbmFtZSB0aGF0IGZvciBUcmlkYWN0eWwgb2JqZWN0IHdpbGwgYmVcXG5hYm91dCA0MCAodXRmLTE2KSBjaGFyYWN0ZXJzICg4MCBieXRlcyksIHBsdXMgb2JqZWN0IG92ZXJoZWFkXFxucm91Z2hseSBwcm9wb3J0aW9uYWwgdG8gdGhlIHN0cmluZy1sZW5ndGggb2YgdGhlIG5hbWUgb2YgdGhlXFxuY29uc3RydWN0b3IgKGluIHRoaXMgY2FzZSBzb21ldGhpbmcgbGlrZSAzMCBieXRlcyksIGZvciBhIHRvdGFsXFxub2Ygd2hhdCB3ZSdsbCBjYWxsIDEyOCBieXRlcyBmb3IgZWFzZSBvZiBtYXRoLlxcblxcbldlIHdhbnQgdG8gc3RvcmUsIGJ5IGRlZmF1bHQsIGFib3V0IDFNQiBvZiBwZXJmb3JtYW5jZVxcbnN0YXRpc3RpY3MsIHNvIHNvbWV3aGVyZSBhcm91bmQgMTBrIHNhbXBsZXMuXCIsIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIGZhbHNlKV0sXG5bXCJtb2RlaW5kaWNhdG9yc2hvd2tleXNcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiU2hvdyAocGFydGlhbCkgY29tbWFuZCBpbiB0aGUgbW9kZSBpbmRpY2F0b3IuXFxuQ29ycmVzcG9uZHMgdG8gJ3Nob3djbWQnIG9wdGlvbiBvZiB2aS5cIiwgbmV3IFVuaW9uVHlwZShbbmV3IExpdGVyYWxUeXBlVHlwZShcImZhbHNlXCIsIGZhbHNlLCBmYWxzZSksXG5uZXcgTGl0ZXJhbFR5cGVUeXBlKFwidHJ1ZVwiLCBmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcInVybHBhcmVudHRyYWlsaW5nc2xhc2hcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiV2hldGhlciBhIHRyYWlsaW5nIHNsYXNoIGlzIGFwcGVuZGVkIHdoZW4gd2UgZ2V0IHRoZSBwYXJlbnQgb2YgYSB1cmwgd2l0aFxcbmd1IChvciBvdGhlciBtZWFucykuXCIsIG5ldyBVbmlvblR5cGUoW25ldyBMaXRlcmFsVHlwZVR5cGUoXCJmYWxzZVwiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcInRydWVcIiwgZmFsc2UsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlKV1dKSldXSksIG5ldyBNYXA8c3RyaW5nLCBTeW1ib2xNZXRhZGF0YT4oW1tcIm9cIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBBbnlUeXBlKHRydWUsIGZhbHNlKV0sIG5ldyBBbnlUeXBlKHRydWUsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgdHJ1ZSldLFxuW1wic2NobGVwcFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJcIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IEFueVR5cGUodHJ1ZSwgZmFsc2UpXSwgbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIHRydWUpXSxcbltcImdldERlZXBQcm9wZXJ0eVwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJHaXZlbiBhbiBvYmplY3QgYW5kIGEgdGFyZ2V0LCBleHRyYWN0IHRoZSB0YXJnZXQgaWYgaXQgZXhpc3RzLCBlbHNlIHJldHVybiB1bmRlZmluZWRcIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IEFueVR5cGUodHJ1ZSwgZmFsc2UpLG5ldyBBcnJheVR5cGUobmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKV0sIG5ldyBBbnlUeXBlKHRydWUsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgdHJ1ZSldLFxuW1wic2V0RGVlcFByb3BlcnR5XCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkNyZWF0ZSB0aGUga2V5IHBhdGggdGFyZ2V0IGlmIGl0IGRvZXNuJ3QgZXhpc3QgYW5kIHNldCB0aGUgZmluYWwgcHJvcGVydHkgdG8gdmFsdWUuXFxuXFxuSWYgdGhlIHBhdGggaXMgYW4gZW1wdHkgYXJyYXksIHJlcGxhY2UgdGhlIG9iai5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IEFueVR5cGUodHJ1ZSwgZmFsc2UpLG5ldyBBbnlUeXBlKHRydWUsIGZhbHNlKSxuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSldLCBuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIHRydWUpXSxcbltcIm1lcmdlRGVlcFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJcIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IEFueVR5cGUodHJ1ZSwgZmFsc2UpLG5ldyBBbnlUeXBlKHRydWUsIGZhbHNlKV0sIG5ldyBBbnlUeXBlKHRydWUsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgdHJ1ZSldLFxuW1wiZ2V0VVJMXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLG5ldyBBcnJheVR5cGUobmV3IFN0cmluZ1R5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKV0sIG5ldyBBbnlUeXBlKHRydWUsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgdHJ1ZSldLFxuW1wiZ2V0XCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkdldCB0aGUgdmFsdWUgb2YgdGhlIGtleSB0YXJnZXQuXFxuXFxuSWYgdGhlIHVzZXIgaGFzIG5vdCBzcGVjaWZpZWQgYSBrZXksIHVzZSB0aGUgY29ycmVzcG9uZGluZyBrZXkgZnJvbVxcbmRlZmF1bHRzLCBpZiBvbmUgZXhpc3RzLCBlbHNlIHVuZGVmaW5lZC5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IFVuaW9uVHlwZShbbmV3IExpdGVyYWxUeXBlVHlwZShcInJzc2NtZFwiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcIm5vaWZyYW1lb25cIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJ0aGVtZVwiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcImV4YWxpYXNlc1wiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcInZpZXdzb3VyY2VcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJhdXRvY29udGFpblwiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcImNvbmZpZ3ZlcnNpb25cIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJzdWJjb25maWdzXCIsIGZhbHNlLCBmYWxzZSksXG5uZXcgTGl0ZXJhbFR5cGVUeXBlKFwicHJpb3JpdHlcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJleG1hcHNcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJpZ25vcmVtYXBzXCIsIGZhbHNlLCBmYWxzZSksXG5uZXcgTGl0ZXJhbFR5cGVUeXBlKFwiaW1hcHNcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJpbnB1dG1hcHNcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIi4uLiA2MCBtb3JlIC4uLlwiLCBbXSwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJ1cmxwYXJlbnR0cmFpbGluZ3NsYXNoXCIsIGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgdHJ1ZSksbmV3IEFycmF5VHlwZShuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCB0cnVlLCBmYWxzZSldLCBuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIHRydWUpXSxcbltcImdldER5bmFtaWNcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiR2V0IHRoZSB2YWx1ZSBvZiB0aGUga2V5IHRhcmdldC5cXG5cXG5QbGVhc2Ugb25seSB1c2UgdGhpcyB3aXRoIHRhcmdldHMgdGhhdCB3aWxsIGJlIHVzZWQgYXQgcnVudGltZSAtIGl0IHNraXBzIHN0YXRpYyBjaGVja3MuIFByZWZlciBbW2dldF1dLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgQXJyYXlUeXBlKG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIHRydWUsIGZhbHNlKV0sIG5ldyBBbnlUeXBlKHRydWUsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UpXSxcbltcImdldEFzeW5jRHluYW1pY1wiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJHZXQgdGhlIHZhbHVlIG9mIHRoZSBrZXkgdGFyZ2V0LlxcblxcblBsZWFzZSBvbmx5IHVzZSB0aGlzIHdpdGggdGFyZ2V0cyB0aGF0IHdpbGwgYmUgdXNlZCBhdCBydW50aW1lIC0gaXQgc2tpcHMgc3RhdGljIGNoZWNrcy4gUHJlZmVyIFtbZ2V0QXN5bmNdXS5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IEFycmF5VHlwZShuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCB0cnVlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSldLFxuW1wiZ2V0QXN5bmNcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiR2V0IHRoZSB2YWx1ZSBvZiB0aGUga2V5IHRhcmdldCwgYnV0IHdhaXQgZm9yIGNvbmZpZyB0byBiZSBsb2FkZWQgZnJvbSB0aGVcXG5kYXRhYmFzZSBmaXJzdCBpZiBpdCBoYXMgbm90IGJlZW4gYXQgbGVhc3Qgb25jZSBiZWZvcmUuXFxuXFxuVGhpcyBpcyB1c2VmdWwgaWYgeW91IGFyZSBhIGNvbnRlbnQgc2NyaXB0IGFuZCB5b3UndmUganVzdCBiZWVuIGxvYWRlZC5cIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IFVuaW9uVHlwZShbbmV3IExpdGVyYWxUeXBlVHlwZShcInJzc2NtZFwiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcIm5vaWZyYW1lb25cIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJ0aGVtZVwiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcImV4YWxpYXNlc1wiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcInZpZXdzb3VyY2VcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJhdXRvY29udGFpblwiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcImNvbmZpZ3ZlcnNpb25cIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJzdWJjb25maWdzXCIsIGZhbHNlLCBmYWxzZSksXG5uZXcgTGl0ZXJhbFR5cGVUeXBlKFwicHJpb3JpdHlcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJleG1hcHNcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJpZ25vcmVtYXBzXCIsIGZhbHNlLCBmYWxzZSksXG5uZXcgTGl0ZXJhbFR5cGVUeXBlKFwiaW1hcHNcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJpbnB1dG1hcHNcIiwgZmFsc2UsIGZhbHNlKSxcbm5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIi4uLiA2MCBtb3JlIC4uLlwiLCBbXSwgZmFsc2UsIGZhbHNlKSxcbm5ldyBMaXRlcmFsVHlwZVR5cGUoXCJ1cmxwYXJlbnR0cmFpbGluZ3NsYXNoXCIsIGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgdHJ1ZSksbmV3IEFycmF5VHlwZShuZXcgU3RyaW5nVHlwZShmYWxzZSwgZmFsc2UpLCB0cnVlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCIuLi5cIiwgW10sIGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCB0cnVlKV0sXG5bXCJzZXRVUkxcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBBbnlUeXBlKHRydWUsIGZhbHNlKSxuZXcgQXJyYXlUeXBlKG5ldyBBbnlUeXBlKHRydWUsIGZhbHNlKSwgdHJ1ZSwgZmFsc2UpXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IEFueVR5cGUodHJ1ZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgdHJ1ZSldLFxuW1wic2V0XCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIkZ1bGwgdGFyZ2V0IHNwZWNpZmljYXRpb24sIHRoZW4gdmFsdWVcXG5cXG5lLmcuXFxuICAgIHNldChcXFwibm1hcHNcXFwiLCBcXFwib1xcXCIsIFxcXCJvcGVuXFxcIilcXG4gICAgc2V0KFxcXCJzZWFyY2hcXFwiLCBcXFwiZGVmYXVsdFxcXCIsIFxcXCJnb29nbGVcXFwiKVxcbiAgICBzZXQoXFxcImF1Y21kXFxcIiwgXFxcIkJ1ZlJlYWRcXFwiLCBcXFwibWVtcmlzZS5jb21cXFwiLCBcXFwib3BlbiBtZW1yaXNlLmNvbVxcXCIpXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBBcnJheVR5cGUobmV3IEFueVR5cGUodHJ1ZSwgZmFsc2UpLCB0cnVlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCB0cnVlKV0sXG5bXCJ1bnNldFVSTFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJcIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IEFueVR5cGUodHJ1ZSwgZmFsc2UpLG5ldyBBcnJheVR5cGUobmV3IEFueVR5cGUodHJ1ZSwgZmFsc2UpLCB0cnVlLCBmYWxzZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCB0cnVlKV0sXG5bXCJ1bnNldFwiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJEZWxldGUgdGhlIGtleSBhdCB0YXJnZXQgaW4gVVNFUkNPTkZJRyBpZiBpdCBleGlzdHNcIiwgbmV3IEZ1bmN0aW9uVHlwZShbbmV3IEFycmF5VHlwZShuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSksIHRydWUsIGZhbHNlKV0sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBBbnlUeXBlKHRydWUsIGZhbHNlKV0sIGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIHRydWUpXSxcbltcInNhdmVcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiU2F2ZSB0aGUgY29uZmlnIGJhY2sgdG8gc3RvcmFnZSBBUEkuXFxuXFxuQ29uZmlnIGlzIG5vdCBzeW5jaHJvbmlzZWQgYmV0d2VlbiBkaWZmZXJlbnQgaW5zdGFuY2VzIG9mIHRoaXMgbW9kdWxlIHVudGlsXFxuc29tZXRpbWUgYWZ0ZXIgdGhpcyBoYXBwZW5zLlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgVW5pb25UeXBlKFtuZXcgTGl0ZXJhbFR5cGVUeXBlKFwic3luY1wiLCBmYWxzZSwgZmFsc2UpLFxubmV3IExpdGVyYWxUeXBlVHlwZShcImxvY2FsXCIsIGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgdHJ1ZSldLCBuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQcm9taXNlXCIsIFtuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCB0cnVlKV0sXG5bXCJ1cGRhdGVcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiVXBkYXRlcyB0aGUgY29uZmlnIHRvIHRoZSBsYXRlc3QgdmVyc2lvbi5cXG5Qcm9wb3NlZCBzZW1hbnRpYyBmb3IgY29uZmlnIHZlcnNpb25uaW5nOlxcbi0geC55IC0+IHgrMS4wIDogbWFqb3IgYXJjaGl0ZWN0dXJhbCBjaGFuZ2VzXFxuLSB4LnkgLT4geC55KzEgOiByZW5hbWluZyBzZXR0aW5ncy9jaGFuZ2luZyB0aGVpciB0eXBlc1xcblRoZXJlJ3Mgbm8gbmVlZCBmb3IgYW4gdXBkYXRlciBpZiB5b3UncmUgb25seSBhZGRpbmcgYSBuZXcgc2V0dGluZy9jaGFuZ2luZ1xcbmEgZGVmYXVsdCBzZXR0aW5nXFxuXFxuV2hlbiBhZGRpbmcgdXBkYXRlcnMsIGRvbid0IGZvcmdldCB0byBzZXQoXFxcImNvbmZpZ3ZlcnNpb25cXFwiLCBuZXd2ZXJzaW9ubnVtYmVyKSFcIiwgbmV3IEZ1bmN0aW9uVHlwZShbXSwgbmV3IFR5cGVSZWZlcmVuY2VUeXBlKFwiUHJvbWlzZVwiLCBbbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSldLCBmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCB0cnVlKV0sXG5bXCJpbml0XCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlJlYWQgYWxsIHVzZXIgY29uZmlndXJhdGlvbiBmcm9tIHN0b3JhZ2UgQVBJIHRoZW4gbm90aWZ5IGFueSB3YWl0aW5nIGFzeW5jaHJvbm91cyBjYWxsc1xcblxcbmFzeW5jaHJvbm91cyBjYWxscyBnZW5lcmF0ZWQgYnkgZ2V0QXN5bmMuXCIsIG5ldyBGdW5jdGlvblR5cGUoW10sIG5ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlByb21pc2VcIiwgW25ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpXSwgZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKSwgdHJ1ZSldLFxuW1wiYWRkQ2hhbmdlTGlzdGVuZXJcIiwgbmV3IFN5bWJvbE1ldGFkYXRhKFwiXCIsIG5ldyBGdW5jdGlvblR5cGUoW25ldyBUeXBlUmVmZXJlbmNlVHlwZShcIlBcIiwgW10sIGZhbHNlLCBmYWxzZSksbmV3IEZ1bmN0aW9uVHlwZShbbmV3IEFueVR5cGUodHJ1ZSwgZmFsc2UpLG5ldyBBbnlUeXBlKHRydWUsIGZhbHNlKV0sIG5ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpXSwgbmV3IFZvaWRUeXBlKGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIHRydWUpXSxcbltcInJlbW92ZUNoYW5nZUxpc3RlbmVyXCIsIG5ldyBTeW1ib2xNZXRhZGF0YShcIlwiLCBuZXcgRnVuY3Rpb25UeXBlKFtuZXcgVHlwZVJlZmVyZW5jZVR5cGUoXCJQXCIsIFtdLCBmYWxzZSwgZmFsc2UpLG5ldyBGdW5jdGlvblR5cGUoW25ldyBBbnlUeXBlKHRydWUsIGZhbHNlKSxuZXcgQW55VHlwZSh0cnVlLCBmYWxzZSldLCBuZXcgVm9pZFR5cGUoZmFsc2UsIGZhbHNlKSwgZmFsc2UsIGZhbHNlKV0sIG5ldyBWb2lkVHlwZShmYWxzZSwgZmFsc2UpLCBmYWxzZSwgZmFsc2UpLCB0cnVlKV0sXG5bXCJwYXJzZUNvbmZpZ1wiLCBuZXcgU3ltYm9sTWV0YWRhdGEoXCJQYXJzZSB0aGUgY29uZmlnIGludG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSAudHJpZGFjdHlscmMgY29uZmlnIGZpbGUuXFxuVHJpZXMgdG8gcGFyc2UgdGhlIGNvbmZpZyBpbnRvIHNlY3Rpb25hYmxlIGNodW5rcyBiYXNlZCBvbiBrZXl3b3Jkcy5cXG5CaW5kcywgYWxpYXNlcywgYXV0b2NtZHMgYW5kIGxvZ2dpbmcgc2V0dGluZ3MgZWFjaCBoYXZlIHRoZWlyIG93biBzZWN0aW9uIHdoaWxlIHRoZSByZXN0IGFyZSBkdW1wZWQgaW50byBcXFwiR2VuZXJhbCBTZXR0aW5nc1xcXCIuXCIsIG5ldyBGdW5jdGlvblR5cGUoW10sIG5ldyBTdHJpbmdUeXBlKGZhbHNlLCBmYWxzZSksIGZhbHNlLCBmYWxzZSksIGZhbHNlKV1dKSldXSkpXG5cbmV4cG9ydCBsZXQgc3RhdGljVGhlbWVzID0gW1wiZGFya1wiLFwiZGVmYXVsdFwiLFwiZ3JlZW5tYXRcIixcImhhbGxvd2VlblwiLFwicXVha2VcIixcInNoeWRhY3R5bFwiXVxuIiwiLyoqICMgQ29tbWFuZCBsaW5lIGZ1bmN0aW9uc1xuICpcbiAqIFRoaXMgZmlsZSBjb250YWlucyBmdW5jdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgY29tbWFuZCBsaW5lLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIGJpbmQgdGhlbSB0byBrZXlib2FyZCBzaG9ydGN1dHMsIGJlIHN1cmUgdG8gcHJlZml4IHRoZW0gd2l0aCBcImV4LlwiLiBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gYmluZCBjb250cm9sLXAgdG8gYHByZXZfY29tcGxldGlvbmAsIHVzZTpcbiAqXG4gKiBgYGBcbiAqIGJpbmQgLS1tb2RlPWV4IDxDLXA+IGV4LnByZXZfY29tcGxldGlvblxuICogYGBgXG4gKlxuICogTm90ZSB0aGF0IHlvdSBjYW4gYWxzbyBiaW5kIFRyaWRhY3R5bCdzIFtlZGl0b3IgZnVuY3Rpb25zXSgvc3RhdGljL2RvY3MvbW9kdWxlcy9fc3JjX2xpYl9lZGl0b3JfLmh0bWwpIGluIHRoZSBjb21tYW5kIGxpbmUuXG4gKlxuICogQ29udHJhcnkgdG8gdGhlIG1haW4gdHJpZGFjdHlsIGhlbHAgcGFnZSwgdGhpcyBvbmUgZG9lc24ndCB0ZWxsIHlvdSB3aGV0aGVyIGEgc3BlY2lmaWMgZnVuY3Rpb24gaXMgYm91bmQgdG8gc29tZXRoaW5nLiBGb3Igbm93LCB5b3UnbGwgaGF2ZSB0byBtYWtlIGRvIHdpdGggYDpiaW5kYCBhbmQgYDp2aWV3Y29uZmlnYC5cbiAqXG4gKi9cbi8qKiBpZ25vcmUgdGhpcyBsaW5lICovXG5cbi8qKiBTY3JpcHQgdXNlZCBpbiB0aGUgY29tbWFuZGxpbmUgaWZyYW1lLiBDb21tdW5pY2F0ZXMgd2l0aCBiYWNrZ3JvdW5kLiAqL1xuXG5pbXBvcnQgKiBhcyBwZXJmIGZyb20gXCJAc3JjL3BlcmZcIlxuaW1wb3J0IFwiQHNyYy9saWIvbnVtYmVyLmNsYW1wXCJcbmltcG9ydCBcIkBzcmMvbGliL2h0bWwtdGFnZ2VkLXRlbXBsYXRlXCJcbmltcG9ydCB7IFRhYkFsbENvbXBsZXRpb25Tb3VyY2UgfSBmcm9tIFwiQHNyYy9jb21wbGV0aW9ucy9UYWJBbGxcIlxuaW1wb3J0IHsgQnVmZmVyQ29tcGxldGlvblNvdXJjZSB9IGZyb20gXCJAc3JjL2NvbXBsZXRpb25zL1RhYlwiXG5pbXBvcnQgeyBCbWFya0NvbXBsZXRpb25Tb3VyY2UgfSBmcm9tIFwiQHNyYy9jb21wbGV0aW9ucy9CbWFya1wiXG5pbXBvcnQgeyBFeGNtZENvbXBsZXRpb25Tb3VyY2UgfSBmcm9tIFwiQHNyYy9jb21wbGV0aW9ucy9FeGNtZFwiXG5pbXBvcnQgeyBGaWxlU3lzdGVtQ29tcGxldGlvblNvdXJjZSB9IGZyb20gXCJAc3JjL2NvbXBsZXRpb25zL0ZpbGVTeXN0ZW1cIlxuaW1wb3J0IHsgR3Vpc2V0Q29tcGxldGlvblNvdXJjZSB9IGZyb20gXCJAc3JjL2NvbXBsZXRpb25zL0d1aXNldFwiXG5pbXBvcnQgeyBIZWxwQ29tcGxldGlvblNvdXJjZSB9IGZyb20gXCJAc3JjL2NvbXBsZXRpb25zL0hlbHBcIlxuaW1wb3J0IHsgSGlzdG9yeUNvbXBsZXRpb25Tb3VyY2UgfSBmcm9tIFwiQHNyYy9jb21wbGV0aW9ucy9IaXN0b3J5XCJcbmltcG9ydCB7IFByZWZlcmVuY2VDb21wbGV0aW9uU291cmNlIH0gZnJvbSBcIkBzcmMvY29tcGxldGlvbnMvUHJlZmVyZW5jZXNcIlxuaW1wb3J0IHsgUnNzQ29tcGxldGlvblNvdXJjZSB9IGZyb20gXCJAc3JjL2NvbXBsZXRpb25zL1Jzc1wiXG5pbXBvcnQgeyBTZXNzaW9uc0NvbXBsZXRpb25Tb3VyY2UgfSBmcm9tIFwiQHNyYy9jb21wbGV0aW9ucy9TZXNzaW9uc1wiXG5pbXBvcnQgeyBTZXR0aW5nc0NvbXBsZXRpb25Tb3VyY2UgfSBmcm9tIFwiQHNyYy9jb21wbGV0aW9ucy9TZXR0aW5nc1wiXG5pbXBvcnQgeyBXaW5kb3dDb21wbGV0aW9uU291cmNlIH0gZnJvbSBcIkBzcmMvY29tcGxldGlvbnMvV2luZG93XCJcbmltcG9ydCAqIGFzIE1lc3NhZ2luZyBmcm9tIFwiQHNyYy9saWIvbWVzc2FnaW5nXCJcbmltcG9ydCBcIkBzcmMvbGliL251bWJlci5jbGFtcFwiXG5pbXBvcnQgc3RhdGUgZnJvbSBcIkBzcmMvc3RhdGVcIlxuaW1wb3J0IExvZ2dlciBmcm9tIFwiQHNyYy9saWIvbG9nZ2luZ1wiXG5pbXBvcnQgeyB0aGVtZSB9IGZyb20gXCJAc3JjL2NvbnRlbnQvc3R5bGluZ1wiXG5cbmltcG9ydCAqIGFzIGdlbmVyaWNQYXJzZXIgZnJvbSBcIkBzcmMvcGFyc2Vycy9nZW5lcmljbW9kZVwiXG5pbXBvcnQgKiBhcyB0cmlfZWRpdG9yIGZyb20gXCJAc3JjL2xpYi9lZGl0b3JcIlxuXG4vKiogQGhpZGRlbiAqKi9cbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoXCJjbWRsaW5lXCIpXG5cbi8qKiBAaGlkZGVuICoqL1xuY29uc3QgY29tbWFuZGxpbmVfc3RhdGUgPSB7XG4gICAgYWN0aXZlQ29tcGxldGlvbnM6IHVuZGVmaW5lZCxcbiAgICBjbElucHV0OiAod2luZG93LmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidHJpZGFjdHlsLWlucHV0XCIpIGFzIEhUTUxJbnB1dEVsZW1lbnQpLFxuICAgIGNsZWFyLFxuICAgIGNtZGxpbmVfaGlzdG9yeV9wb3NpdGlvbjogMCxcbiAgICBjb21wbGV0aW9uc0Rpdjogd2luZG93LmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY29tcGxldGlvbnNcIiksXG4gICAgZm5zOiB1bmRlZmluZWQsXG4gICAgZ2V0Q29tcGxldGlvbixcbiAgICBoaXN0b3J5LFxuICAgIC8qKiBAaGlkZGVuXG4gICAgICogVGhpcyBpcyB0byBoYW5kbGUgRXNjYXBlIGtleSB3aGljaCwgd2hpbGUgdGhlIGNtZGxpbmUgaXMgZm9jdXNlZCxcbiAgICAgKiBlbmRzIHVwIGZpcmluZyBib3RoIGtleWRvd24gYW5kIGlucHV0IGxpc3RlbmVycy4gSW4gdGhlIHdvcnN0IGNhc2VcbiAgICAgKiBoaWRlcyB0aGUgY21kbGluZSwgc2hvd3MgYW5kIHJlZm9jdXNlcyBpdCBhbmQgcmVwbGFjZXMgaXRzIHRleHRcbiAgICAgKiB3aGljaCBjb3VsZCBiZSB0aGUgcHJlZml4IHRvIGdlbmVyYXRlIGEgY29tcGxldGlvbi5cbiAgICAgKiB0bDtkciBUT0RPOiBkZWxldGUgdGhpcyBhbmQgYmV0dGVyIHJlc29sdmUgcmFjZSBjb25kaXRpb25cbiAgICAgKi9cbiAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgIGtleUV2ZW50czogW10sXG4gICAgcmVmcmVzaF9jb21wbGV0aW9ucyxcbiAgICBzdGF0ZSxcbn1cblxuLy8gZmlyc3QgdGhlbWluZyBvZiBjb21tYW5kbGluZSBpZnJhbWVcbnRoZW1lKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCI6cm9vdFwiKSlcblxuLyoqIEBoaWRkZW4gKiovXG5mdW5jdGlvbiByZXNpemVBcmVhKCkge1xuICAgIGlmIChjb21tYW5kbGluZV9zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgICAgTWVzc2FnaW5nLm1lc3NhZ2VPd25UYWIoXCJjb21tYW5kbGluZV9jb250ZW50XCIsIFwic2hvd1wiKVxuICAgICAgICBNZXNzYWdpbmcubWVzc2FnZU93blRhYihcImNvbW1hbmRsaW5lX2NvbnRlbnRcIiwgXCJmb2N1c1wiKVxuICAgICAgICBmb2N1cygpXG4gICAgfVxufVxuXG4vKiogQGhpZGRlblxuICogVGhpcyBpcyBhIGJpdCBsb29zZWx5IGRlZmluZWQgYXQgdGhlIG1vbWVudC5cbiAqIFNob3VsZCB3b3JrIHNvIGxvbmcgYXMgdGhlcmUncyBvbmx5IG9uZSBjb21wbGV0aW9uIHNvdXJjZSBwZXIgcHJlZml4LlxuICovXG5mdW5jdGlvbiBnZXRDb21wbGV0aW9uKCkge1xuICAgIGlmICghY29tbWFuZGxpbmVfc3RhdGUuYWN0aXZlQ29tcGxldGlvbnMpIHJldHVybiB1bmRlZmluZWRcblxuICAgIGZvciAoY29uc3QgY29tcCBvZiBjb21tYW5kbGluZV9zdGF0ZS5hY3RpdmVDb21wbGV0aW9ucykge1xuICAgICAgICBpZiAoY29tcC5zdGF0ZSA9PT0gXCJub3JtYWxcIiAmJiBjb21wLmNvbXBsZXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXAuY29tcGxldGlvblxuICAgICAgICB9XG4gICAgfVxufVxuY29tbWFuZGxpbmVfc3RhdGUuZ2V0Q29tcGxldGlvbiA9IGdldENvbXBsZXRpb25cblxuLyoqIEBoaWRkZW4gKiovXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlQ29tcGxldGlvbnMoKSB7XG4gICAgaWYgKCFjb21tYW5kbGluZV9zdGF0ZS5hY3RpdmVDb21wbGV0aW9ucykge1xuICAgICAgICBjb21tYW5kbGluZV9zdGF0ZS5hY3RpdmVDb21wbGV0aW9ucyA9IFtcbiAgICAgICAgICAgIC8vIEZpbmRDb21wbGV0aW9uU291cmNlLFxuICAgICAgICAgICAgQm1hcmtDb21wbGV0aW9uU291cmNlLFxuICAgICAgICAgICAgVGFiQWxsQ29tcGxldGlvblNvdXJjZSxcbiAgICAgICAgICAgIEJ1ZmZlckNvbXBsZXRpb25Tb3VyY2UsXG4gICAgICAgICAgICBFeGNtZENvbXBsZXRpb25Tb3VyY2UsXG4gICAgICAgICAgICBGaWxlU3lzdGVtQ29tcGxldGlvblNvdXJjZSxcbiAgICAgICAgICAgIEd1aXNldENvbXBsZXRpb25Tb3VyY2UsXG4gICAgICAgICAgICBIZWxwQ29tcGxldGlvblNvdXJjZSxcbiAgICAgICAgICAgIEhpc3RvcnlDb21wbGV0aW9uU291cmNlLFxuICAgICAgICAgICAgUHJlZmVyZW5jZUNvbXBsZXRpb25Tb3VyY2UsXG4gICAgICAgICAgICBSc3NDb21wbGV0aW9uU291cmNlLFxuICAgICAgICAgICAgU2Vzc2lvbnNDb21wbGV0aW9uU291cmNlLFxuICAgICAgICAgICAgU2V0dGluZ3NDb21wbGV0aW9uU291cmNlLFxuICAgICAgICAgICAgV2luZG93Q29tcGxldGlvblNvdXJjZSxcbiAgICAgICAgXVxuICAgICAgICAgICAgLm1hcChjb25zdHJ1Y3RvcnIgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgY29uc3RydWN0b3JyKGNvbW1hbmRsaW5lX3N0YXRlLmNvbXBsZXRpb25zRGl2KVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihjID0+IGMpXG5cbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcbiAgICAgICAgY29tbWFuZGxpbmVfc3RhdGUuYWN0aXZlQ29tcGxldGlvbnMuZm9yRWFjaChjb21wID0+IGZyYWdtZW50LmFwcGVuZENoaWxkKGNvbXAubm9kZSkpXG4gICAgICAgIGNvbW1hbmRsaW5lX3N0YXRlLmNvbXBsZXRpb25zRGl2LmFwcGVuZENoaWxkKGZyYWdtZW50KVxuICAgICAgICBsb2dnZXIuZGVidWcoY29tbWFuZGxpbmVfc3RhdGUuYWN0aXZlQ29tcGxldGlvbnMpXG4gICAgfVxufVxuLyogZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZW5hYmxlQ29tcGxldGlvbnMpICovXG5cbi8qKiBAaGlkZGVuICoqL1xuY29uc3Qgbm9ibHVyID0gZSA9PiBzZXRUaW1lb3V0KCgpID0+IGNvbW1hbmRsaW5lX3N0YXRlLmNsSW5wdXQuZm9jdXMoKSwgMClcblxuLyoqIEBoaWRkZW4gKiovXG5leHBvcnQgZnVuY3Rpb24gZm9jdXMoKSB7XG4gICAgY29tbWFuZGxpbmVfc3RhdGUuY2xJbnB1dC5mb2N1cygpXG4gICAgY29tbWFuZGxpbmVfc3RhdGUuY2xJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCBub2JsdXIpXG4gICAgY29tbWFuZGxpbmVfc3RhdGUuY2xJbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBub2JsdXIpXG59XG5cbi8qKiBAaGlkZGVuICoqL1xubGV0IEhJU1RPUllfU0VBUkNIX1NUUklORzogc3RyaW5nXG5cbi8qKiBAaGlkZGVuXG4gKiBDb21tYW5kIGxpbmUga2V5YmluZGluZ3NcbiAqKi9cbmNvbnN0IGtleVBhcnNlciA9IGtleXMgPT4gZ2VuZXJpY1BhcnNlci5wYXJzZXIoXCJleG1hcHNcIiwga2V5cylcbi8qKiBAaGlkZGVuICoqL1xubGV0IGhpc3RvcnlfY2FsbGVkID0gZmFsc2Vcbi8qKiBAaGlkZGVuICoqL1xubGV0IHByZXZfY21kX2NhbGxlZF9oaXN0b3J5ID0gZmFsc2Vcbi8qKiBAaGlkZGVuICoqL1xuY29tbWFuZGxpbmVfc3RhdGUuY2xJbnB1dC5hZGRFdmVudExpc3RlbmVyKFxuICAgIFwia2V5ZG93blwiLFxuICAgIGZ1bmN0aW9uKGtleWV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgIGlmICgha2V5ZXZlbnQuaXNUcnVzdGVkKSByZXR1cm5cbiAgICAgICAgY29tbWFuZGxpbmVfc3RhdGUua2V5RXZlbnRzLnB1c2goa2V5ZXZlbnQpXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0ga2V5UGFyc2VyKGNvbW1hbmRsaW5lX3N0YXRlLmtleUV2ZW50cylcbiAgICAgICAgaWYgKHJlc3BvbnNlLmlzTWF0Y2gpIHtcbiAgICAgICAgICAgIGtleWV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgIGtleWV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZGVhbGx5LCBhbGwga2V5cyB0aGF0IGFyZW4ndCBleHBsaWNpdGx5IGJvdW5kIHRvIGFuIGV4IGNvbW1hbmRcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBib3VuZCB0byBhIFwic2VsZi1pbnNlcnRcIiBjb21tYW5kIHRoYXQgd291bGQgaW5wdXQgdGhlXG4gICAgICAgICAgICAvLyBrZXkgaXRzZWxmLiBCZWNhdXNlIGl0J3Mgbm90IHBvc3NpYmxlIHRvIGdlbmVyYXRlIGV2ZW50cyBhcyBpZlxuICAgICAgICAgICAgLy8gdGhleSBvcmlnaW5hdGVkIGZyb20gdGhlIHVzZXIsIHdlIGNhbid0IGRvIHRoaXMsIGJ1dCB3ZSBzdGlsbFxuICAgICAgICAgICAgLy8gbmVlZCB0byBzaW11bGF0ZSBpdCwgaW4gb3JkZXIgdG8gaGF2ZSBoaXN0b3J5KCkgd29yay5cbiAgICAgICAgICAgIHByZXZfY21kX2NhbGxlZF9oaXN0b3J5ID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2UudmFsdWUpIHtcbiAgICAgICAgICAgIGNvbW1hbmRsaW5lX3N0YXRlLmtleUV2ZW50cyA9IFtdXG4gICAgICAgICAgICBoaXN0b3J5X2NhbGxlZCA9IGZhbHNlXG5cbiAgICAgICAgICAgIC8vIElmIGV4Y21kcyBzdGFydCB3aXRoICdleC4nIHRoZXkncmUgY29taW5nIGJhY2sgdG8gdXMgYW55d2F5LCBzbyBza2lwIHRoYXQuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGRlZmluaXRlbHkgYSBoYWNrLiBTaG91bGQgZXhwYW5kIGFsaWFzZXMgd2l0aCBleG1vZGUsIGV0Yy5cbiAgICAgICAgICAgIC8vIGJ1dCB0aGlzIHdob2xlIHRoaW5nIHNob3VsZCBiZSBzY3JhcHBlZCBzb29uLCBzbyB3aGF0ZXZlci5cbiAgICAgICAgICAgIGlmIChyZXNwb25zZS52YWx1ZS5zdGFydHNXaXRoKFwiZXguXCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnVuY25hbWUgPSByZXNwb25zZS52YWx1ZS5zbGljZSgzKVxuICAgICAgICAgICAgICAgIGNvbW1hbmRsaW5lX3N0YXRlLmZuc1tmdW5jbmFtZV0oKVxuICAgICAgICAgICAgICAgIHByZXZfY21kX2NhbGxlZF9oaXN0b3J5ID0gaGlzdG9yeV9jYWxsZWRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU2VuZCBleGNtZHMgZGlyZWN0bHkgdG8gb3VyIG93biB0YWIsIHdoaWNoIGZpeGVzIHRoZVxuICAgICAgICAgICAgICAgIC8vIG9sZCBidWcgd2hlcmUgYSBjb21tYW5kIHdvdWxkIGJlIGlzc3VlZCBpbiBvbmUgdGFiIGJ1dFxuICAgICAgICAgICAgICAgIC8vIGxhbmQgaW4gYW5vdGhlciBiZWNhdXNlIHRoZSBhY3RpdmUgdGFiIGhhZFxuICAgICAgICAgICAgICAgIC8vIGNoYW5nZWQuIEJhY2tncm91bmQtbW9kZSBleGNtZHMgd2lsbCBiZSByZWNlaXZlZCBieSB0aGVcbiAgICAgICAgICAgICAgICAvLyBvd24gdGFiJ3MgY29udGVudCBzY3JpcHQgYW5kIHRoZW4gYm91bmNlZCB0aHJvdWdoIGFcbiAgICAgICAgICAgICAgICAvLyBzaGltIHRvIHRoZSBiYWNrZ3JvdW5kLCBidXQgdGhlIGxhdGVuY3kgaW5jcmVhc2Ugc2hvdWxkXG4gICAgICAgICAgICAgICAgLy8gYmUgYWNjZXB0YWJsZSBiZWN1YXNlIHRoZSBiYWNrZ3JvdW5kLW1vZGUgZXhjbWRzIHRlbmRcbiAgICAgICAgICAgICAgICAvLyB0byBiZSBhIHRvdWNoIGxlc3MgbGF0ZW5jeS1zZW5zaXRpdmUuXG4gICAgICAgICAgICAgICAgTWVzc2FnaW5nLm1lc3NhZ2VPd25UYWIoXCJjb250cm9sbGVyX2NvbnRlbnRcIiwgXCJhY2NlcHRFeENtZFwiLCBbXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnZhbHVlLFxuICAgICAgICAgICAgICAgIF0pLnRoZW4oXyA9PiAocHJldl9jbWRfY2FsbGVkX2hpc3RvcnkgPSBoaXN0b3J5X2NhbGxlZCkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21tYW5kbGluZV9zdGF0ZS5rZXlFdmVudHMgPSByZXNwb25zZS5rZXlzXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRydWUsXG4pXG5cbmV4cG9ydCBmdW5jdGlvbiByZWZyZXNoX2NvbXBsZXRpb25zKGV4c3RyKSB7XG4gICAgaWYgKCFjb21tYW5kbGluZV9zdGF0ZS5hY3RpdmVDb21wbGV0aW9ucykgZW5hYmxlQ29tcGxldGlvbnMoKVxuICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgICAgY29tbWFuZGxpbmVfc3RhdGUuYWN0aXZlQ29tcGxldGlvbnMubWFwKGNvbXAgPT5cbiAgICAgICAgICAgIGNvbXAuZmlsdGVyKGV4c3RyKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcC5zaG91bGRSZWZyZXNoKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc2l6ZUFyZWEoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICApLFxuICAgICkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpXG4gICAgICAgIHJldHVybiBbXVxuICAgIH0pIC8vIFdlIGNhbid0IHVzZSB0aGUgcmVndWxhciBsb2dnaW5nIG1lY2hhbmlzbSBiZWNhdXNlIHRoZSB1c2VyIGlzIHVzaW5nIHRoZSBjb21tYW5kIGxpbmUuXG59XG5cbi8qKiBAaGlkZGVuICoqL1xubGV0IG9uSW5wdXRQcm9taXNlOiBQcm9taXNlPGFueT4gPSBQcm9taXNlLnJlc29sdmUoKVxuLyoqIEBoaWRkZW4gKiovXG5jb21tYW5kbGluZV9zdGF0ZS5jbElucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCAoKSA9PiB7XG4gICAgY29uc3QgZXhzdHIgPSBjb21tYW5kbGluZV9zdGF0ZS5jbElucHV0LnZhbHVlXG4gICAgLy8gU2NoZWR1bGUgY29tcGxldGlvbiBjb21wdXRhdGlvbi4gV2UgZG8gbm90IHN0YXJ0IGNvbXB1dGluZyBpbW1lZGlhdGVseSBiZWNhdXNlIHRoaXMgd291bGQgaW5jdXIgYSBzbG93IGRvd24gb24gcXVpY2tseSByZXBlYXRlZCBpbnB1dCBldmVudHMgKGUuZy4gbWFpbnRhaW5pbmcgPEJhY2tzcGFjZT4gcHJlc3NlZClcbiAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBwcmV2aW91cyBjb21wdXRhdGlvbiBoYXMgZW5kZWRcbiAgICAgICAgYXdhaXQgb25JbnB1dFByb21pc2VcbiAgICAgICAgLy8gSWYgd2UncmUgbm90IHRoZSBjdXJyZW50IGNvbXBsZXRpb24gY29tcHV0YXRpb24gYW55bW9yZSwgc3RvcFxuICAgICAgICBpZiAoZXhzdHIgIT09IGNvbW1hbmRsaW5lX3N0YXRlLmNsSW5wdXQudmFsdWUpIHJldHVyblxuXG4gICAgICAgIG9uSW5wdXRQcm9taXNlID0gcmVmcmVzaF9jb21wbGV0aW9ucyhleHN0cilcbiAgICB9LCAxMDApXG59KVxuXG4vKiogQGhpZGRlbiAqKi9cbmxldCBjbWRsaW5lX2hpc3RvcnlfY3VycmVudCA9IFwiXCJcblxuLyoqIEBoaWRkZW5cbiAqIENsZWFycyB0aGUgY29tbWFuZCBsaW5lLlxuICogSWYgeW91IGludGVuZCB0byBjbG9zZSB0aGUgY29tbWFuZCBsaW5lIGFmdGVyIHRoaXMsIHNldCBldmxpc3RlbmVyIHRvIHRydWUgaW4gb3JkZXIgdG8gZW5hYmxlIGxvc2luZyBmb2N1cy5cbiAqICBPdGhlcndpc2UsIG5vIG5lZWQgdG8gcGFzcyBhbiBhcmd1bWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyKGV2bGlzdGVuZXIgPSBmYWxzZSkge1xuICAgIGlmIChldmxpc3RlbmVyKSBjb21tYW5kbGluZV9zdGF0ZS5jbElucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIG5vYmx1cilcbiAgICBjb21tYW5kbGluZV9zdGF0ZS5jbElucHV0LnZhbHVlID0gXCJcIlxuICAgIGNvbW1hbmRsaW5lX3N0YXRlLmNtZGxpbmVfaGlzdG9yeV9wb3NpdGlvbiA9IDBcbiAgICBjbWRsaW5lX2hpc3RvcnlfY3VycmVudCA9IFwiXCJcbn1cbmNvbW1hbmRsaW5lX3N0YXRlLmNsZWFyID0gY2xlYXJcblxuLyoqIEBoaWRkZW4gKiovXG5mdW5jdGlvbiBoaXN0b3J5KG4pIHtcbiAgICBoaXN0b3J5X2NhbGxlZCA9IHRydWVcblxuICAgIGlmICghcHJldl9jbWRfY2FsbGVkX2hpc3RvcnkpIHtcbiAgICAgICAgSElTVE9SWV9TRUFSQ0hfU1RSSU5HID0gY29tbWFuZGxpbmVfc3RhdGUuY2xJbnB1dC52YWx1ZVxuICAgIH1cblxuICAgIGNvbnN0IG1hdGNoZXMgPSBzdGF0ZS5jbWRIaXN0b3J5LmZpbHRlcihrZXkgPT5cbiAgICAgICAga2V5LnN0YXJ0c1dpdGgoSElTVE9SWV9TRUFSQ0hfU1RSSU5HKSxcbiAgICApXG4gICAgaWYgKGNvbW1hbmRsaW5lX3N0YXRlLmNtZGxpbmVfaGlzdG9yeV9wb3NpdGlvbiA9PT0gMCkge1xuICAgICAgICBjbWRsaW5lX2hpc3RvcnlfY3VycmVudCA9IGNvbW1hbmRsaW5lX3N0YXRlLmNsSW5wdXQudmFsdWVcbiAgICB9XG4gICAgbGV0IGNsYW1wZWRfaW5kID0gbWF0Y2hlcy5sZW5ndGggKyBuIC0gY29tbWFuZGxpbmVfc3RhdGUuY21kbGluZV9oaXN0b3J5X3Bvc2l0aW9uXG4gICAgY2xhbXBlZF9pbmQgPSBjbGFtcGVkX2luZC5jbGFtcCgwLCBtYXRjaGVzLmxlbmd0aClcblxuICAgIGNvbnN0IHBvdF9oaXN0b3J5ID0gbWF0Y2hlc1tjbGFtcGVkX2luZF1cbiAgICBjb21tYW5kbGluZV9zdGF0ZS5jbElucHV0LnZhbHVlID1cbiAgICAgICAgcG90X2hpc3RvcnkgPT09IHVuZGVmaW5lZCA/IGNtZGxpbmVfaGlzdG9yeV9jdXJyZW50IDogcG90X2hpc3RvcnlcblxuICAgIC8vIGlmIHRoZXJlIHdhcyBubyBjbGFtcGFnZSwgdXBkYXRlIGhpc3RvcnkgcG9zaXRpb25cbiAgICAvLyB0aGVyZSdzIGEgbW9yZSBzZW5zaWJsZSB3YXkgb2YgZG9pbmcgdGhpcyBidXQgdGhhdCB3b3VsZCByZXF1aXJlIG1vcmUgcHJvZ3JhbW1lciB0aW1lXG4gICAgaWYgKGNsYW1wZWRfaW5kID09PSBtYXRjaGVzLmxlbmd0aCArIG4gLSBjb21tYW5kbGluZV9zdGF0ZS5jbWRsaW5lX2hpc3RvcnlfcG9zaXRpb24pXG4gICAgICAgIGNvbW1hbmRsaW5lX3N0YXRlLmNtZGxpbmVfaGlzdG9yeV9wb3NpdGlvbiA9IGNvbW1hbmRsaW5lX3N0YXRlLmNtZGxpbmVfaGlzdG9yeV9wb3NpdGlvbiAtIG5cbn1cbmNvbW1hbmRsaW5lX3N0YXRlLmhpc3RvcnkgPSBoaXN0b3J5XG5cbi8qKiBAaGlkZGVuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbGxjbWRsaW5lKFxuICAgIG5ld2NvbW1hbmQ/OiBzdHJpbmcsXG4gICAgdHJhaWxzcGFjZSA9IHRydWUsXG4gICAgZmZvY3VzID0gdHJ1ZSxcbikge1xuICAgIGlmICh0cmFpbHNwYWNlKSBjb21tYW5kbGluZV9zdGF0ZS5jbElucHV0LnZhbHVlID0gbmV3Y29tbWFuZCArIFwiIFwiXG4gICAgZWxzZSBjb21tYW5kbGluZV9zdGF0ZS5jbElucHV0LnZhbHVlID0gbmV3Y29tbWFuZFxuICAgIGNvbW1hbmRsaW5lX3N0YXRlLmlzVmlzaWJsZSA9IHRydWVcbiAgICBsZXQgcmVzdWx0ID0gUHJvbWlzZS5yZXNvbHZlKFtdKVxuICAgIC8vIEZvY3VzIGlzIGxvc3QgZm9yIHNvbWUgcmVhc29uLlxuICAgIGlmIChmZm9jdXMpIHtcbiAgICAgICAgZm9jdXMoKVxuICAgICAgICByZXN1bHQgPSByZWZyZXNoX2NvbXBsZXRpb25zKGNvbW1hbmRsaW5lX3N0YXRlLmNsSW5wdXQudmFsdWUpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbn1cblxuLyoqIEBoaWRkZW5cbiAqIENyZWF0ZSBhIHRlbXBvcmFyeSB0ZXh0YXJlYSBhbmQgZ2l2ZSBpdCB0byBmbi4gUmVtb3ZlIHRoZSB0ZXh0YXJlYSBhZnRlcndhcmRzXG4gKlxuICogVXNlZnVsIGZvciBkb2N1bWVudC5leGVjQ29tbWFuZFxuICoqL1xuZnVuY3Rpb24gYXBwbHlXaXRoVG1wVGV4dEFyZWEoZm4pIHtcbiAgICBsZXQgdGV4dGFyZWFcbiAgICB0cnkge1xuICAgICAgICB0ZXh0YXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKVxuICAgICAgICAvLyBTY3JhdGNocGFkIG11c3QgYmUgYGRpc3BsYXlgZWQsIGJ1dCBjYW4gYmUgdGlueSBhbmQgaW52aXNpYmxlLlxuICAgICAgICAvLyBCZWluZyB0aW55IGFuZCBpbnZpc2libGUgbWVhbnMgaXQgd29uJ3QgbWFrZSB0aGUgcGFyZW50IHBhZ2UgbW92ZS5cbiAgICAgICAgdGV4dGFyZWEuc3R5bGUuY3NzVGV4dCA9XG4gICAgICAgICAgICBcInZpc2libGU6IGludmlzaWJsZTsgd2lkdGg6IDA7IGhlaWdodDogMDsgcG9zaXRpb246IGZpeGVkXCJcbiAgICAgICAgdGV4dGFyZWEuY29udGVudEVkaXRhYmxlID0gXCJ0cnVlXCJcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHRleHRhcmVhKVxuICAgICAgICByZXR1cm4gZm4odGV4dGFyZWEpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRleHRhcmVhKVxuICAgIH1cbn1cblxuLyoqIEBoaWRkZW4gKiovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2V0Q2xpcGJvYXJkKGNvbnRlbnQ6IHN0cmluZykge1xuICAgIGF3YWl0IE1lc3NhZ2luZy5tZXNzYWdlT3duVGFiKFwiY29tbWFuZGxpbmVfY29udGVudFwiLCBcImZvY3VzXCIpXG4gICAgYXBwbHlXaXRoVG1wVGV4dEFyZWEoc2NyYXRjaHBhZCA9PiB7XG4gICAgICAgIHNjcmF0Y2hwYWQudmFsdWUgPSBjb250ZW50XG4gICAgICAgIHNjcmF0Y2hwYWQuc2VsZWN0KClcbiAgICAgICAgaWYgKGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiQ29weVwiKSkge1xuICAgICAgICAgICAgLy8gLy8gdG9kbzogTWF5YmUgd2UgY2FuIGNvbnNpZGVyIHRvIHVzaW5nIHNvbWUgbG9nZ2VyIGFuZCBzaG93IGl0IHdpdGggc3RhdHVzIGJhciBpbiB0aGUgZnV0dXJlXG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcInNldCBjbGlwYm9hcmQ6XCIsIHNjcmF0Y2hwYWQudmFsdWUpXG4gICAgICAgIH0gZWxzZSB0aHJvdyBcIkZhaWxlZCB0byBjb3B5IVwiXG4gICAgfSlcbiAgICAvLyBSZXR1cm4gZm9jdXMgdG8gdGhlIGRvY3VtZW50XG4gICAgYXdhaXQgTWVzc2FnaW5nLm1lc3NhZ2VPd25UYWIoXCJjb21tYW5kbGluZV9jb250ZW50XCIsIFwiaGlkZVwiKVxuICAgIHJldHVybiBNZXNzYWdpbmcubWVzc2FnZU93blRhYihcImNvbW1hbmRsaW5lX2NvbnRlbnRcIiwgXCJibHVyXCIpXG59XG5cbi8qKiBAaGlkZGVuICoqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENsaXBib2FyZCgpIHtcbiAgICBhd2FpdCBNZXNzYWdpbmcubWVzc2FnZU93blRhYihcImNvbW1hbmRsaW5lX2NvbnRlbnRcIiwgXCJmb2N1c1wiKVxuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGx5V2l0aFRtcFRleHRBcmVhKHNjcmF0Y2hwYWQgPT4ge1xuICAgICAgICBzY3JhdGNocGFkLmZvY3VzKClcbiAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJQYXN0ZVwiKVxuICAgICAgICByZXR1cm4gc2NyYXRjaHBhZC50ZXh0Q29udGVudFxuICAgIH0pXG4gICAgLy8gUmV0dXJuIGZvY3VzIHRvIHRoZSBkb2N1bWVudFxuICAgIGF3YWl0IE1lc3NhZ2luZy5tZXNzYWdlT3duVGFiKFwiY29tbWFuZGxpbmVfY29udGVudFwiLCBcImhpZGVcIilcbiAgICBhd2FpdCBNZXNzYWdpbmcubWVzc2FnZU93blRhYihcImNvbW1hbmRsaW5lX2NvbnRlbnRcIiwgXCJibHVyXCIpXG4gICAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKiogQGhpZGRlbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250ZW50KCkge1xuICAgIHJldHVybiBjb21tYW5kbGluZV9zdGF0ZS5jbElucHV0LnZhbHVlXG59XG5cbi8qKiBAaGlkZGVuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGVkaXRvcl9mdW5jdGlvbihmbl9uYW1lLCAuLi5hcmdzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFByb21pc2UucmVzb2x2ZShbXSlcbiAgICBpZiAodHJpX2VkaXRvcltmbl9uYW1lXSkge1xuICAgICAgICB0cmlfZWRpdG9yW2ZuX25hbWVdKGNvbW1hbmRsaW5lX3N0YXRlLmNsSW5wdXQsIC4uLmFyZ3MpXG4gICAgICAgIHJlc3VsdCA9IHJlZnJlc2hfY29tcGxldGlvbnMoY29tbWFuZGxpbmVfc3RhdGUuY2xJbnB1dC52YWx1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgdXNlciBpcyB1c2luZyB0aGUgY29tbWFuZCBsaW5lIHNvIHdlIGNhbid0IGxvZyBtZXNzYWdlIHRoZXJlXG4gICAgICAgIC8vIGxvZ2dlci5lcnJvcihgTm8gZWRpdG9yIGZ1bmN0aW9uIG5hbWVkICR7Zm5fbmFtZX0hYClcbiAgICAgICAgY29uc29sZS5lcnJvcihgTm8gZWRpdG9yIGZ1bmN0aW9uIG5hbWVkICR7Zm5fbmFtZX0hYClcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxufVxuXG5pbXBvcnQgKiBhcyBTRUxGIGZyb20gXCJAc3JjL2NvbW1hbmRsaW5lX2ZyYW1lXCJcbk1lc3NhZ2luZy5hZGRMaXN0ZW5lcihcImNvbW1hbmRsaW5lX2ZyYW1lXCIsIE1lc3NhZ2luZy5hdHRyaWJ1dGVDYWxsZXIoU0VMRikpXG5cbmltcG9ydCB7IGdldENvbW1hbmRsaW5lRm5zIH0gZnJvbSBcIkBzcmMvbGliL2NvbW1hbmRsaW5lX2NtZHNcIlxuY29tbWFuZGxpbmVfc3RhdGUuZm5zID0gZ2V0Q29tbWFuZGxpbmVGbnMoY29tbWFuZGxpbmVfc3RhdGUpXG5NZXNzYWdpbmcuYWRkTGlzdGVuZXIoXCJjb21tYW5kbGluZV9jbWRcIiwgTWVzc2FnaW5nLmF0dHJpYnV0ZUNhbGxlcihjb21tYW5kbGluZV9zdGF0ZS5mbnMpKVxuXG4vLyBMaXN0ZW4gZm9yIHN0YXRpc3RpY3MgZnJvbSB0aGUgY29tbWFuZGxpbmUgaWZyYW1lIGFuZCBzZW5kIHRoZW0gdG9cbi8vIHRoZSBiYWNrZ3JvdW5kIGZvciBjb2xsZWN0aW9uLiBBdHRhY2ggdGhlIG9ic2VydmVyIHRvIHRoZSB3aW5kb3dcbi8vIG9iamVjdCBzaW5jZSB0aGVyZSdzIGFwcGFyZW50bHkgYSBidWcgdGhhdCBjYXVzZXMgcGVyZm9ybWFuY2Vcbi8vIG9ic2VydmVycyB0byBiZSBHQydkIGV2ZW4gaWYgdGhleSdyZSBzdGlsbCB0aGUgdGFyZ2V0IG9mIGFcbi8vIGNhbGxiYWNrLlxuOyAod2luZG93IGFzIGFueSkudHJpID0gT2JqZWN0LmFzc2lnbih3aW5kb3cudHJpIHx8IHt9LCB7XG4gICAgcGVyZk9ic2VydmVyOiBwZXJmLmxpc3RlbkZvckNvdW50ZXJzKCksXG59KVxuIiwiLypcblxuSGF2ZSBhbiBhcnJheSBvZiBhbGwgY29tcGxldGlvbiBzb3VyY2VzLiBDb21wbGV0aW9uIHNvdXJjZXMgZGlzcGxheSBub3RoaW5nIGlmIHRoZSBmaWx0ZXIgZG9lc24ndCBtYXRjaCBmb3IgdGhlbS5cblxuT24gZWFjaCBpbnB1dCBldmVudCwgY2FsbCB1cGRhdGVDb21wbGV0aW9ucyBvbiB0aGUgYXJyYXkuIFRoYXQgd2lsbCBtdXRhdGUgdGhlIGFycmF5IGFuZCB1cGRhdGUgdGhlIGRpc3BsYXkgYXMgcmVxdWlyZWQuXG5cbkhvdyB0byBoYW5kbGUgY2FjaGVkIGUuZy4gYnVmZmVyIGluZm9ybWF0aW9uIGdvaW5nIG91dCBvZiBkYXRlP1xuXG5Db25jcmV0ZSBjb21wbGV0aW9uIGNsYXNzZXMgaGF2ZSBiZWVuIG1vdmVkIHRvIHNyYy9jb21wbGV0aW9ucy8uXG5cbiovXG5cbmltcG9ydCAqIGFzIEZ1c2UgZnJvbSBcImZ1c2UuanNcIlxuaW1wb3J0IHsgZW51bWVyYXRlIH0gZnJvbSBcIkBzcmMvbGliL2l0ZXJ0b29sc1wiXG5pbXBvcnQgeyB0b051bWJlciB9IGZyb20gXCJAc3JjL2xpYi9jb252ZXJ0XCJcbmltcG9ydCAqIGFzIGFsaWFzZXMgZnJvbSBcIkBzcmMvbGliL2FsaWFzZXNcIlxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9GQVZJQ09OID0gYnJvd3Nlci5ydW50aW1lLmdldFVSTChcbiAgICBcInN0YXRpYy9kZWZhdWx0RmF2aWNvbi5zdmdcIixcbilcblxuLy8ge3t7IElOVEVSRkFDRVNcblxudHlwZSBPcHRpb25TdGF0ZSA9IFwiZm9jdXNlZFwiIHwgXCJoaWRkZW5cIiB8IFwibm9ybWFsXCJcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENvbXBsZXRpb25PcHRpb24ge1xuICAgIC8qKiBXaGF0IHRvIGZpbGwgaW50byBjbWRsaW5lICovXG4gICAgdmFsdWU6IHN0cmluZ1xuICAgIC8qKiBDb250cm9sIHByZXNlbnRhdGlvbiBvZiB0aGUgb3B0aW9uICovXG4gICAgc3RhdGU6IE9wdGlvblN0YXRlXG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDb21wbGV0aW9uU291cmNlIHtcbiAgICByZWFkb25seSBvcHRpb25zOiBDb21wbGV0aW9uT3B0aW9uW11cbiAgICBub2RlOiBIVE1MRWxlbWVudFxuICAgIHB1YmxpYyBjb21wbGV0aW9uOiBzdHJpbmdcbiAgICBwcm90ZWN0ZWQgcHJlZml4ZXM6IHN0cmluZ1tdID0gW11cbiAgICBwcm90ZWN0ZWQgbGFzdEZvY3VzZWQ6IENvbXBsZXRpb25PcHRpb25cbiAgICBwcml2YXRlIF9zdGF0ZTogT3B0aW9uU3RhdGVcbiAgICBwcml2YXRlIF9wcmV2U3RhdGU6IE9wdGlvblN0YXRlXG5cbiAgICBjb25zdHJ1Y3RvcihwcmVmaXhlcykge1xuICAgICAgICBjb25zdCBjb21tYW5kcyA9IGFsaWFzZXMuZ2V0Q21kQWxpYXNNYXBwaW5nKClcblxuICAgICAgICAvLyBOb3csIGZvciBlYWNoIHByZWZpeCBnaXZlbiBhcyBhcmd1bWVudCwgYWRkIGl0IHRvIHRoZSBjb21wbGV0aW9uc291cmNlJ3MgcHJlZml4IGxpc3QgYW5kIGFsc28gYWRkIGFueSBhbGlhcyBpdCBoYXNcbiAgICAgICAgcHJlZml4ZXNcbiAgICAgICAgICAgIC5tYXAocCA9PiBwLnRyaW0oKSlcbiAgICAgICAgICAgIC5mb3JFYWNoKHAgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucHJlZml4ZXMucHVzaChwKVxuICAgICAgICAgICAgICAgIGlmIChjb21tYW5kc1twXSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmVmaXhlcyA9IHRoaXMucHJlZml4ZXMuY29uY2F0KGNvbW1hbmRzW3BdKVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAvLyBOb3Qgc3VyZSB0aGlzIGlzIG5lY2Vzc2FyeSBidXQgZXZlcnkgY29tcGxldGlvbiBzb3VyY2UgaGFzIGl0XG4gICAgICAgIHRoaXMucHJlZml4ZXMgPSB0aGlzLnByZWZpeGVzLm1hcChwID0+IHAgKyBcIiBcIilcbiAgICB9XG5cbiAgICAvKiogVXBkYXRlIFtbbm9kZV1dIHRvIGRpc3BsYXkgY29tcGxldGlvbnMgcmVsZXZhbnQgdG8gZXhzdHIgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgZmlsdGVyKGV4c3RyOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+XG5cbiAgICAvKiogQ29udHJvbCBwcmVzZW50YXRpb24gb2YgU291cmNlICovXG4gICAgc2V0IHN0YXRlKG5ld3N0YXRlOiBPcHRpb25TdGF0ZSkge1xuICAgICAgICBzd2l0Y2ggKG5ld3N0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFwibm9ybWFsXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlLmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIilcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRpb24gPSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSBcImhpZGRlblwiOlxuICAgICAgICAgICAgICAgIHRoaXMubm9kZS5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcmV2U3RhdGUgPSB0aGlzLl9zdGF0ZVxuICAgICAgICB0aGlzLl9zdGF0ZSA9IG5ld3N0YXRlXG4gICAgfVxuXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGVcbiAgICB9XG5cbiAgICBzaG91bGRSZWZyZXNoKCkge1xuICAgICAgICAvLyBBIGNvbXBsZXRpb24gc291cmNlIHNob3VsZCBiZSByZWZyZXNoZWQgaWYgaXQgaXMgbm90IGhpZGRlbiBvciBpZiBpdCBqdXN0IGJlY2FtZSBoaWRkZW5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlICE9PSBcImhpZGRlblwiIHx8IHRoaXMuc3RhdGUgIT09IHRoaXMuX3ByZXZTdGF0ZVxuICAgIH1cblxuICAgIGFic3RyYWN0IG5leHQoaW5jPzogbnVtYmVyKTogYm9vbGVhblxuXG4gICAgcHJldihpbmMgPSAxKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQoLTEgKiBpbmMpXG4gICAgfVxuXG4gICAgZGVzZWxlY3QoKSB7XG4gICAgICAgIHRoaXMuY29tcGxldGlvbiA9IHVuZGVmaW5lZFxuICAgICAgICBpZiAodGhpcy5sYXN0Rm9jdXNlZCAhPT0gdW5kZWZpbmVkKSB0aGlzLmxhc3RGb2N1c2VkLnN0YXRlID0gXCJub3JtYWxcIlxuICAgIH1cbn1cblxuLy8gRGVmYXVsdCBjbGFzc2VzXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDb21wbGV0aW9uT3B0aW9uSFRNTCBleHRlbmRzIENvbXBsZXRpb25PcHRpb24ge1xuICAgIHB1YmxpYyBodG1sOiBIVE1MRWxlbWVudFxuICAgIHB1YmxpYyB2YWx1ZVxuXG4gICAgcHJpdmF0ZSBfc3RhdGU6IE9wdGlvblN0YXRlID0gXCJoaWRkZW5cIlxuXG4gICAgLyoqIENvbnRyb2wgcHJlc2VudGF0aW9uIG9mIGVsZW1lbnQgKi9cbiAgICBzZXQgc3RhdGUobmV3c3RhdGU6IE9wdGlvblN0YXRlKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwic3RhdGUgZnJvbSB0b1wiLCB0aGlzLl9zdGF0ZSwgbmV3c3RhdGUpXG4gICAgICAgIHN3aXRjaCAobmV3c3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmb2N1c2VkXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5odG1sLmNsYXNzTGlzdC5hZGQoXCJmb2N1c2VkXCIpXG4gICAgICAgICAgICAgICAgdGhpcy5odG1sLnNjcm9sbEludG9WaWV3KClcbiAgICAgICAgICAgICAgICB0aGlzLmh0bWwuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlIFwibm9ybWFsXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5odG1sLmNsYXNzTGlzdC5yZW1vdmUoXCJmb2N1c2VkXCIpXG4gICAgICAgICAgICAgICAgdGhpcy5odG1sLmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIilcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSBcImhpZGRlblwiOlxuICAgICAgICAgICAgICAgIHRoaXMuaHRtbC5jbGFzc0xpc3QucmVtb3ZlKFwiZm9jdXNlZFwiKVxuICAgICAgICAgICAgICAgIHRoaXMuaHRtbC5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0ZSA9IG5ld3N0YXRlXG4gICAgfVxuXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGVcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGxldGlvbk9wdGlvbkZ1c2UgZXh0ZW5kcyBDb21wbGV0aW9uT3B0aW9uSFRNTCB7XG4gICAgLy8gRm9yIGZ1enp5IG1hdGNoaW5nXG4gICAgZnVzZUtleXM6IGFueVtdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2NvcmVkT3B0aW9uIHtcbiAgICBpbmRleDogbnVtYmVyXG4gICAgb3B0aW9uOiBDb21wbGV0aW9uT3B0aW9uRnVzZVxuICAgIHNjb3JlOiBudW1iZXJcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENvbXBsZXRpb25Tb3VyY2VGdXNlIGV4dGVuZHMgQ29tcGxldGlvblNvdXJjZSB7XG4gICAgcHVibGljIG5vZGVcbiAgICBwdWJsaWMgb3B0aW9uczogQ29tcGxldGlvbk9wdGlvbkZ1c2VbXVxuXG4gICAgZnVzZU9wdGlvbnM6IEZ1c2UuRnVzZU9wdGlvbnM8YW55PiA9IHtcbiAgICAgICAga2V5czogW1wiZnVzZUtleXNcIl0sXG4gICAgICAgIHNob3VsZFNvcnQ6IHRydWUsXG4gICAgICAgIGlkOiBcImluZGV4XCIsXG4gICAgICAgIGluY2x1ZGVTY29yZTogdHJ1ZSxcbiAgICB9XG5cbiAgICAvLyBQRVJGOiBDb3VsZCBiZSBleHBlbnNpdmUgbm90IHRvIGNhY2hlIEZ1c2UoKVxuICAgIC8vIHllYWgsIGl0IHdhcy5cbiAgICBmdXNlID0gdW5kZWZpbmVkXG5cbiAgICBwcm90ZWN0ZWQgbGFzdEV4c3RyOiBzdHJpbmdcblxuICAgIHByb3RlY3RlZCBvcHRpb25Db250YWluZXIgPSBodG1sYDx0YWJsZSBjbGFzcz1cIm9wdGlvbkNvbnRhaW5lclwiPjwvdGFibGU+YFxuXG4gICAgY29uc3RydWN0b3IocHJlZml4ZXMsIGNsYXNzTmFtZTogc3RyaW5nLCB0aXRsZT86IHN0cmluZykge1xuICAgICAgICBzdXBlcihwcmVmaXhlcylcbiAgICAgICAgdGhpcy5ub2RlID0gaHRtbGA8ZGl2IGNsYXNzPVwiJHtjbGFzc05hbWV9IGhpZGRlblwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uSGVhZGVyXCI+JHt0aXRsZSB8fCBjbGFzc05hbWV9PC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5gXG4gICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLm9wdGlvbkNvbnRhaW5lcilcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFwiaGlkZGVuXCJcbiAgICB9XG5cbiAgICAvKiBhYnN0cmFjdCBvblVwZGF0ZShxdWVyeTogc3RyaW5nLCBwcmVmaXg6IHN0cmluZywgb3B0aW9uczogQ29tcGxldGlvbk9wdGlvbkZ1c2VbXSkgKi9cbiAgICBhYnN0cmFjdCBvbklucHV0KGV4c3RyOiBzdHJpbmcpXG5cbiAgICAvLyBIZWxwZnVsIGRlZmF1bHQgaW1wbGVtZW50YXRpb25zXG5cbiAgICBwdWJsaWMgYXN5bmMgZmlsdGVyKGV4c3RyOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5sYXN0RXhzdHIgPSBleHN0clxuICAgICAgICBhd2FpdCB0aGlzLm9uSW5wdXQoZXhzdHIpXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUNoYWluKClcbiAgICB9XG5cbiAgICB1cGRhdGVDaGFpbihleHN0ciA9IHRoaXMubGFzdEV4c3RyLCBvcHRpb25zID0gdGhpcy5vcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBcImhpZGRlblwiXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IFtwcmVmaXgsIHF1ZXJ5XSA9IHRoaXMuc3BsaXRPblByZWZpeChleHN0cilcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhwcmVmaXgsIHF1ZXJ5LCBvcHRpb25zKVxuXG4gICAgICAgIC8vIEhpZGUgc2VsZiBhbmQgc3RvcCBpZiBwcmVmaXhlcyBkb24ndCBtYXRjaFxuICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgICAvLyBTaG93IHNlbGYgaWYgcHJlZml4IGFuZCBjdXJyZW50bHkgaGlkZGVuXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJoaWRkZW5cIikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBcIm5vcm1hbFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gXCJoaWRkZW5cIlxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaWx0ZXIgYnkgcXVlcnkgaWYgcXVlcnkgaXMgbm90IGVtcHR5XG4gICAgICAgIGlmIChxdWVyeSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZUZyb21TY29yZSh0aGlzLnNjb3JlZE9wdGlvbnMocXVlcnkpKVxuICAgICAgICAgICAgLy8gRWxzZSBzaG93IGFsbCBvcHRpb25zXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zLmZvckVhY2gob3B0aW9uID0+IChvcHRpb24uc3RhdGUgPSBcIm5vcm1hbFwiKSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGwgY29uY3JldGUgY2xhc3NcbiAgICAgICAgdGhpcy51cGRhdGVEaXNwbGF5KClcbiAgICB9XG5cbiAgICBzZWxlY3Qob3B0aW9uOiBDb21wbGV0aW9uT3B0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmxhc3RFeHN0ciAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBbcHJlZml4XSA9IHRoaXMuc3BsaXRPblByZWZpeCh0aGlzLmxhc3RFeHN0cilcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGlvbiA9IHByZWZpeCArIG9wdGlvbi52YWx1ZVxuICAgICAgICAgICAgb3B0aW9uLnN0YXRlID0gXCJmb2N1c2VkXCJcbiAgICAgICAgICAgIHRoaXMubGFzdEZvY3VzZWQgPSBvcHRpb25cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImxhc3RFeHN0ciBhbmQgb3B0aW9uIG11c3QgYmUgZGVmaW5lZCFcIilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNwbGl0T25QcmVmaXgoZXhzdHI6IHN0cmluZykge1xuICAgICAgICBmb3IgKGNvbnN0IHByZWZpeCBvZiB0aGlzLnByZWZpeGVzKSB7XG4gICAgICAgICAgICBpZiAoZXhzdHIuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBleHN0ci5yZXBsYWNlKHByZWZpeCwgXCJcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gW3ByZWZpeCwgcXVlcnldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAgICB9XG5cbiAgICAvKiogUnRuIHNvcnRlZCBhcnJheSBvZiB7b3B0aW9uLCBzY29yZX0gKi9cbiAgICBzY29yZWRPcHRpb25zKHF1ZXJ5OiBzdHJpbmcsIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMpOiBTY29yZWRPcHRpb25bXSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaFRoaXMgPSB0aGlzLm9wdGlvbnMubWFwKChlbGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgaW5kZXgsIGZ1c2VLZXlzOiBlbGVtLmZ1c2VLZXlzIH1cbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5mdXNlID0gbmV3IEZ1c2Uoc2VhcmNoVGhpcywgdGhpcy5mdXNlT3B0aW9ucylcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVzZS5zZWFyY2gocXVlcnkpLm1hcChyZXN1bHQgPT4ge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2cocmVzdWx0LCByZXN1bHQuaXRlbSwgcXVlcnkpXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRvTnVtYmVyKHJlc3VsdC5pdGVtKVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICBvcHRpb246IHRoaXMub3B0aW9uc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgc2NvcmU6IHJlc3VsdC5zY29yZSBhcyBudW1iZXIsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqIFNldCBvcHRpb24gc3RhdGUgYnkgc2NvcmVcblxuICAgICAgICBGb3Igbm93IGp1c3QgZGlzcGxheXMgYWxsIHNjb3JlZCBlbGVtZW50cyAoc2VlIHRocmVzaG9sZCBpbiBmdXNlKSBhbmRcbiAgICAgICAgZm9jdXMgdGhlIGJlc3QgbWF0Y2guXG4gICAgKi9cbiAgICBzZXRTdGF0ZUZyb21TY29yZShzY29yZWRPcHRzOiBTY29yZWRPcHRpb25bXSwgYXV0b3NlbGVjdCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBzY29yZWRPcHRzLm1hcChyZXMgPT4gcmVzLmluZGV4KVxuXG4gICAgICAgIGZvciAoY29uc3QgW2luZGV4LCBvcHRpb25dIG9mIGVudW1lcmF0ZSh0aGlzLm9wdGlvbnMpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hlcy5pbmNsdWRlcyhpbmRleCkpIG9wdGlvbi5zdGF0ZSA9IFwibm9ybWFsXCJcbiAgICAgICAgICAgIGVsc2Ugb3B0aW9uLnN0YXRlID0gXCJoaWRkZW5cIlxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWRlYWxseSwgdGhpcyB3b3VsZCBub3QgZGVzZWxlY3QgYW55dGhpbmcgdW5sZXNzIGl0IGZlbGwgb2ZmIHRoZSBsaXN0IG9mIG1hdGNoZXNcbiAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoICYmIGF1dG9zZWxlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KHRoaXMub3B0aW9uc1ttYXRjaGVzWzBdXSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzZWxlY3QoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIENhbGwgdG8gcmVwbGFjZSB0aGUgY3VycmVudCBkaXNwbGF5ICovXG4gICAgLy8gVE9ETzogb3B0aW9uQ29udGFpbmVyLnJlcGxhY2VXaXRoIGFuZCBvcHRpb25Db250YWluZXIucmVtb3ZlIGRvbid0IHdvcmsuXG4gICAgLy8gSSBkb24ndCBrbm93IHdoeSwgYnV0IGl0IG1lYW5zIHdlIGNhbid0IHJlcGxhY2UgdGhlIGRpdiBpbiBvbmUgZ28uIE1heWJlXG4gICAgLy8gYW4gaWZyYW1lIHRoaW5nLlxuICAgIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICAgIC8qIGNvbnN0IG5ld0NvbnRhaW5lciA9IGh0bWxgPGRpdj5gICovXG5cbiAgICAgICAgd2hpbGUgKHRoaXMub3B0aW9uQ29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25Db250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5vcHRpb25Db250YWluZXIubGFzdENoaWxkKVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgdGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICAvKiBuZXdDb250YWluZXIuYXBwZW5kQ2hpbGQob3B0aW9uLmh0bWwpICovXG4gICAgICAgICAgICBpZiAob3B0aW9uLnN0YXRlICE9PSBcImhpZGRlblwiKVxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uQ29udGFpbmVyLmFwcGVuZENoaWxkKG9wdGlvbi5odG1sKVxuICAgICAgICB9XG5cbiAgICAgICAgLyogY29uc29sZS5sb2coJ3VwZGF0ZURpc3BsYXknLCB0aGlzLm9wdGlvbkNvbnRhaW5lciwgbmV3Q29udGFpbmVyKSAqL1xuXG4gICAgICAgIC8qIGxldCByZXN1bHQxID0gdGhpcy5vcHRpb25Db250YWluZXIucmVtb3ZlKCkgKi9cbiAgICAgICAgLyogbGV0IHJlczIgPSB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQobmV3Q29udGFpbmVyKSAqL1xuICAgICAgICAvKiBjb25zb2xlLmxvZygncmVzdWx0cycsIHJlc3VsdDEsIHJlczIpICovXG4gICAgfVxuXG4gICAgbmV4dChpbmMgPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBcImhpZGRlblwiKSB7XG4gICAgICAgICAgICBjb25zdCB2aXNvcHRzID0gdGhpcy5vcHRpb25zLmZpbHRlcihvID0+IG8uc3RhdGUgIT09IFwiaGlkZGVuXCIpXG4gICAgICAgICAgICBjb25zdCBjdXJyaW5kID0gdmlzb3B0cy5maW5kSW5kZXgobyA9PiBvLnN0YXRlID09PSBcImZvY3VzZWRcIilcbiAgICAgICAgICAgIHRoaXMuZGVzZWxlY3QoKVxuICAgICAgICAgICAgLy8gdmlzb3B0cy5sZW5ndGggKyAxIGJlY2F1c2Ugd2Ugd2FudCBhbiBlbXB0eSBjb21wbGV0aW9uIGF0IHRoZSBlbmRcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IHZpc29wdHMubGVuZ3RoICsgMVxuICAgICAgICAgICAgY29uc3Qgb3B0ID0gdmlzb3B0c1soY3VycmluZCArIGluYyArIG1heCkgJSBtYXhdXG4gICAgICAgICAgICBpZiAob3B0KSB0aGlzLnNlbGVjdChvcHQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9IGVsc2UgcmV0dXJuIGZhbHNlXG4gICAgfVxufVxuXG4vLyB9fX1cbiIsImltcG9ydCAqIGFzIENvbXBsZXRpb25zIGZyb20gXCJAc3JjL2NvbXBsZXRpb25zXCJcbmltcG9ydCAqIGFzIHByb3ZpZGVycyBmcm9tIFwiQHNyYy9jb21wbGV0aW9ucy9wcm92aWRlcnNcIlxuXG5jbGFzcyBCbWFya0NvbXBsZXRpb25PcHRpb24gZXh0ZW5kcyBDb21wbGV0aW9ucy5Db21wbGV0aW9uT3B0aW9uSFRNTFxuICAgIGltcGxlbWVudHMgQ29tcGxldGlvbnMuQ29tcGxldGlvbk9wdGlvbkZ1c2Uge1xuICAgIHB1YmxpYyBmdXNlS2V5cyA9IFtdXG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHVibGljIHZhbHVlOiBzdHJpbmcsXG4gICAgICAgIGJtYXJrOiBicm93c2VyLmJvb2ttYXJrcy5Cb29rbWFya1RyZWVOb2RlLFxuICAgICkge1xuICAgICAgICBzdXBlcigpXG4gICAgICAgIGlmICghYm1hcmsudGl0bGUpIHtcbiAgICAgICAgICAgIGJtYXJrLnRpdGxlID0gbmV3IFVSTChibWFyay51cmwpLmhvc3RcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFB1c2ggcHJvcGVydGllcyB3ZSB3YW50IHRvIGZ1em1hdGNoIG9uXG4gICAgICAgIHRoaXMuZnVzZUtleXMucHVzaChibWFyay50aXRsZSwgYm1hcmsudXJsKVxuXG4gICAgICAgIHRoaXMuaHRtbCA9IGh0bWxgPHRyIGNsYXNzPVwiQm1hcmtDb21wbGV0aW9uT3B0aW9uIG9wdGlvblwiPlxuICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cInByZWZpeFwiPiR7XCJcIi5wYWRFbmQoMil9PC90ZD5cbiAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJ0aXRsZVwiPiR7Ym1hcmsudGl0bGV9PC90ZD5cbiAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJjb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVwidXJsXCIgdGFyZ2V0PVwiX2JsYW5rXCIgaHJlZj0ke2JtYXJrLnVybH1cbiAgICAgICAgICAgICAgICAgICAgICAgID4ke2JtYXJrLnVybH08L2FcbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8L3RyPmBcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCbWFya0NvbXBsZXRpb25Tb3VyY2UgZXh0ZW5kcyBDb21wbGV0aW9ucy5Db21wbGV0aW9uU291cmNlRnVzZSB7XG4gICAgcHVibGljIG9wdGlvbnM6IEJtYXJrQ29tcGxldGlvbk9wdGlvbltdXG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wYXJlbnQpIHtcbiAgICAgICAgc3VwZXIoW1wiYm1hcmtzXCJdLCBcIkJtYXJrQ29tcGxldGlvblNvdXJjZVwiLCBcIkJvb2ttYXJrc1wiKVxuXG4gICAgICAgIHRoaXMuX3BhcmVudC5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpXG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGZpbHRlcihleHN0cjogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMubGFzdEV4c3RyID0gZXhzdHJcbiAgICAgICAgbGV0IFtwcmVmaXgsIHF1ZXJ5XSA9IHRoaXMuc3BsaXRPblByZWZpeChleHN0cilcbiAgICAgICAgbGV0IG9wdGlvbiA9IFwiXCJcblxuICAgICAgICAvLyBIaWRlIHNlbGYgYW5kIHN0b3AgaWYgcHJlZml4ZXMgZG9uJ3QgbWF0Y2hcbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgICAgLy8gU2hvdyBzZWxmIGlmIHByZWZpeCBhbmQgY3VycmVudGx5IGhpZGRlblxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gXCJub3JtYWxcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFwiaGlkZGVuXCJcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHF1ZXJ5LnN0YXJ0c1dpdGgoXCItdCBcIikpIHtcbiAgICAgICAgICAgIG9wdGlvbiA9IFwiLXQgXCJcbiAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkuc2xpY2UoMylcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVlcnkuc3RhcnRzV2l0aChcIi1jXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gcXVlcnkuc3BsaXQoXCIgXCIpXG4gICAgICAgICAgICBvcHRpb24gKz0gYXJncy5zbGljZSgwLCAyKS5qb2luKFwiIFwiKVxuICAgICAgICAgICAgb3B0aW9uICs9IFwiIFwiO1xuICAgICAgICAgICAgcXVlcnkgPSBhcmdzLnNsaWNlKDIpLmpvaW4oXCIgXCIpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbXBsZXRpb24gPSB1bmRlZmluZWRcbiAgICAgICAgdGhpcy5vcHRpb25zID0gKGF3YWl0IHByb3ZpZGVycy5nZXRCb29rbWFya3MocXVlcnkpKS5zbGljZSgwLCAxMCkubWFwKFxuICAgICAgICAgICAgcGFnZSA9PiBuZXcgQm1hcmtDb21wbGV0aW9uT3B0aW9uKG9wdGlvbiArIHBhZ2UudXJsLCBwYWdlKSxcbiAgICAgICAgKVxuXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUNoYWluKClcbiAgICB9XG5cbiAgICB1cGRhdGVDaGFpbigpIHtcbiAgICAgICAgLy8gT3B0aW9ucyBhcmUgcHJlLXRyaW1tZWQgdG8gdGhlIHJpZ2h0IGxlbmd0aC5cbiAgICAgICAgdGhpcy5vcHRpb25zLmZvckVhY2gob3B0aW9uID0+IChvcHRpb24uc3RhdGUgPSBcIm5vcm1hbFwiKSlcblxuICAgICAgICAvLyBDYWxsIGNvbmNyZXRlIGNsYXNzXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZURpc3BsYXkoKVxuICAgIH1cblxuICAgIG9uSW5wdXQoKSB7fVxuXG4gICAgc2VsZWN0KG9wdGlvbjogQ29tcGxldGlvbnMuQ29tcGxldGlvbk9wdGlvbikge1xuICAgICAgICBpZiAodGhpcy5sYXN0RXhzdHIgIT09IHVuZGVmaW5lZCAmJiBvcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0aW9uID0gXCJibWFya3MgXCIgKyBvcHRpb24udmFsdWVcbiAgICAgICAgICAgIG9wdGlvbi5zdGF0ZSA9IFwiZm9jdXNlZFwiXG4gICAgICAgICAgICB0aGlzLmxhc3RGb2N1c2VkID0gb3B0aW9uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsYXN0RXhzdHIgYW5kIG9wdGlvbiBtdXN0IGJlIGRlZmluZWQhXCIpXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBDb21wbGV0aW9ucyBmcm9tIFwiQHNyYy9jb21wbGV0aW9uc1wiXG5pbXBvcnQgKiBhcyBNZXRhZGF0YSBmcm9tIFwiQHNyYy8ubWV0YWRhdGEuZ2VuZXJhdGVkXCJcbmltcG9ydCAqIGFzIGNvbmZpZyBmcm9tIFwiQHNyYy9saWIvY29uZmlnXCJcbmltcG9ydCAqIGFzIGFsaWFzZXMgZnJvbSBcIkBzcmMvbGliL2FsaWFzZXNcIlxuXG5jbGFzcyBFeGNtZENvbXBsZXRpb25PcHRpb24gZXh0ZW5kcyBDb21wbGV0aW9ucy5Db21wbGV0aW9uT3B0aW9uSFRNTFxuICAgIGltcGxlbWVudHMgQ29tcGxldGlvbnMuQ29tcGxldGlvbk9wdGlvbkZ1c2Uge1xuICAgIHB1YmxpYyBmdXNlS2V5cyA9IFtdXG4gICAgY29uc3RydWN0b3IocHVibGljIHZhbHVlOiBzdHJpbmcsIHB1YmxpYyBkb2N1bWVudGF0aW9uOiBzdHJpbmcgPSBcIlwiKSB7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgdGhpcy5mdXNlS2V5cy5wdXNoKHRoaXMudmFsdWUpXG5cbiAgICAgICAgLy8gQ3JlYXRlIEhUTUxFbGVtZW50XG4gICAgICAgIHRoaXMuaHRtbCA9IGh0bWxgPHRyIGNsYXNzPVwiRXhjbWRDb21wbGV0aW9uT3B0aW9uIG9wdGlvblwiPlxuICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cImV4Y21kXCI+JHt2YWx1ZX08L3RkPlxuICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cImRvY3VtZW50YXRpb25cIj4ke2RvY3VtZW50YXRpb259PC90ZD5cbiAgICAgICAgICAgIDwvdHI+YFxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEV4Y21kQ29tcGxldGlvblNvdXJjZSBleHRlbmRzIENvbXBsZXRpb25zLkNvbXBsZXRpb25Tb3VyY2VGdXNlIHtcbiAgICBwdWJsaWMgb3B0aW9uczogRXhjbWRDb21wbGV0aW9uT3B0aW9uW11cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3BhcmVudCkge1xuICAgICAgICBzdXBlcihbXSwgXCJFeGNtZENvbXBsZXRpb25Tb3VyY2VcIiwgXCJleCBjb21tYW5kc1wiKVxuXG4gICAgICAgIHRoaXMudXBkYXRlT3B0aW9ucygpXG4gICAgICAgIHRoaXMuX3BhcmVudC5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpXG4gICAgfVxuXG4gICAgYXN5bmMgZmlsdGVyKGV4c3RyKSB7XG4gICAgICAgIHRoaXMubGFzdEV4c3RyID0gZXhzdHJcbiAgICAgICAgcmV0dXJuIHRoaXMub25JbnB1dChleHN0cilcbiAgICB9XG5cbiAgICBhc3luYyBvbklucHV0KGV4c3RyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZU9wdGlvbnMoZXhzdHIpXG4gICAgfVxuXG4gICAgdXBkYXRlQ2hhaW4oZXhzdHIgPSB0aGlzLmxhc3RFeHN0ciwgb3B0aW9ucyA9IHRoaXMub3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxlbmd0aCA+IDApIHRoaXMuc3RhdGUgPSBcIm5vcm1hbFwiXG4gICAgICAgIGVsc2UgdGhpcy5zdGF0ZSA9IFwiaGlkZGVuXCJcblxuICAgICAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKVxuICAgIH1cblxuICAgIHNlbGVjdChvcHRpb246IEV4Y21kQ29tcGxldGlvbk9wdGlvbikge1xuICAgICAgICB0aGlzLmNvbXBsZXRpb24gPSBvcHRpb24udmFsdWVcbiAgICAgICAgb3B0aW9uLnN0YXRlID0gXCJmb2N1c2VkXCJcbiAgICAgICAgdGhpcy5sYXN0Rm9jdXNlZCA9IG9wdGlvblxuICAgIH1cblxuICAgIHNldFN0YXRlRnJvbVNjb3JlKHNjb3JlZE9wdHM6IENvbXBsZXRpb25zLlNjb3JlZE9wdGlvbltdKSB7XG4gICAgICAgIHN1cGVyLnNldFN0YXRlRnJvbVNjb3JlKHNjb3JlZE9wdHMsIGZhbHNlKVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgdXBkYXRlT3B0aW9ucyhleHN0ciA9IFwiXCIpIHtcbiAgICAgICAgdGhpcy5sYXN0RXhzdHIgPSBleHN0clxuXG4gICAgICAgIGNvbnN0IGV4Y21kcyA9IE1ldGFkYXRhLmV2ZXJ5dGhpbmcuZ2V0RmlsZShcInNyYy9leGNtZHMudHNcIilcbiAgICAgICAgaWYgKCFleGNtZHMpIHJldHVyblxuICAgICAgICBjb25zdCBmbnMgPSBleGNtZHMuZ2V0RnVuY3Rpb25zKClcblxuICAgICAgICAvLyBBZGQgYWxsIGV4Y21kcyB0aGF0IHN0YXJ0IHdpdGggZXhzdHIgYW5kIHRoYXQgdHJpZGFjdHlsIGhhcyBtZXRhZGF0YSBhYm91dCB0byBjb21wbGV0aW9uc1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLnNjb3JlT3B0aW9ucyhcbiAgICAgICAgICAgIGZuc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKFtuYW1lLCBmbl0pID0+ICFmbi5oaWRkZW4gJiYgbmFtZS5zdGFydHNXaXRoKGV4c3RyKSlcbiAgICAgICAgICAgICAgICAubWFwKChbbmFtZSwgZm5dKSA9PiBuZXcgRXhjbWRDb21wbGV0aW9uT3B0aW9uKG5hbWUsIGZuLmRvYykpLFxuICAgICAgICApXG5cbiAgICAgICAgLy8gQWxzbyBhZGQgYWxpYXNlcyB0byBwb3NzaWJsZSBjb21wbGV0aW9uc1xuICAgICAgICBjb25zdCBleGFsaWFzZXMgPSBPYmplY3Qua2V5cyhjb25maWcuZ2V0KFwiZXhhbGlhc2VzXCIpKS5maWx0ZXIoYSA9PlxuICAgICAgICAgICAgYS5zdGFydHNXaXRoKGV4c3RyKSxcbiAgICAgICAgKVxuICAgICAgICBmb3IgKGNvbnN0IGFsaWFzIG9mIGV4YWxpYXNlcykge1xuICAgICAgICAgICAgY29uc3QgY21kID0gYWxpYXNlcy5leHBhbmRFeHN0cihhbGlhcylcbiAgICAgICAgICAgIGNvbnN0IGZuID0gZXhjbWRzLmdldEZ1bmN0aW9uKGNtZClcbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICBuZXcgRXhjbWRDb21wbGV0aW9uT3B0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBgQWxpYXMgZm9yIFxcYCR7Y21kfVxcYC4gJHtmbi5kb2N9YCxcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHRoZSBhbGlhcyBpcyBhIGNvbXBvc2l0ZSBjb21tYW5kIG9yIGEgY29tbWFuZCB3aXRoIGFyZ3VtZW50cy4gV2UgY2FuJ3QgZGlzcGxheSBkb2MgYmVjYXVzZSB3ZSBkb24ndCBrbm93IHdoYXQgcGFyYW1ldGVyIHRoZSBhbGlhcyB0YWtlcyBvciB3aGF0IGl0IGRvZXMuXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIG5ldyBFeGNtZENvbXBsZXRpb25PcHRpb24oYWxpYXMsIGBBbGlhcyBmb3IgXFxgJHtjbWR9XFxgLmApLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3B0aW9ucy5mb3JFYWNoKG8gPT4gKG8uc3RhdGUgPSBcIm5vcm1hbFwiKSlcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ2hhaW4oKVxuICAgIH1cblxuICAgIHByaXZhdGUgc2NvcmVPcHRpb25zKG9wdGlvbnM6IEV4Y21kQ29tcGxldGlvbk9wdGlvbltdKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnNvcnQoKG8xLCBvMikgPT4gbzEudmFsdWUubG9jYWxlQ29tcGFyZShvMi52YWx1ZSkpXG5cbiAgICAgICAgLy8gVG9vIHNsb3cgd2l0aCBsYXJnZSBwcm9maWxlc1xuICAgICAgICAvLyBsZXQgaGlzdHBvcyA9IHN0YXRlLmNtZEhpc3RvcnkubWFwKHMgPT4gcy5zcGxpdChcIiBcIilbMF0pLnJldmVyc2UoKVxuICAgICAgICAvLyByZXR1cm4gZXhzdHJzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgLy8gICAgIGxldCBwb3NhID0gaGlzdHBvcy5maW5kSW5kZXgoeCA9PiB4ID09IGEpXG4gICAgICAgIC8vICAgICBsZXQgcG9zYiA9IGhpc3Rwb3MuZmluZEluZGV4KHggPT4geCA9PSBiKVxuICAgICAgICAvLyAgICAgLy8gSWYgdHdvIGV4IGNvbW1hbmRzIGhhdmUgdGhlIHNhbWUgcG9zaXRpb24sIHNvcnQgbGV4aWNhbGx5XG4gICAgICAgIC8vICAgICBpZiAocG9zYSA9PSBwb3NiKSByZXR1cm4gYSA8IGIgPyAtMSA6IDFcbiAgICAgICAgLy8gICAgIC8vIElmIHRoZXkgYXJlbid0IGZvdW5kIGluIHRoZSBsaXN0IHRoZXkgZ2V0IGxvd2VyIHByaW9yaXR5XG4gICAgICAgIC8vICAgICBpZiAocG9zYSA9PSAtMSkgcmV0dXJuIDFcbiAgICAgICAgLy8gICAgIGlmIChwb3NiID09IC0xKSByZXR1cm4gLTFcbiAgICAgICAgLy8gICAgIC8vIEZpbmFsbHksIHNvcnQgYnkgaGlzdG9yeSBwb3NpdGlvblxuICAgICAgICAvLyAgICAgcmV0dXJuIHBvc2EgPCBwb3NiID8gLTEgOiAxXG4gICAgICAgIC8vIH0pXG4gICAgfVxufVxuIiwiaW1wb3J0ICogYXMgQ29tcGxldGlvbnMgZnJvbSBcIkBzcmMvY29tcGxldGlvbnNcIlxuaW1wb3J0ICogYXMgTmF0aXZlIGZyb20gXCJAc3JjL2xpYi9uYXRpdmVcIlxuXG5jbGFzcyBGaWxlU3lzdGVtQ29tcGxldGlvbk9wdGlvbiBleHRlbmRzIENvbXBsZXRpb25zLkNvbXBsZXRpb25PcHRpb25IVE1MXG4gICAgaW1wbGVtZW50cyBDb21wbGV0aW9ucy5Db21wbGV0aW9uT3B0aW9uRnVzZSB7XG4gICAgcHVibGljIGZ1c2VLZXlzID0gW11cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgdGhpcy5mdXNlS2V5cyA9IFt2YWx1ZV1cbiAgICAgICAgdGhpcy5odG1sID0gaHRtbGA8dHIgY2xhc3M9XCJGaWxlU3lzdGVtQ29tcGxldGlvbk9wdGlvbiBvcHRpb25cIj5cbiAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJ2YWx1ZVwiPiR7dmFsdWV9PC90ZD5cbiAgICAgICAgICAgIDwvdHI+YFxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZpbGVTeXN0ZW1Db21wbGV0aW9uU291cmNlIGV4dGVuZHMgQ29tcGxldGlvbnMuQ29tcGxldGlvblNvdXJjZUZ1c2Uge1xuICAgIHB1YmxpYyBvcHRpb25zOiBGaWxlU3lzdGVtQ29tcGxldGlvbk9wdGlvbltdXG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wYXJlbnQpIHtcbiAgICAgICAgc3VwZXIoW1wic2F2ZWFzXCIsIFwic291cmNlXCJdLCBcIkZpbGVTeXN0ZW1Db21wbGV0aW9uU291cmNlXCIsIFwiRmlsZVN5c3RlbVwiKVxuXG4gICAgICAgIHRoaXMuX3BhcmVudC5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpXG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIG9uSW5wdXQoZXhzdHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGV4c3RyKVxuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBmaWx0ZXIoZXhzdHI6IHN0cmluZykge1xuICAgICAgICBpZiAoIWV4c3RyIHx8IGV4c3RyLmluZGV4T2YoXCIgXCIpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFwiaGlkZGVuXCJcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IFtjbWQsIHBhdGhdID0gdGhpcy5zcGxpdE9uUHJlZml4KGV4c3RyKVxuICAgICAgICBpZiAoY21kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBcImhpZGRlblwiXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGF0aCkgcGF0aCA9IFwiLlwiXG5cbiAgICAgICAgaWYgKCFbXCIvXCIsIFwiJFwiLCBcIn5cIiwgXCIuXCJdLmZpbmQocyA9PiBwYXRoLnN0YXJ0c1dpdGgocykpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgcGF0aCBkb2Vzbid0IHN0YXJ0IHdpdGggYSBzcGVjaWFsIGNoYXJhY3RlciwgaXQgaXMgcmVsYXRpdmUgdG8gdGhlIG5hdGl2ZSBtZXNzZW5nZXIsIHRodXMgdXNlIFwiLlwiIGFzIHN0YXJ0aW5nIHBvaW50XG4gICAgICAgICAgICAvLyBEb2VzIHRoaXMgd29yayBvbiB3aW5kb3dzP1xuICAgICAgICAgICAgcGF0aCA9IFwiLi9cIiArIHBhdGhcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBsYXN0RXhzdHIgYmVjYXVzZSB3ZSBtb2RpZmllZCB0aGUgcGF0aCBhbmQgc2NvcmVPcHRpb25zIHVzZXMgdGhhdCBpbiBvcmRlciB0byBhc3NpZ24gc2NvcmVzXG4gICAgICAgIHRoaXMubGFzdEV4c3RyID0gY21kICsgcGF0aFxuXG4gICAgICAgIGxldCByZXFcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcSA9IGF3YWl0IE5hdGl2ZS5saXN0RGlyKHBhdGgpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIEZhaWxpbmcgc2lsZW50bHkgYmVjYXVzZSB3ZSBjYW4ndCBuYXRpdmVnYXRlICh0aGUgdXNlciBpcyB0eXBpbmcgc3R1ZmYgaW4gdGhlIGNvbW1hbmRsaW5lKVxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFwiaGlkZGVuXCJcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlcS5pc0Rpcikge1xuICAgICAgICAgICAgaWYgKCFwYXRoLmVuZHNXaXRoKHJlcS5zZXApKSBwYXRoICs9IHJlcS5zZXBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBwYXRoLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9wdGlvbnMgPSByZXEuZmlsZXMubWFwKFxuICAgICAgICAgICAgcCA9PiBuZXcgRmlsZVN5c3RlbUNvbXBsZXRpb25PcHRpb24ocGF0aCArIHApLFxuICAgICAgICApXG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IFwibm9ybWFsXCJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ2hhaW4oKVxuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIENvbXBsZXRpb25zIGZyb20gXCJAc3JjL2NvbXBsZXRpb25zXCJcbmltcG9ydCB7IHBvdGVudGlhbFJ1bGVzLCBtZXRhUnVsZXMgfSBmcm9tIFwiQHNyYy9saWIvY3NzX3V0aWxcIlxuXG5jbGFzcyBHdWlzZXRDb21wbGV0aW9uT3B0aW9uIGV4dGVuZHMgQ29tcGxldGlvbnMuQ29tcGxldGlvbk9wdGlvbkhUTUxcbiAgICBpbXBsZW1lbnRzIENvbXBsZXRpb25zLkNvbXBsZXRpb25PcHRpb25GdXNlIHtcbiAgICBwdWJsaWMgZnVzZUtleXMgPSBbXVxuXG4gICAgY29uc3RydWN0b3IocHVibGljIHZhbHVlOiBzdHJpbmcsIGRpc3BsYXlWYWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgdGhpcy5mdXNlS2V5cy5wdXNoKHZhbHVlKVxuXG4gICAgICAgIHRoaXMuaHRtbCA9IGh0bWxgPHRyIGNsYXNzPVwiR3Vpc2V0Q29tcGxldGlvbk9wdGlvbiBvcHRpb25cIj5cbiAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJ2YWx1ZVwiPiR7ZGlzcGxheVZhbHVlfTwvdGQ+XG4gICAgICAgICAgICA8L3RyPmBcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBHdWlzZXRDb21wbGV0aW9uU291cmNlIGV4dGVuZHMgQ29tcGxldGlvbnMuQ29tcGxldGlvblNvdXJjZUZ1c2Uge1xuICAgIHB1YmxpYyBvcHRpb25zOiBHdWlzZXRDb21wbGV0aW9uT3B0aW9uW11cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3BhcmVudCkge1xuICAgICAgICBzdXBlcihbXCJndWlzZXRcIiwgXCJndWlzZXRfcXVpZXRcIl0sIFwiR3Vpc2V0Q29tcGxldGlvblNvdXJjZVwiLCBcIkd1aXNldFwiKVxuXG4gICAgICAgIHRoaXMuX3BhcmVudC5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpXG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGZpbHRlcihleHN0cjogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMubGFzdEV4c3RyID0gZXhzdHJcbiAgICAgICAgY29uc3QgW3ByZWZpeCwgcXVlcnldID0gdGhpcy5zcGxpdE9uUHJlZml4KGV4c3RyKVxuXG4gICAgICAgIC8vIEhpZGUgc2VsZiBhbmQgc3RvcCBpZiBwcmVmaXhlcyBkb24ndCBtYXRjaFxuICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgICAvLyBTaG93IHNlbGYgaWYgcHJlZml4IGFuZCBjdXJyZW50bHkgaGlkZGVuXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJoaWRkZW5cIikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBcIm5vcm1hbFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gXCJoaWRkZW5cIlxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wbGV0aW9uID0gdW5kZWZpbmVkXG5cbiAgICAgICAgbGV0IHJ1bGVOYW1lID0gXCJcIlxuICAgICAgICBsZXQgc3ViUnVsZSA9IFwiXCJcbiAgICAgICAgaWYgKHF1ZXJ5KSB7XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gcXVlcnkudHJpbSgpLnNwbGl0KFwiIFwiKVxuICAgICAgICAgICAgcnVsZU5hbWUgPSBhcmdzWzBdIHx8IFwiXCJcbiAgICAgICAgICAgIHN1YlJ1bGUgPSBhcmdzWzFdIHx8IFwiXCJcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBbXVxuICAgICAgICBpZiAobWV0YVJ1bGVzW3J1bGVOYW1lXSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5vcHRpb25zLmNvbmNhdChcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhtZXRhUnVsZXNbcnVsZU5hbWVdKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHMgPT4gcy5zdGFydHNXaXRoKHN1YlJ1bGUpKVxuICAgICAgICAgICAgICAgICAgICAubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9PiBuZXcgR3Vpc2V0Q29tcGxldGlvbk9wdGlvbihgJHtydWxlTmFtZX0gJHtzfWAsIHMpLFxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGlmIChwb3RlbnRpYWxSdWxlc1tydWxlTmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMub3B0aW9ucy5jb25jYXQoXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocG90ZW50aWFsUnVsZXNbcnVsZU5hbWVdLm9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIocyA9PiBzLnN0YXJ0c1dpdGgoc3ViUnVsZSkpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0+IG5ldyBHdWlzZXRDb21wbGV0aW9uT3B0aW9uKGAke3J1bGVOYW1lfSAke3N9YCwgcyksXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5rZXlzKG1ldGFSdWxlcylcbiAgICAgICAgICAgICAgICAuY29uY2F0KE9iamVjdC5rZXlzKHBvdGVudGlhbFJ1bGVzKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKHMgPT4gcy5zdGFydHNXaXRoKHJ1bGVOYW1lKSlcbiAgICAgICAgICAgICAgICAubWFwKHMgPT4gbmV3IEd1aXNldENvbXBsZXRpb25PcHRpb24ocywgcykpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVDaGFpbigpXG4gICAgfVxuXG4gICAgdXBkYXRlQ2hhaW4oKSB7XG4gICAgICAgIC8vIE9wdGlvbnMgYXJlIHByZS10cmltbWVkIHRvIHRoZSByaWdodCBsZW5ndGguXG4gICAgICAgIHRoaXMub3B0aW9ucy5mb3JFYWNoKG9wdGlvbiA9PiAob3B0aW9uLnN0YXRlID0gXCJub3JtYWxcIikpXG5cbiAgICAgICAgLy8gQ2FsbCBjb25jcmV0ZSBjbGFzc1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVEaXNwbGF5KClcbiAgICB9XG5cbiAgICBvbklucHV0KGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoYXJnKVxuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIENvbXBsZXRpb25zIGZyb20gXCJAc3JjL2NvbXBsZXRpb25zXCJcbmltcG9ydCAqIGFzIE1ldGFkYXRhIGZyb20gXCJAc3JjLy5tZXRhZGF0YS5nZW5lcmF0ZWRcIlxuaW1wb3J0ICogYXMgYWxpYXNlcyBmcm9tIFwiQHNyYy9saWIvYWxpYXNlc1wiXG5pbXBvcnQgKiBhcyBjb25maWcgZnJvbSBcIkBzcmMvbGliL2NvbmZpZ1wiXG5cbmNsYXNzIEhlbHBDb21wbGV0aW9uT3B0aW9uIGV4dGVuZHMgQ29tcGxldGlvbnMuQ29tcGxldGlvbk9wdGlvbkhUTUxcbiAgICBpbXBsZW1lbnRzIENvbXBsZXRpb25zLkNvbXBsZXRpb25PcHRpb25GdXNlIHtcbiAgICBwdWJsaWMgZnVzZUtleXMgPSBbXVxuXG4gICAgY29uc3RydWN0b3IocHVibGljIG5hbWU6IHN0cmluZywgZG9jOiBzdHJpbmcsIGZsYWc6IHN0cmluZykge1xuICAgICAgICBzdXBlcigpXG4gICAgICAgIHRoaXMudmFsdWUgPSBgJHtmbGFnfSAke25hbWV9YFxuICAgICAgICB0aGlzLmh0bWwgPSBodG1sYDx0ciBjbGFzcz1cIkhlbHBDb21wbGV0aW9uT3B0aW9uIG9wdGlvblwiPlxuICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cIm5hbWVcIj4ke25hbWV9PC90ZD5cbiAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJkb2NcIj4ke2RvY308L3RkPlxuICAgICAgICAgICAgPC90cj5gXG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgSGVscENvbXBsZXRpb25Tb3VyY2UgZXh0ZW5kcyBDb21wbGV0aW9ucy5Db21wbGV0aW9uU291cmNlRnVzZSB7XG4gICAgcHVibGljIG9wdGlvbnM6IEhlbHBDb21wbGV0aW9uT3B0aW9uW11cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3BhcmVudCkge1xuICAgICAgICBzdXBlcihbXCJoZWxwXCJdLCBcIkhlbHBDb21wbGV0aW9uU291cmNlXCIsIFwiSGVscFwiKVxuXG4gICAgICAgIHRoaXMuX3BhcmVudC5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpXG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGZpbHRlcihleHN0cjogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMubGFzdEV4c3RyID0gZXhzdHJcbiAgICAgICAgdGhpcy5jb21wbGV0aW9uID0gdW5kZWZpbmVkXG4gICAgICAgIGNvbnN0IFtwcmVmaXgsIHF1ZXJ5XSA9IHRoaXMuc3BsaXRPblByZWZpeChleHN0cilcblxuICAgICAgICAvLyBIaWRlIHNlbGYgYW5kIHN0b3AgaWYgcHJlZml4ZXMgZG9uJ3QgbWF0Y2hcbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgICAgLy8gU2hvdyBzZWxmIGlmIHByZWZpeCBhbmQgY3VycmVudGx5IGhpZGRlblxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gXCJub3JtYWxcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFwiaGlkZGVuXCJcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmlsZSA9IE1ldGFkYXRhLmV2ZXJ5dGhpbmcuZ2V0RmlsZShcInNyYy9saWIvY29uZmlnLnRzXCIpXG4gICAgICAgIGNvbnN0IGRlZmF1bHRfY29uZmlnID0gZmlsZS5nZXRDbGFzcyhcImRlZmF1bHRfY29uZmlnXCIpXG4gICAgICAgIGNvbnN0IGV4Y21kcyA9IE1ldGFkYXRhLmV2ZXJ5dGhpbmcuZ2V0RmlsZShcInNyYy9leGNtZHMudHNcIilcbiAgICAgICAgY29uc3QgZm5zID0gZXhjbWRzLmdldEZ1bmN0aW9ucygpXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gY29uZmlnLmdldCgpXG4gICAgICAgIGNvbnN0IGV4YWxpYXNlcyA9IHNldHRpbmdzLmV4YWxpYXNlc1xuICAgICAgICBjb25zdCBiaW5kaW5ncyA9IHNldHRpbmdzLm5tYXBzXG4gICAgICAgIGlmIChmbnMgPT09IHVuZGVmaW5lZCB8fCBleGFsaWFzZXMgPT09IHVuZGVmaW5lZCB8fCBiaW5kaW5ncyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZsYWdzID0ge1xuICAgICAgICAgICAgXCItYVwiOiAob3B0aW9ucywgcXVlcnkpID0+XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb25jYXQoXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGV4YWxpYXNlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoYWxpYXMgPT4gYWxpYXMuc3RhcnRzV2l0aChxdWVyeSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGFsaWFzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjbWQgPSBhbGlhc2VzLmV4cGFuZEV4c3RyKGFsaWFzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvYyA9IChleGNtZHMuZ2V0RnVuY3Rpb24oY21kKSB8fCB7fSBhcyBhbnkpLmRvYyB8fCBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIZWxwQ29tcGxldGlvbk9wdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBBbGlhcyBmb3IgXFxgJHtjbWR9XFxgLiAke2RvY31gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIi1hXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFwiLWJcIjogKG9wdGlvbnMsIHF1ZXJ5KSA9PlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29uY2F0KFxuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhiaW5kaW5ncylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoYmluZGluZyA9PiBiaW5kaW5nLnN0YXJ0c1dpdGgocXVlcnkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5kaW5nID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBIZWxwQ29tcGxldGlvbk9wdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgTm9ybWFsIG1vZGUgYmluZGluZyBmb3IgXFxgJHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5kaW5nc1tiaW5kaW5nXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcYGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIi1iXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICBcIi1lXCI6IChvcHRpb25zLCBxdWVyeSkgPT5cbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbmNhdChcbiAgICAgICAgICAgICAgICAgICAgZm5zXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChbbmFtZSwgZm5dKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZm4uaGlkZGVuICYmIG5hbWUuc3RhcnRzV2l0aChxdWVyeSksXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChbbmFtZSwgZm5dKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgSGVscENvbXBsZXRpb25PcHRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYEV4Y21kLiAke2ZuLmRvY31gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCItZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgXCItc1wiOiAob3B0aW9ucywgcXVlcnkpID0+XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb25jYXQoXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHNldHRpbmdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcih4ID0+IHguc3RhcnRzV2l0aChxdWVyeSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKHNldHRpbmcgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lbWJlciA9IGRlZmF1bHRfY29uZmlnLmdldE1lbWJlcihzZXR0aW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkb2MgPSBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvYyA9IG1lbWJlci5kb2NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIZWxwQ29tcGxldGlvbk9wdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFNldHRpbmcuICR7ZG9jfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXJncyA9IHF1ZXJ5LnNwbGl0KFwiIFwiKVxuICAgICAgICBsZXQgb3B0cyA9IFtdXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhmbGFncykuaW5jbHVkZXMoYXJnc1swXSkpIHtcbiAgICAgICAgICAgIG9wdHMgPSBmbGFnc1thcmdzWzBdXShvcHRzLCBhcmdzLnNsaWNlKDEpLmpvaW4oXCIgXCIpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0cyA9IE9iamVjdC5rZXlzKGZsYWdzKS5yZWR1Y2UoXG4gICAgICAgICAgICAgICAgKGFjYywgY3VyRmxhZykgPT4gZmxhZ3NbY3VyRmxhZ10oYWNjLCBxdWVyeSksXG4gICAgICAgICAgICAgICAgW10sXG4gICAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRzXG4gICAgICAgIHRoaXMub3B0aW9ucy5zb3J0KChjb21wb3B0MSwgY29tcG9wdDIpID0+XG4gICAgICAgICAgICBjb21wb3B0MS5uYW1lLmxvY2FsZUNvbXBhcmUoY29tcG9wdDIubmFtZSksXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ2hhaW4oKVxuICAgIH1cblxuICAgIHVwZGF0ZUNoYWluKCkge1xuICAgICAgICAvLyBPcHRpb25zIGFyZSBwcmUtdHJpbW1lZCB0byB0aGUgcmlnaHQgbGVuZ3RoLlxuICAgICAgICB0aGlzLm9wdGlvbnMuZm9yRWFjaChvcHRpb24gPT4gKG9wdGlvbi5zdGF0ZSA9IFwibm9ybWFsXCIpKVxuXG4gICAgICAgIC8vIENhbGwgY29uY3JldGUgY2xhc3NcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlRGlzcGxheSgpXG4gICAgfVxuXG4gICAgb25JbnB1dCgpIHt9XG59XG4iLCJpbXBvcnQgKiBhcyBDb21wbGV0aW9ucyBmcm9tIFwiQHNyYy9jb21wbGV0aW9uc1wiXG5pbXBvcnQgKiBhcyBjb25maWcgZnJvbSBcIkBzcmMvbGliL2NvbmZpZ1wiXG5pbXBvcnQgKiBhcyBwcm92aWRlcnMgZnJvbSBcIkBzcmMvY29tcGxldGlvbnMvcHJvdmlkZXJzXCJcblxuY2xhc3MgSGlzdG9yeUNvbXBsZXRpb25PcHRpb24gZXh0ZW5kcyBDb21wbGV0aW9ucy5Db21wbGV0aW9uT3B0aW9uSFRNTFxuICAgIGltcGxlbWVudHMgQ29tcGxldGlvbnMuQ29tcGxldGlvbk9wdGlvbkZ1c2Uge1xuICAgIHB1YmxpYyBmdXNlS2V5cyA9IFtdXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgdmFsdWU6IHN0cmluZywgcGFnZTogYnJvd3Nlci5oaXN0b3J5Lkhpc3RvcnlJdGVtKSB7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgaWYgKCFwYWdlLnRpdGxlKSB7XG4gICAgICAgICAgICBwYWdlLnRpdGxlID0gbmV3IFVSTChwYWdlLnVybCkuaG9zdFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHVzaCBwcm9wZXJ0aWVzIHdlIHdhbnQgdG8gZnV6bWF0Y2ggb25cbiAgICAgICAgdGhpcy5mdXNlS2V5cy5wdXNoKHBhZ2UudGl0bGUsIHBhZ2UudXJsKSAvLyB3ZWlnaHQgYnkgcGFnZS52aXNpdENvdW50XG5cbiAgICAgICAgLy8gQ3JlYXRlIEhUTUxFbGVtZW50XG4gICAgICAgIHRoaXMuaHRtbCA9IGh0bWxgPHRyIGNsYXNzPVwiSGlzdG9yeUNvbXBsZXRpb25PcHRpb24gb3B0aW9uXCI+XG4gICAgICAgICAgICAgICAgPHRkIGNsYXNzPVwicHJlZml4XCI+JHtcIlwiLnBhZEVuZCgyKX08L3RkPlxuICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cInRpdGxlXCI+JHtwYWdlLnRpdGxlfTwvdGQ+XG4gICAgICAgICAgICAgICAgPHRkIGNsYXNzPVwiY29udGVudFwiPlxuICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cInVybFwiIHRhcmdldD1cIl9ibGFua1wiIGhyZWY9JHtwYWdlLnVybH1cbiAgICAgICAgICAgICAgICAgICAgICAgID4ke3BhZ2UudXJsfTwvYVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDwvdHI+YFxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEhpc3RvcnlDb21wbGV0aW9uU291cmNlIGV4dGVuZHMgQ29tcGxldGlvbnMuQ29tcGxldGlvblNvdXJjZUZ1c2Uge1xuICAgIHB1YmxpYyBvcHRpb25zOiBIaXN0b3J5Q29tcGxldGlvbk9wdGlvbltdXG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wYXJlbnQpIHtcbiAgICAgICAgc3VwZXIoXG4gICAgICAgICAgICBbXCJvcGVuXCIsIFwidGFib3BlblwiLCBcIndpbm9wZW5cIl0sXG4gICAgICAgICAgICBcIkhpc3RvcnlDb21wbGV0aW9uU291cmNlXCIsXG4gICAgICAgICAgICBcIkhpc3RvcnkgYW5kIGJvb2ttYXJrc1wiLFxuICAgICAgICApXG5cbiAgICAgICAgdGhpcy5fcGFyZW50LmFwcGVuZENoaWxkKHRoaXMubm9kZSlcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZmlsdGVyKGV4c3RyOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgcHJldlN0ciA9IHRoaXMubGFzdEV4c3RyXG4gICAgICAgIHRoaXMubGFzdEV4c3RyID0gZXhzdHJcbiAgICAgICAgbGV0IFtwcmVmaXgsIHF1ZXJ5XSA9IHRoaXMuc3BsaXRPblByZWZpeChleHN0cilcbiAgICAgICAgbGV0IG9wdGlvbnMgPSBcIlwiXG5cbiAgICAgICAgLy8gSGlkZSBzZWxmIGFuZCBzdG9wIGlmIHByZWZpeGVzIGRvbid0IG1hdGNoXG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIC8vIFNob3cgc2VsZiBpZiBwcmVmaXggYW5kIGN1cnJlbnRseSBoaWRkZW5cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcImhpZGRlblwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFwibm9ybWFsXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBcImhpZGRlblwiXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElnbm9yaW5nIGNvbW1hbmQtc3BlY2lmaWMgYXJndW1lbnRzXG4gICAgICAgIC8vIEl0J3MgdGVycmlibGUgYnV0IGl0J3Mgb2sgYmVjYXVzZSBpdCdzIGp1c3QgYSBzdG9wZ2FwIHVudGlsIGFuIGFjdHVhbCBjb21tYW5kbGluZS1wYXJzaW5nIEFQSSBpcyBpbXBsZW1lbnRlZFxuICAgICAgICBpZiAocHJlZml4ID09PSBcInRhYm9wZW4gXCIpIHtcbiAgICAgICAgICAgIGlmIChxdWVyeS5zdGFydHNXaXRoKFwiLWNcIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gcXVlcnkuc3BsaXQoXCIgXCIpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZ3Muc2xpY2UoMCwgMikuam9pbihcIiBcIilcbiAgICAgICAgICAgICAgICBxdWVyeSA9IGFyZ3Muc2xpY2UoMikuam9pbihcIiBcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChxdWVyeS5zdGFydHNXaXRoKFwiLWJcIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gcXVlcnkuc3BsaXQoXCIgXCIpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZ3Muc2xpY2UoMCwgMSkuam9pbihcIiBcIilcbiAgICAgICAgICAgICAgICBxdWVyeSA9IGFyZ3Muc2xpY2UoMSkuam9pbihcIiBcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwcmVmaXggPT09IFwid2lub3BlbiBcIiAmJiBxdWVyeS5zdGFydHNXaXRoKFwiLXByaXZhdGVcIikpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBcIi1wcml2YXRlXCJcbiAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkuc3Vic3RyaW5nKG9wdGlvbnMubGVuZ3RoKVxuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgKz0gb3B0aW9ucyA/IFwiIFwiIDogXCJcIlxuXG4gICAgICAgIC8vIE9wdGlvbnMgYXJlIHByZS10cmltbWVkIHRvIHRoZSByaWdodCBsZW5ndGguXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IChhd2FpdCB0aGlzLnNjb3JlT3B0aW9ucyhxdWVyeSwgMTApKS5tYXAoXG4gICAgICAgICAgICBwYWdlID0+IG5ldyBIaXN0b3J5Q29tcGxldGlvbk9wdGlvbihvcHRpb25zICsgcGFnZS51cmwsIHBhZ2UpLFxuICAgICAgICApXG5cbiAgICAgICAgLy8gRGVzZWxlY3QgYW55IHNlbGVjdGVkLCBidXQgcmVtZW1iZXIgd2hhdCB0aGV5IHdlcmUuXG4gICAgICAgIGNvbnN0IGxhc3RGb2N1c2VkID0gdGhpcy5sYXN0Rm9jdXNlZFxuICAgICAgICB0aGlzLmRlc2VsZWN0KClcblxuICAgICAgICAvLyBTZXQgaW5pdGlhbCBzdGF0ZSB0byBub3JtYWwsIHVubGVzcyB0aGUgb3B0aW9uIHdhcyBzZWxlY3RlZCBhIG1vbWVudFxuICAgICAgICAvLyBhZ28sIHRoZW4gcmVzZWxlY3QgaXQgc28gdGhhdCB1c2VycyBkb24ndCBsb3NlIHRoZWlyIHNlbGVjdGlvbnMuXG4gICAgICAgIHRoaXMub3B0aW9ucy5mb3JFYWNoKG9wdGlvbiA9PiBvcHRpb24uc3RhdGUgPSBcIm5vcm1hbFwiKVxuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChsYXN0Rm9jdXNlZCAhPT0gdW5kZWZpbmVkICYmIGxhc3RGb2N1c2VkLnZhbHVlID09PSBvcHRpb24udmFsdWUgJiYgcHJldlN0ci5sZW5ndGggPD0gZXhzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Qob3B0aW9uKVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVEaXNwbGF5KClcbiAgICB9XG5cbiAgICB1cGRhdGVDaGFpbigpIHt9XG5cbiAgICBvbklucHV0KCkge31cblxuICAgIHByaXZhdGUgYXN5bmMgc2NvcmVPcHRpb25zKHF1ZXJ5OiBzdHJpbmcsIG46IG51bWJlcikge1xuICAgICAgICBpZiAoIXF1ZXJ5IHx8IGNvbmZpZy5nZXQoXCJoaXN0b3J5cmVzdWx0c1wiKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIChhd2FpdCBwcm92aWRlcnMuZ2V0VG9wU2l0ZXMoKSkuc2xpY2UoMCwgbilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoYXdhaXQgcHJvdmlkZXJzLmdldENvbWJpbmVkSGlzdG9yeUJtYXJrcyhxdWVyeSkpLnNsaWNlKDAsIG4pXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBDb21wbGV0aW9ucyBmcm9tIFwiQHNyYy9jb21wbGV0aW9uc1wiXG5pbXBvcnQgKiBhcyBOYXRpdmUgZnJvbSBcIkBzcmMvbGliL25hdGl2ZVwiXG5cbmNsYXNzIFByZWZlcmVuY2VDb21wbGV0aW9uT3B0aW9uIGV4dGVuZHMgQ29tcGxldGlvbnMuQ29tcGxldGlvbk9wdGlvbkhUTUxcbiAgICBpbXBsZW1lbnRzIENvbXBsZXRpb25zLkNvbXBsZXRpb25PcHRpb25GdXNlIHtcbiAgICBwdWJsaWMgZnVzZUtleXMgPSBbXVxuXG4gICAgY29uc3RydWN0b3IocHVibGljIHZhbHVlOiBzdHJpbmcsIHB1YmxpYyBwcmVmdmFsdWU6IHN0cmluZykge1xuICAgICAgICBzdXBlcigpXG4gICAgICAgIHRoaXMuZnVzZUtleXMucHVzaCh2YWx1ZSlcbiAgICAgICAgdGhpcy5odG1sID0gaHRtbGA8dHIgY2xhc3M9XCJQcmVmZXJlbmNlQ29tcGxldGlvbk9wdGlvbiBvcHRpb25cIj5cbiAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJuYW1lXCI+JHt2YWx1ZX08L3RkPlxuICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cInZhbHVlXCI+JHtwcmVmdmFsdWV9PC90ZD5cbiAgICAgICAgICAgIDwvdHI+YFxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFByZWZlcmVuY2VDb21wbGV0aW9uU291cmNlIGV4dGVuZHMgQ29tcGxldGlvbnMuQ29tcGxldGlvblNvdXJjZUZ1c2Uge1xuICAgIHB1YmxpYyBvcHRpb25zOiBQcmVmZXJlbmNlQ29tcGxldGlvbk9wdGlvbltdXG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wYXJlbnQpIHtcbiAgICAgICAgc3VwZXIoW1wic2V0cHJlZlwiXSwgXCJQcmVmZXJlbmNlQ29tcGxldGlvblNvdXJjZVwiLCBcIlByZWZlcmVuY2VcIilcblxuICAgICAgICB0aGlzLl9wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKVxuICAgIH1cblxuICAgIHB1YmxpYyBvbklucHV0KGV4c3RyOiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGV4c3RyKVxuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBmaWx0ZXIoZXhzdHI6IHN0cmluZykge1xuICAgICAgICBpZiAoIWV4c3RyKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gXCJoaWRkZW5cIlxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlZiA9IHRoaXMuc3BsaXRPblByZWZpeChleHN0cilbMV1cbiAgICAgICAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFwiaGlkZGVuXCJcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdEV4c3RyID0gZXhzdHJcbiAgICAgICAgY29uc3QgcHJlZmVyZW5jZXMgPSBhd2FpdCBOYXRpdmUuZ2V0UHJlZnMoKVxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3Qua2V5cyhwcmVmZXJlbmNlcylcbiAgICAgICAgICAgIC5maWx0ZXIoa2V5ID0+IGtleS5zdGFydHNXaXRoKHByZWYpKVxuICAgICAgICAgICAgLm1hcChrZXkgPT4gbmV3IFByZWZlcmVuY2VDb21wbGV0aW9uT3B0aW9uKGtleSwgcHJlZmVyZW5jZXNba2V5XSkpXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGVuZ3RoID4gMCkgdGhpcy5zdGF0ZSA9IFwibm9ybWFsXCJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ2hhaW4oKVxuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIE1lc3NhZ2luZyBmcm9tIFwiQHNyYy9saWIvbWVzc2FnaW5nXCJcbmltcG9ydCAqIGFzIENvbXBsZXRpb25zIGZyb20gXCJAc3JjL2NvbXBsZXRpb25zXCJcblxuY2xhc3MgUnNzQ29tcGxldGlvbk9wdGlvbiBleHRlbmRzIENvbXBsZXRpb25zLkNvbXBsZXRpb25PcHRpb25IVE1MXG4gICAgaW1wbGVtZW50cyBDb21wbGV0aW9ucy5Db21wbGV0aW9uT3B0aW9uRnVzZSB7XG4gICAgcHVibGljIGZ1c2VLZXlzID0gW11cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB1cmwsIHB1YmxpYyB0aXRsZSwgcHVibGljIHR5cGUpIHtcbiAgICAgICAgc3VwZXIoKVxuICAgICAgICB0aGlzLnZhbHVlID0gYCR7dXJsfSAke3R5cGV9ICR7dGl0bGV9YFxuICAgICAgICB0aGlzLmZ1c2VLZXlzLnB1c2godXJsKVxuICAgICAgICB0aGlzLmZ1c2VLZXlzLnB1c2godGl0bGUpXG5cbiAgICAgICAgdGhpcy5odG1sID0gaHRtbGA8dHIgY2xhc3M9XCJSc3NDb21wbGV0aW9uT3B0aW9uIG9wdGlvblwiPlxuICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cInRpdGxlXCI+JHt0aXRsZX08L3RkPlxuICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cImNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XCJ1cmxcIiB0YXJnZXQ9XCJfYmxhbmtcIiBocmVmPSR7dXJsfT4ke3VybH08L2E+XG4gICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJ0eXBlXCI+JHt0eXBlfTwvdGQ+XG4gICAgICAgICAgICA8L3RyPmBcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSc3NDb21wbGV0aW9uU291cmNlIGV4dGVuZHMgQ29tcGxldGlvbnMuQ29tcGxldGlvblNvdXJjZUZ1c2Uge1xuICAgIHB1YmxpYyBvcHRpb25zOiBSc3NDb21wbGV0aW9uT3B0aW9uW10gPSBbXVxuICAgIHByaXZhdGUgc2hvdWxkU2V0U3RhdGVGcm9tU2NvcmUgPSB0cnVlXG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wYXJlbnQpIHtcbiAgICAgICAgc3VwZXIoW1wicnNzZXhlY1wiXSwgXCJSc3NDb21wbGV0aW9uU291cmNlXCIsIFwiRmVlZHNcIilcblxuICAgICAgICB0aGlzLnVwZGF0ZU9wdGlvbnMoKVxuICAgICAgICB0aGlzLl9wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKVxuICAgIH1cblxuICAgIG9uSW5wdXQoLi4ud2hhdGV2ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlT3B0aW9ucyguLi53aGF0ZXZlcilcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHVwZGF0ZU9wdGlvbnMoZXhzdHIgPSBcIlwiKSB7XG4gICAgICAgIHRoaXMubGFzdEV4c3RyID0gZXhzdHJcbiAgICAgICAgY29uc3QgW3ByZWZpeF0gPSB0aGlzLnNwbGl0T25QcmVmaXgoZXhzdHIpXG5cbiAgICAgICAgLy8gSGlkZSBzZWxmIGFuZCBzdG9wIGlmIHByZWZpeGVzIGRvbid0IG1hdGNoXG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIC8vIFNob3cgc2VsZiBpZiBwcmVmaXggYW5kIGN1cnJlbnRseSBoaWRkZW5cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcImhpZGRlblwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFwibm9ybWFsXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBcImhpZGRlblwiXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gKGF3YWl0IE1lc3NhZ2luZy5tZXNzYWdlT3duVGFiKFxuICAgICAgICAgICAgICAgIFwiZXhjbWRfY29udGVudFwiLFxuICAgICAgICAgICAgICAgIFwiZ2V0UnNzTGlua3NcIixcbiAgICAgICAgICAgICAgICBbXSxcbiAgICAgICAgICAgICkpLm1hcChsaW5rID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHQgPSBuZXcgUnNzQ29tcGxldGlvbk9wdGlvbihcbiAgICAgICAgICAgICAgICAgICAgbGluay51cmwsXG4gICAgICAgICAgICAgICAgICAgIGxpbmsudGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIGxpbmsudHlwZSxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgb3B0LnN0YXRlID0gXCJub3JtYWxcIlxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ2hhaW4oKVxuICAgIH1cbn1cbiIsImltcG9ydCB7IGJyb3dzZXJCZyB9IGZyb20gXCJAc3JjL2xpYi93ZWJleHQudHNcIlxuaW1wb3J0ICogYXMgQ29tcGxldGlvbnMgZnJvbSBcIkBzcmMvY29tcGxldGlvbnNcIlxuXG5mdW5jdGlvbiBjb21wdXRlRGF0ZShzZXNzaW9uKSB7XG4gICAgbGV0IGhvd0xvbmcgPSBNYXRoLnJvdW5kKFxuICAgICAgICAoKG5ldyBEYXRlKCkgYXMgYW55KSAtIHNlc3Npb24ubGFzdE1vZGlmaWVkKSAvIDEwMDAsXG4gICAgKVxuICAgIGxldCBxdWFsaWZpZXIgPSBcInNcIlxuICAgIGlmIChob3dMb25nID4gNjApIHtcbiAgICAgICAgcXVhbGlmaWVyID0gXCJtXCJcbiAgICAgICAgaG93TG9uZyA9IE1hdGgucm91bmQoaG93TG9uZyAvIDYwKVxuICAgICAgICBpZiAoaG93TG9uZyA+IDYwKSB7XG4gICAgICAgICAgICBxdWFsaWZpZXIgPSBcImhcIlxuICAgICAgICAgICAgaG93TG9uZyA9IE1hdGgucm91bmQoaG93TG9uZyAvIDYwKVxuICAgICAgICAgICAgaWYgKGhvd0xvbmcgPiAyNCkge1xuICAgICAgICAgICAgICAgIHF1YWxpZmllciA9IFwiZFwiXG4gICAgICAgICAgICAgICAgaG93TG9uZyA9IE1hdGgucm91bmQoaG93TG9uZyAvIDI0KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbaG93TG9uZywgcXVhbGlmaWVyXVxufVxuXG5mdW5jdGlvbiBnZXRUYWJJbmZvKHNlc3Npb24pIHtcbiAgICBsZXQgdGFiXG4gICAgbGV0IGV4dHJhSW5mb1xuICAgIGlmIChzZXNzaW9uLnRhYikge1xuICAgICAgICB0YWIgPSBzZXNzaW9uLnRhYlxuICAgICAgICBleHRyYUluZm8gPSB0YWIudXJsXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGFiID0gc2Vzc2lvbi53aW5kb3cudGFicy5zb3J0KFxuICAgICAgICAgICAgKGEsIGIpID0+IGIubGFzdEFjY2Vzc2VkIC0gYS5sYXN0QWNjZXNzZWQsXG4gICAgICAgIClbMF1cbiAgICAgICAgY29uc3QgdGFiQ291bnQgPSBzZXNzaW9uLndpbmRvdy50YWJzLmxlbmd0aFxuICAgICAgICBpZiAodGFiQ291bnQgPCAyKSB7XG4gICAgICAgICAgICBleHRyYUluZm8gPSB0YWIudXJsXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHRyYUluZm8gPSBgJHt0YWJDb3VudCAtIDF9IG1vcmUgdGFiJHt0YWJDb3VudCA+IDIgPyBcInNcIiA6IFwiXCJ9LmBcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3RhYiwgZXh0cmFJbmZvXVxufVxuXG5jbGFzcyBTZXNzaW9uQ29tcGxldGlvbk9wdGlvbiBleHRlbmRzIENvbXBsZXRpb25zLkNvbXBsZXRpb25PcHRpb25IVE1MXG4gICAgaW1wbGVtZW50cyBDb21wbGV0aW9ucy5Db21wbGV0aW9uT3B0aW9uRnVzZSB7XG4gICAgcHVibGljIGZ1c2VLZXlzID0gW11cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBzZXNzaW9uKSB7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgdGhpcy52YWx1ZSA9IChzZXNzaW9uLnRhYiB8fCBzZXNzaW9uLndpbmRvdykuc2Vzc2lvbklkXG4gICAgICAgIGNvbnN0IFtob3dMb25nLCBxdWFsaWZpZXJdID0gY29tcHV0ZURhdGUoc2Vzc2lvbilcbiAgICAgICAgY29uc3QgW3RhYiwgZXh0cmFJbmZvXSA9IGdldFRhYkluZm8oc2Vzc2lvbilcbiAgICAgICAgdGhpcy5mdXNlS2V5cy5wdXNoKHRhYi50aXRsZSlcbiAgICAgICAgdGhpcy5odG1sID0gaHRtbGA8dHIgY2xhc3M9XCJTZXNzaW9uQ29tcGxldGlvbk9wdGlvbiBvcHRpb25cIj5cbiAgICAgICAgICAgIDx0ZCBjbGFzcz1cInR5cGVcIj4ke3Nlc3Npb24udGFiID8gXCJUXCIgOiBcIldcIn08L3RkPlxuICAgICAgICAgICAgPHRkIGNsYXNzPVwidGltZVwiPiR7aG93TG9uZ30ke3F1YWxpZmllcn08L3RkPlxuICAgICAgICAgICAgPHRkIGNsYXNzPVwiaWNvblwiPjxpbWcgc3JjPVwiJHt0YWIuZmF2SWNvblVybCB8fFxuICAgICAgICAgICAgICAgIENvbXBsZXRpb25zLkRFRkFVTFRfRkFWSUNPTn1cIi8+PC90ZD5cbiAgICAgICAgICAgIDx0ZCBjbGFzcz1cInRpdGxlXCI+JHt0YWIudGl0bGV9PC90ZD5cbiAgICAgICAgICAgIDx0ZCBjbGFzcz1cImV4dHJhSW5mb1wiPiR7ZXh0cmFJbmZvfTwvdGQ+XG4gICAgICAgIDwvdHI+YFxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNlc3Npb25zQ29tcGxldGlvblNvdXJjZSBleHRlbmRzIENvbXBsZXRpb25zLkNvbXBsZXRpb25Tb3VyY2VGdXNlIHtcbiAgICBwdWJsaWMgb3B0aW9uczogU2Vzc2lvbkNvbXBsZXRpb25PcHRpb25bXVxuICAgIHByaXZhdGUgc2hvdWxkU2V0U3RhdGVGcm9tU2NvcmUgPSB0cnVlXG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wYXJlbnQpIHtcbiAgICAgICAgc3VwZXIoW1widW5kb1wiXSwgXCJTZXNzaW9uQ29tcGxldGlvblNvdXJjZVwiLCBcInNlc3Npb25zXCIpXG5cbiAgICAgICAgdGhpcy51cGRhdGVPcHRpb25zKClcbiAgICAgICAgdGhpcy5fcGFyZW50LmFwcGVuZENoaWxkKHRoaXMubm9kZSlcbiAgICB9XG5cbiAgICBhc3luYyBvbklucHV0KGV4c3RyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZU9wdGlvbnMoZXhzdHIpXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyB1cGRhdGVPcHRpb25zKGV4c3RyID0gXCJcIikge1xuICAgICAgICB0aGlzLmxhc3RFeHN0ciA9IGV4c3RyXG4gICAgICAgIGNvbnN0IFtwcmVmaXhdID0gdGhpcy5zcGxpdE9uUHJlZml4KGV4c3RyKVxuXG4gICAgICAgIC8vIEhpZGUgc2VsZiBhbmQgc3RvcCBpZiBwcmVmaXhlcyBkb24ndCBtYXRjaFxuICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgICAvLyBTaG93IHNlbGYgaWYgcHJlZml4IGFuZCBjdXJyZW50bHkgaGlkZGVuXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJoaWRkZW5cIikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBcIm5vcm1hbFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gXCJoaWRkZW5cIlxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZXNzaW9ucyA9IGF3YWl0IGJyb3dzZXJCZy5zZXNzaW9ucy5nZXRSZWNlbnRseUNsb3NlZCgpXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHNlc3Npb25zLm1hcChzID0+IG5ldyBTZXNzaW9uQ29tcGxldGlvbk9wdGlvbihzKSlcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBDb21wbGV0aW9ucyBmcm9tIFwiQHNyYy9jb21wbGV0aW9uc1wiXG5pbXBvcnQgKiBhcyBjb25maWcgZnJvbSBcIkBzcmMvbGliL2NvbmZpZ1wiXG5pbXBvcnQgKiBhcyBtZXRhZGF0YSBmcm9tIFwiQHNyYy8ubWV0YWRhdGEuZ2VuZXJhdGVkXCJcblxuY2xhc3MgU2V0dGluZ3NDb21wbGV0aW9uT3B0aW9uIGV4dGVuZHMgQ29tcGxldGlvbnMuQ29tcGxldGlvbk9wdGlvbkhUTUxcbiAgICBpbXBsZW1lbnRzIENvbXBsZXRpb25zLkNvbXBsZXRpb25PcHRpb25GdXNlIHtcbiAgICBwdWJsaWMgZnVzZUtleXMgPSBbXVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHB1YmxpYyB2YWx1ZTogc3RyaW5nLFxuICAgICAgICBzZXR0aW5nOiB7IG5hbWU6IHN0cmluZzsgdmFsdWU6IHN0cmluZzsgdHlwZTogc3RyaW5nOyBkb2M6IHN0cmluZyB9LFxuICAgICkge1xuICAgICAgICBzdXBlcigpXG4gICAgICAgIHRoaXMuaHRtbCA9IGh0bWxgPHRyIGNsYXNzPVwiU2V0dGluZ3NDb21wbGV0aW9uT3B0aW9uIG9wdGlvblwiPlxuICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cInRpdGxlXCI+JHtzZXR0aW5nLm5hbWV9PC90ZD5cbiAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJjb250ZW50XCI+JHtzZXR0aW5nLnZhbHVlfTwvdGQ+XG4gICAgICAgICAgICAgICAgPHRkIGNsYXNzPVwidHlwZVwiPiR7c2V0dGluZy50eXBlfTwvdGQ+XG4gICAgICAgICAgICAgICAgPHRkIGNsYXNzPVwiZG9jXCI+JHtzZXR0aW5nLmRvY308L3RkPlxuICAgICAgICAgICAgPC90cj5gXG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgU2V0dGluZ3NDb21wbGV0aW9uU291cmNlIGV4dGVuZHMgQ29tcGxldGlvbnMuQ29tcGxldGlvblNvdXJjZUZ1c2Uge1xuICAgIHB1YmxpYyBvcHRpb25zOiBTZXR0aW5nc0NvbXBsZXRpb25PcHRpb25bXVxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfcGFyZW50KSB7XG4gICAgICAgIHN1cGVyKFxuICAgICAgICAgICAgW1wic2V0XCIsIFwiZ2V0XCIsIFwidW5zZXRcIiwgXCJzZXR1cmxcIiwgXCJ1bnNldHVybFwiXSxcbiAgICAgICAgICAgIFwiU2V0dGluZ3NDb21wbGV0aW9uU291cmNlXCIsXG4gICAgICAgICAgICBcIlNldHRpbmdzXCIsXG4gICAgICAgIClcblxuICAgICAgICB0aGlzLl9wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKVxuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBmaWx0ZXIoZXhzdHI6IHN0cmluZykge1xuICAgICAgICB0aGlzLmxhc3RFeHN0ciA9IGV4c3RyXG4gICAgICAgIGxldCBbcHJlZml4LCBxdWVyeV0gPSB0aGlzLnNwbGl0T25QcmVmaXgoZXhzdHIpXG4gICAgICAgIGxldCBvcHRpb25zID0gXCJcIlxuXG4gICAgICAgIC8vIEhpZGUgc2VsZiBhbmQgc3RvcCBpZiBwcmVmaXhlcyBkb24ndCBtYXRjaFxuICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgICAvLyBTaG93IHNlbGYgaWYgcHJlZml4IGFuZCBjdXJyZW50bHkgaGlkZGVuXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJoaWRkZW5cIikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBcIm5vcm1hbFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gXCJoaWRkZW5cIlxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZ25vcmluZyBjb21tYW5kLXNwZWNpZmljIGFyZ3VtZW50c1xuICAgICAgICAvLyBJdCdzIHRlcnJpYmxlIGJ1dCBpdCdzIG9rIGJlY2F1c2UgaXQncyBqdXN0IGEgc3RvcGdhcCB1bnRpbCBhbiBhY3R1YWwgY29tbWFuZGxpbmUtcGFyc2luZyBBUEkgaXMgaW1wbGVtZW50ZWRcbiAgICAgICAgLy8gY29weSBwYXN0aW5nIGNvZGUgaXMgZnVuIGFuZCBnb29kXG4gICAgICAgIGlmIChwcmVmaXggPT09IFwic2V0dXJsIFwiIHx8IHByZWZpeCA9PT0gXCJ1bnNldHVybCBcIikge1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IHF1ZXJ5LnNwbGl0KFwiIFwiKVxuICAgICAgICAgICAgb3B0aW9ucyA9IGFyZ3Muc2xpY2UoMCwgMSkuam9pbihcIiBcIilcbiAgICAgICAgICAgIHF1ZXJ5ID0gYXJncy5zbGljZSgxKS5qb2luKFwiIFwiKVxuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyArPSBvcHRpb25zID8gXCIgXCIgOiBcIlwiXG5cbiAgICAgICAgY29uc3QgZmlsZSA9IG1ldGFkYXRhLmV2ZXJ5dGhpbmcuZ2V0RmlsZShcInNyYy9saWIvY29uZmlnLnRzXCIpXG4gICAgICAgIGNvbnN0IGRlZmF1bHRfY29uZmlnID0gZmlsZS5nZXRDbGFzcyhcImRlZmF1bHRfY29uZmlnXCIpXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gY29uZmlnLmdldCgpXG5cbiAgICAgICAgaWYgKGRlZmF1bHRfY29uZmlnID09PSB1bmRlZmluZWQgfHwgc2V0dGluZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3Qua2V5cyhzZXR0aW5ncylcbiAgICAgICAgICAgIC5maWx0ZXIoeCA9PiB4LnN0YXJ0c1dpdGgocXVlcnkpKVxuICAgICAgICAgICAgLnNvcnQoKVxuICAgICAgICAgICAgLm1hcChzZXR0aW5nID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZCA9IGRlZmF1bHRfY29uZmlnLmdldE1lbWJlcihzZXR0aW5nKVxuICAgICAgICAgICAgICAgIGxldCBkb2MgPSBcIlwiXG4gICAgICAgICAgICAgICAgbGV0IHR5cGUgPSBcIlwiXG4gICAgICAgICAgICAgICAgaWYgKG1kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jID0gbWQuZG9jXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBtZC50eXBlLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXR0aW5nc0NvbXBsZXRpb25PcHRpb24ob3B0aW9ucyArIHNldHRpbmcsIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogc2V0dGluZyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KHNldHRpbmdzW3NldHRpbmddKSxcbiAgICAgICAgICAgICAgICAgICAgZG9jLFxuICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUNoYWluKClcbiAgICB9XG5cbiAgICB1cGRhdGVDaGFpbigpIHtcbiAgICAgICAgLy8gT3B0aW9ucyBhcmUgcHJlLXRyaW1tZWQgdG8gdGhlIHJpZ2h0IGxlbmd0aC5cbiAgICAgICAgdGhpcy5vcHRpb25zLmZvckVhY2gob3B0aW9uID0+IChvcHRpb24uc3RhdGUgPSBcIm5vcm1hbFwiKSlcblxuICAgICAgICAvLyBDYWxsIGNvbmNyZXRlIGNsYXNzXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZURpc3BsYXkoKVxuICAgIH1cblxuICAgIG9uSW5wdXQoKSB7fVxufVxuIiwiaW1wb3J0ICogYXMgUGVyZiBmcm9tIFwiQHNyYy9wZXJmXCJcbmltcG9ydCB7IGJyb3dzZXJCZyB9IGZyb20gXCJAc3JjL2xpYi93ZWJleHQudHNcIlxuaW1wb3J0IHsgZW51bWVyYXRlIH0gZnJvbSBcIkBzcmMvbGliL2l0ZXJ0b29sc1wiXG5pbXBvcnQgKiBhcyBDb250YWluZXJzIGZyb20gXCJAc3JjL2xpYi9jb250YWluZXJzXCJcbmltcG9ydCAqIGFzIENvbXBsZXRpb25zIGZyb20gXCJAc3JjL2NvbXBsZXRpb25zXCJcblxuY2xhc3MgQnVmZmVyQ29tcGxldGlvbk9wdGlvbiBleHRlbmRzIENvbXBsZXRpb25zLkNvbXBsZXRpb25PcHRpb25IVE1MXG4gICAgaW1wbGVtZW50cyBDb21wbGV0aW9ucy5Db21wbGV0aW9uT3B0aW9uRnVzZSB7XG4gICAgcHVibGljIGZ1c2VLZXlzID0gW11cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgdmFsdWU6IHN0cmluZyxcbiAgICAgICAgdGFiOiBicm93c2VyLnRhYnMuVGFiLFxuICAgICAgICBwdWJsaWMgaXNBbHRlcm5hdGl2ZSA9IGZhbHNlLFxuICAgICAgICBjb250YWluZXI6IGJyb3dzZXIuY29udGV4dHVhbElkZW50aXRpZXMuQ29udGV4dHVhbElkZW50aXR5LFxuICAgICkge1xuICAgICAgICBzdXBlcigpXG4gICAgICAgIC8vIFR3byBjaGFyYWN0ZXIgdGFiIHByb3BlcnRpZXMgcHJlZml4XG4gICAgICAgIGxldCBwcmUgPSBcIlwiXG4gICAgICAgIGlmICh0YWIuYWN0aXZlKSBwcmUgKz0gXCIlXCJcbiAgICAgICAgZWxzZSBpZiAoaXNBbHRlcm5hdGl2ZSkge1xuICAgICAgICAgICAgcHJlICs9IFwiI1wiXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCIjXCJcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFiLnBpbm5lZCkgcHJlICs9IFwiQFwiXG5cbiAgICAgICAgLy8gUHVzaCBwcmVmaXggYmVmb3JlIHBhZGRpbmcgc28gd2UgZG9uJ3QgbWF0Y2ggb24gd2hpdGVzcGFjZVxuICAgICAgICB0aGlzLmZ1c2VLZXlzLnB1c2gocHJlKVxuXG4gICAgICAgIC8vIFB1c2ggcHJvcGVydGllcyB3ZSB3YW50IHRvIGZ1em1hdGNoIG9uXG4gICAgICAgIHRoaXMuZnVzZUtleXMucHVzaChTdHJpbmcodGFiLmluZGV4ICsgMSksIHRhYi50aXRsZSwgdGFiLnVybClcblxuICAgICAgICAvLyBDcmVhdGUgSFRNTEVsZW1lbnRcbiAgICAgICAgY29uc3QgZmF2SWNvblVybCA9IHRhYi5mYXZJY29uVXJsXG4gICAgICAgICAgICA/IHRhYi5mYXZJY29uVXJsXG4gICAgICAgICAgICA6IENvbXBsZXRpb25zLkRFRkFVTFRfRkFWSUNPTlxuICAgICAgICB0aGlzLmh0bWwgPSBodG1sYDx0ciBjbGFzcz1cIkJ1ZmZlckNvbXBsZXRpb25PcHRpb24gb3B0aW9uIGNvbnRhaW5lcl8ke2NvbnRhaW5lci5jb2xvcn0gY29udGFpbmVyXyR7Y29udGFpbmVyLmljb259IGNvbnRhaW5lcl8ke2NvbnRhaW5lci5uYW1lfVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPHRkIGNsYXNzPVwicHJlZml4XCI+JHtwcmUucGFkRW5kKDIpfTwvdGQ+XG4gICAgICAgICAgICAgICAgPHRkIGNsYXNzPVwiY29udGFpbmVyXCI+PC90ZD5cbiAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJpY29uXCI+PGltZyBzcmM9XCIke2Zhdkljb25Vcmx9XCIgLz48L3RkPlxuICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cInRpdGxlXCI+JHt0YWIuaW5kZXggKyAxfTogJHt0YWIudGl0bGV9PC90ZD5cbiAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJjb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVwidXJsXCIgdGFyZ2V0PVwiX2JsYW5rXCIgaHJlZj0ke3RhYi51cmx9XG4gICAgICAgICAgICAgICAgICAgICAgICA+JHt0YWIudXJsfTwvYVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDwvdHI+YFxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEJ1ZmZlckNvbXBsZXRpb25Tb3VyY2UgZXh0ZW5kcyBDb21wbGV0aW9ucy5Db21wbGV0aW9uU291cmNlRnVzZSB7XG4gICAgcHVibGljIG9wdGlvbnM6IEJ1ZmZlckNvbXBsZXRpb25PcHRpb25bXVxuICAgIHByaXZhdGUgc2hvdWxkU2V0U3RhdGVGcm9tU2NvcmUgPSB0cnVlXG5cbiAgICAvLyBUT0RPOlxuICAgIC8vICAgICAtIHN0b3JlIHRoZSBleHN0ciBhbmQgdHJpZ2dlciByZWRyYXdzIG9uIHVzZXIgb3IgZGF0YSBpbnB1dCB3aXRob3V0XG4gICAgLy8gICAgICAgY2FsbGJhY2sgZmFmZmVyeVxuICAgIC8vICAgICAtIHNvcnQgb3V0IHRoZSBlbGVtZW50IHJlZHJhd2luZy5cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3BhcmVudCkge1xuICAgICAgICBzdXBlcihcbiAgICAgICAgICAgIFtcInRhYlwiLCBcInRhYmNsb3NlXCIsIFwidGFiZGV0YWNoXCIsIFwidGFiZHVwbGljYXRlXCIsIFwidGFibW92ZVwiXSxcbiAgICAgICAgICAgIFwiQnVmZmVyQ29tcGxldGlvblNvdXJjZVwiLFxuICAgICAgICAgICAgXCJUYWJzXCIsXG4gICAgICAgIClcblxuICAgICAgICB0aGlzLnVwZGF0ZU9wdGlvbnMoKVxuICAgICAgICB0aGlzLl9wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKVxuICAgIH1cblxuICAgIGFzeW5jIG9uSW5wdXQoZXhzdHIpIHtcbiAgICAgICAgLy8gU2NoZWR1bGUgYW4gdXBkYXRlLCBpZiB5b3UgbGlrZS4gTm90IHZlcnkgdXNlZnVsIGZvciB0YWJzLCBidXRcbiAgICAgICAgLy8gd2lsbCBiZSBmb3Igb3RoZXIgdGhpbmdzLlxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVPcHRpb25zKGV4c3RyKVxuICAgIH1cblxuICAgIGFzeW5jIGZpbHRlcihleHN0cikge1xuICAgICAgICB0aGlzLmxhc3RFeHN0ciA9IGV4c3RyXG4gICAgICAgIHJldHVybiB0aGlzLm9uSW5wdXQoZXhzdHIpXG4gICAgfVxuXG4gICAgc2V0U3RhdGVGcm9tU2NvcmUoc2NvcmVkT3B0czogQ29tcGxldGlvbnMuU2NvcmVkT3B0aW9uW10pIHtcbiAgICAgICAgc3VwZXIuc2V0U3RhdGVGcm9tU2NvcmUoc2NvcmVkT3B0cywgdGhpcy5zaG91bGRTZXRTdGF0ZUZyb21TY29yZSlcbiAgICB9XG5cbiAgICAvKiogU2NvcmUgd2l0aCBmdXNlIHVubGVzcyBxdWVyeSBpcyBhIHNpbmdsZSAjIG9yIGxvb2tzIGxpa2UgYSB0YWIgaW5kZXggKi9cbiAgICBzY29yZWRPcHRpb25zKFxuICAgICAgICBxdWVyeTogc3RyaW5nLFxuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICk6IENvbXBsZXRpb25zLlNjb3JlZE9wdGlvbltdIHtcbiAgICAgICAgY29uc3QgYXJncyA9IHF1ZXJ5LnRyaW0oKS5zcGxpdCgvXFxzKy9ndSlcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyBpZiBxdWVyeSBpcyBhbiBpbnRlZ2VyIG4gYW5kIHxufCA8IG9wdGlvbnMubGVuZ3RoXG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihOdW1iZXIoYXJnc1swXSkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gTnVtYmVyKGFyZ3NbMF0pIC0gMVxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhpbmRleCkgPCBvcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4Lm1vZChvcHRpb25zLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb246IG9wdGlvbnNbaW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JlOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnc1swXSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgb3B0aW9uXSBvZiBlbnVtZXJhdGUob3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbi5pc0FsdGVybmF0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG5vdCB5ZXQgcmV0dXJuZWQuLi5cbiAgICAgICAgcmV0dXJuIHN1cGVyLnNjb3JlZE9wdGlvbnMocXVlcnksIG9wdGlvbnMpXG4gICAgfVxuXG4gICAgQFBlcmYubWVhc3VyZWRBc3luY1xuICAgIHByaXZhdGUgYXN5bmMgdXBkYXRlT3B0aW9ucyhleHN0ciA9IFwiXCIpIHtcbiAgICAgICAgdGhpcy5sYXN0RXhzdHIgPSBleHN0clxuICAgICAgICBjb25zdCBbcHJlZml4LCBxdWVyeV0gPSB0aGlzLnNwbGl0T25QcmVmaXgoZXhzdHIpXG5cbiAgICAgICAgLy8gSGlkZSBzZWxmIGFuZCBzdG9wIGlmIHByZWZpeGVzIGRvbid0IG1hdGNoXG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIC8vIFNob3cgc2VsZiBpZiBwcmVmaXggYW5kIGN1cnJlbnRseSBoaWRkZW5cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcImhpZGRlblwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFwibm9ybWFsXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBcImhpZGRlblwiXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdoZW4gdGhlIHVzZXIgaXMgYXNraW5nIGZvciB0YWJtb3ZlIGNvbXBsZXRpb25zLCBkb24ndCBhdXRvc2VsZWN0IGlmIHRoZSBxdWVyeSBsb29rcyBsaWtlIGEgcmVsYXRpdmUgbW92ZSBodHRwczovL2dpdGh1Yi5jb20vdHJpZGFjdHlsL3RyaWRhY3R5bC9pc3N1ZXMvODI1XG4gICAgICAgIHRoaXMuc2hvdWxkU2V0U3RhdGVGcm9tU2NvcmUgPSAhKFxuICAgICAgICAgICAgcHJlZml4ID09PSBcInRhYm1vdmUgXCIgJiYgcXVlcnkubWF0Y2goXCJeWystXVswLTldKyRcIilcbiAgICAgICAgKVxuXG4gICAgICAgIC8qIGNvbnNvbGUubG9nKCd1cGRhdGVPcHRpb25zJywgdGhpcy5vcHRpb25Db250YWluZXIpICovXG4gICAgICAgIGNvbnN0IHRhYnM6IGJyb3dzZXIudGFicy5UYWJbXSA9IGF3YWl0IGJyb3dzZXJCZy50YWJzLnF1ZXJ5KHtcbiAgICAgICAgICAgIGN1cnJlbnRXaW5kb3c6IHRydWUsXG4gICAgICAgIH0pXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBbXVxuICAgICAgICAvLyBHZXQgYWx0ZXJuYXRpdmUgdGFiLCBkZWZpbmVkIGFzIGxhc3QgYWNjZXNzZWQgdGFiLlxuICAgICAgICB0YWJzLnNvcnQoKGEsIGIpID0+IChiLmxhc3RBY2Nlc3NlZCAtIGEubGFzdEFjY2Vzc2VkKSlcbiAgICAgICAgY29uc3QgYWx0ID0gdGFic1sxXVxuICAgICAgICB0YWJzLnNvcnQoKGEsIGIpID0+IChhLmluZGV4IC0gYi5pbmRleCkpXG5cbiAgICAgICAgZm9yIChjb25zdCB0YWIgb2YgdGFicykge1xuICAgICAgICAgICAgb3B0aW9ucy5wdXNoKFxuICAgICAgICAgICAgICAgIG5ldyBCdWZmZXJDb21wbGV0aW9uT3B0aW9uKFxuICAgICAgICAgICAgICAgICAgICAodGFiLmluZGV4ICsgMSkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgdGFiLFxuICAgICAgICAgICAgICAgICAgICB0YWIgPT09IGFsdCxcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgQ29udGFpbmVycy5nZXRGcm9tSWQodGFiLmNvb2tpZVN0b3JlSWQpLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbXBsZXRpb24gPSB1bmRlZmluZWRcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgICAgICBpZiAocXVlcnkgJiYgcXVlcnkudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGVGcm9tU2NvcmUodGhpcy5zY29yZWRPcHRpb25zKHF1ZXJ5KSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5mb3JFYWNoKG9wdGlvbiA9PiAob3B0aW9uLnN0YXRlID0gXCJub3JtYWxcIikpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlRGlzcGxheSgpXG4gICAgfVxufVxuIiwiaW1wb3J0ICogYXMgUGVyZiBmcm9tIFwiQHNyYy9wZXJmXCJcbmltcG9ydCB7IGJyb3dzZXJCZyB9IGZyb20gXCJAc3JjL2xpYi93ZWJleHRcIlxuaW1wb3J0ICogYXMgQ29udGFpbmVycyBmcm9tIFwiQHNyYy9saWIvY29udGFpbmVyc1wiXG5pbXBvcnQgKiBhcyBDb21wbGV0aW9ucyBmcm9tIFwiQHNyYy9jb21wbGV0aW9uc1wiXG5cbmNsYXNzIFRhYkFsbENvbXBsZXRpb25PcHRpb24gZXh0ZW5kcyBDb21wbGV0aW9ucy5Db21wbGV0aW9uT3B0aW9uSFRNTFxuICAgIGltcGxlbWVudHMgQ29tcGxldGlvbnMuQ29tcGxldGlvbk9wdGlvbkZ1c2Uge1xuICAgIHB1YmxpYyBmdXNlS2V5cyA9IFtdXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHB1YmxpYyB2YWx1ZTogc3RyaW5nLFxuICAgICAgICB0YWI6IGJyb3dzZXIudGFicy5UYWIsXG4gICAgICAgIHdpbmluZGV4OiBudW1iZXIsXG4gICAgICAgIGNvbnRhaW5lcjogYnJvd3Nlci5jb250ZXh0dWFsSWRlbnRpdGllcy5Db250ZXh0dWFsSWRlbnRpdHksXG4gICAgICAgIGluY29nbml0bzogYm9vbGVhbixcbiAgICApIHtcbiAgICAgICAgc3VwZXIoKVxuICAgICAgICB0aGlzLnZhbHVlID0gYCR7d2luaW5kZXh9LiR7dGFiLmluZGV4ICsgMX1gXG4gICAgICAgIHRoaXMuZnVzZUtleXMucHVzaCh0aGlzLnZhbHVlLCB0YWIudGl0bGUsIHRhYi51cmwpXG5cbiAgICAgICAgLy8gQ3JlYXRlIEhUTUxFbGVtZW50XG4gICAgICAgIGNvbnN0IGZhdkljb25VcmwgPSB0YWIuZmF2SWNvblVybFxuICAgICAgICAgICAgPyB0YWIuZmF2SWNvblVybFxuICAgICAgICAgICAgOiBDb21wbGV0aW9ucy5ERUZBVUxUX0ZBVklDT05cbiAgICAgICAgdGhpcy5odG1sID0gaHRtbGA8dHIgY2xhc3M9XCJCdWZmZXJBbGxDb21wbGV0aW9uT3B0aW9uIG9wdGlvbiBjb250YWluZXJfJHtjb250YWluZXIuY29sb3J9IGNvbnRhaW5lcl8ke2NvbnRhaW5lci5pY29ufSBjb250YWluZXJfJHtjb250YWluZXIubmFtZX0gJHtpbmNvZ25pdG9cbiAgICAgICAgICAgICAgICAgICAgPyBcImluY29nbml0b1wiXG4gICAgICAgICAgICAgICAgICAgIDogXCJcIn1cIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cInByZWZpeFwiPjwvdGQ+XG4gICAgICAgICAgICAgICAgPHRkIGNsYXNzPVwicHJpdmF0ZXdpbmRvd1wiPjwvdGQ+XG4gICAgICAgICAgICAgICAgPHRkIGNsYXNzPVwiY29udGFpbmVyXCI+PC90ZD5cbiAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJpY29uXCI+PGltZyBzcmM9XCIke2Zhdkljb25Vcmx9XCIgLz48L3RkPlxuICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cInRpdGxlXCI+JHt0aGlzLnZhbHVlfTogJHt0YWIudGl0bGV9PC90ZD5cbiAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJjb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVwidXJsXCIgdGFyZ2V0PVwiX2JsYW5rXCIgaHJlZj0ke3RhYi51cmx9XG4gICAgICAgICAgICAgICAgICAgICAgICA+JHt0YWIudXJsfTwvYVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDwvdHI+YFxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRhYkFsbENvbXBsZXRpb25Tb3VyY2UgZXh0ZW5kcyBDb21wbGV0aW9ucy5Db21wbGV0aW9uU291cmNlRnVzZSB7XG4gICAgcHVibGljIG9wdGlvbnM6IFRhYkFsbENvbXBsZXRpb25PcHRpb25bXVxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfcGFyZW50KSB7XG4gICAgICAgIHN1cGVyKFtcInRhYmFsbFwiXSwgXCJUYWJBbGxDb21wbGV0aW9uU291cmNlXCIsIFwiQWxsIFRhYnNcIilcblxuICAgICAgICB0aGlzLnVwZGF0ZU9wdGlvbnMoKVxuICAgICAgICB0aGlzLl9wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKVxuICAgIH1cblxuICAgIGFzeW5jIG9uSW5wdXQoZXhzdHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlT3B0aW9ucyhleHN0cilcbiAgICB9XG5cbiAgICBzZXRTdGF0ZUZyb21TY29yZShzY29yZWRPcHRzOiBDb21wbGV0aW9ucy5TY29yZWRPcHRpb25bXSkge1xuICAgICAgICBzdXBlci5zZXRTdGF0ZUZyb21TY29yZShzY29yZWRPcHRzLCB0cnVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcCBhbGwgd2luZG93cyBpbnRvIGEge1t3aW5kb3dJZF06IHdpbmRvd30gb2JqZWN0XG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRXaW5kb3dzKCkge1xuICAgICAgICBjb25zdCB3aW5kb3dzID0gYXdhaXQgYnJvd3NlckJnLndpbmRvd3MuZ2V0QWxsKClcbiAgICAgICAgY29uc3QgcmVzcG9uc2U6IHsgW3dpbmRvd0lkOiBudW1iZXJdOiBicm93c2VyLndpbmRvd3MuV2luZG93IH0gPSB7fVxuICAgICAgICB3aW5kb3dzLmZvckVhY2god2luID0+IChyZXNwb25zZVt3aW4uaWRdID0gd2luKSlcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlXG4gICAgfVxuXG4gICAgQFBlcmYubWVhc3VyZWRBc3luY1xuICAgIHByaXZhdGUgYXN5bmMgdXBkYXRlT3B0aW9ucyhleHN0ciA9IFwiXCIpIHtcbiAgICAgICAgdGhpcy5sYXN0RXhzdHIgPSBleHN0clxuICAgICAgICBjb25zdCBbcHJlZml4XSA9IHRoaXMuc3BsaXRPblByZWZpeChleHN0cilcblxuICAgICAgICAvLyBIaWRlIHNlbGYgYW5kIHN0b3AgaWYgcHJlZml4ZXMgZG9uJ3QgbWF0Y2hcbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgICAgLy8gU2hvdyBzZWxmIGlmIHByZWZpeCBhbmQgY3VycmVudGx5IGhpZGRlblxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gXCJub3JtYWxcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFwiaGlkZGVuXCJcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGFic1Byb21pc2UgPSBicm93c2VyQmcudGFicy5xdWVyeSh7fSlcbiAgICAgICAgY29uc3Qgd2luZG93c1Byb21pc2UgPSB0aGlzLmdldFdpbmRvd3MoKVxuICAgICAgICBjb25zdCBbdGFicywgd2luZG93c10gPSBhd2FpdCBQcm9taXNlLmFsbChbdGFic1Byb21pc2UsIHdpbmRvd3NQcm9taXNlXSlcblxuICAgICAgICBjb25zdCBvcHRpb25zID0gW11cblxuICAgICAgICB0YWJzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGlmIChhLndpbmRvd0lkID09PSBiLndpbmRvd0lkKSByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXhcbiAgICAgICAgICAgIHJldHVybiBhLndpbmRvd0lkIC0gYi53aW5kb3dJZFxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIFdpbmRvdyBJZHMgZG9uJ3QgbWFrZSBzZW5zZSBzbyB3ZSdyZSB1c2luZyBMQVNUSUQgYW5kIFdJTklOREVYIHRvIGNvbXB1dGUgYSB3aW5kb3cgaW5kZXhcbiAgICAgICAgLy8gVGhpcyByZWxpZXMgb24gdGhlIGZhY3QgdGhhdCB0YWJzIGFyZSBzb3J0ZWQgYnkgd2luZG93IGlkc1xuICAgICAgICBsZXQgbGFzdElkID0gMFxuICAgICAgICBsZXQgd2luaW5kZXggPSAwXG4gICAgICAgIGZvciAoY29uc3QgdGFiIG9mIHRhYnMpIHtcbiAgICAgICAgICAgIGlmIChsYXN0SWQgIT09IHRhYi53aW5kb3dJZCkge1xuICAgICAgICAgICAgICAgIGxhc3RJZCA9IHRhYi53aW5kb3dJZFxuICAgICAgICAgICAgICAgIHdpbmluZGV4ICs9IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMucHVzaChcbiAgICAgICAgICAgICAgICBuZXcgVGFiQWxsQ29tcGxldGlvbk9wdGlvbihcbiAgICAgICAgICAgICAgICAgICAgdGFiLmlkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIHRhYixcbiAgICAgICAgICAgICAgICAgICAgd2luaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IENvbnRhaW5lcnMuZ2V0RnJvbUlkKHRhYi5jb29raWVTdG9yZUlkKSxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93c1t0YWIud2luZG93SWRdLmluY29nbml0byxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb21wbGV0aW9uID0gdW5kZWZpbmVkXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ2hhaW4oKVxuICAgIH1cbn1cbiIsImltcG9ydCB7IGJyb3dzZXJCZyB9IGZyb20gXCJAc3JjL2xpYi93ZWJleHQudHNcIlxuaW1wb3J0ICogYXMgQ29tcGxldGlvbnMgZnJvbSBcIkBzcmMvY29tcGxldGlvbnNcIlxuXG5jbGFzcyBXaW5kb3dDb21wbGV0aW9uT3B0aW9uIGV4dGVuZHMgQ29tcGxldGlvbnMuQ29tcGxldGlvbk9wdGlvbkhUTUxcbiAgICBpbXBsZW1lbnRzIENvbXBsZXRpb25zLkNvbXBsZXRpb25PcHRpb25GdXNlIHtcbiAgICBwdWJsaWMgZnVzZUtleXMgPSBbXVxuXG4gICAgY29uc3RydWN0b3Iod2luKSB7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgdGhpcy52YWx1ZSA9IHdpbi5pZFxuICAgICAgICB0aGlzLmZ1c2VLZXlzLnB1c2goYCR7d2luLnRpdGxlfWApXG4gICAgICAgIHRoaXMuZnVzZUtleXMucHVzaChgJHt3aW4uaWR9YClcblxuICAgICAgICAvLyBDcmVhdGUgSFRNTEVsZW1lbnRcbiAgICAgICAgdGhpcy5odG1sID0gaHRtbGA8dHIgY2xhc3M9XCJXaW5kb3dDb21wbGV0aW9uT3B0aW9uIG9wdGlvbiAke1xuICAgICAgICAgICAgd2luLmluY29nbml0byA/IFwiaW5jb2duaXRvXCIgOiBcIlwiXG4gICAgICAgIH1cIj5cbiAgICAgICAgICAgIDx0ZCBjbGFzcz1cInByaXZhdGV3aW5kb3dcIj48L3RkPlxuICAgICAgICAgICAgPHRkIGNsYXNzPVwiaWRcIj4ke3dpbi5pZH08L3RkPlxuICAgICAgICAgICAgPHRkIGNsYXNzPVwidGl0bGVcIj4ke3dpbi50aXRsZX08L3RkPlxuICAgICAgICAgICAgPHRkIGNsYXNzPVwidGFiY291bnRcIj4ke3dpbi50YWJzLmxlbmd0aH0gdGFiJHtcbiAgICAgICAgICAgIHdpbi50YWJzLmxlbmd0aCAhPT0gMSA/IFwic1wiIDogXCJcIlxuICAgICAgICB9PC90ZD5cbiAgICAgICAgPC90cj5gXG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgV2luZG93Q29tcGxldGlvblNvdXJjZSBleHRlbmRzIENvbXBsZXRpb25zLkNvbXBsZXRpb25Tb3VyY2VGdXNlIHtcbiAgICBwdWJsaWMgb3B0aW9uczogV2luZG93Q29tcGxldGlvbk9wdGlvbltdXG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wYXJlbnQpIHtcbiAgICAgICAgc3VwZXIoW1wid2luY2xvc2VcIl0sIFwiV2luZG93Q29tcGxldGlvblNvdXJjZVwiLCBcIldpbmRvd3NcIilcblxuICAgICAgICB0aGlzLnVwZGF0ZU9wdGlvbnMoKVxuICAgICAgICB0aGlzLl9wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKVxuICAgIH1cblxuICAgIGFzeW5jIG9uSW5wdXQoZXhzdHIpIHtcbiAgICAgICAgLy8gU2NoZWR1bGUgYW4gdXBkYXRlLCBpZiB5b3UgbGlrZS4gTm90IHZlcnkgdXNlZnVsIGZvciB3aW5kb3dzLCBidXRcbiAgICAgICAgLy8gd2lsbCBiZSBmb3Igb3RoZXIgdGhpbmdzLlxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVPcHRpb25zKGV4c3RyKVxuICAgIH1cblxuICAgIGFzeW5jIGZpbHRlcihleHN0cikge1xuICAgICAgICB0aGlzLmxhc3RFeHN0ciA9IGV4c3RyXG4gICAgICAgIHJldHVybiB0aGlzLm9uSW5wdXQoZXhzdHIpXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyB1cGRhdGVPcHRpb25zKGV4c3RyID0gXCJcIikge1xuICAgICAgICB0aGlzLmxhc3RFeHN0ciA9IGV4c3RyXG4gICAgICAgIGNvbnN0IFtwcmVmaXhdID0gdGhpcy5zcGxpdE9uUHJlZml4KGV4c3RyKVxuXG4gICAgICAgIC8vIEhpZGUgc2VsZiBhbmQgc3RvcCBpZiBwcmVmaXhlcyBkb24ndCBtYXRjaFxuICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgICAvLyBTaG93IHNlbGYgaWYgcHJlZml4IGFuZCBjdXJyZW50bHkgaGlkZGVuXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJoaWRkZW5cIikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBcIm5vcm1hbFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gXCJoaWRkZW5cIlxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9wdGlvbnMgPSAoYXdhaXQgYnJvd3NlckJnLndpbmRvd3MuZ2V0QWxsKHsgcG9wdWxhdGU6IHRydWUgfSkpLm1hcChcbiAgICAgICAgICAgIHdpbiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbyA9IG5ldyBXaW5kb3dDb21wbGV0aW9uT3B0aW9uKHdpbilcbiAgICAgICAgICAgICAgICBvLnN0YXRlID0gXCJub3JtYWxcIlxuICAgICAgICAgICAgICAgIHJldHVybiBvXG4gICAgICAgICAgICB9LFxuICAgICAgICApXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZURpc3BsYXkoKVxuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIGNvbmZpZyBmcm9tIFwiQHNyYy9saWIvY29uZmlnXCJcbmltcG9ydCB7IGJyb3dzZXJCZyB9IGZyb20gXCJAc3JjL2xpYi93ZWJleHRcIlxuXG5leHBvcnQgZnVuY3Rpb24gbmV3dGFidXJsKCkge1xuICAgIC8vIEluIHRoZSBub25ld3RhYiB2ZXJzaW9uLCB0aGlzIHdpbGwgcmV0dXJuIGBudWxsYCBhbmQgdXBzZXQgZ2V0VVJMLlxuICAgIC8vIFRlcm5hcnkgb3AgYmVsb3cgcHJldmVudHMgdGhlIHJ1bnRpbWUgZXJyb3IuXG4gICAgY29uc3QgbmV3dGFiID0gKGJyb3dzZXIucnVudGltZS5nZXRNYW5pZmVzdCgpKS5jaHJvbWVfdXJsX292ZXJyaWRlcy5uZXd0YWJcbiAgICByZXR1cm4gbmV3dGFiICE9PSBudWxsID8gYnJvd3Nlci5ydW50aW1lLmdldFVSTChuZXd0YWIpIDogbnVsbFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Qm9va21hcmtzKHF1ZXJ5OiBzdHJpbmcpIHtcbiAgICAvLyBTZWFyY2ggYm9va21hcmtzLCBkZWR1cGUgYW5kIHNvcnQgYnkgbW9zdCByZWNlbnQuXG4gICAgbGV0IGJvb2ttYXJrcyA9IGF3YWl0IGJyb3dzZXJCZy5ib29rbWFya3Muc2VhcmNoKHsgcXVlcnkgfSlcblxuICAgIC8vIFJlbW92ZSBmb2xkZXIgbm9kZXMgYW5kIGJhZCBVUkxzXG4gICAgYm9va21hcmtzID0gYm9va21hcmtzLmZpbHRlcihiID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVVJMKGIudXJsKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICBib29rbWFya3Muc29ydCgoYSwgYikgPT4gYi5kYXRlQWRkZWQgLSBhLmRhdGVBZGRlZClcblxuICAgIC8vIFJlbW92ZSBkdXBsaWNhdGUgYm9va21hcmtzXG4gICAgY29uc3Qgc2VlbiA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KClcbiAgICBib29rbWFya3MgPSBib29rbWFya3MuZmlsdGVyKGIgPT4ge1xuICAgICAgICBpZiAoc2Vlbi5nZXQoYi50aXRsZSkgPT09IGIudXJsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2Vlbi5zZXQoYi50aXRsZSwgYi51cmwpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiBib29rbWFya3Ncbn1cblxuZnVuY3Rpb24gZnJlY2VuY3koaXRlbTogYnJvd3Nlci5oaXN0b3J5Lkhpc3RvcnlJdGVtKSB7XG4gICAgLy8gRG9lc24ndCBhY3R1YWxseSBjYXJlIGFib3V0IHJlY2VuY3kgeWV0LlxuICAgIHJldHVybiBpdGVtLnZpc2l0Q291bnQgKiAtMVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0SGlzdG9yeShxdWVyeTogc3RyaW5nKTogUHJvbWlzZTxicm93c2VyLmhpc3RvcnkuSGlzdG9yeUl0ZW1bXT4ge1xuICAgIC8vIFNlYXJjaCBoaXN0b3J5LCBkZWR1cGUgYW5kIHNvcnQgYnkgZnJlY2VuY3lcbiAgICBsZXQgaGlzdG9yeSA9IGF3YWl0IGJyb3dzZXJCZy5oaXN0b3J5LnNlYXJjaCh7XG4gICAgICAgIHRleHQ6IHF1ZXJ5LFxuICAgICAgICBtYXhSZXN1bHRzOiBjb25maWcuZ2V0KFwiaGlzdG9yeXJlc3VsdHNcIiksXG4gICAgICAgIHN0YXJ0VGltZTogMCxcbiAgICB9KVxuXG4gICAgLy8gUmVtb3ZlIGVudHJpZXMgd2l0aCBkdXBsaWNhdGUgVVJMc1xuICAgIGNvbnN0IGRlZHVwZSA9IG5ldyBNYXAoKVxuICAgIGZvciAoY29uc3QgcGFnZSBvZiBoaXN0b3J5KSB7XG4gICAgICAgIGlmIChwYWdlLnVybCAhPT0gbmV3dGFidXJsKCkpIHtcbiAgICAgICAgICAgIGlmIChkZWR1cGUuaGFzKHBhZ2UudXJsKSkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgZGVkdXBlLmdldChwYWdlLnVybCkudGl0bGUubGVuZ3RoIDxcbiAgICAgICAgICAgICAgICAgICAgcGFnZS50aXRsZS5sZW5ndGhcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVkdXBlLnNldChwYWdlLnVybCwgcGFnZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZHVwZS5zZXQocGFnZS51cmwsIHBhZ2UpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGlzdG9yeSA9IFsuLi5kZWR1cGUudmFsdWVzKCldXG5cbiAgICBoaXN0b3J5LnNvcnQoKGEsIGIpID0+IGZyZWNlbmN5KGEpIC0gZnJlY2VuY3koYikpXG5cbiAgICByZXR1cm4gaGlzdG9yeVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VG9wU2l0ZXMoKSB7XG4gICAgcmV0dXJuIChhd2FpdCBicm93c2VyQmcudG9wU2l0ZXMuZ2V0KCkpXG4gICAgICAgIC5maWx0ZXIocGFnZSA9PiBwYWdlLnVybCAhPT0gbmV3dGFidXJsKCkpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb21iaW5lZEhpc3RvcnlCbWFya3MocXVlcnk6IHN0cmluZyk6IFByb21pc2U8QXJyYXk8e3RpdGxlOiBzdHJpbmcsIHVybDogc3RyaW5nfT4+IHtcbiAgICBjb25zdCBbaGlzdG9yeSwgYm9va21hcmtzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgZ2V0SGlzdG9yeShxdWVyeSksXG4gICAgICAgIGdldEJvb2ttYXJrcyhxdWVyeSksXG4gICAgXSlcblxuICAgIC8vIEpvaW4gcmVjb3JkcyBieSBVUkwsIHVzaW5nIHRoZSB0aXRsZSBmcm9tIGJvb2ttYXJrcyBieSBwcmVmZXJlbmNlLlxuICAgIGNvbnN0IGNvbWJpbmVkTWFwID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oYm9va21hcmtzLm1hcChibWFyayA9PiBbXG4gICAgICAgIGJtYXJrLnVybCwge3RpdGxlOiBibWFyay50aXRsZSwgdXJsOiBibWFyay51cmwsIGJtYXJrfVxuICAgIF0pKVxuICAgIGhpc3RvcnkuZm9yRWFjaChwYWdlID0+IHtcbiAgICAgICAgaWYgKGNvbWJpbmVkTWFwLmhhcyhwYWdlLnVybCkpIGNvbWJpbmVkTWFwLmdldChwYWdlLnVybCkuaGlzdG9yeSA9IHBhZ2VcbiAgICAgICAgZWxzZSBjb21iaW5lZE1hcC5zZXQocGFnZS51cmwsIHt0aXRsZTogcGFnZS50aXRsZSwgdXJsOiBwYWdlLnVybCwgaGlzdG9yeTogcGFnZX0pXG4gICAgfSlcblxuICAgIGNvbnN0IHNjb3JlID0geCA9PiAoeC5oaXN0b3J5ID8gZnJlY2VuY3koeC5oaXN0b3J5KSA6IDApIC0gKHguYm1hcmsgPyBjb25maWcuZ2V0KFwiYm1hcmt3ZWlnaHRcIikgOiAwKVxuXG4gICAgcmV0dXJuIEFycmF5LmZyb20oY29tYmluZWRNYXAudmFsdWVzKCkpLnNvcnQoKGEsIGIpID0+IHNjb3JlKGEpIC0gc2NvcmUoYikpXG59XG4iLCJpbXBvcnQgeyBzdGF0aWNUaGVtZXMgfSBmcm9tIFwiQHNyYy8ubWV0YWRhdGEuZ2VuZXJhdGVkXCJcbmltcG9ydCAqIGFzIGNvbmZpZyBmcm9tIFwiQHNyYy9saWIvY29uZmlnXCJcbmltcG9ydCAqIGFzIExvZ2dpbmcgZnJvbSBcIkBzcmMvbGliL2xvZ2dpbmdcIlxuaW1wb3J0IHsgYnJvd3NlckJnLCBvd25UYWJJZCB9IGZyb20gXCJAc3JjL2xpYi93ZWJleHRcIlxuXG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2luZy5Mb2dnZXIoXCJzdHlsaW5nXCIpXG5cbmV4cG9ydCBjb25zdCBUSEVNRVMgPSBzdGF0aWNUaGVtZXNcblxuZnVuY3Rpb24gY2FwaXRhbGlzZShzdHIpIHtcbiAgICBpZiAoc3RyID09PSBcIlwiKSByZXR1cm4gc3RyXG4gICAgcmV0dXJuIHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59XG5cbmZ1bmN0aW9uIHByZWZpeFRoZW1lKG5hbWUpIHtcbiAgICByZXR1cm4gXCJUcmlkYWN0eWxUaGVtZVwiICsgY2FwaXRhbGlzZShuYW1lKVxufVxuXG4vLyBBdCB0aGUgbW9tZW50IGVsZW1lbnRzIGFyZSBvbmx5IGV2ZXIgYDpyb290YCBhbmQgc28gdGhpcyBhcnJheSBhbmQgc3R1ZmYgaXMgYWxsIGEgYml0IG92ZXJkZXNpZ25lZC5cbmNvbnN0IFRIRU1FRF9FTEVNRU5UUyA9IFtdXG5cbmxldCBpbnNlcnRlZENTUyA9IGZhbHNlXG5jb25zdCBjdXN0b21Dc3MgPSB7XG4gICAgYWxsRnJhbWVzOiB0cnVlLFxuICAgIG1hdGNoQWJvdXRCbGFuazogdHJ1ZSxcbiAgICBjb2RlOiBcIlwiLFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdGhlbWUoZWxlbWVudCkge1xuICAgIC8vIFJlbW92ZSBhbnkgb2xkIHRoZW1lXG4gICAgZm9yIChjb25zdCB0aGVtZSBvZiBUSEVNRVMubWFwKHByZWZpeFRoZW1lKSkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUodGhlbWUpXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZENTUykge1xuICAgICAgICAvLyBUeXBlc2NyaXB0IGRvZXNuJ3Qgc2VlbSB0byBiZSBhd2FyZSB0aGFuIHJlbW92ZS9pbnNlcnRDU1MncyB0YWJpZFxuICAgICAgICAvLyBhcmd1bWVudCBpcyBvcHRpb25hbFxuICAgICAgICBhd2FpdCBicm93c2VyQmcudGFicy5yZW1vdmVDU1MoYXdhaXQgb3duVGFiSWQoKSwgY3VzdG9tQ3NzKVxuICAgICAgICBpbnNlcnRlZENTUyA9IGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgbmV3VGhlbWUgPSBhd2FpdCBjb25maWcuZ2V0QXN5bmMoXCJ0aGVtZVwiKVxuXG4gICAgLy8gQWRkIGEgY2xhc3MgY29ycmVzcG9uZGluZyB0byBjb25maWcuZ2V0KCd0aGVtZScpXG4gICAgaWYgKG5ld1RoZW1lICE9PSBcImRlZmF1bHRcIikge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQocHJlZml4VGhlbWUobmV3VGhlbWUpKVxuICAgIH1cblxuICAgIC8vIEluc2VydCBjdXN0b20gY3NzIGlmIG5lZWRlZFxuICAgIGlmIChuZXdUaGVtZSAhPT0gXCJkZWZhdWx0XCIgJiYgIVRIRU1FUy5pbmNsdWRlcyhuZXdUaGVtZSkpIHtcbiAgICAgICAgY3VzdG9tQ3NzLmNvZGUgPSBhd2FpdCBjb25maWcuZ2V0QXN5bmMoXCJjdXN0b210aGVtZXNcIiwgbmV3VGhlbWUpXG4gICAgICAgIGlmIChjdXN0b21Dc3MuY29kZSkge1xuICAgICAgICAgICAgYXdhaXQgYnJvd3NlckJnLnRhYnMuaW5zZXJ0Q1NTKGF3YWl0IG93blRhYklkKCksIGN1c3RvbUNzcylcbiAgICAgICAgICAgIGluc2VydGVkQ1NTID0gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiVGhlbWUgXCIgKyBuZXdUaGVtZSArIFwiIGNvdWxkbid0IGJlIGZvdW5kLlwiKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVjb3JkIGZvciByZS10aGVtaW5nXG4gICAgLy8gY29uc2lkZXJpbmcgb25seSBlbGVtZW50cyA6cm9vdCAocGFnZSBhbmQgY21kbGluZV9pZnJhbWUpXG4gICAgLy8gVE9ETzpcbiAgICAvLyAgICAgLSBGaW5kIHdheXMgdG8gY2hlY2sgaWYgZWxlbWVudCBpcyBhbHJlYWR5IHB1c2hlZFxuICAgIGlmIChcbiAgICAgICAgVEhFTUVEX0VMRU1FTlRTLmxlbmd0aCA8IDIgJiZcbiAgICAgICAgZWxlbWVudC50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiSFRNTFwiXG4gICAgKSB7XG4gICAgICAgIFRIRU1FRF9FTEVNRU5UUy5wdXNoKGVsZW1lbnQpXG4gICAgfVxufVxuXG5mdW5jdGlvbiByZXRoZW1lKCkge1xuICAgIFRIRU1FRF9FTEVNRU5UUy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICB0aGVtZShlbGVtZW50KS5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuaW5nKFxuICAgICAgICAgICAgICAgIGBGYWlsZWQgdG8gcmV0aGVtZSBlbGVtZW50IFwiJHtlbGVtZW50fVwiLiBFcnJvcjogJHtlfWAsXG4gICAgICAgICAgICApXG4gICAgICAgIH0pXG4gICAgfSlcbn1cblxuY29uZmlnLmFkZENoYW5nZUxpc3RlbmVyKFwidGhlbWVcIiwgcmV0aGVtZSlcblxuLy8gU29tZXRpbWVzIHBhZ2VzIHdpbGwgb3ZlcndyaXRlIGNsYXNzIG5hbWVzIG9mIGVsZW1lbnRzLiBXZSB1c2UgYSBNdXRhdGlvbk9ic2VydmVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBIVE1MIGVsZW1lbnQgYWx3YXlzIGhhcyBhIFRyaWRhY3R5bFRoZW1lIGNsYXNzXG4vLyBXZSBjYW4ndCBqdXN0IGNhbGwgdGhlbWUoKSBiZWNhdXNlIGl0IHdvdWxkIGZpcnN0IHRyeSB0byByZW1vdmUgY2xhc3MgbmFtZXMgZnJvbSB0aGUgZWxlbWVudCwgd2hpY2ggd291bGQgdHJpZ2dlciB0aGUgTXV0YXRpb25PYnNlcnZlciBiZWZvcmUgd2UgaGFkIGEgY2hhbmNlIHRvIGFkZCB0aGUgdGhlbWUgY2xhc3MgYW5kIHRodXMgY2F1c2UgaW5maW5pdGUgcmVjdXJzaW9uXG5jb25zdCBjYiA9IGFzeW5jIG11dGF0aW9uTGlzdCA9PiB7XG4gICAgY29uc3QgdGhlbWUgPSBhd2FpdCBjb25maWcuZ2V0QXN5bmMoXCJ0aGVtZVwiKVxuICAgIG11dGF0aW9uTGlzdFxuICAgICAgICAuZmlsdGVyKG0gPT4gbS50YXJnZXQuY2xhc3NOYW1lLnNlYXJjaChwcmVmaXhUaGVtZShcIlwiKSkgPT09IC0xKVxuICAgICAgICAuZm9yRWFjaChtID0+IG0udGFyZ2V0LmNsYXNzTGlzdC5hZGQocHJlZml4VGhlbWUodGhlbWUpKSlcbn1cblxubmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2IpLm9ic2VydmUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7XG4gICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICBjaGlsZExpc3Q6IGZhbHNlLFxuICAgIGNoYXJhY3RlckRhdGE6IGZhbHNlLFxuICAgIHN1YnRyZWU6IGZhbHNlLFxuICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiBmYWxzZSxcbiAgICBhdHRyaWJ1dGVGaWx0ZXI6IFtcImNsYXNzXCJdLFxufSlcbiIsIi8vIEdlbmVyYXRlZCBhdXRvbWF0aWNhbGx5IGJ5IG5lYXJsZXksIHZlcnNpb24gMi4xOC4wXG4vLyBodHRwOi8vZ2l0aHViLmNvbS9IYXJkbWF0aDEyMy9uZWFybGV5XG4vLyBCeXBhc3NlcyBUUzYxMzMuIEFsbG93IGRlY2xhcmVkIGJ1dCB1bnVzZWQgZnVuY3Rpb25zLlxuLy8gQHRzLWlnbm9yZVxuZnVuY3Rpb24gaWQoZDogYW55W10pOiBhbnkgeyByZXR1cm4gZFswXTsgfVxuXG5leHBvcnQgaW50ZXJmYWNlIFRva2VuIHsgdmFsdWU6IGFueTsgW2tleTogc3RyaW5nXTogYW55IH07XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGV4ZXIge1xuICByZXNldDogKGNodW5rOiBzdHJpbmcsIGluZm86IGFueSkgPT4gdm9pZDtcbiAgbmV4dDogKCkgPT4gVG9rZW4gfCB1bmRlZmluZWQ7XG4gIHNhdmU6ICgpID0+IGFueTtcbiAgZm9ybWF0RXJyb3I6ICh0b2tlbjogVG9rZW4pID0+IHN0cmluZztcbiAgaGFzOiAodG9rZW5UeXBlOiBzdHJpbmcpID0+IGJvb2xlYW5cbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmVhcmxleVJ1bGUge1xuICBuYW1lOiBzdHJpbmc7XG4gIHN5bWJvbHM6IE5lYXJsZXlTeW1ib2xbXTtcbiAgcG9zdHByb2Nlc3M/OiAoZDogYW55W10sIGxvYz86IG51bWJlciwgcmVqZWN0Pzoge30pID0+IGFueVxufTtcblxuZXhwb3J0IHR5cGUgTmVhcmxleVN5bWJvbCA9IHN0cmluZyB8IHsgbGl0ZXJhbDogYW55IH0gfCB7IHRlc3Q6ICh0b2tlbjogYW55KSA9PiBib29sZWFuIH07XG5cbmV4cG9ydCB2YXIgTGV4ZXI6IExleGVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG5leHBvcnQgdmFyIFBhcnNlclJ1bGVzOiBOZWFybGV5UnVsZVtdID0gW1xuICAgIHtcIm5hbWVcIjogXCJCcmFja2V0RXhwclwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIjxcIn0sIFwiTW9kaWZpZXJcIiwgXCJNb2RLZXlcIiwge1wibGl0ZXJhbFwiOlwiPlwifV0sIFwicG9zdHByb2Nlc3NcIjogYmV4cHI9PmJleHByLnNsaWNlKDEsLTEpfSxcbiAgICB7XCJuYW1lXCI6IFwiQnJhY2tldEV4cHJcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCI8XCJ9LCBcIktleVwiLCB7XCJsaXRlcmFsXCI6XCI+XCJ9XSwgXCJwb3N0cHJvY2Vzc1wiOiBiZXhwcj0+W3t9XS5jb25jYXQoYmV4cHIuc2xpY2UoMSwtMSkpfSxcbiAgICB7XCJuYW1lXCI6IFwiTW9kaWZpZXIkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbL1thY21zQUNNU10vXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcIk1vZGlmaWVyJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW10sIFwicG9zdHByb2Nlc3NcIjogKCkgPT4gbnVsbH0sXG4gICAge1wibmFtZVwiOiBcIk1vZGlmaWVyJGVibmYkMlwiLCBcInN5bWJvbHNcIjogWy9bYWNtc0FDTVNdL10sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJNb2RpZmllciRlYm5mJDJcIiwgXCJzeW1ib2xzXCI6IFtdLCBcInBvc3Rwcm9jZXNzXCI6ICgpID0+IG51bGx9LFxuICAgIHtcIm5hbWVcIjogXCJNb2RpZmllciRlYm5mJDNcIiwgXCJzeW1ib2xzXCI6IFsvW2FjbXNBQ01TXS9dLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwiTW9kaWZpZXIkZWJuZiQzXCIsIFwic3ltYm9sc1wiOiBbXSwgXCJwb3N0cHJvY2Vzc1wiOiAoKSA9PiBudWxsfSxcbiAgICB7XCJuYW1lXCI6IFwiTW9kaWZpZXIkZWJuZiQ0XCIsIFwic3ltYm9sc1wiOiBbL1thY21zQUNNU10vXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcIk1vZGlmaWVyJGVibmYkNFwiLCBcInN5bWJvbHNcIjogW10sIFwicG9zdHByb2Nlc3NcIjogKCkgPT4gbnVsbH0sXG4gICAge1wibmFtZVwiOiBcIk1vZGlmaWVyXCIsIFwic3ltYm9sc1wiOiBbXCJNb2RpZmllciRlYm5mJDFcIiwgXCJNb2RpZmllciRlYm5mJDJcIiwgXCJNb2RpZmllciRlYm5mJDNcIiwgXCJNb2RpZmllciRlYm5mJDRcIiwge1wibGl0ZXJhbFwiOlwiLVwifV0sIFwicG9zdHByb2Nlc3NcIjogXG4gICAgICAgIC8qKiBGb3IgZWFjaCBtb2RpZmllciBwcmVzZW50LFxuICAgICAgICAgICAgYWRkIGl0cyBsb25nIG5hbWUgYXMgYW4gYXR0cmlidXRlIHNldCB0byB0cnVlIHRvIGFuIG9iamVjdCAqL1xuICAgICAgICAobW9kcywgXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb25nTmFtZXMgPSBuZXcgTWFwKFtcbiAgICAgICAgICAgICAgICBbXCJBXCIsIFwiYWx0S2V5XCJdLFxuICAgICAgICAgICAgICAgIFtcIkNcIiwgXCJjdHJsS2V5XCJdLFxuICAgICAgICAgICAgICAgIFtcIk1cIiwgXCJtZXRhS2V5XCJdLFxuICAgICAgICAgICAgICAgIFtcIlNcIiwgXCJzaGlmdEtleVwiXSxcbiAgICAgICAgICAgIF0pXG4gICAgICAgIFxuICAgICAgICAgICAgbGV0IG1vZGlmaWVyc09iaiA9IHt9XG4gICAgICAgICAgICBmb3IgKGxldCBtb2Qgb2YgbW9kcykge1xuICAgICAgICAgICAgICAgIGlmIChtb2QgPT09IG51bGwgfHwgbW9kID09PSBcIi1cIikgY29udGludWVcbiAgICAgICAgICAgICAgICBsZXQgbG9uZ05hbWUgPSBsb25nTmFtZXMuZ2V0KG1vZC50b1VwcGVyQ2FzZSgpKVxuICAgICAgICAgICAgICAgIGlmIChsb25nTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWplY3QgaWYgdGhlIHNhbWUgbmFtZSBpcyB1c2VkIHR3aWNlLlxuICAgICAgICAgICAgICAgICAgICBpZiAobG9uZ05hbWUgaW4gbW9kaWZpZXJzT2JqKSByZXR1cm4gcmVqZWN0XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgbW9kaWZpZXJzT2JqW2xvbmdOYW1lXSA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbW9kaWZpZXJzT2JqXG4gICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB7XCJuYW1lXCI6IFwiTW9kS2V5XCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiPFwifV0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJNb2RLZXlcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCI+XCJ9XSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcIk1vZEtleVwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIi1cIn1dLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwiTW9kS2V5XCIsIFwic3ltYm9sc1wiOiBbXCJLZXlcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJLZXkkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbL1teXFxzPD4tXS9dfSxcbiAgICB7XCJuYW1lXCI6IFwiS2V5JGVibmYkMVwiLCBcInN5bWJvbHNcIjogW1wiS2V5JGVibmYkMVwiLCAvW15cXHM8Pi1dL10sIFwicG9zdHByb2Nlc3NcIjogKGQpID0+IGRbMF0uY29uY2F0KFtkWzFdXSl9LFxuICAgIHtcIm5hbWVcIjogXCJLZXlcIiwgXCJzeW1ib2xzXCI6IFtcIktleSRlYm5mJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogKGtleSk9PmtleVswXS5qb2luKFwiXCIpfVxuXTtcblxuZXhwb3J0IHZhciBQYXJzZXJTdGFydDogc3RyaW5nID0gXCJCcmFja2V0RXhwclwiO1xuIiwiaW1wb3J0ICogYXMgY29uZmlnIGZyb20gXCJAc3JjL2xpYi9jb25maWdcIlxuXG4vKipcbiAqIEV4cGFuZHMgdGhlIGFsaWFzIGluIHRoZSBwcm92aWRlZCBleHN0ciByZWN1cnNpdmVseS4gRG9lcyBub3RoaW5nIGlmXG4gKiB0aGUgY29tbWFuZCBpcyBub3QgYWxpYXNlZCwgaW5jbHVkaW5nIHdoZW4gdGhlIGNvbW1hbmQgaXMgaW52YWxpZC5cbiAqXG4gKiBAcGFyYW0gZXhzdHIgOmV4c3RyIHR5cGVkIGJ5IHRoZSB1c2VyIG9uIHRoZSBjb21tYW50ZCBsaW5lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRFeHN0cihcbiAgICBleHN0cjogc3RyaW5nLFxuICAgIGFsaWFzZXMgPSBjb25maWcuZ2V0KFwiZXhhbGlhc2VzXCIpLFxuICAgIHByZXZFeHBhbnNpb25zOiBzdHJpbmdbXSA9IFtdLFxuKTogc3RyaW5nIHtcbiAgICAvLyBTcGxpdCBvbiB3aGl0ZXNwYWNlXG4gICAgY29uc3QgW2NvbW1hbmRdID0gZXhzdHIudHJpbSgpLnNwbGl0KC9cXHMrLylcblxuICAgIC8vIEJhc2UgY2FzZTogYWxpYXMgbm90IGZvdW5kOyByZXR1cm4gb3JpZ2luYWwgY29tbWFuZFxuICAgIGlmIChhbGlhc2VzW2NvbW1hbmRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGV4c3RyXG4gICAgfVxuXG4gICAgLy8gSW5maW5pdGUgbG9vcCBkZXRlY3RlZFxuICAgIGlmIChwcmV2RXhwYW5zaW9ucy5pbmNsdWRlcyhjb21tYW5kKSkge1xuICAgICAgICB0aHJvdyBgSW5maW5pdGUgbG9vcCBkZXRlY3RlZCB3aGlsZSBleHBhbmRpbmcgYWxpYXNlcy4gU3RhY2s6ICR7cHJldkV4cGFuc2lvbnN9LmBcbiAgICB9XG5cbiAgICAvLyBBZGQgY29tbWFuZCB0byBleHBhbnNpb25zIHVzZWQgc28gZmFyXG4gICAgcHJldkV4cGFuc2lvbnMucHVzaChjb21tYW5kKVxuXG4gICAgLy8gQWxpYXMgZXhpc3RzOyBleHBhbmQgaXQgcmVjdXJzaXZlbHlcbiAgICByZXR1cm4gZXhwYW5kRXhzdHIoXG4gICAgICAgIGV4c3RyLnJlcGxhY2UoY29tbWFuZCwgYWxpYXNlc1tjb21tYW5kXSksXG4gICAgICAgIGFsaWFzZXMsXG4gICAgICAgIHByZXZFeHBhbnNpb25zLFxuICAgIClcbn1cblxuLyoqXG4gKiBHZXQgYWxsIGFsaWFzZXMgZm9yIGFsbCBjb21tYW5kcy5cbiAqXG4gKiBAcGFyYW0gYWxpYXNlcyBBbiBvYmplY3QgbWFwcGluZyBhbGlhc2VzIHRvIGNvbW1hbmRzXG4gKiBAcmV0dXJuIGNvbW1hbmRzIEFuIG9iamVjdCBtYXBwaW5nIGNvbW1hbmRzIHRvIGFuIGFycmF5IG9mIGFsaWFzZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENtZEFsaWFzTWFwcGluZyhcbiAgICBhbGlhc2VzID0gY29uZmlnLmdldChcImV4YWxpYXNlc1wiKSxcbik6IHsgW3N0cjogc3RyaW5nXTogc3RyaW5nW10gfSB7XG4gICAgY29uc3QgY29tbWFuZHMgPSB7fVxuICAgIC8vIGFsaWFzZXMgbG9vayBsaWtlIHRoaXM6IHthbGlhczogY29tbWFuZH0gYnV0IHdoYXQgd2UgcmVhbGx5IG5lZWQgaXMgdGhpczoge2NvbW1hbmQ6IFthbGlhczEsIGFsaWFzMi4uLl19XG4gICAgLy8gVGhpcyBpcyB3aGF0IHRoaXMgbG9vcCBidWlsZHNcbiAgICBmb3IgKGNvbnN0IGFsaWFzIG9mIE9iamVjdC5rZXlzKGFsaWFzZXMpKSB7XG4gICAgICAgIGNvbnN0IGNtZCA9IGV4cGFuZEV4c3RyKGFsaWFzLCBhbGlhc2VzKS50cmltKClcbiAgICAgICAgaWYgKCFjb21tYW5kc1tjbWRdKSBjb21tYW5kc1tjbWRdID0gW11cbiAgICAgICAgY29tbWFuZHNbY21kXS5wdXNoKGFsaWFzLnRyaW0oKSlcbiAgICB9XG4gICAgcmV0dXJuIGNvbW1hbmRzXG59XG4iLCJpbXBvcnQgeyBtZXNzYWdlIH0gZnJvbSBcIkBzcmMvbGliL21lc3NhZ2luZ1wiXG5cbmNvbnN0IGJyb3dzZXJQcm94eSA9IG5ldyBQcm94eShPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgZ2V0KHRhcmdldCwgYXBpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkoXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnZXQoXywgZnVuYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlKFwiYnJvd3Nlcl9wcm94eV9iYWNrZ3JvdW5kXCIsIFwic2hpbVwiLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIClcbiAgICB9LFxufSkgYXMgdHlwZW9mIGJyb3dzZXJcblxuZXhwb3J0IGRlZmF1bHQgYnJvd3NlclByb3h5XG4iLCJpbXBvcnQgeyBtZXNzYWdlT3duVGFiIH0gZnJvbSBcIkBzcmMvbGliL21lc3NhZ2luZ1wiXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb21tYW5kbGluZUZucyhjbWRsaW5lX3N0YXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc2VydCB0aGUgZmlyc3QgY29tbWFuZCBsaW5lIGhpc3RvcnkgbGluZSB0aGF0IHN0YXJ0cyB3aXRoIHRoZSBjb250ZW50IG9mIHRoZSBjb21tYW5kIGxpbmUgaW4gdGhlIGNvbW1hbmQgbGluZS5cbiAgICAgICAgICovXG4gICAgICAgIFwiY29tcGxldGVcIjogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjbWRsaW5lX3N0YXRlLmNsSW5wdXQudmFsdWVcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBjbWRsaW5lX3N0YXRlLnN0YXRlLmNtZEhpc3RvcnkuZmlsdGVyKGtleSA9PiBrZXkuc3RhcnRzV2l0aChmcmFnbWVudCkpXG4gICAgICAgICAgICBjb25zdCBtb3N0cmVjZW50ID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICBpZiAobW9zdHJlY2VudCAhPT0gdW5kZWZpbmVkKSBjbWRsaW5lX3N0YXRlLmNsSW5wdXQudmFsdWUgPSBtb3N0cmVjZW50XG4gICAgICAgICAgICByZXR1cm4gY21kbGluZV9zdGF0ZS5yZWZyZXNoX2NvbXBsZXRpb25zKGNtZGxpbmVfc3RhdGUuY2xJbnB1dC52YWx1ZSlcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2VsZWN0cyB0aGUgbmV4dCBjb21wbGV0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgXCJuZXh0X2NvbXBsZXRpb25cIjogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNtZGxpbmVfc3RhdGUuYWN0aXZlQ29tcGxldGlvbnMpIGNtZGxpbmVfc3RhdGUuYWN0aXZlQ29tcGxldGlvbnMuZm9yRWFjaChjb21wID0+IGNvbXAubmV4dCgpKVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWxlY3RzIHRoZSBwcmV2aW91cyBjb21wbGV0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgXCJwcmV2X2NvbXBsZXRpb25cIjogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNtZGxpbmVfc3RhdGUuYWN0aXZlQ29tcGxldGlvbnMpIGNtZGxpbmVfc3RhdGUuYWN0aXZlQ29tcGxldGlvbnMuZm9yRWFjaChjb21wID0+IGNvbXAucHJldigpKVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXNlbGVjdHMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjb21wbGV0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgXCJkZXNlbGVjdF9jb21wbGV0aW9uXCI6ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChjbWRsaW5lX3N0YXRlLmFjdGl2ZUNvbXBsZXRpb25zKSBjbWRsaW5lX3N0YXRlLmFjdGl2ZUNvbXBsZXRpb25zLmZvckVhY2goY29tcCA9PiBjb21wLmRlc2VsZWN0KCkpXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc2VydHMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjb21wbGV0aW9uIGFuZCBhIHNwYWNlIGluIHRoZSBjb21tYW5kIGxpbmUuXG4gICAgICAgICAqL1xuICAgICAgICBcImluc2VydF9jb21wbGV0aW9uXCI6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1hbmQgPSBjbWRsaW5lX3N0YXRlLmdldENvbXBsZXRpb24oKVxuICAgICAgICAgICAgaWYgKGNtZGxpbmVfc3RhdGUuYWN0aXZlQ29tcGxldGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjbWRsaW5lX3N0YXRlLmFjdGl2ZUNvbXBsZXRpb25zLmZvckVhY2goY29tcCA9PiAoY29tcC5jb21wbGV0aW9uID0gdW5kZWZpbmVkKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBQcm9taXNlLnJlc29sdmUoW10pXG4gICAgICAgICAgICBpZiAoY29tbWFuZCkge1xuICAgICAgICAgICAgICAgIGNtZGxpbmVfc3RhdGUuY2xJbnB1dC52YWx1ZSA9IGNvbW1hbmQgKyBcIiBcIlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNtZGxpbmVfc3RhdGUucmVmcmVzaF9jb21wbGV0aW9ucyhjbWRsaW5lX3N0YXRlLmNsSW5wdXQudmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGEgY29tcGxldGlvbiBpcyBzZWxlY3RlZCwgaW5zZXJ0cyBpdCBpbiB0aGUgY29tbWFuZCBsaW5lIHdpdGggYSBzcGFjZS5cbiAgICAgICAgICogSWYgbm8gY29tcGxldGlvbiBpcyBzZWxlY3RlZCwgaW5zZXJ0cyBhIHNwYWNlIHdoZXJlIHRoZSBjYXJldCBpcy5cbiAgICAgICAgICovXG4gICAgICAgIFwiaW5zZXJ0X3NwYWNlX29yX2NvbXBsZXRpb25cIjogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29tbWFuZCA9IGNtZGxpbmVfc3RhdGUuZ2V0Q29tcGxldGlvbigpXG4gICAgICAgICAgICBpZiAoY21kbGluZV9zdGF0ZS5hY3RpdmVDb21wbGV0aW9ucykge1xuICAgICAgICAgICAgICAgIGNtZGxpbmVfc3RhdGUuYWN0aXZlQ29tcGxldGlvbnMuZm9yRWFjaChjb21wID0+IChjb21wLmNvbXBsZXRpb24gPSB1bmRlZmluZWQpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICBjbWRsaW5lX3N0YXRlLmNsSW5wdXQudmFsdWUgPSBjb21tYW5kICsgXCIgXCJcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uU3RhcnQgPSBjbWRsaW5lX3N0YXRlLmNsSW5wdXQuc2VsZWN0aW9uU3RhcnRcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb25FbmQgPSBjbWRsaW5lX3N0YXRlLmNsSW5wdXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICAgICAgY21kbGluZV9zdGF0ZS5jbElucHV0LnZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgY21kbGluZV9zdGF0ZS5jbElucHV0LnZhbHVlLnN1YnN0cmluZygwLCBzZWxlY3Rpb25TdGFydCkgK1xuICAgICAgICAgICAgICAgICAgICBcIiBcIiArXG4gICAgICAgICAgICAgICAgICAgIGNtZGxpbmVfc3RhdGUuY2xJbnB1dC52YWx1ZS5zdWJzdHJpbmcoc2VsZWN0aW9uRW5kKVxuICAgICAgICAgICAgICAgIGNtZGxpbmVfc3RhdGUuY2xJbnB1dC5zZWxlY3Rpb25TdGFydCA9IGNtZGxpbmVfc3RhdGUuY2xJbnB1dC5zZWxlY3Rpb25FbmQgPSBzZWxlY3Rpb25TdGFydCArIDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjbWRsaW5lX3N0YXRlLnJlZnJlc2hfY29tcGxldGlvbnMoY21kbGluZV9zdGF0ZS5jbElucHV0LnZhbHVlKVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiBIaWRlIHRoZSBjb21tYW5kIGxpbmUgYW5kIGNtZGxpbmVfc3RhdGUuY2xlYXIgaXRzIGNvbnRlbnQgd2l0aG91dCBleGVjdXRpbmcgaXQuICoqL1xuICAgICAgICBcImhpZGVfYW5kX2NsZWFyXCI6ICgpID0+IHtcbiAgICAgICAgICAgIGNtZGxpbmVfc3RhdGUuY2xlYXIodHJ1ZSlcbiAgICAgICAgICAgIGNtZGxpbmVfc3RhdGUua2V5RXZlbnRzID0gW11cblxuICAgICAgICAgICAgLy8gVHJ5IHRvIG1ha2UgdGhlIGNsb3NlIGNtZGxpbmUgYW5pbWF0aW9uIGFzIHNtb290aCBhcyBwb3NzaWJsZS5cbiAgICAgICAgICAgIG1lc3NhZ2VPd25UYWIoXCJjb21tYW5kbGluZV9jb250ZW50XCIsIFwiaGlkZVwiKVxuICAgICAgICAgICAgbWVzc2FnZU93blRhYihcImNvbW1hbmRsaW5lX2NvbnRlbnRcIiwgXCJibHVyXCIpXG4gICAgICAgICAgICAvLyBEZWxldGUgYWxsIGNvbXBsZXRpb24gc291cmNlcyAtIEkgZG9uJ3QgdGhpbmsgdGhpcyBpcyByZXF1aXJlZCwgYnV0IHRoaXNcbiAgICAgICAgICAgIC8vIHdheSBpZiB0aGVyZSBpcyBhIHRyYW5zaWVudCBidWcgaW4gY29tcGxldGlvbnMgaXQgc2hvdWxkbid0IHBlcnNpc3QuXG4gICAgICAgICAgICBpZiAoY21kbGluZV9zdGF0ZS5hY3RpdmVDb21wbGV0aW9ucylcbiAgICAgICAgICAgICAgICBjbWRsaW5lX3N0YXRlLmFjdGl2ZUNvbXBsZXRpb25zLmZvckVhY2goY29tcCA9PiBjbWRsaW5lX3N0YXRlLmNvbXBsZXRpb25zRGl2LnJlbW92ZUNoaWxkKGNvbXAubm9kZSkpXG4gICAgICAgICAgICBjbWRsaW5lX3N0YXRlLmFjdGl2ZUNvbXBsZXRpb25zID0gdW5kZWZpbmVkXG4gICAgICAgICAgICBjbWRsaW5lX3N0YXRlLmlzVmlzaWJsZSA9IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbGVjdHMgdGhlIG5leHQgaGlzdG9yeSBsaW5lLlxuICAgICAgICAgKi9cbiAgICAgICAgXCJuZXh0X2hpc3RvcnlcIjogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNtZGxpbmVfc3RhdGUuaGlzdG9yeSgxKVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWxlY3RzIHRoZSBwcmV2IGhpc3RvcnkgbGluZS5cbiAgICAgICAgICovXG4gICAgICAgIFwicHJldl9oaXN0b3J5XCI6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjbWRsaW5lX3N0YXRlLmhpc3RvcnkoLTEpXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeGVjdXRlIHRoZSBjb250ZW50IG9mIHRoZSBjb21tYW5kIGxpbmUgYW5kIGhpZGUgaXQuXG4gICAgICAgICAqKi9cbiAgICAgICAgXCJhY2NlcHRfbGluZVwiOiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb21tYW5kID0gY21kbGluZV9zdGF0ZS5nZXRDb21wbGV0aW9uKCkgfHwgY21kbGluZV9zdGF0ZS5jbElucHV0LnZhbHVlXG5cbiAgICAgICAgICAgIGNtZGxpbmVfc3RhdGUuZm5zLmhpZGVfYW5kX2NsZWFyKClcblxuICAgICAgICAgICAgY29uc3QgW2Z1bmMsIC4uLmFyZ3NdID0gY29tbWFuZC50cmltKCkuc3BsaXQoL1xccysvKVxuXG4gICAgICAgICAgICBpZiAoZnVuYy5sZW5ndGggPT09IDAgfHwgZnVuYy5zdGFydHNXaXRoKFwiI1wiKSkge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTYXZlIG5vbi1zZWNyZXQgY29tbWFuZGxpbmVzIHRvIHRoZSBoaXN0b3J5LlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFicm93c2VyLmV4dGVuc2lvbi5pbkluY29nbml0b0NvbnRleHQgJiZcbiAgICAgICAgICAgICAgICAhKGZ1bmMgPT09IFwid2lub3BlblwiICYmIGFyZ3NbMF0gPT09IFwiLXByaXZhdGVcIilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGNtZGxpbmVfc3RhdGUuc3RhdGUuY21kSGlzdG9yeSA9IGNtZGxpbmVfc3RhdGUuc3RhdGUuY21kSGlzdG9yeS5jb25jYXQoW2NvbW1hbmRdKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY21kbGluZV9zdGF0ZS5jbWRsaW5lX2hpc3RvcnlfcG9zaXRpb24gPSAwXG5cbiAgICAgICAgICAgIC8vIFNlbmQgZXhjbWRzIGRpcmVjdGx5IHRvIG91ciBvd24gdGFiLCB3aGljaCBmaXhlcyB0aGVcbiAgICAgICAgICAgIC8vIG9sZCBidWcgd2hlcmUgYSBjb21tYW5kIHdvdWxkIGJlIGlzc3VlZCBpbiBvbmUgdGFiIGJ1dFxuICAgICAgICAgICAgLy8gbGFuZCBpbiBhbm90aGVyIGJlY2F1c2UgdGhlIGFjdGl2ZSB0YWIgaGFkXG4gICAgICAgICAgICAvLyBjaGFuZ2VkLiBCYWNrZ3JvdW5kLW1vZGUgZXhjbWRzIHdpbGwgYmUgcmVjZWl2ZWQgYnkgdGhlXG4gICAgICAgICAgICAvLyBvd24gdGFiJ3MgY29udGVudCBzY3JpcHQgYW5kIHRoZW4gYm91bmNlZCB0aHJvdWdoIGFcbiAgICAgICAgICAgIC8vIHNoaW0gdG8gdGhlIGJhY2tncm91bmQsIGJ1dCB0aGUgbGF0ZW5jeSBpbmNyZWFzZSBzaG91bGRcbiAgICAgICAgICAgIC8vIGJlIGFjY2VwdGFibGUgYmVjdWFzZSB0aGUgYmFja2dyb3VuZC1tb2RlIGV4Y21kcyB0ZW5kXG4gICAgICAgICAgICAvLyB0byBiZSBhIHRvdWNoIGxlc3MgbGF0ZW5jeS1zZW5zaXRpdmUuXG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZU93blRhYihcImNvbnRyb2xsZXJfY29udGVudFwiLCBcImFjY2VwdEV4Q21kXCIsIFtjb21tYW5kXSlcbiAgICAgICAgfSxcbiAgICB9XG59XG4iLCIvLyBTa2V0Y2hcbi8vXG4vLyBOZWVkIGFuIGVhc3kgd2F5IG9mIGdldHRpbmcgYW5kIHNldHRpbmcgc2V0dGluZ3Ncbi8vIElmIGEgc2V0dGluZyBpcyBub3Qgc2V0LCB0aGUgZGVmYXVsdCBzaG91bGQgcHJvYmFibHkgYmUgcmV0dXJuZWQuXG4vLyBUaGF0IHByb2JhYmx5IG1lYW5zIHRoYXQgYmluZHMgZXRjLiBzaG91bGQgYmUgcGVyLWtleT9cbi8vXG4vLyBXZSBzaG91bGQgcHJvYmFibHkgc3RvcmUgYWxsIHNldHRpbmdzIGluIG1lbW9yeSwgYW5kIG9ubHkgbG9hZCBmcm9tIHN0b3JhZ2Ugb24gc3RhcnR1cCBhbmQgd2hlbiB3ZSBzZXQgaXRcbi8vXG4vLyBSZWFsbHksIHdlJ2QgbGlrZSBhIHdheSBvZiBqdXN0IGxldHRpbmcgdGhpbmdzIHVzZSB0aGUgdmFyaWFibGVzXG4vL1xuXG4vKiogIyBUcmlkYWN0eWwgQ29uZmlndXJhdGlvblxuICpcbiAqIFdlIHZlcnkgc3Ryb25nbHkgcmVjb21tZW5kIHRoYXQgeW91IHByZXR0eSBtdWNoIGlnbm9yZSB0aGlzIHBhZ2UgYW5kIGluc3RlYWQgZm9sbG93IHRoZSBsaW5rIGJlbG93IERFRkFVTFRTIHRoYXQgd2lsbCB0YWtlIHlvdSB0byBvdXIgb3duIHNvdXJjZSBjb2RlIHdoaWNoIGlzIGZvcm1hdHRlZCBpbiBhIG1hcmdpbmFsbHkgbW9yZSBzYW5lIGZhc2hpb24uXG4gKlxuICovXG5cbi8qKiBAaGlkZGVuICovXG5jb25zdCBDT05GSUdOQU1FID0gXCJ1c2VyY29uZmlnXCJcbi8qKiBAaGlkZGVuICovXG5jb25zdCBXQUlURVJTID0gW11cbi8qKiBAaGlkZGVuICovXG5sZXQgSU5JVElBTElTRUQgPSBmYWxzZVxuXG4vKiogQGhpZGRlbiAqL1xuLy8gbWFrZSBhIG5ha2VkIG9iamVjdFxuZXhwb3J0IGZ1bmN0aW9uIG8ob2JqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgb2JqZWN0KVxufVxuXG4vKiogQGhpZGRlbiAqL1xuLy8gXCJJbXBvcnRcIiBpcyBhIHJlc2VydmVkIHdvcmQgc28gdGhpcyB3aWxsIGhhdmUgdG8gZG9cbmZ1bmN0aW9uIHNjaGxlcHAoc2V0dGluZ3MpIHtcbiAgICBPYmplY3QuYXNzaWduKFVTRVJDT05GSUcsIHNldHRpbmdzKVxufVxuXG4vKiogQGhpZGRlbiAqL1xuZXhwb3J0IGxldCBVU0VSQ09ORklHID0gbyh7fSlcblxuLyoqIEBoaWRkZW5cbiAqIElkZWFsbHksIExvZ2dpbmdMZXZlbCBzaG91bGQgYmUgaW4gbG9nZ2luZy50cyBhbmQgaW1wb3J0ZWQgZnJvbSB0aGVyZS4gSG93ZXZlciB0aGlzIHdvdWxkIGNhdXNlIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSwgd2hpY2ggd2VicGFjayBjYW4ndCBkZWFsIHdpdGhcbiAqL1xuZXhwb3J0IHR5cGUgTG9nZ2luZ0xldmVsID0gXCJuZXZlclwiIHwgXCJlcnJvclwiIHwgXCJ3YXJuaW5nXCIgfCBcImluZm9cIiB8IFwiZGVidWdcIlxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiB0aGF0IFRyaWRhY3R5bCBjb21lcyB3aXRoLlxuICpcbiAqIFlvdSBjYW4gY2hhbmdlIGFueXRoaW5nIGhlcmUgdXNpbmcgYHNldCBrZXkxLmtleTIua2V5MyB2YWx1ZWAgb3Igc3BlY2lmaWMgdGhpbmdzIGFueSBvZiB0aGUgdmFyaW91cyBoZWxwZXIgY29tbWFuZHMgc3VjaCBhcyBgYmluZGAgb3IgYGNvbW1hbmRgLiBZb3UgY2FuIGFsc28ganVtcCB0byB0aGUgaGVscCBzZWN0aW9uIG9mIGEgc2V0dGluZyB1c2luZyBgOmhlbHAgJHNldHRpbmduYW1lYC4gU29tZSBvZiB0aGUgc2V0dGluZ3MgaGF2ZSBhbiBpbnB1dCBmaWVsZCBjb250YWluaW5nIHRoZWlyIGN1cnJlbnQgdmFsdWUuIFlvdSBjYW4gbW9kaWZ5IHRoZXNlIHZhbHVlcyBhbmQgc2F2ZSB0aGVtIGJ5IHByZXNzaW5nIGA8RW50ZXI+YCBidXQgdXNpbmcgYDpzZXQgJHNldHRpbmcgJHZhbHVlYCBpcyBhIGdvb2QgaGFiaXQgdG8gdGFrZSBhcyBpdCBkb2Vzbid0IGZvcmNlIHlvdSB0byBsZWF2ZSB0aGUgcGFnZSB5b3UncmUgdmlzaXRpbmcgdG8gY2hhbmdlIHlvdXIgc2V0dGluZ3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBkZWZhdWx0X2NvbmZpZyB7XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgdmVyc2lvbiBudW1iZXIgVHJpZGFjdHlsIHVzZXMgdG8ga25vdyB3aGV0aGVyIGl0IG5lZWRzIHRvIHVwZGF0ZSBmcm9tIG9sZCB2ZXJzaW9ucyBvZiB0aGUgY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIENoYW5naW5nIHRoaXMgbWlnaHQgZG8gd2VpcmQgc3R1ZmYuXG4gICAgICovXG4gICAgY29uZmlndmVyc2lvbiA9IFwiMC4wXCJcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGZpZWxkIHRvIGhhbmRsZSBzaXRlLXNwZWNpZmljIGNvbmZpZ3MuIFVzZSA6c2V0dXJsLzp1bnNldHVybCB0byBjaGFuZ2UgdGhlc2UgdmFsdWVzLlxuICAgICAqL1xuICAgIHN1YmNvbmZpZ3M6IHsgW2tleTogc3RyaW5nXTogZGVmYXVsdF9jb25maWcgfSA9IHtcbiAgICAgICAgXCJ3d3cuZ29vZ2xlLmNvbVwiOiB7XG4gICAgICAgICAgICBmb2xsb3dwYWdlcGF0dGVybnM6IHtcbiAgICAgICAgICAgICAgICBuZXh0OiBcIk5leHRcIixcbiAgICAgICAgICAgICAgICBwcmV2OiBcIlByZXZpb3VzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9IGFzIGRlZmF1bHRfY29uZmlnLFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGZpZWxkIHRvIGhhbmRsZSBzaXRlLXNwZWNpZmljIGNvbmZpZyBwcmlvcml0aWVzLiBVc2UgOnNldHVybC86dW5zZXR1cmwgdG8gY2hhbmdlIHRoaXMgdmFsdWUuXG4gICAgICovXG4gICAgcHJpb3JpdHkgPSAwXG5cbiAgICAvLyBOb3RlIHRvIGRldmVsb3BlcnM6IFdoZW4gY3JlYXRpbmcgbmV3IDxtb2RpZmllci1sZXR0ZXI+IG1hcHMsIG1ha2Ugc3VyZSB0byBtYWtlIHRoZSBtb2RpZmllciB1cHBlcmNhc2UgKGUuZy4gPEMtYT4gaW5zdGVhZCBvZiA8Yy1hPikgb3RoZXJ3aXNlIHNvbWUgY29tbWFuZHMgbWlnaHQgbm90IGJlIGFibGUgdG8gZmluZCB0aGVtIChlLmcuIGBiaW5kIDxjLWE+YClcblxuICAgIC8qKlxuICAgICAqIGV4bWFwcyBjb250YWlucyBhbGwgb2YgdGhlIGJpbmRpbmdzIGZvciB0aGUgY29tbWFuZCBsaW5lLlxuICAgICAqIFlvdSBjYW4gb2YgY291cnNlIGJpbmQgcmVndWxhciBleCBjb21tYW5kcyBidXQgYWxzbyBbZWRpdG9yIGZ1bmN0aW9uc10oL3N0YXRpYy9kb2NzL21vZHVsZXMvX3NyY19saWJfZWRpdG9yXy5odG1sKSBhbmQgW2NvbW1hbmRsaW5lLXNwZWNpZmljIGZ1bmN0aW9uc10oL3N0YXRpYy9kb2NzL21vZHVsZXMvX3NyY19jb21tYW5kbGluZV9mcmFtZV8uaHRtbCkuXG4gICAgICovXG4gICAgZXhtYXBzID0ge1xuICAgICAgICBcIjxFbnRlcj5cIjogXCJleC5hY2NlcHRfbGluZVwiLFxuICAgICAgICBcIjxDLWo+XCI6IFwiZXguYWNjZXB0X2xpbmVcIixcbiAgICAgICAgXCI8Qy1tPlwiOiBcImV4LmFjY2VwdF9saW5lXCIsXG4gICAgICAgIFwiPEVzY2FwZT5cIjogXCJleC5oaWRlX2FuZF9jbGVhclwiLFxuICAgICAgICBcIjxBcnJvd1VwPlwiOiBcImV4LnByZXZfaGlzdG9yeVwiLFxuICAgICAgICBcIjxBcnJvd0Rvd24+XCI6IFwiZXgubmV4dF9oaXN0b3J5XCIsXG4gICAgICAgIFwiPEMtYT5cIjogXCJ0ZXh0LmJlZ2lubmluZ19vZl9saW5lXCIsXG4gICAgICAgIFwiPEMtZT5cIjogXCJ0ZXh0LmVuZF9vZl9saW5lXCIsXG4gICAgICAgIFwiPEMtdT5cIjogXCJ0ZXh0LmJhY2t3YXJkX2tpbGxfbGluZVwiLFxuICAgICAgICBcIjxDLWs+XCI6IFwidGV4dC5raWxsX2xpbmVcIixcbiAgICAgICAgXCI8Qy1jPlwiOiBcInRleHQua2lsbF93aG9sZV9saW5lXCIsXG4gICAgICAgIFwiPEMtZj5cIjogXCJleC5jb21wbGV0ZVwiLFxuICAgICAgICBcIjxUYWI+XCI6IFwiZXgubmV4dF9jb21wbGV0aW9uXCIsXG4gICAgICAgIFwiPFMtVGFiPlwiOiBcImV4LnByZXZfY29tcGxldGlvblwiLFxuICAgICAgICBcIjxTcGFjZT5cIjogXCJleC5pbnNlcnRfc3BhY2Vfb3JfY29tcGxldGlvblwiLFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGlnbm9yZW1hcHMgY29udGFpbiBhbGwgb2YgdGhlIGJpbmRpbmdzIGZvciBcImlnbm9yZSBtb2RlXCIuXG4gICAgICpcbiAgICAgKiBUaGV5IGNvbnNpc3Qgb2Yga2V5IHNlcXVlbmNlcyBtYXBwZWQgdG8gZXggY29tbWFuZHMuXG4gICAgICovXG4gICAgaWdub3JlbWFwcyA9IHtcbiAgICAgICAgXCI8Uy1JbnNlcnQ+XCI6IFwibW9kZSBub3JtYWxcIixcbiAgICAgICAgXCI8Q0EtRXNjYXBlPlwiOiBcIm1vZGUgbm9ybWFsXCIsXG4gICAgICAgIFwiPENBLWA+XCI6IFwibW9kZSBub3JtYWxcIixcbiAgICAgICAgXCI8Uy1Fc2NhcGU+XCI6IFwibW9kZSBub3JtYWxcIixcbiAgICAgICAgXCI8Qy1ePlwiOiBcInRhYiAjXCIsXG4gICAgICAgIFwiPEMtNj5cIjogXCJ0YWIgI1wiLFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGltYXBzIGNvbnRhaW4gYWxsIG9mIHRoZSBiaW5kaW5ncyBmb3IgXCJpbnNlcnQgbW9kZVwiLlxuICAgICAqXG4gICAgICogT24gdG9wIG9mIHJlZ3VsYXIgZXggY29tbWFuZHMsIHlvdSBjYW4gYWxzbyBiaW5kIFtlZGl0b3IgZnVuY3Rpb25zXSgvc3RhdGljL2RvY3MvbW9kdWxlcy9fc3JjX2xpYl9lZGl0b3JfLmh0bWwpIGluIGluc2VydCBtb2RlLlxuICAgICAqXG4gICAgICogVGhleSBjb25zaXN0IG9mIGtleSBzZXF1ZW5jZXMgbWFwcGVkIHRvIGV4IGNvbW1hbmRzLlxuICAgICAqL1xuICAgIGltYXBzID0ge1xuICAgICAgICBcIjxFc2NhcGU+XCI6IFwiY29tcG9zaXRlIHVuZm9jdXMgfCBtb2RlIG5vcm1hbFwiLFxuICAgICAgICBcIjxDLVs+XCI6IFwiY29tcG9zaXRlIHVuZm9jdXMgfCBtb2RlIG5vcm1hbFwiLFxuICAgICAgICBcIjxDLWk+XCI6IFwiZWRpdG9yXCIsXG4gICAgICAgIFwiPENBLUVzY2FwZT5cIjogXCJtb2RlIG5vcm1hbFwiLFxuICAgICAgICBcIjxDQS1gPlwiOiBcIm1vZGUgbm9ybWFsXCIsXG4gICAgICAgIFwiPEMtNj5cIjogXCJ0YWIgI1wiLFxuICAgICAgICBcIjxDLV4+XCI6IFwidGFiICNcIixcbiAgICAgICAgXCI8Uy1Fc2NhcGU+XCI6IFwibW9kZSBpZ25vcmVcIixcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpbnB1dG1hcHMgY29udGFpbiBhbGwgb2YgdGhlIGJpbmRpbmdzIGZvciBcImlucHV0IG1vZGVcIi5cbiAgICAgKlxuICAgICAqIE9uIHRvcCBvZiByZWd1bGFyIGV4IGNvbW1hbmRzLCB5b3UgY2FuIGFsc28gYmluZCBbZWRpdG9yIGZ1bmN0aW9uc10oL3N0YXRpYy9kb2NzL21vZHVsZXMvX3NyY19saWJfZWRpdG9yXy5odG1sKSBpbiBpbnB1dCBtb2RlLlxuICAgICAqXG4gICAgICogVGhleSBjb25zaXN0IG9mIGtleSBzZXF1ZW5jZXMgbWFwcGVkIHRvIGV4IGNvbW1hbmRzLlxuICAgICAqL1xuICAgIGlucHV0bWFwcyA9IG1lcmdlRGVlcCh0aGlzLmltYXBzLCB7XG4gICAgICAgIFwiPFRhYj5cIjogXCJmb2N1c2lucHV0IC1uXCIsXG4gICAgICAgIFwiPFMtVGFiPlwiOiBcImZvY3VzaW5wdXQgLU5cIixcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogbm1hcHMgY29udGFpbiBhbGwgb2YgdGhlIGJpbmRpbmdzIGZvciBcIm5vcm1hbCBtb2RlXCIuXG4gICAgICpcbiAgICAgKiBUaGV5IGNvbnNpc3Qgb2Yga2V5IHNlcXVlbmNlcyBtYXBwZWQgdG8gZXggY29tbWFuZHMuXG4gICAgICovXG4gICAgbm1hcHMgPSB7XG4gICAgICAgIFwiPEEtcD5cIjogXCJwaW5cIixcbiAgICAgICAgXCI8QS1tPlwiOiBcIm11dGUgdG9nZ2xlXCIsXG4gICAgICAgIFwiPEYxPlwiOiBcImhlbHBcIixcbiAgICAgICAgbzogXCJmaWxsY21kbGluZSBvcGVuXCIsXG4gICAgICAgIE86IFwiY3VycmVudF91cmwgb3BlblwiLFxuICAgICAgICB3OiBcImZpbGxjbWRsaW5lIHdpbm9wZW5cIixcbiAgICAgICAgVzogXCJjdXJyZW50X3VybCB3aW5vcGVuXCIsXG4gICAgICAgIHQ6IFwiZmlsbGNtZGxpbmUgdGFib3BlblwiLFxuICAgICAgICBcIl1dXCI6IFwiZm9sbG93cGFnZSBuZXh0XCIsXG4gICAgICAgIFwiW1tcIjogXCJmb2xsb3dwYWdlIHByZXZcIixcbiAgICAgICAgXCJbY1wiOiBcInVybGluY3JlbWVudCAtMVwiLFxuICAgICAgICBcIl1jXCI6IFwidXJsaW5jcmVtZW50IDFcIixcbiAgICAgICAgXCI8Qy14PlwiOiBcInVybGluY3JlbWVudCAtMVwiLFxuICAgICAgICBcIjxDLWE+XCI6IFwidXJsaW5jcmVtZW50IDFcIixcbiAgICAgICAgVDogXCJjdXJyZW50X3VybCB0YWJvcGVuXCIsXG4gICAgICAgIHl5OiBcImNsaXBib2FyZCB5YW5rXCIsXG4gICAgICAgIHlzOiBcImNsaXBib2FyZCB5YW5rc2hvcnRcIixcbiAgICAgICAgeWM6IFwiY2xpcGJvYXJkIHlhbmtjYW5vblwiLFxuICAgICAgICB5bTogXCJjbGlwYm9hcmQgeWFua21kXCIsXG4gICAgICAgIHl0OiBcImNsaXBib2FyZCB5YW5rdGl0bGVcIixcbiAgICAgICAgZ2g6IFwiaG9tZVwiLFxuICAgICAgICBnSDogXCJob21lIHRydWVcIixcbiAgICAgICAgcDogXCJjbGlwYm9hcmQgb3BlblwiLFxuICAgICAgICBQOiBcImNsaXBib2FyZCB0YWJvcGVuXCIsXG4gICAgICAgIGo6IFwic2Nyb2xsbGluZSAxMFwiLFxuICAgICAgICBcIjxDLWU+XCI6IFwic2Nyb2xsbGluZSAxMFwiLFxuICAgICAgICBrOiBcInNjcm9sbGxpbmUgLTEwXCIsXG4gICAgICAgIFwiPEMteT5cIjogXCJzY3JvbGxsaW5lIC0xMFwiLFxuICAgICAgICBoOiBcInNjcm9sbHB4IC01MFwiLFxuICAgICAgICBsOiBcInNjcm9sbHB4IDUwXCIsXG4gICAgICAgIEc6IFwic2Nyb2xsdG8gMTAwXCIsXG4gICAgICAgIGdnOiBcInNjcm9sbHRvIDBcIixcbiAgICAgICAgXCI8Qy11PlwiOiBcInNjcm9sbHBhZ2UgLTAuNVwiLFxuICAgICAgICBcIjxDLWQ+XCI6IFwic2Nyb2xscGFnZSAwLjVcIixcbiAgICAgICAgXCI8Qy1mPlwiOiBcInNjcm9sbHBhZ2UgMVwiLFxuICAgICAgICBcIjxDLWI+XCI6IFwic2Nyb2xscGFnZSAtMVwiLFxuICAgICAgICAkOiBcInNjcm9sbHRvIDEwMCB4XCIsXG4gICAgICAgIC8vIFwiMFwiOiBcInNjcm9sbHRvIDAgeFwiLCAvLyB3aWxsIGdldCBpbnRlcnByZXRlZCBhcyBhIGNvdW50XG4gICAgICAgIFwiXlwiOiBcInNjcm9sbHRvIDAgeFwiLFxuICAgICAgICBcIjxDLTY+XCI6IFwidGFiICNcIixcbiAgICAgICAgXCI8Qy1ePlwiOiBcInRhYiAjXCIsXG4gICAgICAgIEg6IFwiYmFja1wiLFxuICAgICAgICBMOiBcImZvcndhcmRcIixcbiAgICAgICAgXCI8Qy1vPlwiOiBcImp1bXBwcmV2XCIsXG4gICAgICAgIFwiPEMtaT5cIjogXCJqdW1wbmV4dFwiLFxuICAgICAgICBkOiBcInRhYmNsb3NlXCIsXG4gICAgICAgIEQ6IFwiY29tcG9zaXRlIHRhYnByZXY7IHRhYmNsb3NlICNcIixcbiAgICAgICAgZ3gwOiBcInRhYmNsb3NlYWxsdG9sZWZ0XCIsXG4gICAgICAgIGd4JDogXCJ0YWJjbG9zZWFsbHRvcmlnaHRcIixcbiAgICAgICAgXCI8PFwiOiBcInRhYm1vdmUgLTFcIixcbiAgICAgICAgXCI+PlwiOiBcInRhYm1vdmUgKzFcIixcbiAgICAgICAgdTogXCJ1bmRvXCIsXG4gICAgICAgIFU6IFwidW5kbyB3aW5kb3dcIixcbiAgICAgICAgcjogXCJyZWxvYWRcIixcbiAgICAgICAgUjogXCJyZWxvYWRoYXJkXCIsXG4gICAgICAgIHg6IFwic3RvcFwiLFxuICAgICAgICBnaTogXCJmb2N1c2lucHV0IC1sXCIsXG4gICAgICAgIFwiZz9cIjogXCJyb3QxM1wiLFxuICAgICAgICBcImc7XCI6IFwiY2hhbmdlbGlzdGp1bXAgLTFcIixcbiAgICAgICAgSjogXCJ0YWJwcmV2XCIsXG4gICAgICAgIEs6IFwidGFibmV4dFwiLFxuICAgICAgICBndDogXCJ0YWJuZXh0X2d0XCIsXG4gICAgICAgIGdUOiBcInRhYnByZXZcIixcbiAgICAgICAgLy8gXCI8Yy1uPlwiOiBcInRhYm5leHRfZ3RcIiwgLy8gYy1uIGlzIHJlc2VydmVkIGZvciBuZXcgd2luZG93XG4gICAgICAgIC8vIFwiPGMtcD5cIjogXCJ0YWJwcmV2XCIsXG4gICAgICAgIFwiZ15cIjogXCJ0YWJmaXJzdFwiLFxuICAgICAgICBnMDogXCJ0YWJmaXJzdFwiLFxuICAgICAgICBnJDogXCJ0YWJsYXN0XCIsXG4gICAgICAgIGdyOiBcInJlYWRlclwiLFxuICAgICAgICBndTogXCJ1cmxwYXJlbnRcIixcbiAgICAgICAgZ1U6IFwidXJscm9vdFwiLFxuICAgICAgICBnZjogXCJ2aWV3c291cmNlXCIsXG4gICAgICAgIFwiOlwiOiBcImZpbGxjbWRsaW5lX25vdHJhaWxcIixcbiAgICAgICAgczogXCJmaWxsY21kbGluZSBvcGVuIHNlYXJjaFwiLFxuICAgICAgICBTOiBcImZpbGxjbWRsaW5lIHRhYm9wZW4gc2VhcmNoXCIsXG4gICAgICAgIC8vIGZpbmQgbW9kZSBub3Qgc3VpdGFibGUgZm9yIGdlbmVyYWwgY29uc3VtcHRpb24geWV0LlxuICAgICAgICAvLyBcIi9cIjogXCJmaWxsY21kbGluZSBmaW5kXCIsXG4gICAgICAgIC8vIFwiP1wiOiBcImZpbGxjbWRsaW5lIGZpbmQgLT9cIixcbiAgICAgICAgLy8gbjogXCJmaW5kbmV4dCAxXCIsXG4gICAgICAgIC8vIE46IFwiZmluZG5leHQgLTFcIixcbiAgICAgICAgLy8gXCIsPFNwYWNlPlwiOiBcIm5vaGxzZWFyY2hcIixcbiAgICAgICAgTTogXCJnb2JibGUgMSBxdWlja21hcmtcIixcbiAgICAgICAgQjogXCJmaWxsY21kbGluZSB0YWJhbGxcIixcbiAgICAgICAgYjogXCJmaWxsY21kbGluZSB0YWJcIixcbiAgICAgICAgWlo6IFwicWFsbFwiLFxuICAgICAgICBmOiBcImhpbnRcIixcbiAgICAgICAgRjogXCJoaW50IC1iXCIsXG4gICAgICAgIGdGOiBcImhpbnQgLWJyXCIsXG4gICAgICAgIFwiO2lcIjogXCJoaW50IC1pXCIsXG4gICAgICAgIFwiO2JcIjogXCJoaW50IC1iXCIsXG4gICAgICAgIFwiO29cIjogXCJoaW50XCIsXG4gICAgICAgIFwiO0lcIjogXCJoaW50IC1JXCIsXG4gICAgICAgIFwiO2tcIjogXCJoaW50IC1rXCIsXG4gICAgICAgIFwiO3lcIjogXCJoaW50IC15XCIsXG4gICAgICAgIFwiO3BcIjogXCJoaW50IC1wXCIsXG4gICAgICAgIFwiO1BcIjogXCJoaW50IC1QXCIsXG4gICAgICAgIFwiO3JcIjogXCJoaW50IC1yXCIsXG4gICAgICAgIFwiO3NcIjogXCJoaW50IC1zXCIsXG4gICAgICAgIFwiO1NcIjogXCJoaW50IC1TXCIsXG4gICAgICAgIFwiO2FcIjogXCJoaW50IC1hXCIsXG4gICAgICAgIFwiO0FcIjogXCJoaW50IC1BXCIsXG4gICAgICAgIFwiOztcIjogXCJoaW50IC07XCIsXG4gICAgICAgIFwiOyNcIjogXCJoaW50IC0jXCIsXG4gICAgICAgIFwiO3ZcIjogXCJoaW50IC1XIG1wdnNhZmVcIixcbiAgICAgICAgXCI7d1wiOiBcImhpbnQgLXdcIixcbiAgICAgICAgXCI7dFwiOiBcImhpbnQgLVcgdGFib3BlblwiLFxuICAgICAgICBcIjtPXCI6IFwiaGludCAtVyBmaWxsY21kbGluZV9ub3RyYWlsIG9wZW4gXCIsXG4gICAgICAgIFwiO1dcIjogXCJoaW50IC1XIGZpbGxjbWRsaW5lX25vdHJhaWwgd2lub3BlbiBcIixcbiAgICAgICAgXCI7VFwiOiBcImhpbnQgLVcgZmlsbGNtZGxpbmVfbm90cmFpbCB0YWJvcGVuIFwiLFxuICAgICAgICBcIjt6XCI6IFwiaGludCAtelwiLFxuICAgICAgICBcIjttXCI6XG4gICAgICAgICAgICBcImNvbXBvc2l0ZSBoaW50IC1waXBlIGltZyBzcmMgfCBqcyAtcCB0cmkuZXhjbWRzLm9wZW4oJ2ltYWdlcy5nb29nbGUuY29tL3NlYXJjaGJ5aW1hZ2U/aW1hZ2VfdXJsPScgKyBKU19BUkcpXCIsXG4gICAgICAgIFwiO01cIjpcbiAgICAgICAgICAgIFwiY29tcG9zaXRlIGhpbnQgLXBpcGUgaW1nIHNyYyB8IGpzYiAtcCB0cmkuZXhjbWRzLnRhYm9wZW4oJ2ltYWdlcy5nb29nbGUuY29tL3NlYXJjaGJ5aW1hZ2U/aW1hZ2VfdXJsPScgKyBKU19BUkcpXCIsXG4gICAgICAgIFwiO2dpXCI6IFwiaGludCAtcWlcIixcbiAgICAgICAgXCI7Z0lcIjogXCJoaW50IC1xSVwiLFxuICAgICAgICBcIjtna1wiOiBcImhpbnQgLXFrXCIsXG4gICAgICAgIFwiO2d5XCI6IFwiaGludCAtcXlcIixcbiAgICAgICAgXCI7Z3BcIjogXCJoaW50IC1xcFwiLFxuICAgICAgICBcIjtnUFwiOiBcImhpbnQgLXFQXCIsXG4gICAgICAgIFwiO2dyXCI6IFwiaGludCAtcXJcIixcbiAgICAgICAgXCI7Z3NcIjogXCJoaW50IC1xc1wiLFxuICAgICAgICBcIjtnU1wiOiBcImhpbnQgLXFTXCIsXG4gICAgICAgIFwiO2dhXCI6IFwiaGludCAtcWFcIixcbiAgICAgICAgXCI7Z0FcIjogXCJoaW50IC1xQVwiLFxuICAgICAgICBcIjtnO1wiOiBcImhpbnQgLXE7XCIsXG4gICAgICAgIFwiO2cjXCI6IFwiaGludCAtcSNcIixcbiAgICAgICAgXCI7Z3ZcIjogXCJoaW50IC1xVyBtcHZzYWZlXCIsXG4gICAgICAgIFwiO2d3XCI6IFwiaGludCAtcXdcIixcbiAgICAgICAgXCI7Z2JcIjogXCJoaW50IC1xYlwiLFxuICAgICAgICBcIjxTLUluc2VydD5cIjogXCJtb2RlIGlnbm9yZVwiLFxuICAgICAgICBcIjxDQS1Fc2NhcGU+XCI6IFwibW9kZSBpZ25vcmVcIixcbiAgICAgICAgXCI8Q0EtYD5cIjogXCJtb2RlIGlnbm9yZVwiLFxuICAgICAgICBcIjxTLUVzY2FwZT5cIjogXCJtb2RlIGlnbm9yZVwiLFxuICAgICAgICBcIjxFc2NhcGU+XCI6IFwiY29tcG9zaXRlIG1vZGUgbm9ybWFsIDsgaGlkZWNtZGxpbmVcIixcbiAgICAgICAgXCI8Qy1bPlwiOiBcImNvbXBvc2l0ZSBtb2RlIG5vcm1hbCA7IGhpZGVjbWRsaW5lXCIsXG4gICAgICAgIGE6IFwiY3VycmVudF91cmwgYm1hcmtcIixcbiAgICAgICAgQTogXCJibWFya1wiLFxuICAgICAgICB6aTogXCJ6b29tIDAuMSB0cnVlXCIsXG4gICAgICAgIHpvOiBcInpvb20gLTAuMSB0cnVlXCIsXG4gICAgICAgIHptOiBcInpvb20gMC41IHRydWVcIixcbiAgICAgICAgenI6IFwiem9vbSAtMC41IHRydWVcIixcbiAgICAgICAgek06IFwiem9vbSAwLjUgdHJ1ZVwiLFxuICAgICAgICB6UjogXCJ6b29tIC0wLjUgdHJ1ZVwiLFxuICAgICAgICB6ejogXCJ6b29tIDFcIixcbiAgICAgICAgekk6IFwiem9vbSAzXCIsXG4gICAgICAgIHpPOiBcInpvb20gMC4zXCIsXG4gICAgICAgIFwiLlwiOiBcInJlcGVhdFwiLFxuICAgICAgICBcIjxTQS1BcnJvd1VwPjxTQS1BcnJvd1VwPjxTQS1BcnJvd0Rvd24+PFNBLUFycm93RG93bj48U0EtQXJyb3dMZWZ0PjxTQS1BcnJvd1JpZ2h0PjxTQS1BcnJvd0xlZnQ+PFNBLUFycm93UmlnaHQ+YmFcIjpcbiAgICAgICAgICAgIFwib3BlbiBodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PU0zaU9ST3VUdU1BXCIsXG4gICAgfVxuXG4gICAgaGludG1hcHMgPSB7XG4gICAgICAgIFwiPEJhY2tzcGFjZT5cIjogXCJoaW50LnBvcEtleVwiLFxuICAgICAgICBcIjxFc2NhcGU+XCI6IFwiaGludC5yZXNldFwiLFxuICAgICAgICBcIjxUYWI+XCI6IFwiaGludC5mb2N1c1ByZXZpb3VzSGludFwiLFxuICAgICAgICBcIjxTLVRhYj5cIjogXCJoaW50LmZvY3VzTmV4dEhpbnRcIixcbiAgICAgICAgXCI8QXJyb3dVcD5cIjogXCJoaW50LmZvY3VzVG9wSGludFwiLFxuICAgICAgICBcIjxBcnJvd0Rvd24+XCI6IFwiaGludC5mb2N1c0JvdHRvbUhpbnRcIixcbiAgICAgICAgXCI8QXJyb3dMZWZ0PlwiOiBcImhpbnQuZm9jdXNMZWZ0SGludFwiLFxuICAgICAgICBcIjxBcnJvd1JpZ2h0PlwiOiBcImhpbnQuZm9jdXNSaWdodEhpbnRcIixcbiAgICAgICAgXCI8RW50ZXI+XCI6IFwiaGludC5zZWxlY3RGb2N1c2VkSGludFwiLFxuICAgICAgICBcIjxTcGFjZT5cIjogXCJoaW50LnNlbGVjdEZvY3VzZWRIaW50XCIsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBhbGxvdyBwYWdlcyAobm90IG5lY2Vzc2FyaWx5IGdpdGh1YikgdG8gb3ZlcnJpZGUgYC9gLCB3aGljaCBpcyBhIGRlZmF1bHQgRmlyZWZveCBiaW5kaW5nLlxuICAgICAqL1xuICAgIGxlYXZlZ2l0aHViYWxvbmU6IFwidHJ1ZVwiIHwgXCJmYWxzZVwiID0gXCJmYWxzZVwiXG5cbiAgICAvKipcbiAgICAgKiBXaGljaCBrZXlzIHRvIHByb3RlY3QgZnJvbSBwYWdlcyB0aGF0IHRyeSB0byBvdmVycmlkZSB0aGVtLiBSZXF1aXJlcyBbW2xlYXZlZ2l0aHViYWxvbmVdXSB0byBiZSBzZXQgdG8gZmFsc2UuXG4gICAgICovXG4gICAgYmxhY2tsaXN0a2V5czogc3RyaW5nW10gPSBbXCIvXCJdXG5cbiAgICAvKipcbiAgICAgKiBBdXRvY29tbWFuZHMgdGhhdCBydW4gd2hlbiBjZXJ0YWluIGV2ZW50cyBoYXBwZW4sIGFuZCBvdGhlciBjb25kaXRpb25zIGFyZSBtZXQuXG4gICAgICpcbiAgICAgKiBSZWxhdGVkIGV4IGNvbW1hbmQ6IGBhdXRvY21kYC5cbiAgICAgKi9cbiAgICBhdXRvY21kcyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbW1hbmRzIHRoYXQgd2lsbCBiZSBydW4gYXMgc29vbiBhcyBUcmlkYWN0eWwgbG9hZHMgaW50byBhIHBhZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEVhY2gga2V5IGNvcnJlc3BvbmRzIHRvIGEgVVJMIGZyYWdtZW50IHdoaWNoLCBpZiBjb250YWluZWQgd2l0aGluIHRoZSBwYWdlIFVSTCwgd2lsbCBydW4gdGhlIGNvcnJlc3BvbmRpbmcgY29tbWFuZC5cbiAgICAgICAgICovXG4gICAgICAgIERvY1N0YXJ0OiB7XG4gICAgICAgICAgICAvLyBcImFkZG9ucy5tb3ppbGxhLm9yZ1wiOiBcIm1vZGUgaWdub3JlXCIsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbW1hbmRzIHRoYXQgd2lsbCBiZSBydW4gd2hlbiBwYWdlcyBhcmUgbG9hZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBFYWNoIGtleSBjb3JyZXNwb25kcyB0byBhIFVSTCBmcmFnbWVudCB3aGljaCwgaWYgY29udGFpbmVkIHdpdGhpbiB0aGUgcGFnZSBVUkwsIHdpbGwgcnVuIHRoZSBjb3JyZXNwb25kaW5nIGNvbW1hbmQuXG4gICAgICAgICAqL1xuICAgICAgICBEb2NMb2FkOiB7XG4gICAgICAgICAgICBcIl5odHRwczovL2dpdGh1Yi5jb20vdHJpZGFjdHlsL3RyaWRhY3R5bC9pc3N1ZXMvbmV3JFwiOiBcImlzc3VlXCIsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbW1hbmRzIHRoYXQgd2lsbCBiZSBydW4gd2hlbiBwYWdlcyBhcmUgdW5sb2FkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEVhY2gga2V5IGNvcnJlc3BvbmRzIHRvIGEgVVJMIGZyYWdtZW50IHdoaWNoLCBpZiBjb250YWluZWQgd2l0aGluIHRoZSBwYWdlIFVSTCwgd2lsbCBydW4gdGhlIGNvcnJlc3BvbmRpbmcgY29tbWFuZC5cbiAgICAgICAgICovXG4gICAgICAgIERvY0VuZDoge1xuICAgICAgICAgICAgLy8gXCJlbWFjcy5vcmdcIjogXCJzYW5pdGlzZSBoaXN0b3J5XCIsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbW1hbmRzIHRoYXQgd2lsbCBiZSBydW4gd2hlbiBUcmlkYWN0eWwgZmlyc3QgcnVucyBlYWNoIHRpbWUgeW91IHN0YXJ0IHlvdXIgYnJvd3Nlci5cbiAgICAgICAgICpcbiAgICAgICAgICogRWFjaCBrZXkgY29ycmVzcG9uZHMgdG8gYSBVUkwgZnJhZ21lbnQgd2hpY2gsIGlmIGNvbnRhaW5lZCB3aXRoaW4gdGhlIHBhZ2UgVVJMLCB3aWxsIHJ1biB0aGUgY29ycmVzcG9uZGluZyBjb21tYW5kLlxuICAgICAgICAgKi9cbiAgICAgICAgVHJpU3RhcnQ6IHtcbiAgICAgICAgICAgIFwiLipcIjogXCJzb3VyY2VfcXVpZXRcIixcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tbWFuZHMgdGhhdCB3aWxsIGJlIHJ1biB3aGVuIHlvdSBlbnRlciBhIHRhYi5cbiAgICAgICAgICpcbiAgICAgICAgICogRWFjaCBrZXkgY29ycmVzcG9uZHMgdG8gYSBVUkwgZnJhZ21lbnQgd2hpY2gsIGlmIGNvbnRhaW5lZCB3aXRoaW4gdGhlIHBhZ2UgVVJMLCB3aWxsIHJ1biB0aGUgY29ycmVzcG9uZGluZyBjb21tYW5kLlxuICAgICAgICAgKi9cbiAgICAgICAgVGFiRW50ZXI6IHtcbiAgICAgICAgICAgIC8vIFwiZ21haWwuY29tXCI6IFwibW9kZSBpZ25vcmVcIixcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tbWFuZHMgdGhhdCB3aWxsIGJlIHJ1biB3aGVuIHlvdSBsZWF2ZSBhIHRhYi5cbiAgICAgICAgICpcbiAgICAgICAgICogRWFjaCBrZXkgY29ycmVzcG9uZHMgdG8gYSBVUkwgZnJhZ21lbnQgd2hpY2gsIGlmIGNvbnRhaW5lZCB3aXRoaW4gdGhlIHBhZ2UgVVJMLCB3aWxsIHJ1biB0aGUgY29ycmVzcG9uZGluZyBjb21tYW5kLlxuICAgICAgICAgKi9cbiAgICAgICAgVGFiTGVmdDoge1xuICAgICAgICAgICAgLy8gQWN0dWFsbHksIHRoaXMgZG9lc24ndCB3b3JrIGJlY2F1c2UgdGFiY2xvc2UgY2xvc2VzIHRoZSBjdXJyZW50IHRhYlxuICAgICAgICAgICAgLy8gVG9vIGJhZCA6L1xuICAgICAgICAgICAgLy8gXCJlbWFjcy5vcmdcIjogXCJ0YWJjbG9zZVwiLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21tYW5kcyB0aGF0IHdpbGwgYmUgcnVuIHdoZW4gZnVsbHNjcmVlbiBzdGF0ZSBjaGFuZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgRnVsbHNjcmVlbkNoYW5nZToge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbW1hbmRzIHRoYXQgd2lsbCBiZSBydW4gd2hlbiBmdWxsc2NyZWVuIHN0YXRlIGlzIGVudGVyZWQuXG4gICAgICAgICAqL1xuICAgICAgICBGdWxsc2NyZWVuRW50ZXI6IHt9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21tYW5kcyB0aGF0IHdpbGwgYmUgcnVuIHdoZW4gZnVsbHNjcmVlbiBzdGF0ZSBpcyBsZWZ0LlxuICAgICAgICAgKi9cbiAgICAgICAgRnVsbHNjcmVlbkxlZnQ6IHt9LFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcCBmb3IgdHJhbnNsYXRpbmcga2V5cyBkaXJlY3RseSBpbnRvIG90aGVyIGtleXMgaW4gbm9ybWFsLWlzaCBtb2Rlcy4gRm9yIGV4YW1wbGUsIGlmIHlvdSBoYXZlIGFuIGVudHJ5IGluIHRoaXMgY29uZmlnIG9wdGlvbiBtYXBwaW5nIGDQv2AgdG8gYGdgLCB0aGVuIHlvdSBjb3VsZCB0eXBlIGDQv9C/YCBpbnN0ZWFkIG9mIGBnZ2Agb3IgYNC/aWAgaW5zdGVhZCBvZiBgZ2lgIG9yIGA70L9gIGluc3RlYWQgb2YgYDtnYC4gVGhpcyBpcyBwcmltYXJpbHkgdXNlZnVsIGZvciBpbnRlcm5hdGlvbmFsIHVzZXJzIHdobyBkb24ndCB3YW50IHRvIGRlYWwgd2l0aCByZWJ1aWxkaW5nIHRoZWlyIGJpbmRpbmdzIGV2ZXJ5IHRpbWUgdHJpZGFjdHlsIHNoaXBzIGEgbmV3IGRlZmF1bHQga2V5YmluZC4gSXQncyBub3QgYXMgZ29vZCBhcyBzaGlwcGluZyBwcm9wZXJseSBpbnRlcm5hdGlvbmFsaXplZCBzZXRzIG9mIGRlZmF1bHQgYmluZGluZ3MsIGJ1dCBpdCdzIHByb2JhYmx5IGFzIGNsb3NlIGFzIHdlJ3JlIGdvaW5nIHRvIGdldCBvbiBhIHNtYWxsIG9wZW4tc291cmNlIHByb2plY3QgbGlrZSB0aGlzLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIGRvZXMgbm90IGFsbG93IHlvdSB0byBcImNoYWluXCIga2V5cywgZm9yIGV4YW1wbGUsIFwiYVwiPT5cImJcIiBhbmQgXCJiXCI9PlwiY1wiIGZvciBcImFcIj0+XCJjXCIuIFlvdSBjYW4sIGhvd2V2ZXIsIHN3YXAgb3Igcm90YXRlIGtleXMsIHNvIFwiYVwiPT5cImJcIiBhbmQgXCJiXCI9PlwiYVwiIHdpbGwgd29yayB0aGUgd2F5IHlvdSdkIGV4cGVjdCwgYXMgd2lsbCBcImFcIj0+XCJiXCIgYW5kIFwiYlwiPT5cImNcIiBhbmQgXCJjXCI9PlwiYVwiLlxuICAgICAqL1xuICAgIGtleXRyYW5zbGF0ZW1hcCA9IHtcbiAgICAgICAgLy8gRXhhbXBsZXMgKEkgdGhpbmsgPl8+KTpcbiAgICAgICAgLy8gXCLQtFwiOiBcImxcIiwgLy8gUnVzc2lhbiBsYW5ndWFnZVxuICAgICAgICAvLyBcIsOpXCIgOiBcIndcIiwgLy8gQsOJUE9cbiAgICAgICAgLy8gXCJoXCI6IFwialwiLCAvLyBEdm9yYWtcbiAgICAgICAgLy8gXCJuXCI6IFwialwiLCAvLyBDb2xlbWFrXG4gICAgICAgIC8vIGV0Y1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gdXNlIHRoZSBrZXl0cmFuc2xhdGVtYXAgaW4gdmFyaW91cyBtYXBzLlxuICAgICAqL1xuICAgIGtleXRyYW5zbGF0ZW1vZGVzOiB7IFtrZXk6IHN0cmluZ106IFwidHJ1ZVwiIHwgXCJmYWxzZVwiIH0gPSB7XG4gICAgICAgIG5tYXBzOiBcInRydWVcIixcbiAgICAgICAgaW1hcHM6IFwiZmFsc2VcIixcbiAgICAgICAgaW5wdXRtYXBzOiBcImZhbHNlXCIsXG4gICAgICAgIGlnbm9yZW1hcHM6IFwiZmFsc2VcIixcbiAgICAgICAgZXhtYXBzOiBcImZhbHNlXCIsXG4gICAgICAgIGhpbnRtYXBzOiBcImZhbHNlXCIsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXV0b21hdGljYWxseSBwbGFjZSB0aGVzZSBzaXRlcyBpbiB0aGUgbmFtZWQgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogRWFjaCBrZXkgY29ycmVzcG9uZHMgdG8gYSBVUkwgZnJhZ21lbnQgd2hpY2gsIGlmIGNvbnRhaW5lZCB3aXRoaW4gdGhlIHBhZ2UgVVJMLCB0aGUgc2l0ZSB3aWxsIGJlIG9wZW5lZCBpbiBhIGNvbnRhaW5lciB0YWIgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBhdXRvY29udGFpbiA9IG8oe1xuICAgICAgICAvLyBcImdpdGh1Yi5jb21cIjogXCJtaWNyb3NvZnRcIixcbiAgICAgICAgLy8gXCJ5b3V0dWJlLmNvbVwiOiBcImdvb2dsZVwiLFxuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBBbGlhc2VzIGZvciB0aGUgY29tbWFuZGxpbmUuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIG1ha2UgYSBuZXcgb25lIHdpdGggYGNvbW1hbmQgYWxpYXMgZXgtY29tbWFuZGAuXG4gICAgICovXG4gICAgZXhhbGlhc2VzID0ge1xuICAgICAgICBhbGlhczogXCJjb21tYW5kXCIsXG4gICAgICAgIGF1OiBcImF1dG9jbWRcIixcbiAgICAgICAgYXVjb246IFwiYXV0b2NvbnRhaW5cIixcbiAgICAgICAgYXVkZWw6IFwiYXV0b2NtZGRlbGV0ZVwiLFxuICAgICAgICBhdWRlbGV0ZTogXCJhdXRvY21kZGVsZXRlXCIsXG4gICAgICAgIGI6IFwidGFiXCIsXG4gICAgICAgIGNsc2g6IFwiY2xlYXJzZWFyY2hoaWdobGlnaHRcIixcbiAgICAgICAgbm9obHNlYXJjaDogXCJjbGVhcnNlYXJjaGhpZ2hsaWdodFwiLFxuICAgICAgICBub2g6IFwiY2xlYXJzZWFyY2hoaWdobGlnaHRcIixcbiAgICAgICAgbzogXCJvcGVuXCIsXG4gICAgICAgIHc6IFwid2lub3BlblwiLFxuICAgICAgICB0OiBcInRhYm9wZW5cIixcbiAgICAgICAgdGFibmV3OiBcInRhYm9wZW5cIixcbiAgICAgICAgdGFibTogXCJ0YWJtb3ZlXCIsXG4gICAgICAgIHRhYm86IFwidGFib25seVwiLFxuICAgICAgICB0bjogXCJ0YWJuZXh0X2d0XCIsXG4gICAgICAgIGJuOiBcInRhYm5leHRfZ3RcIixcbiAgICAgICAgdG5leHQ6IFwidGFibmV4dF9ndFwiLFxuICAgICAgICBibmV4dDogXCJ0YWJuZXh0X2d0XCIsXG4gICAgICAgIHRwOiBcInRhYnByZXZcIixcbiAgICAgICAgdE46IFwidGFicHJldlwiLFxuICAgICAgICBicDogXCJ0YWJwcmV2XCIsXG4gICAgICAgIGJOOiBcInRhYnByZXZcIixcbiAgICAgICAgdHByZXY6IFwidGFicHJldlwiLFxuICAgICAgICBicHJldjogXCJ0YWJwcmV2XCIsXG4gICAgICAgIHRhYmZpcnN0OiBcInRhYiAxXCIsXG4gICAgICAgIHRhYmxhc3Q6IFwidGFiIDBcIixcbiAgICAgICAgYmZpcnN0OiBcInRhYmZpcnN0XCIsXG4gICAgICAgIGJsYXN0OiBcInRhYmxhc3RcIixcbiAgICAgICAgdGZpcnN0OiBcInRhYmZpcnN0XCIsXG4gICAgICAgIHRsYXN0OiBcInRhYmxhc3RcIixcbiAgICAgICAgYnVmZmVyOiBcInRhYlwiLFxuICAgICAgICBidWZmZXJhbGw6IFwidGFiYWxsXCIsXG4gICAgICAgIGJkOiBcInRhYmNsb3NlXCIsXG4gICAgICAgIGJkZWxldGU6IFwidGFiY2xvc2VcIixcbiAgICAgICAgcXVpdDogXCJ0YWJjbG9zZVwiLFxuICAgICAgICBxOiBcInRhYmNsb3NlXCIsXG4gICAgICAgIHFhOiBcInFhbGxcIixcbiAgICAgICAgc2FuaXRpemU6IFwic2FuaXRpc2VcIixcbiAgICAgICAgdHV0b3JpYWw6IFwidHV0b3JcIixcbiAgICAgICAgaDogXCJoZWxwXCIsXG4gICAgICAgIHVubXV0ZTogXCJtdXRlIHVubXV0ZVwiLFxuICAgICAgICBhdXRob3JzOiBcImNyZWRpdHNcIixcbiAgICAgICAgb3BlbndpdGg6IFwiaGludCAtV1wiLFxuICAgICAgICBcIiFcIjogXCJleGNsYWltXCIsXG4gICAgICAgIFwiIXNcIjogXCJleGNsYWltX3F1aWV0XCIsXG4gICAgICAgIGNvbnRhaW5lcnJlbW92ZTogXCJjb250YWluZXJkZWxldGVcIixcbiAgICAgICAgY29sb3VyczogXCJjb2xvdXJzY2hlbWVcIixcbiAgICAgICAgY29sb3JzY2hlbWU6IFwiY29sb3Vyc2NoZW1lXCIsXG4gICAgICAgIGNvbG9yczogXCJjb2xvdXJzY2hlbWVcIixcbiAgICAgICAgbWFuOiBcImhlbHBcIixcbiAgICAgICAgXCIhanNcIjogXCJmaWxsY21kbGluZV90bXAgMzAwMCAhanMgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBqcyBpbnN0ZWFkXCIsXG4gICAgICAgIFwiIWpzYlwiOlxuICAgICAgICAgICAgXCJmaWxsY21kbGluZV90bXAgMzAwMCAhanNiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UganNiIGluc3RlYWRcIixcbiAgICAgICAgZ2V0X2N1cnJlbnRfdXJsOiBcImpzIGRvY3VtZW50LmxvY2F0aW9uLmhyZWZcIixcbiAgICAgICAgY3VycmVudF91cmw6IFwiY29tcG9zaXRlIGdldF9jdXJyZW50X3VybCB8IGZpbGxjbWRsaW5lX25vdHJhaWwgXCIsXG4gICAgICAgIHN0b3A6IFwianMgd2luZG93LnN0b3AoKVwiLFxuICAgICAgICB6bzogXCJ6b29tXCIsXG4gICAgICAgIGluc3RhbGxuYXRpdmU6IFwibmF0aXZlaW5zdGFsbFwiLFxuICAgICAgICBuYXRpdmV1cGRhdGU6IFwidXBkYXRlbmF0aXZlXCIsXG4gICAgICAgIG1rdDogXCJta3RyaWRhY3R5bHJjXCIsXG4gICAgICAgIFwibWt0IVwiOiBcIm1rdHJpZGFjdHlscmMgLWZcIixcbiAgICAgICAgXCJta3RyaWRhY3R5bHJjIVwiOiBcIm1rdHJpZGFjdHlscmMgLWZcIixcbiAgICAgICAgbXB2c2FmZTogXCJqcyAtcCB0cmkuZXhjbWRzLnNoZWxsZXNjYXBlKEpTX0FSRykudGhlbih1cmwgPT4gdHJpLmV4Y21kcy5leGNsYWltX3F1aWV0KCdtcHYgJyArIHVybCkpXCIsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXV1gIGFuZCBgW1tgIHRvIGxvb2sgZm9yIGxpbmtzIGNvbnRhaW5pbmcgdGhlc2Ugd29yZHMuXG4gICAgICpcbiAgICAgKiBFZGl0IHRoZXNlIGlmIHlvdSB3YW50IHRvIGFkZCwgZS5nLiBvdGhlciBsYW5ndWFnZSBzdXBwb3J0LlxuICAgICAqL1xuICAgIGZvbGxvd3BhZ2VwYXR0ZXJucyA9IHtcbiAgICAgICAgbmV4dDogXCJeKG5leHR8bmV3ZXIpXFxcXGJ8wrt8Pj58bW9yZVwiLFxuICAgICAgICBwcmV2OiBcIl4ocHJldihpb3VzKT98b2xkZXIpXFxcXGJ8wqt8PDxcIixcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBzZWFyY2ggZW5naW5lIHVzZWQgYnkgYG9wZW4gc2VhcmNoYC4gSWYgZW1wdHkgc3RyaW5nLCB5b3VyIGJyb3dzZXIncyBkZWZhdWx0IHNlYXJjaCBlbmdpbmUgd2lsbCBiZSB1c2VkLiBJZiBzZXQgdG8gc29tZXRoaW5nLCBUcmlkYWN0eWwgd2lsbCBmaXJzdCBsb29rIGF0IHlvdXIgW1tzZWFyY2h1cmxzXV0gYW5kIHRoZW4gYXQgdGhlIHNlYXJjaCBlbmdpbmVzIGZvciB3aGljaCB5b3UgaGF2ZSBkZWZpbmVkIGEga2V5d29yZCBvbiBgYWJvdXQ6cHJlZmVyZW5jZXMjc2VhcmNoYC5cbiAgICAgKi9cbiAgICBzZWFyY2hlbmdpbmUgPSBcIlwiXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbml0aW9ucyBvZiBzZWFyY2ggZW5naW5lcyBmb3IgdXNlIHZpYSBgb3BlbiBba2V5d29yZF1gLlxuICAgICAqXG4gICAgICogYCVzYCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggeW91ciB3aG9sZSBxdWVyeSBhbmQgYCVzMWAsIGAlczJgLCAuLi4sIGAlc25gIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgZmlyc3QsIHNlY29uZCBhbmQgbnRoIHdvcmQgb2YgeW91ciBxdWVyeS4gSWYgdGhlcmUgYXJlIG5vbmUgb2YgdGhlc2UgcGF0dGVybnMgaW4geW91ciBzZWFyY2ggdXJscywgeW91ciBxdWVyeSB3aWxsIHNpbXBseSBiZSBhcHBlbmRlZCB0byB0aGUgc2VhcmNodXJsLlxuICAgICAqXG4gICAgICogRXhhbXBsZXM6XG4gICAgICogLSBXaGVuIHJ1bm5pbmcgYG9wZW4gZ2kgY3V0ZSBwdXBwaWVzYCwgd2l0aCBhIGBnaWAgc2VhcmNodXJsIGRlZmluZWQgd2l0aCBgc2V0IHNlYXJjaHVybHMuZ2kgaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9zZWFyY2g/cT0lcyZ0Ym09aXNjaGAsIHRyaWRhY3R5bCB3aWxsIG5hdmlnYXRlIHRvIGBodHRwczovL3d3dy5nb29nbGUuY29tL3NlYXJjaD9xPWN1dGUgcHVwcGllcyZ0Ym09aXNjaGAuXG4gICAgICogLSBXaGVuIHJ1bm5pbmcgYHRhYm9wZW4gdHJhbnNsYXRlIGVuIGphIFRyaWRhY3R5bGAsIHdpdGggYSBgdHJhbnNsYXRlYCBzZWFyY2h1cmwgZGVmaW5lZCB3aXRoIGBzZXQgc2VhcmNodXJscy50cmFuc2xhdGUgaHR0cHM6Ly90cmFuc2xhdGUuZ29vZ2xlLmNvbS8jdmlldz1ob21lJm9wPXRyYW5zbGF0ZSZzbD0lczEmdGw9JXMyJnRleHQ9JXMzYCwgdHJpZGFjdHlsIHdpbGwgbmF2aWdhdGUgdG8gYGh0dHBzOi8vdHJhbnNsYXRlLmdvb2dsZS5jb20vI3ZpZXc9aG9tZSZvcD10cmFuc2xhdGUmc2w9ZW4mdGw9amEmdGV4dD1UcmlkYWN0eWxgLlxuICAgICAqL1xuICAgIHNlYXJjaHVybHMgPSB7XG4gICAgICAgIGdvb2dsZTogXCJodHRwczovL3d3dy5nb29nbGUuY29tL3NlYXJjaD9xPVwiLFxuICAgICAgICBnb29nbGVsdWNreTogXCJodHRwczovL3d3dy5nb29nbGUuY29tL3NlYXJjaD9idG5JPUknbStGZWVsaW5nK0x1Y2t5JnE9XCIsXG4gICAgICAgIHNjaG9sYXI6IFwiaHR0cHM6Ly9zY2hvbGFyLmdvb2dsZS5jb20vc2Nob2xhcj9xPVwiLFxuICAgICAgICBnb29nbGV1azogXCJodHRwczovL3d3dy5nb29nbGUuY28udWsvc2VhcmNoP3E9XCIsXG4gICAgICAgIGJpbmc6IFwiaHR0cHM6Ly93d3cuYmluZy5jb20vc2VhcmNoP3E9XCIsXG4gICAgICAgIGR1Y2tkdWNrZ286IFwiaHR0cHM6Ly9kdWNrZHVja2dvLmNvbS8/cT1cIixcbiAgICAgICAgeWFob286IFwiaHR0cHM6Ly9zZWFyY2gueWFob28uY29tL3NlYXJjaD9wPVwiLFxuICAgICAgICB0d2l0dGVyOiBcImh0dHBzOi8vdHdpdHRlci5jb20vc2VhcmNoP3E9XCIsXG4gICAgICAgIHdpa2lwZWRpYTogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TcGVjaWFsOlNlYXJjaC9cIixcbiAgICAgICAgeW91dHViZTogXCJodHRwczovL3d3dy55b3V0dWJlLmNvbS9yZXN1bHRzP3NlYXJjaF9xdWVyeT1cIixcbiAgICAgICAgYW1hem9uOlxuICAgICAgICAgICAgXCJodHRwczovL3d3dy5hbWF6b24uY29tL3MvcmVmPW5iX3NiX25vc3M/dXJsPXNlYXJjaC1hbGlhcyUzRGFwcyZmaWVsZC1rZXl3b3Jkcz1cIixcbiAgICAgICAgYW1hem9udWs6XG4gICAgICAgICAgICBcImh0dHBzOi8vd3d3LmFtYXpvbi5jby51ay9zL3JlZj1uYl9zYl9ub3NzP3VybD1zZWFyY2gtYWxpYXMlM0RhcHMmZmllbGQta2V5d29yZHM9XCIsXG4gICAgICAgIHN0YXJ0cGFnZTpcbiAgICAgICAgICAgIFwiaHR0cHM6Ly9zdGFydHBhZ2UuY29tL2RvL3NlYXJjaD9sYW5ndWFnZT1lbmdsaXNoJmNhdD13ZWImcXVlcnk9XCIsXG4gICAgICAgIGdpdGh1YjogXCJodHRwczovL2dpdGh1Yi5jb20vc2VhcmNoP3V0Zjg94pyTJnE9XCIsXG4gICAgICAgIHNlYXJ4OiBcImh0dHBzOi8vc2VhcngubWUvP2NhdGVnb3J5X2dlbmVyYWw9b24mcT1cIixcbiAgICAgICAgY25ydGw6IFwiaHR0cDovL3d3dy5jbnJ0bC5mci9sZXhpY29ncmFwaGllL1wiLFxuICAgICAgICBvc206IFwiaHR0cHM6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvc2VhcmNoP3F1ZXJ5PVwiLFxuICAgICAgICBtZG46IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvc2VhcmNoP3E9XCIsXG4gICAgICAgIGdlbnRvb193aWtpOlxuICAgICAgICAgICAgXCJodHRwczovL3dpa2kuZ2VudG9vLm9yZy9pbmRleC5waHA/dGl0bGU9U3BlY2lhbCUzQVNlYXJjaCZwcm9maWxlPWRlZmF1bHQmZnVsbHRleHQ9U2VhcmNoJnNlYXJjaD1cIixcbiAgICAgICAgcXdhbnQ6IFwiaHR0cHM6Ly93d3cucXdhbnQuY29tLz9xPVwiLFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVSTCB0aGUgbmV3dGFiIHdpbGwgcmVkaXJlY3QgdG8uXG4gICAgICpcbiAgICAgKiBBbGwgdXN1YWwgcnVsZXMgYWJvdXQgdGhpbmdzIHlvdSBjYW4gb3BlbiB3aXRoIGBvcGVuYCBhcHBseSwgd2l0aCB0aGUgY2F2ZWF0IHRoYXQgeW91J2xsIGdldCBpbnRlcmVzdGluZyByZXN1bHRzIGlmIHlvdSB0cnkgdG8gdXNlIHNvbWV0aGluZyB0aGF0IG5lZWRzIGBuYXRpdmVvcGVuYDogc28gZG9uJ3QgdHJ5IGBhYm91dDpuZXd0YWJgLlxuICAgICAqL1xuICAgIG5ld3RhYiA9IFwiXCJcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgYDp2aWV3c291cmNlYCB3aWxsIHVzZSBvdXIgb3duIHBhZ2UgdGhhdCB5b3UgY2FuIHVzZSBUcmlkYWN0eWwgYmluZHMgb24sIG9yIEZpcmVmb3gncyBkZWZhdWx0IHZpZXdlciwgd2hpY2ggeW91IGNhbm5vdCB1c2UgVHJpZGFjdHlsIG9uLlxuICAgICAqL1xuICAgIHZpZXdzb3VyY2U6IFwidHJpZGFjdHlsXCIgfCBcImRlZmF1bHRcIiA9IFwidHJpZGFjdHlsXCJcblxuICAgIC8qKlxuICAgICAqIFdoaWNoIHN0b3JhZ2UgdG8gdXNlLiBTeW5jIHN0b3JhZ2Ugd2lsbCBzeW5jaHJvbmlzZSB5b3VyIHNldHRpbmdzIHZpYSB5b3VyIEZpcmVmb3ggQWNjb3VudC5cbiAgICAgKi9cbiAgICBzdG9yYWdlbG9jOiBcInN5bmNcIiB8IFwibG9jYWxcIiA9IFwic3luY1wiXG5cbiAgICAvKipcbiAgICAgKiBQYWdlcyBvcGVuZWQgd2l0aCBgZ0hgLiBJbiBvcmRlciB0byBzZXQgdGhpcyB2YWx1ZSwgdXNlIGA6c2V0IGhvbWVwYWdlcyBbXCJleGFtcGxlLm9yZ1wiLCBcImV4YW1wbGUubmV0XCIsIFwiZXhhbXBsZS5jb21cIl1gIGFuZCBzbyBvbi5cbiAgICAgKi9cbiAgICBob21lcGFnZXM6IHN0cmluZ1tdID0gW11cblxuICAgIC8qKlxuICAgICAqIENoYXJhY3RlcnMgdG8gdXNlIGluIGhpbnQgbW9kZS5cbiAgICAgKlxuICAgICAqIFRoZXkgYXJlIHVzZWQgcHJlZmVyZW50aWFsbHkgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAqL1xuICAgIGhpbnRjaGFycyA9IFwiaGprbGFzZGZneXVpb3Bxd2VydG5tenhjdmJcIlxuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgaGludGluZyB0byB1c2UuIGB2aW1wZXJhdG9yYCB3aWxsIGFsbG93IHlvdSB0byBmaWx0ZXIgbGlua3MgYmFzZWQgb24gdGhlaXIgbmFtZXMgYnkgdHlwaW5nIG5vbi1oaW50IGNoYXJzLiBJdCBpcyByZWNvbW1lbmRlZCB0aGF0IHlvdSB1c2UgdGhpcyBpbiBjb25qdWN0aW9uIHdpdGggdGhlIFtbaGludGNoYXJzXV0gc2V0dGluZywgd2hpY2ggeW91IHNob3VsZCBwcm9iYWJseSBzZXQgdG8gZS5nLCBgNTQzMjE2Nzg5MGAuIMK0dmltcGVyYXRvci1yZWZsb3fCtCBhZGRpdGlvbmFsbHkgdXBkYXRlcyB0aGUgaGludCBsYWJlbHMgYWZ0ZXIgZmlsdGVyaW5nLlxuICAgICAqL1xuICAgIGhpbnRmaWx0ZXJtb2RlOiBcInNpbXBsZVwiIHwgXCJ2aW1wZXJhdG9yXCIgfCBcInZpbXBlcmF0b3ItcmVmbG93XCIgPSBcInNpbXBsZVwiXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIG9wdGltaXNlIGZvciB0aGUgc2hvcnRlc3QgcG9zc2libGUgbmFtZXMgZm9yIGVhY2ggaGludCwgb3IgdG8gdXNlIGEgc2ltcGxlIG51bWVyaWNhbCBvcmRlcmluZy4gSWYgc2V0IHRvIGBudW1lcmljYCwgb3ZlcnJpZGVzIGBoaW50Y2hhcnNgIHNldHRpbmcuXG4gICAgICovXG4gICAgaGludG5hbWVzOiBcInNob3J0XCIgfCBcIm51bWVyaWNcIiB8IFwidW5pZm9ybVwiID0gXCJzaG9ydFwiXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGRpc3BsYXkgdGhlIG5hbWVzIGZvciBoaW50cyBpbiB1cHBlcmNhc2UuXG4gICAgICovXG4gICAgaGludHVwcGVyY2FzZTogXCJ0cnVlXCIgfCBcImZhbHNlXCIgPSBcInRydWVcIlxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlbGF5IGluIG1pbGxpc2Vjb25kcyBpbiBgdmltcGVyYXRvcmAgc3R5bGUgaGludCBtb2RlcyBhZnRlciBzZWxlY3RpbmcgYSBoaW50IGJlZm9yZSB5b3UgYXJlIHJldHVybmVkIHRvIG5vcm1hbCBtb2RlLlxuICAgICAqXG4gICAgICogVGhlIHBvaW50IG9mIHRoaXMgaXMgdG8gcHJldmVudCBhY2NpZGVudGFsIGV4ZWN1dGlvbiBvZiBub3JtYWwgbW9kZSBiaW5kcyBkdWUgdG8gcGVvcGxlIHR5cGluZyBtb3JlIHRoYW4gaXMgbmVjZXNzYXJ5IHRvIGNob29zZSBhIGhpbnQuXG4gICAgICovXG4gICAgaGludGRlbGF5ID0gMzAwXG5cbiAgICAvKipcbiAgICAgKiBDb250cm9scyB3aGV0aGVyIHRoZSBwYWdlIGNhbiBmb2N1cyBlbGVtZW50cyBmb3IgeW91IHZpYSBqc1xuICAgICAqXG4gICAgICogTkI6IHdpbGwgYnJlYWsgZmFuY3kgZWRpdG9ycyBzdWNoIGFzIENvZGVNaXJyb3Igb24gSnVweXRlci4gU2ltcGx5IHVzZSBgc2V0dXJsYCB0byB3aGl0ZWxpc3QgcGFnZXMgeW91IG5lZWQgaXQgb24uXG4gICAgICpcbiAgICAgKiBCZXN0IHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBicm93c2VyLmF1dG9mb2N1cyBpbiBgYWJvdXQ6Y29uZmlnYFxuICAgICAqL1xuICAgIGFsbG93YXV0b2ZvY3VzOiBcInRydWVcIiB8IFwiZmFsc2VcIiA9IFwidHJ1ZVwiXG5cbiAgICAvKipcbiAgICAgKiBVc2VzIGEgbG9vcCB0byBwcmV2ZW50IGZvY3VzIHVudGlsIHlvdSBpbnRlcmFjdCB3aXRoIGEgcGFnZS4gT25seSByZWNvbW1lbmRlZCBmb3IgdXNlIHZpYSBgc2V0dXJsYCBmb3IgcHJvYmxlbWF0aWMgc2l0ZXMgYXMgaXQgY2FuIGJlIGEgbGl0dGxlIGhlYXZ5IG9uIENQVSBpZiBydW5uaW5nIG9uIGFsbCB0YWJzLiBTaG91bGQgYmUgdXNlZCBpbiBjb25qdWN0aW9uIHdpdGggW1thbGxvd2F1dG9mb2N1c11dXG4gICAgICovXG4gICAgcHJldmVudGF1dG9mb2N1c2phY2toYW1tZXI6IFwidHJ1ZVwiIHwgXCJmYWxzZVwiID0gXCJmYWxzZVwiXG5cbiAgICAvKipcbiAgICAgKiBDb250cm9scyB3aGV0aGVyIHRoZSBuZXd0YWIgZm9jdXNlcyBvbiB0cmlkYWN0eWwncyBuZXd0YWIgcGFnZSBvciB0aGUgZmlyZWZveCB1cmxiYXIuXG4gICAgICpcbiAgICAgKiBUbyBnZXQgRkYgZGVmYXVsdCBiZWhhdmlvdXIsIHVzZSBcInVybGJhclwiLlxuICAgICAqL1xuICAgIG5ld3RhYmZvY3VzOiBcInBhZ2VcIiB8IFwidXJsYmFyXCIgPSBcInBhZ2VcIlxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byB1c2UgVHJpZGFjdHlsJ3MgKGJhZCkgc21vb3RoIHNjcm9sbGluZy5cbiAgICAgKi9cbiAgICBzbW9vdGhzY3JvbGw6IFwidHJ1ZVwiIHwgXCJmYWxzZVwiID0gXCJmYWxzZVwiXG5cbiAgICAvKipcbiAgICAgKiBIb3cgdmlzY291cyB5b3Ugd2FudCBzbW9vdGggc2Nyb2xsaW5nIHRvIGZlZWwuXG4gICAgICovXG4gICAgc2Nyb2xsZHVyYXRpb24gPSAxMDBcblxuICAgIC8qKlxuICAgICAqIFdoZXJlIHRvIG9wZW4gdGFicyBvcGVuZWQgd2l0aCBgdGFib3BlbmAgLSB0byB0aGUgcmlnaHQgb2YgdGhlIGN1cnJlbnQgdGFiLCBvciBhdCB0aGUgZW5kIG9mIHRoZSB0YWJzLlxuICAgICAqL1xuICAgIHRhYm9wZW5wb3M6IFwibmV4dFwiIHwgXCJsYXN0XCIgPSBcIm5leHRcIlxuXG4gICAgLyoqXG4gICAgICogV2hlcmUgdG8gb3BlbiB0YWJzIG9wZW5lZCB3aXRoIGhpbnRpbmcgLSBhcyBpZiBpdCBoYWQgYmVlbiBtaWRkbGUgY2xpY2tlZCwgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjdXJyZW50IHRhYiwgb3IgYXQgdGhlIGVuZCBvZiB0aGUgdGFicy5cbiAgICAgKi9cbiAgICByZWxhdGVkb3BlbnBvczogXCJyZWxhdGVkXCIgfCBcIm5leHRcIiB8IFwibGFzdFwiID0gXCJyZWxhdGVkXCJcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgdm9pY2UgdG8gdXNlIGZvciB0ZXh0LXRvLXNwZWVjaC4gWW91IGNhbiBnZXQgdGhlIGxpc3Qgb2YgaW5zdGFsbGVkIHZvaWNlcyBieSBydW5uaW5nIHRoZSBmb2xsb3dpbmcgc25pcHBldDogYGpzIGFsZXJ0KHdpbmRvdy5zcGVlY2hTeW50aGVzaXMuZ2V0Vm9pY2VzKCkucmVkdWNlKChhLCBiKSA9PiBhICsgXCIgXCIgKyBiLm5hbWUpKWBcbiAgICAgKi9cbiAgICB0dHN2b2ljZSA9IFwiZGVmYXVsdFwiIC8vIGNob3NlbiBmcm9tIHRoZSBsaXN0dm9pY2VzIGxpc3Qgb3IgXCJkZWZhdWx0XCJcbiAgICAvKipcbiAgICAgKiBDb250cm9scyB0ZXh0LXRvLXNwZWVjaCB2b2x1bWUuIEhhcyB0byBiZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICovXG4gICAgdHRzdm9sdW1lID0gMVxuICAgIC8qKlxuICAgICAqIENvbnRyb2xzIHRleHQtdG8tc3BlZWNoIHNwZWVkLiBIYXMgdG8gYmUgYSBudW1iZXIgYmV0d2VlbiAwLjEgYW5kIDEwLlxuICAgICAqL1xuICAgIHR0c3JhdGUgPSAxXG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgdGV4dC10by1zcGVlY2ggcGl0Y2guIEhhcyB0byBiZSBiZXR3ZWVuIDAgYW5kIDIuXG4gICAgICovXG4gICAgdHRzcGl0Y2ggPSAxXG5cbiAgICAvKipcbiAgICAgKiBJZiBuZXh0aW5wdXQsIDxUYWI+IGFmdGVyIGdpIGJyaW5ncyBzZWxlY3RzIHRoZSBuZXh0IGlucHV0XG4gICAgICpcbiAgICAgKiBJZiBmaXJlZm94LCA8VGFiPiBzZWxlY3RzIHRoZSBuZXh0IHNlbGVjdGFibGUgZWxlbWVudCwgZS5nLiBhIGxpbmtcbiAgICAgKi9cbiAgICBnaW1vZGU6IFwibmV4dGlucHV0XCIgfCBcImZpcmVmb3hcIiA9IFwibmV4dGlucHV0XCJcblxuICAgIC8qKlxuICAgICAqIERlY2lkZXMgd2hlcmUgdG8gcGxhY2UgdGhlIGN1cnNvciB3aGVuIHNlbGVjdGluZyBub24tZW1wdHkgaW5wdXQgZmllbGRzXG4gICAgICovXG4gICAgY3Vyc29ycG9zOiBcImJlZ2lubmluZ1wiIHwgXCJlbmRcIiA9IFwiZW5kXCJcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aGVtZSB0byB1c2UuXG4gICAgICpcbiAgICAgKiBQZXJtaXR0ZWQgdmFsdWVzOiBydW4gYDpjb21wb3NpdGUganMgdHJpLnN0eWxpbmcuVEhFTUVTIHwgZmlsbGNtZGxpbmVgIHRvIGZpbmQgb3V0LlxuICAgICAqL1xuICAgIHRoZW1lID0gXCJkZWZhdWx0XCJcblxuICAgIC8qKlxuICAgICAqIFN0b3JhZ2UgZm9yIGN1c3RvbSB0aGVtZXNcbiAgICAgKlxuICAgICAqIE1hcHMgdGhlbWUgbmFtZXMgdG8gQ1NTLiBQcmVkb21pbmFudGx5IHVzZWQgYXV0b21hdGljYWxseSBieSBbW2NvbG91cnNjaGVtZV1dIHRvIHN0b3JlIHRoZW1lcyByZWFkIGZyb20gZGlzaywgYXMgZG9jdW1lbnRlZCBieSBbW2NvbG91cnNjaGVtZV1dLiBTZXR0aW5nIHRoaXMgbWFudWFsbHkgaXMgdW50ZXN0ZWQgYnV0IG1pZ2h0IHdvcmsgcHJvdmlkZWQgdGhhdCBbW2NvbG91cnNjaGVtZV1dIGlzIHRoZW4gdXNlZCB0byBjaGFuZ2UgdGhlIHRoZW1lIHRvIHRoZSByaWdodCB0aGVtZSBuYW1lLlxuICAgICAqL1xuICAgIGN1c3RvbXRoZW1lcyA9IHt9XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGRpc3BsYXkgdGhlIG1vZGUgaW5kaWNhdG9yIG9yIG5vdC5cbiAgICAgKi9cbiAgICBtb2RlaW5kaWNhdG9yOiBcInRydWVcIiB8IFwiZmFsc2VcIiA9IFwidHJ1ZVwiXG5cbiAgICAvKipcbiAgICAgKiBNaWxsaXNlY29uZHMgYmVmb3JlIHJlZ2lzdGVyaW5nIGEgc2Nyb2xsIGluIHRoZSBqdW1wbGlzdFxuICAgICAqL1xuICAgIGp1bXBkZWxheSA9IDMwMDBcblxuICAgIC8qKlxuICAgICAqIExvZ2dpbmcgbGV2ZWxzLiBVbmxlc3MgeW91J3JlIGRlYnVnZ2luZyBUcmlkYWN0eWwsIGl0J3MgdW5saWtlbHkgeW91J2xsIGV2ZXIgbmVlZCB0byBjaGFuZ2UgdGhlc2UuXG4gICAgICovXG4gICAgbG9nZ2luZzogeyBba2V5OiBzdHJpbmddOiBMb2dnaW5nTGV2ZWwgfSA9IHtcbiAgICAgICAgY21kbGluZTogXCJ3YXJuaW5nXCIsXG4gICAgICAgIGNvbnRhaW5lcnM6IFwid2FybmluZ1wiLFxuICAgICAgICBjb250cm9sbGVyOiBcIndhcm5pbmdcIixcbiAgICAgICAgZXhjbWQ6IFwiZXJyb3JcIixcbiAgICAgICAgaGludGluZzogXCJ3YXJuaW5nXCIsXG4gICAgICAgIG1lc3NhZ2luZzogXCJ3YXJuaW5nXCIsXG4gICAgICAgIG5hdGl2ZTogXCJ3YXJuaW5nXCIsXG4gICAgICAgIHBlcmZvcm1hbmNlOiBcIndhcm5pbmdcIixcbiAgICAgICAgc3RhdGU6IFwid2FybmluZ1wiLFxuICAgICAgICBzdHlsaW5nOiBcIndhcm5pbmdcIixcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlcyB0aGUgY29tbWFuZGxpbmUgaWZyYW1lLiBEYW5nZXJvdXMgc2V0dGluZywgdXNlIFtbc2V0dXJsXV0gdG8gc2V0IGl0LiBJZiB5b3UgZXZlciBzZXQgdGhpcyBzZXR0aW5nIHRvIFwidHJ1ZVwiIGdsb2JhbGx5IGFuZCB0aGVuIHdhbnQgdG8gc2V0IGl0IHRvIGZhbHNlIGFnYWluLCB5b3UgY2FuIGRvIHRoaXMgYnkgb3BlbmluZyBUcmlkYWN0eWwncyBwcmVmZXJlbmNlcyBwYWdlIGZyb20gYWJvdXQ6YWRkb25zLlxuICAgICAqL1xuICAgIG5vaWZyYW1lOiBcInRydWVcIiB8IFwiZmFsc2VcIiA9IFwiZmFsc2VcIlxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgQSBsaXN0IG9mIFVSTHMgb24gd2hpY2ggdG8gbm90IGxvYWQgdGhlIGlmcmFtZS4gVXNlIGBzZXR1cmwgW1VSTF0gbm9pZnJhbWUgdHJ1ZWAgaW5zdGVhZCwgYXMgc2hvd24gaW4gW1tub2lmcmFtZV1dLlxuICAgICAqL1xuICAgIG5vaWZyYW1lb246IHN0cmluZ1tdID0gW11cblxuICAgIC8qKlxuICAgICAqIEluc2VydCAvIGlucHV0IG1vZGUgZWRpdC1pbi0kRURJVE9SIGNvbW1hbmQgdG8gcnVuXG4gICAgICogVGhpcyBoYXMgdG8gYmUgYSBjb21tYW5kIHRoYXQgc3RheXMgaW4gdGhlIGZvcmVncm91bmQgZm9yIHRoZSB3aG9sZSBlZGl0aW5nIHNlc3Npb25cbiAgICAgKiBcImF1dG9cIiB3aWxsIGF0dGVtcHQgdG8gZmluZCBhIHNhbmUgZWRpdG9yIGluIHlvdXIgcGF0aC5cbiAgICAgKiBQbGVhc2Ugc2VuZCB5b3VyIHJlcXVlc3RzIHRvIGhhdmUgeW91ciBmYXZvdXJpdGUgdGVybWluYWwgbW92ZWQgZnVydGhlciB1cCB0aGUgbGlzdCB0byAvZGV2L251bGwuXG4gICAgICogICAgICAgICAgKGJ1dCB3ZSBhcmUgcHJvYmFibHkgaGFwcHkgdG8gYWRkIHlvdXIgdGVybWluYWwgdG8gdGhlIGxpc3QgaWYgaXQgaXNuJ3QgYWxyZWFkeSB0aGVyZS4pXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIHZhbHVlczpcbiAgICAgKiAtIGxpbnV4OiBgeHRlcm0gLWUgdmltYFxuICAgICAqIC0gd2luZG93czogYHN0YXJ0IGNtZC5leGUgL2MgXFxcInZpbVxcXCJgLlxuICAgICAqXG4gICAgICogQWxzbyBzZWUgWzplZGl0b3JdKC9zdGF0aWMvZG9jcy9tb2R1bGVzL19zcmNfZXhjbWRzXy5odG1sI2VkaXRvcikuXG4gICAgICovXG4gICAgZWRpdG9yY21kID0gXCJhdXRvXCJcblxuICAgIC8qKlxuICAgICAqIENvbW1hbmQgdGhhdCBzaG91bGQgYmUgcnVuIGJ5IHRoZSBbW3Jzc2V4ZWNdXSBleCBjb21tYW5kLiBIYXMgdGhlXG4gICAgICogZm9sbG93aW5nIGZvcm1hdDpcbiAgICAgKiAtICV1OiB1cmxcbiAgICAgKiAtICV0OiB0aXRsZVxuICAgICAqIC0gJXk6IHR5cGUgKHJzcywgYXRvbSwgeG1sLi4uKVxuICAgICAqIFdhcm5pbmc6IFRoaXMgaXMgYSB2ZXJ5IGxhcmdlIGZvb3RndW4uICV1IHdpbGwgYmUgaW5zZXJ0ZWQgd2l0aG91dCBhbnlcbiAgICAgKiBraW5kIG9mIGVzY2FwaW5nLCBoZW5jZSB5b3UgbXVzdCBvYmV5IHRoZSBmb2xsb3dpbmcgcnVsZXMgaWYgeW91IGNhcmVcbiAgICAgKiBhYm91dCBzZWN1cml0eTpcbiAgICAgKiAtIERvIG5vdCB1c2UgYSBjb21wb3NpdGUgY29tbWFuZC4gSWYgeW91IG5lZWQgYSBjb21wb3NpdGUgY29tbWFuZCxcbiAgICAgKiBjcmVhdGUgYW4gYWxpYXMuXG4gICAgICogLSBEbyBub3QgdXNlIGBqc2Agb3IgYGpzYmAuIElmIHlvdSBuZWVkIHRvIHVzZSB0aGVtLCBjcmVhdGUgYW4gYWxpYXMuXG4gICAgICogLSBEbyBub3QgaW5zZXJ0IGFueSAldSwgJXQgb3IgJXkgaW4gc2hlbGwgY29tbWFuZHMgcnVuIGJ5IHRoZSBuYXRpdmVcbiAgICAgKiBtZXNzZW5nZXIuIFVzZSBwaXBlcyBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogSGVyZSdzIGFuIGV4YW1wbGUgb2YgaG93IHRvIHNhdmUgYW4gcnNzIHVybCBpbiBhIGZpbGUgb24geW91ciBkaXNrXG4gICAgICogc2FmZWx5OlxuICAgICAqIGBhbGlhcyBzYXZlX3JzcyBqc2IgLXAgdHJpLm5hdGl2ZS5ydW4oXCJjYXQgPj4gfi8uY29uZmlnLm5ld3Nib2F0L3VybHNcIiwgSlNfQVJHKWBcbiAgICAgKiBgc2V0IHJzc2NtZCBzYXZlX3JzcyAldWBcbiAgICAgKiBUaGlzIGlzIHNhZmUgYmVjYXVzZSB0aGUgdXJsIGlzIHBhc3NlZCB0byBqc2IgYXMgYW4gYXJndW1lbnQgcmF0aGVyIHRoYW5cbiAgICAgKiBiZWluZyBleHBhbmRlZCBpbnNpZGUgb2YgdGhlIHN0cmluZyBpdCB3aWxsIGV4ZWN1dGUgYW5kIGJlY2F1c2UgaXQgaXNcbiAgICAgKiBwaXBlZCB0byB0aGUgc2hlbGwgY29tbWFuZCByYXRoZXIgdGhhbiBiZWluZyBleHBhbmRlZCBpbnNpZGUgb2YgaXQuXG4gICAgICovXG4gICAgcnNzY21kID0gXCJ5YW5rICV1XCJcblxuICAgIC8qKlxuICAgICAqIFRoZSBicm93c2VyIGV4ZWN1dGFibGUgdG8gbG9vayBmb3IgaW4gY29tbWFuZHMgc3VjaCBhcyBgcmVzdGFydGAuIE5vdCBhcyBtYWQgYXMgaXQgc2VlbXMgaWYgeW91IGhhdmUgbXVsdGlwbGUgdmVyc2lvbnMgb2YgRmlyZWZveC4uLlxuICAgICAqL1xuICAgIGJyb3dzZXIgPSBcImZpcmVmb3hcIlxuXG4gICAgLyoqXG4gICAgICogV2hpY2ggY2xpcGJvYXJkIHRvIHN0b3JlIGl0ZW1zIGluLiBSZXF1aXJlcyB0aGUgbmF0aXZlIG1lc3NlbmdlciB0byBiZSBpbnN0YWxsZWQuXG4gICAgICovXG4gICAgeWFua3RvOiBcImNsaXBib2FyZFwiIHwgXCJzZWxlY3Rpb25cIiB8IFwiYm90aFwiID0gXCJjbGlwYm9hcmRcIlxuXG4gICAgLyoqXG4gICAgICogV2hpY2ggY2xpcGJvYXJkIHRvIHJldHJpZXZlIGl0ZW1zIGZyb20uIFJlcXVpcmVzIHRoZSBuYXRpdmUgbWVzc2VuZ2VyIHRvIGJlIGluc3RhbGxlZC5cbiAgICAgKlxuICAgICAqIFBlcm1pdHRlZCB2YWx1ZXM6IGBjbGlwYm9hcmRgLCBvciBgc2VsZWN0aW9uYC5cbiAgICAgKi9cbiAgICBwdXRmcm9tOiBcImNsaXBib2FyZFwiIHwgXCJzZWxlY3Rpb25cIiA9IFwiY2xpcGJvYXJkXCJcblxuICAgIC8qKlxuICAgICAqIENsaXBib2FyZCBjb21tYW5kIHRvIHRyeSB0byBnZXQgdGhlIHNlbGVjdGlvbiBmcm9tIChlLmcuIGB4c2VsYCBvciBgeGNsaXBgKVxuICAgICAqL1xuICAgIGV4dGVybmFsY2xpcGJvYXJkY21kID0gXCJhdXRvXCJcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGlzIHRvIHNvbWV0aGluZyB3ZWlyZCBpZiB5b3Ugd2FudCB0byBoYXZlIGZ1biBldmVyeSB0aW1lIFRyaWRhY3R5bCB0cmllcyB0byB1cGRhdGUgaXRzIG5hdGl2ZSBtZXNzZW5nZXIuXG4gICAgICpcbiAgICAgKiAlVEFHIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB5b3VyIHZlcnNpb24gb2YgVHJpZGFjdHlsIGZvciBzdGFibGUgYnVpbGRzLCBvciBcIm1hc3RlclwiIGZvciBiZXRhIGJ1aWxkc1xuICAgICAqL1xuICAgIG5hdGl2ZWluc3RhbGxjbWQgPVxuICAgICAgICBcImN1cmwgLWZzU2wgaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3RyaWRhY3R5bC90cmlkYWN0eWwvbWFzdGVyL25hdGl2ZS9pbnN0YWxsLnNoIC1vIC90bXAvdHJpbmF0aXZlaW5zdGFsbC5zaCAmJiBiYXNoIC90bXAvdHJpbmF0aXZlaW5zdGFsbC5zaCAlVEFHXCJcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGlzIHRvIHNvbWV0aGluZyB3ZWlyZCBpZiB5b3Ugd2FudCB0byBoYXZlIGZ1biBldmVyeSB0aW1lIFRyaWRhY3R5bCB0cmllcyB0byB1cGRhdGUgaXRzIG5hdGl2ZSBtZXNzZW5nZXIuXG4gICAgICpcbiAgICAgKiBSZXBsYWNlcyAlV0lOVEFHIHdpdGggXCItVGFnICRUUklfVkVSU0lPTlwiLCBzaW1pbGFybHkgdG8gW1tuYXRpdmVpbnN0YWxsY21kXV0uXG4gICAgICovXG4gICAgIHdpbl9uYXRpdmVpbnN0YWxsY21kID0gYHBvd2Vyc2hlbGwgLU5vUHJvZmlsZSAtSW5wdXRGb3JtYXQgTm9uZSAtQ29tbWFuZCBcIkludm9rZS1FeHByZXNzaW9uICgoTmV3LU9iamVjdCBTeXN0ZW0uTmV0LldlYkNsaWVudCkuRG93bmxvYWRTdHJpbmcoJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9jbWNhaW5lL3RyaWRhY3R5bC9tYXN0ZXIvbmF0aXZlL3dpbl9pbnN0YWxsLnBzMScpKVwiYFxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSA6dXBkYXRlY2hlY2sgYW5kIHJlbGF0ZWQgYnVpbHQtaW4gZnVuY3Rpb25hbGl0eSB0byBhdXRvbWF0aWNhbGx5IGNoZWNrIGZvciB1cGRhdGVzIGFuZCBwcm9tcHQgdXNlcnMgdG8gdXBncmFkZS5cbiAgICAgKi9cbiAgICB1cGRhdGUgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIFRyaWRhY3R5bCBzaG91bGQgY2hlY2sgZm9yIGF2YWlsYWJsZSB1cGRhdGVzIGF0IHN0YXJ0dXAuXG4gICAgICAgICAqL1xuICAgICAgICBuYWc6IHRydWUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvdyBtYW55IGRheXMgdG8gd2FpdCBhZnRlciBhbiB1cGRhdGUgaXMgZmlyc3QgYXZhaWxhYmxlIHVudGlsIHRlbGxpbmcgcGVvcGxlLlxuICAgICAgICAgKi9cbiAgICAgICAgbmFnd2FpdDogNyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZlcnNpb24gd2UgbGFzdCBuYWdnZWQgeW91IGFib3V0LiBXZSBvbmx5IG5hZyB5b3Ugb25jZSBwZXIgdmVyc2lvbi5cbiAgICAgICAgICovXG4gICAgICAgIGxhc3RuYWdnZWR2ZXJzaW9uOiBcIjEuMTQuMFwiLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaW1lIHdlIGxhc3QgY2hlY2tlZCBmb3IgYW4gdXBkYXRlLCBtaWxsaXNlY29uZHMgc2luY2UgdW5peCBlcG9jaC5cbiAgICAgICAgICovXG4gICAgICAgIGxhc3RjaGVja3RpbWU6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1pbmltdW0gaW50ZXJ2YWwgYmV0d2VlbiBhdXRvbWF0aWMgdXBkYXRlIGNoZWNrcywgaW4gc2Vjb25kcy5cbiAgICAgICAgICovXG4gICAgICAgIGNoZWNraW50ZXJ2YWxzZWNzOiA2MCAqIDYwICogMjQsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZmlsZSBkaXJlY3RvcnkgdG8gdXNlIHdpdGggbmF0aXZlIG1lc3NlbmdlciB3aXRoIGUuZywgYGd1aXNldGAuXG4gICAgICovXG4gICAgcHJvZmlsZWRpciA9IFwiYXV0b1wiXG5cbiAgICAvLyBDb250YWluZXIgc2V0dGluZ3NcblxuICAgIC8qKlxuICAgICAqIElmIGVuYWJsZWQsIHRhYm9wZW4gb3BlbnMgYSBuZXcgdGFiIGluIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRhYidzIGNvbnRhaW5lci5cbiAgICAgKi9cbiAgICB0YWJvcGVuY29udGFpbmVyYXdhcmU6IFwidHJ1ZVwiIHwgXCJmYWxzZVwiID0gXCJmYWxzZVwiXG5cbiAgICAvKipcbiAgICAgKiBJZiBtb29kZWluZGljYXRvciBpcyBlbmFibGVkLCBjb250YWluZXJpbmRpY2F0b3Igd2lsbCBjb2xvciB0aGUgYm9yZGVyIG9mIHRoZSBtb2RlIGluZGljYXRvciB3aXRoIHRoZSBjb250YWluZXIgY29sb3IuXG4gICAgICovXG4gICAgY29udGFpbmVyaW5kaWNhdG9yOiBcInRydWVcIiB8IFwiZmFsc2VcIiA9IFwidHJ1ZVwiXG5cbiAgICAvKipcbiAgICAgKiBBdXRvY29udGFpbiBkaXJlY3RpdmVzIGNyZWF0ZSBhIGNvbnRhaW5lciBpZiBpdCBkb2Vzbid0IGV4aXN0IGFscmVhZHkuXG4gICAgICovXG4gICAgYXVjb25jcmVhdGVjb250YWluZXI6IFwidHJ1ZVwiIHwgXCJmYWxzZVwiID0gXCJ0cnVlXCJcblxuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBtb3N0IHJlY2VudCByZXN1bHRzIHRvIGFzayBGaXJlZm94IGZvci4gV2UgZGlzcGxheSB0aGUgdG9wIDIwIG9yIHNvIG1vc3QgZnJlcXVlbnRseSB2aXNpdGVkIG9uZXMuXG4gICAgICovXG4gICAgaGlzdG9yeXJlc3VsdHMgPSA1MFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBkaXNwbGF5aW5nIGJvb2ttYXJrcyBpbiBoaXN0b3J5IGNvbXBsZXRpb25zLCBob3cgbWFueSBwYWdlIHZpZXdzIHRvIHByZXRlbmQgdGhleSBoYXZlLlxuICAgICAqL1xuICAgIGJtYXJrd2VpZ2h0ID0gMTAwXG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgcmVzdWx0cyB0aGF0IHNob3VsZCBiZSBzaG93biBpbiBjb21wbGV0aW9ucy4gLTEgZm9yIHVubGltaXRlZFxuICAgICAqL1xuICAgIGZpbmRyZXN1bHRzID0gLTFcblxuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIHVzZSBhcyBjb250ZXh0IGZvciB0aGUgbWF0Y2hlcyBzaG93biBpbiBjb21wbGV0aW9uc1xuICAgICAqL1xuICAgIGZpbmRjb250ZXh0bGVuID0gMTAwXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGZpbmQgc2hvdWxkIGJlIGNhc2Utc2Vuc2l0aXZlXG4gICAgICovXG4gICAgZmluZGNhc2U6IFwic21hcnRcIiB8IFwic2Vuc2l0aXZlXCIgfCBcImluc2Vuc2l0aXZlXCIgPSBcInNtYXJ0XCJcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgVHJpZGFjdHlsIHNob3VsZCBqdW1wIHRvIHRoZSBmaXJzdCBtYXRjaCB3aGVuIHVzaW5nIGA6ZmluZGBcbiAgICAgKi9cbiAgICBpbmNzZWFyY2g6IFwidHJ1ZVwiIHwgXCJmYWxzZVwiID0gXCJmYWxzZVwiXG5cbiAgICAvKipcbiAgICAgKiBIb3cgbWFueSBjaGFyYWN0ZXJzIHNob3VsZCBiZSB0eXBlZCBiZWZvcmUgdHJpZ2dlcmluZyBpbmNzZWFyY2gvY29tcGxldGlvbnNcbiAgICAgKi9cbiAgICBtaW5pbmNzZWFyY2hsZW4gPSAzXG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhpcyB0byBcImNsb2JiZXJcIiB0byBydWluIHRoZSBcIkNvbnRlbnQgU2VjdXJpdHkgUG9saWN5XCIgb2YgYWxsIHNpdGVzIGEgYml0IGFuZCBtYWtlIFRyaWRhY3R5bCBydW4gYSBiaXQgYmV0dGVyIG9uIHNvbWUgb2YgdGhlbSwgZS5nLiByYXcuZ2l0aHViKlxuICAgICAqL1xuICAgIGNzcDogXCJ1bnRvdWNoZWRcIiB8IFwiY2xvYmJlclwiID0gXCJ1bnRvdWNoZWRcIlxuXG4gICAgLyoqXG4gICAgICogSmF2YVNjcmlwdCBSZWdFeHAgdXNlZCB0byByZWNvZ25pemUgd29yZHMgaW4gdGV4dC4qIGZ1bmN0aW9ucyAoZS5nLiB0ZXh0LnRyYW5zcG9zZV93b3JkcykuIFNob3VsZCBtYXRjaCBhbnkgY2hhcmFjdGVyIGJlbG9uZ2luZyB0byBhIHdvcmQuXG4gICAgICovXG4gICAgd29yZHBhdHRlcm4gPSBcIlteXFxcXHNdK1wiXG5cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZSB0cmlkYWN0eWwncyBwZXJmb3JtYW5jZSBjb3VudGVycy4gVGhlc2UgaGF2ZSBhXG4gICAgICogbWVhc3VyYWJsZSBwZXJmb3JtYW5jZSBpbXBhY3QsIHNpbmNlIGV2ZXJ5IHNhbXBsZSBpcyBhIGZld1xuICAgICAqIGh1bmRyZWQgYnl0ZXMgYW5kIHdlIHNhbXBsZSB0cmlkYWN0eWwgZGVuc2VseSwgYnV0IHRoZXkncmUgZ29vZFxuICAgICAqIHdoZW4geW91J3JlIHRyeWluZyB0byBvcHRpbWl6ZSB0aGluZ3MuXG4gICAgICovXG4gICAgcGVyZmNvdW50ZXJzOiBcInRydWVcIiB8IFwiZmFsc2VcIiA9IFwiZmFsc2VcIlxuXG4gICAgLyoqXG4gICAgICogSG93IG1hbnkgc2FtcGxlcyB0byBzdG9yZSBmcm9tIHRoZSBwZXJmIGNvdW50ZXJzLlxuICAgICAqXG4gICAgICogRWFjaCBwZXJmb3JtYW5jZSBlbnRyeSBpcyB0d28gbnVtYmVycyAoMTYgYnl0ZXMpLCBhbiBlbnRyeVR5cGVcbiAgICAgKiBvZiBlaXRoZXIgXCJtYXJrXCIgb3IgXCJtZWFzdXJlXCIgKGpzIHN0cmluZ3MgYXJlIHV0Zi0xNiBhZCB3ZSBoYXZlXG4gICAgICogdHdvIG1hcmtzIGZvciBlYWNoIG1lYXN1cmUsIHNvIGFtb3J0aXplIHRvIGFib3V0IDEwIGJ5dGVzIHBlclxuICAgICAqIGVudHJ5KSwgYW5kIGEgc3RyaW5nIG5hbWUgdGhhdCBmb3IgVHJpZGFjdHlsIG9iamVjdCB3aWxsIGJlXG4gICAgICogYWJvdXQgNDAgKHV0Zi0xNikgY2hhcmFjdGVycyAoODAgYnl0ZXMpLCBwbHVzIG9iamVjdCBvdmVyaGVhZFxuICAgICAqIHJvdWdobHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBzdHJpbmctbGVuZ3RoIG9mIHRoZSBuYW1lIG9mIHRoZVxuICAgICAqIGNvbnN0cnVjdG9yIChpbiB0aGlzIGNhc2Ugc29tZXRoaW5nIGxpa2UgMzAgYnl0ZXMpLCBmb3IgYSB0b3RhbFxuICAgICAqIG9mIHdoYXQgd2UnbGwgY2FsbCAxMjggYnl0ZXMgZm9yIGVhc2Ugb2YgbWF0aC5cbiAgICAgKlxuICAgICAqIFdlIHdhbnQgdG8gc3RvcmUsIGJ5IGRlZmF1bHQsIGFib3V0IDFNQiBvZiBwZXJmb3JtYW5jZVxuICAgICAqIHN0YXRpc3RpY3MsIHNvIHNvbWV3aGVyZSBhcm91bmQgMTBrIHNhbXBsZXMuXG4gICAgICpcbiAgICAgKi9cbiAgICBwZXJmc2FtcGxlczogc3RyaW5nID0gXCIxMDAwMFwiXG5cbiAgICAvKipcbiAgICAgKiBTaG93IChwYXJ0aWFsKSBjb21tYW5kIGluIHRoZSBtb2RlIGluZGljYXRvci5cbiAgICAgKiBDb3JyZXNwb25kcyB0byAnc2hvd2NtZCcgb3B0aW9uIG9mIHZpLlxuICAgICAqL1xuICAgIG1vZGVpbmRpY2F0b3JzaG93a2V5czogXCJ0cnVlXCIgfCBcImZhbHNlXCIgPSBcImZhbHNlXCJcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgYSB0cmFpbGluZyBzbGFzaCBpcyBhcHBlbmRlZCB3aGVuIHdlIGdldCB0aGUgcGFyZW50IG9mIGEgdXJsIHdpdGhcbiAgICAgKiBndSAob3Igb3RoZXIgbWVhbnMpLlxuICAgICAqL1xuICAgIHVybHBhcmVudHRyYWlsaW5nc2xhc2g6IFwidHJ1ZVwiIHwgXCJmYWxzZVwiID0gXCJ0cnVlXCJcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmNvbnN0IERFRkFVTFRTID0gbyhuZXcgZGVmYXVsdF9jb25maWcoKSlcblxuLyoqIEdpdmVuIGFuIG9iamVjdCBhbmQgYSB0YXJnZXQsIGV4dHJhY3QgdGhlIHRhcmdldCBpZiBpdCBleGlzdHMsIGVsc2UgcmV0dXJuIHVuZGVmaW5lZFxuXG4gICAgQHBhcmFtIHRhcmdldCBwYXRoIG9mIHByb3BlcnRpZXMgYXMgYW4gYXJyYXlcbiAgICBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGdldERlZXBQcm9wZXJ0eShvYmosIHRhcmdldDogc3RyaW5nW10pIHtcbiAgICBpZiAob2JqICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZ2V0RGVlcFByb3BlcnR5KG9ialt0YXJnZXRbMF1dLCB0YXJnZXQuc2xpY2UoMSkpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9ialxuICAgIH1cbn1cblxuLyoqIENyZWF0ZSB0aGUga2V5IHBhdGggdGFyZ2V0IGlmIGl0IGRvZXNuJ3QgZXhpc3QgYW5kIHNldCB0aGUgZmluYWwgcHJvcGVydHkgdG8gdmFsdWUuXG5cbiAgICBJZiB0aGUgcGF0aCBpcyBhbiBlbXB0eSBhcnJheSwgcmVwbGFjZSB0aGUgb2JqLlxuXG4gICAgQHBhcmFtIHRhcmdldCBwYXRoIG9mIHByb3BlcnRpZXMgYXMgYW4gYXJyYXlcbiAgICBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIHNldERlZXBQcm9wZXJ0eShvYmosIHZhbHVlLCB0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gSWYgbmVjZXNzYXJ5IGFudGVjZWRlbnQgb2JqZWN0cyBkb24ndCBleGlzdCwgY3JlYXRlIHRoZW0uXG4gICAgICAgIGlmIChvYmpbdGFyZ2V0WzBdXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmpbdGFyZ2V0WzBdXSA9IG8oe30pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldERlZXBQcm9wZXJ0eShvYmpbdGFyZ2V0WzBdXSwgdmFsdWUsIHRhcmdldC5zbGljZSgxKSlcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpbdGFyZ2V0WzBdXSA9IHZhbHVlXG4gICAgfVxufVxuXG4vKiogQGhpZGRlblxuICogTWVyZ2VzIHR3byBvYmplY3RzIGFuZCBhbnkgY2hpbGQgb2JqZWN0cyB0aGV5IG1heSBoYXZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZURlZXAobzEsIG8yKSB7XG4gICAgY29uc3QgciA9IEFycmF5LmlzQXJyYXkobzEpID8gbzEuc2xpY2UoKSA6IE9iamVjdC5jcmVhdGUobzEpXG4gICAgT2JqZWN0LmFzc2lnbihyLCBvMSwgbzIpXG4gICAgaWYgKG8yID09PSB1bmRlZmluZWQpIHJldHVybiByXG4gICAgT2JqZWN0LmtleXMobzEpXG4gICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgICBrZXkgPT4gdHlwZW9mIG8xW2tleV0gPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG8yW2tleV0gPT09IFwib2JqZWN0XCIsXG4gICAgICAgIClcbiAgICAgICAgLmZvckVhY2goa2V5ID0+IE9iamVjdC5hc3NpZ24ocltrZXldLCBtZXJnZURlZXAobzFba2V5XSwgbzJba2V5XSkpKVxuICAgIHJldHVybiByXG59XG5cbi8qKiBAaGlkZGVuXG4gKiBHZXRzIGEgc2l0ZS1zcGVjaWZpYyBzZXR0aW5nLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVUkwodXJsOiBzdHJpbmcsIHRhcmdldDogc3RyaW5nW10pIHtcbiAgICBmdW5jdGlvbiBfZ2V0VVJMKGNvbmYsIHVybCwgdGFyZ2V0KSB7XG4gICAgICAgIGlmICghY29uZi5zdWJjb25maWdzKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIC8vIEZvciBlYWNoIGtleVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgT2JqZWN0LmtleXMoY29uZi5zdWJjb25maWdzKVxuICAgICAgICAgICAgICAgIC8vIEtlZXAgb25seSB0aGUgb25lcyB0aGF0IGhhdmUgYSBtYXRjaFxuICAgICAgICAgICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgIGsgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHVybC5tYXRjaChrKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0RGVlcFByb3BlcnR5KGNvbmYuc3ViY29uZmlnc1trXSwgdGFyZ2V0KSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC8vIFNvcnQgdGhlbSBmcm9tIGxvd2VzdCB0byBoaWdoZXN0IHByaW9yaXR5LCBkZWZhdWx0IHRvIGEgcHJpb3JpdHkgb2YgMTBcbiAgICAgICAgICAgICAgICAuc29ydChcbiAgICAgICAgICAgICAgICAgICAgKGsxLCBrMikgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgIChjb25mLnN1YmNvbmZpZ3NbazFdLnByaW9yaXR5IHx8IDEwKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAoY29uZi5zdWJjb25maWdzW2syXS5wcmlvcml0eSB8fCAxMCksXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC8vIE1lcmdlIHRoZWlyIGNvcnJlc3BvbmRpbmcgdmFsdWUgaWYgdGhleSdyZSBvYmplY3RzLCBvdGhlcndpc2UgcmV0dXJuIHRoZSBsYXN0IHZhbHVlXG4gICAgICAgICAgICAgICAgLnJlZHVjZShcbiAgICAgICAgICAgICAgICAgICAgKGFjYywgY3VyS2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJWYWwgPSBnZXREZWVwUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZi5zdWJjb25maWdzW2N1cktleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjYyBpbnN0YW5jZW9mIE9iamVjdCAmJiBjdXJWYWwgaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlRGVlcChhY2MsIGN1clZhbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJWYWxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkIGFzIGFueSxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgIClcbiAgICB9XG4gICAgY29uc3QgdXNlciA9IF9nZXRVUkwoVVNFUkNPTkZJRywgdXJsLCB0YXJnZXQpXG4gICAgY29uc3QgZGVmbHQgPSBfZ2V0VVJMKERFRkFVTFRTLCB1cmwsIHRhcmdldClcbiAgICBpZiAodXNlciA9PT0gdW5kZWZpbmVkIHx8IHVzZXIgPT09IG51bGwpIHJldHVybiBkZWZsdFxuICAgIGlmICh0eXBlb2YgdXNlciAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZGVmbHQgIT09IFwib2JqZWN0XCIpIHJldHVybiB1c2VyXG4gICAgcmV0dXJuIG1lcmdlRGVlcChkZWZsdCwgdXNlcilcbn1cblxuLyoqIEdldCB0aGUgdmFsdWUgb2YgdGhlIGtleSB0YXJnZXQuXG5cbiAgICBJZiB0aGUgdXNlciBoYXMgbm90IHNwZWNpZmllZCBhIGtleSwgdXNlIHRoZSBjb3JyZXNwb25kaW5nIGtleSBmcm9tXG4gICAgZGVmYXVsdHMsIGlmIG9uZSBleGlzdHMsIGVsc2UgdW5kZWZpbmVkLlxuICAgIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldCh0YXJnZXRfdHlwZWQ/OiBrZXlvZiBkZWZhdWx0X2NvbmZpZywgLi4udGFyZ2V0OiBzdHJpbmdbXSkge1xuICAgIGlmICh0YXJnZXRfdHlwZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0YXJnZXQgPSBbXVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldCA9IFt0YXJnZXRfdHlwZWQgYXMgc3RyaW5nXS5jb25jYXQodGFyZ2V0KVxuICAgIH1cbiAgICAvLyBXaW5kb3cudHJpIG1pZ2h0IG5vdCBiZSBkZWZpbmVkIHdoZW4gY2FsbGVkIGZyb20gdGhlIHVudHJ1c3RlZCBwYWdlIGNvbnRleHRcbiAgICBsZXQgbG9jID0gd2luZG93LmxvY2F0aW9uXG4gICAgaWYgKCh3aW5kb3cgYXMgYW55KS50cmkgJiYgKHdpbmRvdyBhcyBhbnkpLnRyaS5jb250ZW50TG9jYXRpb24pXG4gICAgICAgIGxvYyA9ICh3aW5kb3cgYXMgYW55KS50cmkuY29udGVudExvY2F0aW9uXG4gICAgLy8gSWYgdGhlcmUncyBhIHNpdGUtc3BlY2lmaW5nIHNldHRpbmcsIGl0IG92ZXJyaWRlcyBnbG9iYWwgc2V0dGluZ3NcbiAgICBjb25zdCBzaXRlID0gZ2V0VVJMKGxvYy5ocmVmLCB0YXJnZXQpXG4gICAgY29uc3QgdXNlciA9IGdldERlZXBQcm9wZXJ0eShVU0VSQ09ORklHLCB0YXJnZXQpXG4gICAgY29uc3QgZGVmdWx0ID0gZ2V0RGVlcFByb3BlcnR5KERFRkFVTFRTLCB0YXJnZXQpXG5cbiAgICAvLyBNZXJnZSByZXN1bHRzIGlmIHRoZXJlJ3MgYSBkZWZhdWx0IHZhbHVlIGFuZCBpdCdzIG5vdCBhbiBBcnJheSBvciBwcmltaXRpdmUuXG4gICAgaWYgKHR5cGVvZiBkZWZ1bHQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGVlcChtZXJnZURlZXAoZGVmdWx0LCB1c2VyKSwgc2l0ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2l0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l0ZVxuICAgICAgICB9IGVsc2UgaWYgKHVzZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVzZXJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZ1bHRcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqIEdldCB0aGUgdmFsdWUgb2YgdGhlIGtleSB0YXJnZXQuXG5cbiAgICBQbGVhc2Ugb25seSB1c2UgdGhpcyB3aXRoIHRhcmdldHMgdGhhdCB3aWxsIGJlIHVzZWQgYXQgcnVudGltZSAtIGl0IHNraXBzIHN0YXRpYyBjaGVja3MuIFByZWZlciBbW2dldF1dLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RHluYW1pYyguLi50YXJnZXQ6IHN0cmluZ1tdKSB7XG4gICAgcmV0dXJuIGdldCh0YXJnZXRbMF0gYXMga2V5b2YgZGVmYXVsdF9jb25maWcsIC4uLnRhcmdldC5zbGljZSgxKSlcbn1cblxuLyoqIEdldCB0aGUgdmFsdWUgb2YgdGhlIGtleSB0YXJnZXQuXG5cbiAgICBQbGVhc2Ugb25seSB1c2UgdGhpcyB3aXRoIHRhcmdldHMgdGhhdCB3aWxsIGJlIHVzZWQgYXQgcnVudGltZSAtIGl0IHNraXBzIHN0YXRpYyBjaGVja3MuIFByZWZlciBbW2dldEFzeW5jXV0uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBc3luY0R5bmFtaWMoLi4udGFyZ2V0OiBzdHJpbmdbXSkge1xuICAgIHJldHVybiBnZXRBc3luYyh0YXJnZXRbMF0gYXMga2V5b2YgZGVmYXVsdF9jb25maWcsIC4uLnRhcmdldC5zbGljZSgxKSlcbn1cblxuLyoqIEdldCB0aGUgdmFsdWUgb2YgdGhlIGtleSB0YXJnZXQsIGJ1dCB3YWl0IGZvciBjb25maWcgdG8gYmUgbG9hZGVkIGZyb20gdGhlXG4gICAgZGF0YWJhc2UgZmlyc3QgaWYgaXQgaGFzIG5vdCBiZWVuIGF0IGxlYXN0IG9uY2UgYmVmb3JlLlxuXG4gICAgVGhpcyBpcyB1c2VmdWwgaWYgeW91IGFyZSBhIGNvbnRlbnQgc2NyaXB0IGFuZCB5b3UndmUganVzdCBiZWVuIGxvYWRlZC5cbiAgICBAaGlkZGVuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBc3luYyhcbiAgICB0YXJnZXRfdHlwZWQ/OiBrZXlvZiBkZWZhdWx0X2NvbmZpZyxcbiAgICAuLi50YXJnZXQ6IHN0cmluZ1tdXG4pIHtcbiAgICBpZiAoSU5JVElBTElTRUQpIHtcbiAgICAgICAgcmV0dXJuIGdldCh0YXJnZXRfdHlwZWQsIC4uLnRhcmdldClcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PlxuICAgICAgICAgICAgV0FJVEVSUy5wdXNoKCgpID0+IHJlc29sdmUoZ2V0KHRhcmdldF90eXBlZCwgLi4udGFyZ2V0KSkpLFxuICAgICAgICApXG4gICAgfVxufVxuXG4vKiogQGhpZGRlblxuICogTGlrZSBzZXQoKSwgYnV0IGZvciBhIHNwZWNpZmljIHBhdHRlcm4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRVUkwocGF0dGVybiwgLi4uYXJncykge1xuICAgIHJldHVybiBzZXQoXCJzdWJjb25maWdzXCIsIHBhdHRlcm4sIC4uLmFyZ3MpXG59XG4vKiogRnVsbCB0YXJnZXQgc3BlY2lmaWNhdGlvbiwgdGhlbiB2YWx1ZVxuXG4gICAgZS5nLlxuICAgICAgICBzZXQoXCJubWFwc1wiLCBcIm9cIiwgXCJvcGVuXCIpXG4gICAgICAgIHNldChcInNlYXJjaFwiLCBcImRlZmF1bHRcIiwgXCJnb29nbGVcIilcbiAgICAgICAgc2V0KFwiYXVjbWRcIiwgXCJCdWZSZWFkXCIsIFwibWVtcmlzZS5jb21cIiwgXCJvcGVuIG1lbXJpc2UuY29tXCIpXG5cbiAgICBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQoLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdGhyb3cgXCJZb3UgbXVzdCBwcm92aWRlIGF0IGxlYXN0IHR3byBhcmd1bWVudHMhXCJcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSBhcmdzLnNsaWNlKDAsIGFyZ3MubGVuZ3RoIC0gMSlcbiAgICBjb25zdCB2YWx1ZSA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXVxuXG4gICAgc2V0RGVlcFByb3BlcnR5KFVTRVJDT05GSUcsIHZhbHVlLCB0YXJnZXQpXG4gICAgcmV0dXJuIHNhdmUoKVxufVxuXG4vKiogQGhpZGRlblxuICogRGVsZXRlIHRoZSBrZXkgYXQgVVNFUkNPTkZJR1twYXR0ZXJuXVt0YXJnZXRdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnNldFVSTChwYXR0ZXJuLCAuLi50YXJnZXQpIHtcbiAgICByZXR1cm4gdW5zZXQoXCJzdWJjb25maWdzXCIsIHBhdHRlcm4sIC4uLnRhcmdldClcbn1cblxuLyoqIERlbGV0ZSB0aGUga2V5IGF0IHRhcmdldCBpbiBVU0VSQ09ORklHIGlmIGl0IGV4aXN0c1xuICogQGhpZGRlbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuc2V0KC4uLnRhcmdldCkge1xuICAgIGNvbnN0IHBhcmVudCA9IGdldERlZXBQcm9wZXJ0eShVU0VSQ09ORklHLCB0YXJnZXQuc2xpY2UoMCwgLTEpKVxuICAgIGlmIChwYXJlbnQgIT09IHVuZGVmaW5lZCkgZGVsZXRlIHBhcmVudFt0YXJnZXRbdGFyZ2V0Lmxlbmd0aCAtIDFdXVxuICAgIHJldHVybiBzYXZlKClcbn1cblxuLyoqIFNhdmUgdGhlIGNvbmZpZyBiYWNrIHRvIHN0b3JhZ2UgQVBJLlxuXG4gICAgQ29uZmlnIGlzIG5vdCBzeW5jaHJvbmlzZWQgYmV0d2VlbiBkaWZmZXJlbnQgaW5zdGFuY2VzIG9mIHRoaXMgbW9kdWxlIHVudGlsXG4gICAgc29tZXRpbWUgYWZ0ZXIgdGhpcyBoYXBwZW5zLlxuXG4gICAgQGhpZGRlblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2F2ZShzdG9yYWdlOiBcImxvY2FsXCIgfCBcInN5bmNcIiA9IGdldChcInN0b3JhZ2Vsb2NcIikpIHtcbiAgICAvLyBsZXQgc3RvcmFnZW9iaiA9IHN0b3JhZ2UgPT09IFwibG9jYWxcIiA/IGJyb3dzZXIuc3RvcmFnZS5sb2NhbCA6IGJyb3dzZXIuc3RvcmFnZS5zeW5jXG4gICAgLy8gc3RvcmFnZW9iai5zZXQoe0NPTkZJR05BTUU6IFVTRVJDT05GSUd9KVxuICAgIGNvbnN0IHNldHRpbmdzb2JqID0gbyh7fSlcbiAgICBzZXR0aW5nc29ialtDT05GSUdOQU1FXSA9IFVTRVJDT05GSUdcbiAgICByZXR1cm4gc3RvcmFnZSA9PT0gXCJsb2NhbFwiXG4gICAgICAgID8gYnJvd3Nlci5zdG9yYWdlLmxvY2FsLnNldChzZXR0aW5nc29iailcbiAgICAgICAgOiBicm93c2VyLnN0b3JhZ2Uuc3luYy5zZXQoc2V0dGluZ3NvYmopXG59XG5cbi8qKiBVcGRhdGVzIHRoZSBjb25maWcgdG8gdGhlIGxhdGVzdCB2ZXJzaW9uLlxuICAgIFByb3Bvc2VkIHNlbWFudGljIGZvciBjb25maWcgdmVyc2lvbm5pbmc6XG4gICAgIC0geC55IC0+IHgrMS4wIDogbWFqb3IgYXJjaGl0ZWN0dXJhbCBjaGFuZ2VzXG4gICAgIC0geC55IC0+IHgueSsxIDogcmVuYW1pbmcgc2V0dGluZ3MvY2hhbmdpbmcgdGhlaXIgdHlwZXNcbiAgICBUaGVyZSdzIG5vIG5lZWQgZm9yIGFuIHVwZGF0ZXIgaWYgeW91J3JlIG9ubHkgYWRkaW5nIGEgbmV3IHNldHRpbmcvY2hhbmdpbmdcbiAgICBhIGRlZmF1bHQgc2V0dGluZ1xuXG4gICAgV2hlbiBhZGRpbmcgdXBkYXRlcnMsIGRvbid0IGZvcmdldCB0byBzZXQoXCJjb25maWd2ZXJzaW9uXCIsIG5ld3ZlcnNpb25udW1iZXIpIVxuICAgIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAvLyBVcGRhdGVzIGEgdmFsdWUgYm90aCBpbiB0aGUgbWFpbiBjb25maWcgYW5kIGluIHN1YiAoPXNpdGUgc3BlY2lmaWMpIGNvbmZpZ3NcbiAgICBjb25zdCB1cGRhdGVBbGwgPSAoc2V0dGluZzogYW55W10sIGZuOiAoYW55KSA9PiBhbnkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsID0gZ2V0RGVlcFByb3BlcnR5KFVTRVJDT05GSUcsIHNldHRpbmcpXG4gICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgIHNldCguLi5zZXR0aW5nLCBmbih2YWwpKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1YmNvbmZpZ3MgPSBnZXREZWVwUHJvcGVydHkoVVNFUkNPTkZJRywgW1wic3ViY29uZmlnc1wiXSlcbiAgICAgICAgaWYgKHN1YmNvbmZpZ3MpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHN1YmNvbmZpZ3MpXG4gICAgICAgICAgICAgICAgLm1hcChwYXR0ZXJuID0+IFtwYXR0ZXJuLCBnZXRVUkwocGF0dGVybiwgc2V0dGluZyldKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKFtwYXR0ZXJuLCB2YWx1ZV0pID0+IHZhbHVlKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChbcGF0dGVybiwgdmFsdWVdKSA9PlxuICAgICAgICAgICAgICAgICAgICBzZXRVUkwocGF0dGVybiwgLi4uc2V0dGluZywgZm4odmFsdWUpKSxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB1cGRhdGVycyA9IHtcbiAgICAgICAgXCIwLjBcIjogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBCZWZvcmUgd2UgaGFkIGEgY29uZmlnIHN5c3RlbSwgd2UgaGFkIG5tYXBzLCBhbmQgd2UgcHV0IHRoZW0gaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gcm9vdCBuYW1lc3BhY2UgYmVjYXVzZSB3ZSB3ZXJlIHlvdW5nIGFuZCBib2xkLlxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZ2FjeV9ubWFwcyA9IGF3YWl0IGJyb3dzZXIuc3RvcmFnZS5zeW5jLmdldChcIm5tYXBzXCIpXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGxlZ2FjeV9ubWFwcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBVU0VSQ09ORklHLm5tYXBzID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZ2FjeV9ubWFwcy5ubWFwcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFVTRVJDT05GSUcubm1hcHMsXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHNldChcImNvbmZpZ3ZlcnNpb25cIiwgXCIxLjBcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCIxLjBcIjogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmltaXVtZ2kgPSBnZXREZWVwUHJvcGVydHkoVVNFUkNPTkZJRywgW1widmltaXVtLWdpXCJdKVxuICAgICAgICAgICAgaWYgKHZpbWl1bWdpID09PSB0cnVlIHx8IHZpbWl1bWdpID09PSBcInRydWVcIilcbiAgICAgICAgICAgICAgICBzZXQoXCJnaW1vZGVcIiwgXCJuZXh0aW5wdXRcIilcbiAgICAgICAgICAgIGVsc2UgaWYgKHZpbWl1bWdpID09PSBmYWxzZSB8fCB2aW1pdW1naSA9PT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHNldChcImdpbW9kZVwiLCBcImZpcmVmb3hcIilcbiAgICAgICAgICAgIHVuc2V0KFwidmltaXVtLWdpXCIpXG4gICAgICAgICAgICBzZXQoXCJjb25maWd2ZXJzaW9uXCIsIFwiMS4xXCIpXG4gICAgICAgIH0sXG4gICAgICAgIFwiMS4xXCI6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxldmVsdG9zdHI6IHsgW2tleTogbnVtYmVyXTogTG9nZ2luZ0xldmVsIH0gPSB7XG4gICAgICAgICAgICAgICAgMDogXCJuZXZlclwiLFxuICAgICAgICAgICAgICAgIDE6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICAyOiBcIndhcm5pbmdcIixcbiAgICAgICAgICAgICAgICAzOiBcImluZm9cIixcbiAgICAgICAgICAgICAgICA0OiBcImRlYnVnXCIsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2dnaW5nID0gZ2V0RGVlcFByb3BlcnR5KFVTRVJDT05GSUcsIFtcImxvZ2dpbmdcIl0pXG4gICAgICAgICAgICAvLyBsb2dnaW5nIGlzIG5vdCBuZWNlc3NhcmlseSBkZWZpbmVkIGlmIHRoZSB1c2VyIGRpZG4ndCBjaGFuZ2UgZGVmYXVsdCB2YWx1ZXNcbiAgICAgICAgICAgIGlmIChsb2dnaW5nKVxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGxvZ2dpbmcpLmZvckVhY2gobCA9PlxuICAgICAgICAgICAgICAgICAgICBzZXQoXCJsb2dnaW5nXCIsIGwsIGxldmVsdG9zdHJbbG9nZ2luZ1tsXV0pLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIHNldChcImNvbmZpZ3ZlcnNpb25cIiwgXCIxLjJcIilcbiAgICAgICAgfSxcbiAgICAgICAgXCIxLjJcIjogKCkgPT4ge1xuICAgICAgICAgICAgOyBbXCJpZ25vcmVtYXBzXCIsIFwiaW5wdXRtYXBzXCIsIFwiaW1hcHNcIiwgXCJubWFwc1wiXVxuICAgICAgICAgICAgICAgIC5tYXAobWFwbmFtZSA9PiBbXG4gICAgICAgICAgICAgICAgICAgIG1hcG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGdldERlZXBQcm9wZXJ0eShVU0VSQ09ORklHLCBbbWFwbmFtZV0pLFxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgLy8gbWFwb2JqIGlzIHVuZGVmaW5lZCBpZiB0aGUgdXNlciBkaWRuJ3QgZGVmaW5lIGFueSBiaW5kaW5nc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKFttYXBuYW1lLCBtYXBvYmpdKSA9PiBtYXBvYmopXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKFttYXBuYW1lLCBtYXBvYmpdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBlYWNoIG1hcHBpbmdcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMobWFwb2JqKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBvbmx5IHRoZSBvbmVzIHdpdGggaW1fKiBmdW5jdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcG9ialtrZXldLnNlYXJjaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXmltX3woW15hLXpBLVowLTlfLV0paW1fXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgPj0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIHByZWZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goa2V5ID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RGVlcFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVU0VSQ09ORklHLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBvYmpba2V5XS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFJlZ0V4cChcIl5pbV98KFteYS16QS1aMC05Xy1dKWltX1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJDF0ZXh0LlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbWFwbmFtZSwga2V5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBzZXQoXCJjb25maWd2ZXJzaW9uXCIsIFwiMS4zXCIpXG4gICAgICAgIH0sXG4gICAgICAgIFwiMS4zXCI6ICgpID0+IHtcbiAgICAgICAgICAgIDsgW1xuICAgICAgICAgICAgICAgIFwicHJpb3JpdHlcIixcbiAgICAgICAgICAgICAgICBcImhpbnRkZWxheVwiLFxuICAgICAgICAgICAgICAgIFwic2Nyb2xsZHVyYXRpb25cIixcbiAgICAgICAgICAgICAgICBcInR0c3ZvbHVtZVwiLFxuICAgICAgICAgICAgICAgIFwidHRzcmF0ZVwiLFxuICAgICAgICAgICAgICAgIFwidHRzcGl0Y2hcIixcbiAgICAgICAgICAgICAgICBcImp1bXBkZWxheVwiLFxuICAgICAgICAgICAgICAgIFwiaGlzdG9yeXJlc3VsdHNcIixcbiAgICAgICAgICAgIF0uZm9yRWFjaChzZXR0aW5nID0+IHVwZGF0ZUFsbChbc2V0dGluZ10sIHBhcnNlSW50KSlcbiAgICAgICAgICAgIHNldChcImNvbmZpZ3ZlcnNpb25cIiwgXCIxLjRcIilcbiAgICAgICAgfSxcbiAgICAgICAgXCIxLjRcIjogKCkgPT4ge1xuICAgICAgICAgICAgOyAoZ2V0RGVlcFByb3BlcnR5KFVTRVJDT05GSUcsIFtcIm5vaWZyYW1lb25cIl0pIHx8IFtdKS5mb3JFYWNoKFxuICAgICAgICAgICAgICAgIHNpdGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXRVUkwoc2l0ZSwgXCJub2lmcmFtZVwiLCBcInRydWVcIilcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgc2V0KFwiY29uZmlndmVyc2lvblwiLCBcIjEuNVwiKVxuICAgICAgICB9LFxuICAgICAgICBcIjEuNVwiOiAoKSA9PiB7XG4gICAgICAgICAgICB1bnNldChcImV4YWxpYXNlc1wiLCBcInRhYlwiKVxuICAgICAgICAgICAgc2V0KFwiY29uZmlndmVyc2lvblwiLCBcIjEuNlwiKVxuICAgICAgICB9LFxuICAgICAgICBcIjEuNlwiOiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVTZXR0aW5nID0gbWFwT2JqID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hcE9iaikgcmV0dXJuIG1hcE9ialxuICAgICAgICAgICAgICAgIGlmIChtYXBPYmpbXCIgXCJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwT2JqW1wiPFNwYWNlPlwiXSA9IG1hcE9ialtcIiBcIl1cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG1hcE9ialtcIiBcIl1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOyBbXG4gICAgICAgICAgICAgICAgICAgIFwiPEEtID5cIixcbiAgICAgICAgICAgICAgICAgICAgXCI8Qy0gPlwiLFxuICAgICAgICAgICAgICAgICAgICBcIjxNLSA+XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiPFMtID5cIixcbiAgICAgICAgICAgICAgICAgICAgXCI8QUMtID5cIixcbiAgICAgICAgICAgICAgICAgICAgXCI8QU0tID5cIixcbiAgICAgICAgICAgICAgICAgICAgXCI8QVMtID5cIixcbiAgICAgICAgICAgICAgICAgICAgXCI8Q00tID5cIixcbiAgICAgICAgICAgICAgICAgICAgXCI8Q1MtID5cIixcbiAgICAgICAgICAgICAgICAgICAgXCI8TVMtID5cIixcbiAgICAgICAgICAgICAgICBdLmZvckVhY2goYmluZGluZyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXBPYmpbYmluZGluZ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYmluZGluZy5yZXBsYWNlKFwiIFwiLCBcIlNwYWNlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBPYmpba2V5XSA9IG1hcE9ialtiaW5kaW5nXVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG1hcE9ialtiaW5kaW5nXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwT2JqXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA7IFtcIm5tYXBzXCIsIFwiZXhtYXBzXCIsIFwiaW1hcHNcIiwgXCJpbnB1dG1hcHNcIiwgXCJpZ25vcmVtYXBzXCJdLmZvckVhY2goXG4gICAgICAgICAgICAgICAgc2V0dGluZ05hbWUgPT4gdXBkYXRlQWxsKFtzZXR0aW5nTmFtZV0sIHVwZGF0ZVNldHRpbmcpLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgc2V0KFwiY29uZmlndmVyc2lvblwiLCBcIjEuN1wiKVxuICAgICAgICB9LFxuICAgIH1cbiAgICBpZiAoIWdldChcImNvbmZpZ3ZlcnNpb25cIikpIHNldChcImNvbmZpZ3ZlcnNpb25cIiwgXCIwLjBcIilcbiAgICBjb25zdCB1cGRhdGV0ZXN0ID0gdiA9PiB7XG4gICAgICAgIHJldHVybiB1cGRhdGVycy5oYXNPd25Qcm9wZXJ0eSh2KSAmJiB1cGRhdGVyc1t2XSBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgfVxuICAgIHdoaWxlICh1cGRhdGV0ZXN0KGdldChcImNvbmZpZ3ZlcnNpb25cIikpKSB7XG4gICAgICAgIGF3YWl0IHVwZGF0ZXJzW2dldChcImNvbmZpZ3ZlcnNpb25cIildKClcbiAgICB9XG59XG5cbi8qKiBSZWFkIGFsbCB1c2VyIGNvbmZpZ3VyYXRpb24gZnJvbSBzdG9yYWdlIEFQSSB0aGVuIG5vdGlmeSBhbnkgd2FpdGluZyBhc3luY2hyb25vdXMgY2FsbHNcblxuICAgIGFzeW5jaHJvbm91cyBjYWxscyBnZW5lcmF0ZWQgYnkgZ2V0QXN5bmMuXG4gICAgQGhpZGRlblxuICovXG5hc3luYyBmdW5jdGlvbiBpbml0KCkge1xuICAgIGNvbnN0IHN5bmNDb25maWcgPSBhd2FpdCBicm93c2VyLnN0b3JhZ2Uuc3luYy5nZXQoQ09ORklHTkFNRSlcbiAgICBzY2hsZXBwKHN5bmNDb25maWdbQ09ORklHTkFNRV0pXG4gICAgLy8gTG9jYWwgc3RvcmFnZSBvdmVycmlkZXMgc3luY1xuICAgIGNvbnN0IGxvY2FsQ29uZmlnID0gYXdhaXQgYnJvd3Nlci5zdG9yYWdlLmxvY2FsLmdldChDT05GSUdOQU1FKVxuICAgIHNjaGxlcHAobG9jYWxDb25maWdbQ09ORklHTkFNRV0pXG5cbiAgICBhd2FpdCB1cGRhdGUoKVxuICAgIElOSVRJQUxJU0VEID0gdHJ1ZVxuICAgIGZvciAoY29uc3Qgd2FpdGVyIG9mIFdBSVRFUlMpIHtcbiAgICAgICAgd2FpdGVyKClcbiAgICB9XG59XG5cbi8qKiBAaGlkZGVuICovXG5jb25zdCBjaGFuZ2VMaXN0ZW5lcnMgPSBuZXcgTWFwKClcblxuLyoqIEBoaWRkZW5cbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIGEgXCJ0b3BsZXZlbFwiIGNvbmZpZyBzZXR0aW5nIChpLmUuIFwibm1hcHNcIiwgbm90IFwibm1hcHMualwiKVxuICogQHBhcmFtIGxpc3RlbmVyIEEgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSB2YWx1ZSBvZiAkbmFtZSBpcyBtb2RpZmllZCBpbiB0aGUgY29uZmlnLiBUYWtlcyB0aGUgcHJldmlvdXMgYW5kIG5ldyB2YWx1ZSBhcyBwYXJhbWV0ZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQ2hhbmdlTGlzdGVuZXI8UCBleHRlbmRzIGtleW9mIGRlZmF1bHRfY29uZmlnPihcbiAgICBuYW1lOiBQLFxuICAgIGxpc3RlbmVyOiAob2xkOiBkZWZhdWx0X2NvbmZpZ1tQXSwgbmV3dzogZGVmYXVsdF9jb25maWdbUF0pID0+IHZvaWQsXG4pIHtcbiAgICBsZXQgYXJyID0gY2hhbmdlTGlzdGVuZXJzLmdldChuYW1lKVxuICAgIGlmICghYXJyKSB7XG4gICAgICAgIGFyciA9IFtdXG4gICAgICAgIGNoYW5nZUxpc3RlbmVycy5zZXQobmFtZSwgYXJyKVxuICAgIH1cbiAgICBhcnIucHVzaChsaXN0ZW5lcilcbn1cblxuLyoqIEBoaWRkZW5cbiAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXJzIHNldCB3aXRoIGFkZENoYW5nZUxpc3RlbmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDaGFuZ2VMaXN0ZW5lcjxQIGV4dGVuZHMga2V5b2YgZGVmYXVsdF9jb25maWc+KFxuICAgIG5hbWU6IFAsXG4gICAgbGlzdGVuZXI6IChvbGQ6IGRlZmF1bHRfY29uZmlnW1BdLCBuZXd3OiBkZWZhdWx0X2NvbmZpZ1tQXSkgPT4gdm9pZCxcbikge1xuICAgIGNvbnN0IGFyciA9IGNoYW5nZUxpc3RlbmVycy5nZXQobmFtZSlcbiAgICBpZiAoIWFycikgcmV0dXJuXG4gICAgY29uc3QgaSA9IGFyci5pbmRleE9mKGxpc3RlbmVyKVxuICAgIGlmIChpID49IDApIGFyci5zcGxpY2UoaSwgMSlcbn1cblxuLyoqIFBhcnNlIHRoZSBjb25maWcgaW50byBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIC50cmlkYWN0eWxyYyBjb25maWcgZmlsZS5cbiAgICBUcmllcyB0byBwYXJzZSB0aGUgY29uZmlnIGludG8gc2VjdGlvbmFibGUgY2h1bmtzIGJhc2VkIG9uIGtleXdvcmRzLlxuICAgIEJpbmRzLCBhbGlhc2VzLCBhdXRvY21kcyBhbmQgbG9nZ2luZyBzZXR0aW5ncyBlYWNoIGhhdmUgdGhlaXIgb3duIHNlY3Rpb24gd2hpbGUgdGhlIHJlc3QgYXJlIGR1bXBlZCBpbnRvIFwiR2VuZXJhbCBTZXR0aW5nc1wiLlxuXG4gICAgQHJldHVybnMgc3RyaW5nIFRoZSBwYXJzZWQgY29uZmlnIGZpbGUuXG5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29uZmlnKCk6IHN0cmluZyB7XG4gICAgbGV0IHAgPSB7XG4gICAgICAgIGNvbmY6IFtdLFxuICAgICAgICBiaW5kczogW10sXG4gICAgICAgIGFsaWFzZXM6IFtdLFxuICAgICAgICBzdWJjb25maWdzOiBbXSxcbiAgICAgICAgYXVjbWRzOiBbXSxcbiAgICAgICAgYXVjb25zOiBbXSxcbiAgICAgICAgbG9nZ2luZzogW10sXG4gICAgfVxuXG4gICAgcCA9IHBhcnNlQ29uZmlnSGVscGVyKFVTRVJDT05GSUcsIHApXG5cbiAgICBjb25zdCBzID0ge1xuICAgICAgICBnZW5lcmFsOiBgYCxcbiAgICAgICAgYmluZHM6IGBgLFxuICAgICAgICBhbGlhc2VzOiBgYCxcbiAgICAgICAgYXVjbWRzOiBgYCxcbiAgICAgICAgYXVjb25zOiBgYCxcbiAgICAgICAgc3ViY29uZmlnczogYGAsXG4gICAgICAgIGxvZ2dpbmc6IGBgLFxuICAgIH1cblxuICAgIGlmIChwLmNvbmYubGVuZ3RoID4gMClcbiAgICAgICAgcy5nZW5lcmFsID0gYFwiIEdlbmVyYWwgU2V0dGluZ3NcXG4ke3AuY29uZi5qb2luKFwiXFxuXCIpfVxcblxcbmBcbiAgICBpZiAocC5iaW5kcy5sZW5ndGggPiAwKSBzLmJpbmRzID0gYFwiIEJpbmRzXFxuJHtwLmJpbmRzLmpvaW4oXCJcXG5cIil9XFxuXFxuYFxuICAgIGlmIChwLmFsaWFzZXMubGVuZ3RoID4gMClcbiAgICAgICAgcy5hbGlhc2VzID0gYFwiIEFsaWFzZXNcXG4ke3AuYWxpYXNlcy5qb2luKFwiXFxuXCIpfVxcblxcbmBcbiAgICBpZiAocC5hdWNtZHMubGVuZ3RoID4gMCkgcy5hdWNtZHMgPSBgXCIgQXV0b2NtZHNcXG4ke3AuYXVjbWRzLmpvaW4oXCJcXG5cIil9XFxuXFxuYFxuICAgIGlmIChwLmF1Y29ucy5sZW5ndGggPiAwKVxuICAgICAgICBzLmF1Y29ucyA9IGBcIiBBdXRvY29udGFpbmVyc1xcbiR7cC5hdWNvbnMuam9pbihcIlxcblwiKX1cXG5cXG5gXG4gICAgaWYgKHAuc3ViY29uZmlncy5sZW5ndGggPiAwKVxuICAgICAgICBzLnN1YmNvbmZpZ3MgPSBgXCIgU3ViY29uZmlnIFNldHRpbmdzXFxuJHtwLnN1YmNvbmZpZ3Muam9pbihcIlxcblwiKX1cXG5cXG5gXG4gICAgaWYgKHAubG9nZ2luZy5sZW5ndGggPiAwKVxuICAgICAgICBzLmxvZ2dpbmcgPSBgXCIgTG9nZ2luZ1xcbiR7cC5sb2dnaW5nLmpvaW4oXCJcXG5cIil9XFxuXFxuYFxuXG4gICAgY29uc3QgZnRkZXRlY3QgPSBgXCIgdmltOiBzZXQgZmlsZXR5cGU9dmltOmBcblxuICAgIHJldHVybiBgJHtzLmdlbmVyYWx9JHtzLmJpbmRzfSR7cy5zdWJjb25maWdzfSR7cy5hbGlhc2VzfSR7cy5hdWNtZHN9JHtcbiAgICAgICAgcy5hdWNvbnNcbiAgICB9JHtzLmxvZ2dpbmd9JHtmdGRldGVjdH1gXG59XG5cbmNvbnN0IHBhcnNlQ29uZmlnSGVscGVyID0gKHBjb25mLCBwYXJzZW9iaikgPT4ge1xuICAgIGZvciAoY29uc3QgaSBpbiBwY29uZikge1xuICAgICAgICBpZiAodHlwZW9mIHBjb25mW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgcGFyc2VvYmouY29uZi5wdXNoKGBzZXQgJHtpfSAke3Bjb25mW2ldfWApXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIE9iamVjdC5rZXlzKHBjb25mW2ldKSkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBcIm5tYXBzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBjb25mW2ldW2VdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlb2JqLmJpbmRzLnB1c2goYGJpbmQgJHtlfSAke3Bjb25mW2ldW2VdfWApXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZW9iai5iaW5kcy5wdXNoKGB1bmJpbmQgJHtlfWApXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IFwiZXhtYXBzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBjb25mW2ldW2VdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlb2JqLmJpbmRzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYGJpbmQgLS1tb2RlPWV4ICR7ZX0gJHtwY29uZltpXVtlXX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VvYmouYmluZHMucHVzaChgdW5iaW5kIC0tbW9kZT1leCAke2V9YClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gXCJpZ25vcmVtYXBzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBjb25mW2ldW2VdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlb2JqLmJpbmRzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYGJpbmQgLS1tb2RlPWlnbm9yZSAke2V9ICR7cGNvbmZbaV1bZV19YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlb2JqLmJpbmRzLnB1c2goYHVuYmluZCAtLW1vZGU9aWdub3JlICR7ZX1gKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpID09PSBcImltYXBzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBjb25mW2ldW2VdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlb2JqLmJpbmRzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYGJpbmQgLS1tb2RlPWluc2VydCAke2V9ICR7cGNvbmZbaV1bZV19YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlb2JqLmJpbmRzLnB1c2goYHVuYmluZCAtLW1vZGU9aW5zZXJ0ICR7ZX1gKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpID09PSBcImlucHV0bWFwc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwY29uZltpXVtlXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZW9iai5iaW5kcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBiaW5kIC0tbW9kZT1pbnB1dCAke2V9ICR7cGNvbmZbaV1bZV19YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlb2JqLmJpbmRzLnB1c2goYHVuYmluZCAtLW1vZGU9aW5wdXQgJHtlfWApXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IFwiaGludG1hcHNcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGNvbmZbaV1bZV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VvYmouYmluZHMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgYmluZCAtLW1vZGU9aGludCAke2V9ICR7cGNvbmZbaV1bZV19YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlb2JqLmJpbmRzLnB1c2goYHVuYmluZCAtLW1vZGU9aGludCAke2V9YClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gXCJzdWJjb25maWdzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VvYmouc3ViY29uZmlncy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgYGpzIHRyaS5jb25maWcuc2V0KFwiJHtpfVwiLCB7XCIke2V9XCI6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGNvbmZbaV1bZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICApfX0pYCxcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gXCJleGFsaWFzZXNcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHJlYWxseSB1c2VmdWwgaWYgbWFwcGluZyB0aGUgZW50aXJlIGNvbmZpZyBhbmQgbm90IGp1c3QgcGNvbmYuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlID09PSBcImFsaWFzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlb2JqLmFsaWFzZXMucHVzaChgY29tbWFuZCAke2V9ICR7cGNvbmZbaV1bZV19YClcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlb2JqLmFsaWFzZXMucHVzaChgYWxpYXMgJHtlfSAke3Bjb25mW2ldW2VdfWApXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IFwiYXV0b2NtZHNcIikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGEgb2YgT2JqZWN0LmtleXMocGNvbmZbaV1bZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZW9iai5hdWNtZHMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgYXV0b2NtZCAke2V9ICR7YX0gJHtwY29uZltpXVtlXVthXX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpID09PSBcImF1dG9jb250YWluXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VvYmouYXVjb25zLnB1c2goYGF1dG9jb250YWluICR7ZX0gJHtwY29uZltpXVtlXX1gKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gXCJsb2dnaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFwIHRoZSBpbnQgdmFsdWVzIGluIGUgdG8gYSBsb2cgbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxldmVsXG4gICAgICAgICAgICAgICAgICAgIGlmIChwY29uZltpXVtlXSA9PT0gMCkgbGV2ZWwgPSBcIm5ldmVyXCJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBjb25mW2ldW2VdID09PSAxKSBsZXZlbCA9IFwiZXJyb3JcIlxuICAgICAgICAgICAgICAgICAgICBpZiAocGNvbmZbaV1bZV0gPT09IDIpIGxldmVsID0gXCJ3YXJuaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBjb25mW2ldW2VdID09PSAzKSBsZXZlbCA9IFwiaW5mb1wiXG4gICAgICAgICAgICAgICAgICAgIGlmIChwY29uZltpXVtlXSA9PT0gNCkgbGV2ZWwgPSBcImRlYnVnXCJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VvYmoubG9nZ2luZy5wdXNoKGBzZXQgbG9nZ2luZy4ke2V9ICR7bGV2ZWx9YClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZW9iai5jb25mLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICBganMgdHJpLmNvbmZpZy5zZXQoXCIke2l9XCIsIHtcIiR7ZX1cIjogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwY29uZltpXVtlXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICl9fSlgLFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZW9ialxufVxuXG4vLyBMaXN0ZW4gZm9yIGNoYW5nZXMgdG8gdGhlIHN0b3JhZ2UgYW5kIHVwZGF0ZSB0aGUgVVNFUkNPTkZJRyBpZiBhcHByb3ByaWF0ZS5cbi8vIFRPRE86IEJVRyEgU3luYyBhbmQgbG9jYWwgc3RvcmFnZSBhcmUgbWVyZ2VkIGF0IHN0YXJ0dXAsIGJ1dCBub3QgYnkgdGhpcyB0aGluZy5cbmJyb3dzZXIuc3RvcmFnZS5vbkNoYW5nZWQuYWRkTGlzdGVuZXIoYXN5bmMgKGNoYW5nZXMsIGFyZWFuYW1lKSA9PiB7XG4gICAgaWYgKENPTkZJR05BTUUgaW4gY2hhbmdlcykge1xuICAgICAgICBjb25zdCBkZWZhdWx0Q29uZiA9IG5ldyBkZWZhdWx0X2NvbmZpZygpXG4gICAgICAgIGNvbnN0IG9sZCA9IFVTRVJDT05GSUdcblxuICAgICAgICBmdW5jdGlvbiB0cmlnZ2VyQ2hhbmdlTGlzdGVuZXJzKGtleSkge1xuICAgICAgICAgICAgY29uc3QgYXJyID0gY2hhbmdlTGlzdGVuZXJzLmdldChrZXkpXG4gICAgICAgICAgICBpZiAoYXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IG9sZFtrZXldID09PSB1bmRlZmluZWQgPyBkZWZhdWx0Q29uZltrZXldIDogb2xkW2tleV1cbiAgICAgICAgICAgICAgICBhcnIuZm9yRWFjaChmID0+IGYodiwgVVNFUkNPTkZJR1trZXldKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5ld1ZhbHVlIGlzIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgYnJvd3Nlci5zdG9yYWdlLkFSRUFOQU1FLmNsZWFyKClcbiAgICAgICAgaWYgKGNoYW5nZXNbQ09ORklHTkFNRV0ubmV3VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gQSBrZXkgaGFzIGJlZW4gOnVuc2V0IGlmIGl0IGV4aXN0cyBpbiBVU0VSQ09ORklHIGFuZCBkb2Vzbid0IGluIGNoYW5nZXMgYW5kIGlmIGl0cyB2YWx1ZSBpbiBVU0VSQ09ORklHIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBvbmUgaXQgaGFzIGluIGRlZmF1bHRfY29uZmlnXG4gICAgICAgICAgICBjb25zdCB1bnNldEtleXMgPSBPYmplY3Qua2V5cyhVU0VSQ09ORklHKS5maWx0ZXIoXG4gICAgICAgICAgICAgICAgayA9PlxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzW0NPTkZJR05BTUVdLm5ld1ZhbHVlW2tdID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoVVNFUkNPTkZJR1trXSkgIT09XG4gICAgICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShkZWZhdWx0Q29uZltrXSksXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIC8vIEEga2V5IGhhcyBjaGFuZ2VkIGlmIGl0IGlzIGRlZmluZWQgaW4gVVNFUkNPTkZJRyBhbmQgaXRzIHZhbHVlIGluIFVTRVJDT05GSUcgaXMgZGlmZmVyZW50IGZyb20gdGhlIG9uZSBpbiBgY2hhbmdlc2Agb3IgaWYgdGhlIHZhbHVlIGluIGRlZmF1bHRDb25mIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBvbmUgaW4gYGNoYW5nZXNgXG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VkS2V5cyA9IE9iamVjdC5rZXlzKFxuICAgICAgICAgICAgICAgIGNoYW5nZXNbQ09ORklHTkFNRV0ubmV3VmFsdWUsXG4gICAgICAgICAgICApLmZpbHRlcihcbiAgICAgICAgICAgICAgICBrID0+XG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgVVNFUkNPTkZJR1trXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBVU0VSQ09ORklHW2tdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBkZWZhdWx0Q29uZltrXSxcbiAgICAgICAgICAgICAgICAgICAgKSAhPT0gSlNPTi5zdHJpbmdpZnkoY2hhbmdlc1tDT05GSUdOQU1FXS5uZXdWYWx1ZVtrXSksXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIFVTRVJDT05GSUcgPSBjaGFuZ2VzW0NPTkZJR05BTUVdLm5ld1ZhbHVlXG5cbiAgICAgICAgICAgIC8vIFRyaWdnZXIgbGlzdGVuZXJzXG4gICAgICAgICAgICB1bnNldEtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyciA9IGNoYW5nZUxpc3RlbmVycy5nZXQoa2V5KVxuICAgICAgICAgICAgICAgIGlmIChhcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyLmZvckVhY2goZiA9PiBmKG9sZFtrZXldLCBkZWZhdWx0Q29uZltrZXldKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBjaGFuZ2VkS2V5cy5mb3JFYWNoKGtleSA9PiB0cmlnZ2VyQ2hhbmdlTGlzdGVuZXJzKGtleSkpXG4gICAgICAgIH0gZWxzZSBpZiAoYXJlYW5hbWUgPT09IChhd2FpdCBnZXQoXCJzdG9yYWdlbG9jXCIpKSkge1xuICAgICAgICAgICAgLy8gSWYgbmV3VmFsdWUgaXMgdW5kZWZpbmVkIGFuZCBBUkVBTkFNRSBpcyB0aGUgc2FtZSB2YWx1ZSBhcyBTVE9SQUdFTE9DLCB0aGUgdXNlciB3YW50cyB0byBjbGVhbiB0aGVpciBjb25maWdcbiAgICAgICAgICAgIFVTRVJDT05GSUcgPSBvKHt9KVxuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhvbGQpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihrZXkgPT4gb2xkW2tleV0gIT09IGRlZmF1bHRDb25mW2tleV0pXG4gICAgICAgICAgICAgICAgLmZvckVhY2goa2V5ID0+IHRyaWdnZXJDaGFuZ2VMaXN0ZW5lcnMoa2V5KSlcbiAgICAgICAgfVxuICAgIH1cbn0pXG5cbmluaXQoKVxuIiwiaW1wb3J0IHsgYnJvd3NlckJnIH0gZnJvbSBcIkBzcmMvbGliL3dlYmV4dFwiXG5pbXBvcnQgKiBhcyBGdXNlIGZyb20gXCJmdXNlLmpzXCJcbmltcG9ydCAqIGFzIExvZ2dpbmcgZnJvbSBcIkBzcmMvbGliL2xvZ2dpbmdcIlxuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dpbmcuTG9nZ2VyKFwiY29udGFpbmVyc1wiKVxuXG4vLyBBcyBwZXIgTW96aWxsYSBzcGVjaWZpY2F0aW9uOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9BZGQtb25zL1dlYkV4dGVuc2lvbnMvQVBJL2NvbnRleHR1YWxJZGVudGl0aWVzL0NvbnRleHR1YWxJZGVudGl0eVxuY29uc3QgQ29udGFpbmVyQ29sb3IgPSBbXG4gICAgXCJibHVlXCIsXG4gICAgXCJ0dXJxdW9pc2VcIixcbiAgICBcImdyZWVuXCIsXG4gICAgXCJ5ZWxsb3dcIixcbiAgICBcIm9yYW5nZVwiLFxuICAgIFwicmVkXCIsXG4gICAgXCJwaW5rXCIsXG4gICAgXCJwdXJwbGVcIixcbl1cblxuLy8gQXMgcGVyIE1vemlsbGEgc3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvQWRkLW9ucy9XZWJFeHRlbnNpb25zL0FQSS9jb250ZXh0dWFsSWRlbnRpdGllcy9Db250ZXh0dWFsSWRlbnRpdHlcbmNvbnN0IENvbnRhaW5lckljb24gPSBbXG4gICAgXCJmaW5nZXJwcmludFwiLFxuICAgIFwiYnJpZWZjYXNlXCIsXG4gICAgXCJkb2xsYXJcIixcbiAgICBcImNhcnRcIixcbiAgICBcImNpcmNsZVwiLFxuICAgIFwiZ2lmdFwiLFxuICAgIFwidmFjYXRpb25cIixcbiAgICBcImZvb2RcIixcbiAgICBcImZydWl0XCIsXG4gICAgXCJwZXRcIixcbiAgICBcInRyZWVcIixcbiAgICBcImNoaWxsXCIsXG5dXG5cbmNvbnN0IERlZmF1bHRDb250YWluZXIgPSBPYmplY3QuZnJlZXplKFxuICAgIGZyb21TdHJpbmcoXCJkZWZhdWx0XCIsIFwiaW52aXNpYmxlXCIsIFwibm9pY29uZFwiLCBcImZpcmVmb3gtZGVmYXVsdFwiKSxcbilcblxuLyoqIENyZWF0ZXMgYSBjb250YWluZXIgZnJvbSB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlcnMuRG9lcyBub3QgYWxsb3cgbXVsdGlwbGUgY29udGFpbmVycyB3aXRoIHRoZSBzYW1lIG5hbWUuXG4gICAgQHBhcmFtIG5hbWUgIFRoZSBjb250YWluZXIgbmFtZS5cbiAgICBAcGFyYW0gY29sb3IgIFRoZSBjb250YWluZXIgY29sb3IsIG11c3QgYmUgb25lIG9mOiBcImJsdWVcIiwgXCJ0dXJxdW9pc2VcIiwgXCJncmVlblwiLCBcInllbGxvd1wiLCBcIm9yYW5nZVwiLCBcInJlZFwiLCBcInBpbmtcIiBvciBcInB1cnBsZVwiLiBJZiBub3RoaW5nIGlzIHN1cHBsaWVkLCBpdCBzZWxlY3RzIG9uZSBhdCByYW5kb20uXG4gICAgQHBhcmFtIGljb24gIFRoZSBjb250YWluZXIgaWNvbiwgbXVzdCBiZSBvbmUgb2Y6IFwiZmluZ2VycHJpbnRcIiwgXCJicmllZmNhc2VcIiwgXCJkb2xsYXJcIiwgXCJjYXJ0XCIsIFwiY2lyY2xlXCIsIFwiZ2lmdFwiLCBcInZhY2F0aW9uXCIsIFwiZm9vZFwiLCBcImZydWl0XCIsIFwicGV0XCIsIFwidHJlZVwiLCBcImNoaWxsXCJcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZShcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgY29sb3IgPSBcInJhbmRvbVwiLFxuICAgIGljb24gPSBcImZpbmdlcnByaW50XCIsXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGlmIChjb2xvciA9PT0gXCJyYW5kb21cIikgY29sb3IgPSBjaG9vc2VSYW5kb21Db2xvcigpXG4gICAgY29uc3QgY29udGFpbmVyID0gZnJvbVN0cmluZyhuYW1lLCBjb2xvciwgaWNvbilcbiAgICAvLyBicm93c2VyLmNvbnRleHR1YWxJZGVudGl0aWVzLmNyZWF0ZSBkb2VzIG5vdCBhY2NlcHQgYSBjb29raWVTdG9yZUlkIHByb3BlcnR5LlxuICAgIGRlbGV0ZSBjb250YWluZXIuY29va2llU3RvcmVJZFxuICAgIGxvZ2dlci5kZWJ1Zyhjb250YWluZXIpXG5cbiAgICBpZiAoYXdhaXQgZXhpc3RzKG5hbWUpKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgW0NvbnRhaW5lci5jcmVhdGVdIGNvbnRhaW5lciBhbHJlYWR5IGV4aXN0cyAke2NvbnRhaW5lcn1gKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgW0NvbnRhaW5lci5jcmVhdGVdIGNvbnRhaW5lciBhbHJlYWR5IGV4aXN0cywgYWJvcnRpbmcuYCxcbiAgICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGJyb3dzZXIuY29udGV4dHVhbElkZW50aXRpZXMuY3JlYXRlKGNvbnRhaW5lcilcbiAgICAgICAgcmV0dXJuIHJlcy5jb29raWVTdG9yZUlkXG4gICAgfVxufVxuXG4vKiogUmVtb3ZlcyBzcGVjaWZpZWQgY29udGFpbmVyLiBObyBmdXp6eSBtYXRjaGluZyBpcyBpbnRlbnRpb25hbCBoZXJlLiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY29udGFpbmVycyB3aXRoIHRoZSBzYW1lIG5hbWUgKGFsbG93ZWQgYnkgb3RoZXIgY29udGFpbmVyIHBsdWdpbnMpLCBpdCBjaG9vc2VzIHRoZSBvbmUgd2l0aCB0aGUgbG93ZXN0IGNvb2tpZVN0b3JlSWRcbiAgICBAcGFyYW0gbmFtZSBUaGUgY29udGFpbmVyIG5hbWVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbW92ZShuYW1lOiBzdHJpbmcpIHtcbiAgICBsb2dnZXIuZGVidWcobmFtZSlcbiAgICBjb25zdCBpZCA9IGF3YWl0IGdldElkKG5hbWUpXG4gICAgY29uc3QgcmVzID0gYXdhaXQgYnJvd3Nlci5jb250ZXh0dWFsSWRlbnRpdGllcy5yZW1vdmUoaWQpXG4gICAgbG9nZ2VyLmRlYnVnKFwiW0NvbnRhaW5lci5yZW1vdmVdIHJlbW92ZWQgY29udGFpbmVyOlwiLCByZXMuY29va2llU3RvcmVJZClcbn1cblxuLyoqIFVwZGF0ZXMgdGhlIHNwZWNpZmllZCBjb250YWluZXIuXG4gICAgVE9ETzogcGFzcyBhbiBvYmplY3QgdG8gdGhpcyB3aGVuIHRyaWRhY3R5bCBnZXRzIHByb3BlciBmbGFnIHBhcnNpbmdcbiAgICBOT1RFOiB3aGlsZSBicm93c2VyLmNvbnRleHR1YWxJZGVudGl0aWVzLmNyZWF0ZSBkb2VzIGNoZWNrIGZvciB2YWxpZCBjb2xvci9pY29uIGNvbWJvcywgYnJvd3Nlci5jb250ZXh0dWFsSWRlbnRpdGllcy51cGRhdGUgZG9lcyBub3QuXG4gICAgQHBhcmFtIGNvbnRhaW5lcklkIEV4cGVjdHMgYSBjb29raWVTdHJpbmdJZCBlLmcuIFwiZmlyZWZveC1jb250YWluZXItblwiLlxuICAgIEBwYXJhbSBuYW1lIHRoZSBuZXcgbmFtZSBvZiB0aGUgY29udGFpbmVyXG4gICAgQHBhcmFtIGNvbG9yIHRoZSBuZXcgY29sb3Igb2YgdGhlIGNvbnRhaW5lclxuICAgIEBwYXJhbSBpY29uIHRoZSBuZXcgaWNvbiBvZiB0aGUgY29udGFpbmVyXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGUoXG4gICAgY29udGFpbmVySWQ6IHN0cmluZyxcbiAgICB1cGRhdGVPYmo6IHtcbiAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgIGNvbG9yOiBicm93c2VyLmNvbnRleHR1YWxJZGVudGl0aWVzLklkZW50aXR5Q29sb3JcbiAgICAgICAgaWNvbjogYnJvd3Nlci5jb250ZXh0dWFsSWRlbnRpdGllcy5JZGVudGl0eUljb25cbiAgICB9LFxuKSB7XG4gICAgaWYgKGlzVmFsaWRDb2xvcih1cGRhdGVPYmouY29sb3IpICYmIGlzVmFsaWRJY29uKHVwZGF0ZU9iai5pY29uKSkge1xuICAgICAgICBicm93c2VyLmNvbnRleHR1YWxJZGVudGl0aWVzLnVwZGF0ZShjb250YWluZXJJZCwgdXBkYXRlT2JqKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zyh1cGRhdGVPYmopXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIltDb250YWluZXIudXBkYXRlXSBpbnZhbGlkIGNvbnRhaW5lciBpY29uIG9yIGNvbG9yXCIpXG4gICAgfVxufVxuXG4vKiogR2V0cyBhIGNvbnRhaW5lciBvYmplY3QgZnJvbSBhIHN1cHBsaWVkIGNvbnRhaW5lciBpZCBzdHJpbmcuIElmIG5vIGNvbnRhaW5lciBjb3JyZXNwb25kcyB0byBjb250YWluZXJJZCwgcmV0dXJucyBhIGRlZmF1bHQgZW1wdHkgY29udGFpbmVyLlxuICAgIEBwYXJhbSBjb250YWluZXJJZCBFeHBlY3RzIGEgY29va2llU3RyaW5nSWQgZS5nLiBcImZpcmVmb3gtY29udGFpbmVyLW5cIlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RnJvbUlkKFxuICAgIGNvbnRhaW5lcklkOiBzdHJpbmcsXG4pOiBQcm9taXNlPGJyb3dzZXIuY29udGV4dHVhbElkZW50aXRpZXMuQ29udGV4dHVhbElkZW50aXR5PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGJyb3dzZXJCZy5jb250ZXh0dWFsSWRlbnRpdGllcy5nZXQoY29udGFpbmVySWQpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gRGVmYXVsdENvbnRhaW5lclxuICAgIH1cbn1cblxuLyoqIEZldGNoZXMgYWxsIGNvbnRhaW5lcnMgZnJvbSBGaXJlZm94J3MgY29udGV4dHVhbCBpZGVudGl0aWVzIEFQSSBhbmQgY2hlY2tzIGlmIG9uZSBleGlzdHMgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXG4gICAgTm90ZTogVGhpcyBvcGVyYXRpb24gaXMgZW50aXJlbHkgY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICBAcGFyYW0gc3RyaW5nIGNuYW1lXG4gICAgQHJldHVybnMgYm9vbGVhbiBSZXR1cm5zIHRydWUgd2hlbiBjbmFtZSBtYXRjaGVzIGFuIGV4aXN0aW5nIGNvbnRhaW5lciBvciBvbiBxdWVyeSBlcnJvci5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4aXN0cyhjbmFtZTogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgbGV0IGV4aXN0cyA9IGZhbHNlXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY29udGFpbmVycyA9IGF3YWl0IGdldEFsbCgpXG4gICAgICAgIGNvbnN0IHJlcyA9IGNvbnRhaW5lcnMuZmlsdGVyKGMgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGMubmFtZS50b0xvd2VyQ2FzZSgpID09PSBjbmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIH0pXG4gICAgICAgIGlmIChyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZXhpc3RzID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBleGlzdHMgPSB0cnVlIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCBhY2NpZGVudGFsbHkgYnJlYWsgdGhlIGNvbnN0cmFpbnQgb24gcXVlcnkgZXJyb3IuXG4gICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgIFwiW0NvbnRhaW5lci5leGlzdHNdIEVycm9yIHF1ZXJ5aW5nIGNvbnRleHR1YWxJZGVudGl0aWVzOlwiLFxuICAgICAgICAgICAgZSxcbiAgICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gZXhpc3RzXG59XG5cbi8qKiBUYWtlcyBzdHJpbmcgcGFyYW1ldGVycyBhbmQgcmV0dXJucyB0aGVtIGFzIGEgcHNldWRvIGNvbnRhaW5lciBvYmplY3RcbiAgICBmb3IgdXNlIGluIG90aGVyIGZ1bmN0aW9ucyBpbiB0aGUgbGlicmFyeS5cbiAgICBAcGFyYW0gbmFtZVxuICAgIEBwYXJhbSBjb2xvclxuICAgIEBwYXJhbSBpY29uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU3RyaW5nKFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBjb2xvcjogc3RyaW5nLFxuICAgIGljb246IHN0cmluZyxcbiAgICBpZDogc3RyaW5nID0gXCJcIixcbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGNvbG9yOiBjb2xvciBhcyBicm93c2VyLmNvbnRleHR1YWxJZGVudGl0aWVzLklkZW50aXR5Q29sb3IsXG4gICAgICAgIGljb246IGljb24gYXMgYnJvd3Nlci5jb250ZXh0dWFsSWRlbnRpdGllcy5JZGVudGl0eUljb24sXG4gICAgICAgIGNvb2tpZVN0b3JlSWQ6IGlkLFxuICAgIH0gYXMgYnJvd3Nlci5jb250ZXh0dWFsSWRlbnRpdGllcy5Db250ZXh0dWFsSWRlbnRpdHkgLy8gcnVsZXMgYXJlIG1hZGUgdG8gYmUgYnJva2VuXG59XG5cbi8qKlxuICogIEByZXR1cm5zIEFuIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIGFsbCBjb250YWluZXJzLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxsKCk6IFByb21pc2U8YW55W10+IHtcbiAgICByZXR1cm4gYnJvd3Nlci5jb250ZXh0dWFsSWRlbnRpdGllcy5xdWVyeSh7fSlcbn1cblxuLyoqIEZldGNoZXMgdGhlIGNvb2tpZVN0b3JlSWQgb2YgYSBnaXZlbiBjb250YWluZXJcblxuIE5vdGU6IGFsbCBjaGVja3MgYXJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cbiBAcGFyYW0gbmFtZSBUaGUgY29udGFpbmVyIG5hbWVcbiBAcmV0dXJucyBUaGUgY29va2llU3RvcmVJZCBvZiB0aGUgZmlyc3QgbWF0Y2ggb2YgdGhlIHF1ZXJ5LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0SWQobmFtZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjb250YWluZXJzID0gYXdhaXQgZ2V0QWxsKClcbiAgICAgICAgY29uc3QgcmVzID0gY29udGFpbmVycy5maWx0ZXIoXG4gICAgICAgICAgICBjID0+IGMubmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIClcbiAgICAgICAgaWYgKHJlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlc1swXS5jb29raWVTdG9yZUlkXG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgIFwiW0NvbnRhaW5lci5nZXRJZF0gY291bGQgbm90IGZpbmQgYSBjb250YWluZXIgd2l0aCB0aGF0IG5hbWUuXCIsXG4gICAgICAgIClcbiAgICB9XG59XG5cbi8qKiBUcmllcyBzb21lIHNpbXBsZSB3YXlzIHRvIG1hdGNoIGNvbnRhaW5lcnMgdG8geW91ciBpbnB1dC5cbiAgICBGdXp6eSBtYXRjaGluZyBpcyBlbnRpcmVseSBjYXNlLWluc2Vuc2l0aXZlLlxuICAgIEBwYXJhbSBwYXJ0aWFsTmFtZSBUaGUgKHBhcnRpYWwpIG5hbWUgb2YgdGhlIGNvbnRhaW5lci5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZ1enp5TWF0Y2gocGFydGlhbE5hbWU6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgZnVzZU9wdGlvbnMgPSB7XG4gICAgICAgIGlkOiBcImNvb2tpZVN0b3JlSWRcIixcbiAgICAgICAgc2hvdWxkU29ydDogdHJ1ZSxcbiAgICAgICAgdGhyZXNob2xkOiAwLjUsXG4gICAgICAgIGxvY2F0aW9uOiAwLFxuICAgICAgICBkaXN0YW5jZTogMTAwLFxuICAgICAgICBtaW1NYXRjaENoYXJMZW5ndGg6IDMsXG4gICAgICAgIGtleXM6IFtcIm5hbWVcIl0sXG4gICAgfVxuXG4gICAgY29uc3QgY29udGFpbmVycyA9IGF3YWl0IGdldEFsbCgpXG4gICAgY29uc3QgZnVzZSA9IG5ldyBGdXNlKGNvbnRhaW5lcnMsIGZ1c2VPcHRpb25zKVxuICAgIGNvbnN0IHJlcyA9IGZ1c2Uuc2VhcmNoKHBhcnRpYWxOYW1lKVxuXG4gICAgaWYgKHJlcy5sZW5ndGggPj0gMSkgcmV0dXJuIHJlc1swXVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIltDb250YWluZXIuZnV6enlNYXRjaF0gbm8gY29udGFpbmVyIG1hdGNoZWQgdGhhdCBzdHJpbmdcIixcbiAgICAgICAgKVxuICAgIH1cbn1cblxuLyoqIEhlbHBlciBmdW5jdGlvbiBmb3IgY3JlYXRlLCByZXR1cm5zIGEgcmFuZG9tIHZhbGlkIElkZW50aXR5Q29sb3IgZm9yIHVzZSBpZiBubyBjb2xvciBpcyBhcHBsaWVkIGF0IGNyZWF0aW9uLiovXG5mdW5jdGlvbiBjaG9vc2VSYW5kb21Db2xvcigpOiBzdHJpbmcge1xuICAgIGNvbnN0IG1heCA9IE1hdGguZmxvb3IoQ29udGFpbmVyQ29sb3IubGVuZ3RoKVxuICAgIGNvbnN0IG4gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXgpXG4gICAgcmV0dXJuIENvbnRhaW5lckNvbG9yW25dXG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRDb2xvcihjb2xvcjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIENvbnRhaW5lckNvbG9yLmluZGV4T2YoY29sb3IpID4gLTFcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEljb24oaWNvbjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIENvbnRhaW5lckljb24uaW5kZXhPZihpY29uKSA+IC0xXG59XG4iLCJleHBvcnQgZnVuY3Rpb24gdG9Cb29sZWFuKHM6IHN0cmluZykge1xuICAgIGlmIChzID09PSBcInRydWVcIikgcmV0dXJuIHRydWVcbiAgICBlbHNlIGlmIChzID09PSBcImZhbHNlXCIpIHJldHVybiBmYWxzZVxuICAgIGVsc2UgdGhyb3cgXCJOb3QgYSBib29sZWFuXCJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvTnVtYmVyKHM6IHN0cmluZykge1xuICAgIGNvbnN0IG4gPSBOdW1iZXIocylcbiAgICBpZiAoaXNOYU4obikpIHRocm93IFwiTm90IGEgbnVtYmVyISBcIiArIHNcbiAgICBlbHNlIHJldHVybiBuXG59XG4iLCIvKiB0c2xpbnQ6ZGlzYWJsZTpuby1zdHJpbmctbGl0ZXJhbCAqL1xuaW1wb3J0ICogYXMgQ1NTIGZyb20gXCJjc3NcIlxuXG4vLyBMYXlvdXQgKG9mIGJpdHMgd2UgY2FyZSBhYm91dDpcbi8vIHtzdHlsZXNoZWV0OiB7XG4vLyAgICAgICAgICBydWxlczogW3tcbi8vICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicnVsZVwiLCBzZWxlY3RvcnM6IFtzdHJpbmddLCBkZWNsYXJhdGlvbnM6IFtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICB7dHlwZTogXCJkZWNsYXJhdGlvblwiLCBwcm9wZXJ0eTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nfVxuXG4vKiogRmluZCBydWxlcyBpbiBzaGVldCB0aGF0IG1hdGNoIHNlbGVjdG9yICovXG5leHBvcnQgZnVuY3Rpb24gZmluZENzc1J1bGVzKFxuICAgIHNlbGVjdG9yczogc3RyaW5nW10sXG4gICAgc2hlZXQ6IENTUy5TdHlsZXNoZWV0LFxuKTogbnVtYmVyW10ge1xuICAgIGNvbnN0IGZpbHRTaGVldCA9IFsuLi5zaGVldC5zdHlsZXNoZWV0LnJ1bGVzLmVudHJpZXMoKV0uZmlsdGVyKHggPT4ge1xuICAgICAgICBjb25zdCBydWxlID0geFsxXVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcnVsZS50eXBlID09PSBcInJ1bGVcIiAmJlxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlcmUgYXJlIGFzIG1hbnkgc2VsZWN0b3JzIGluIHRoZSBjdXJyZW50IHJ1bGVcbiAgICAgICAgICAgIC8vIGFzIHRoZXJlIGFyZSBpbiB0aGUgcnVsZSB3ZSdyZSBsb29raW5nIGZvclxuICAgICAgICAgICAgcnVsZVtcInNlbGVjdG9yc1wiXS5sZW5ndGggPT09IHNlbGVjdG9ycy5sZW5ndGggJiZcbiAgICAgICAgICAgIC8vIEFsc28gbWFrZSBzdXJlIHRoYXQgZWFjaCBvZiB0aGUgc2VsZWN0b3JzIG9mIHRoZSBjdXJyZW50IHJ1bGVcbiAgICAgICAgICAgIC8vIGFyZSBwcmVzZW50IGluIHRoZSBydWxlIHdlJ3JlIGxvb2tpbmcgZm9yXG4gICAgICAgICAgICAhcnVsZVtcInNlbGVjdG9yc1wiXS5maW5kKHNlbGVjdG9yID0+ICFzZWxlY3RvcnMuaW5jbHVkZXMoc2VsZWN0b3IpKVxuICAgICAgICApXG4gICAgfSlcbiAgICByZXR1cm4gZmlsdFNoZWV0Lm1hcCh4ID0+IHhbMF0pXG59XG5cbi8qKiBSdWxlbmFtZSAtPiB7IG5hbWU6IDxzZWxlY3Rvcj4sIG9wdGlvbnM6IHsgPG9wdGlvbi1uYW1lPjogPGNzcy1zdHJpbmc+IH0gfVxuICpcbiAqICBNdWx0aS1sZXZlbCBtYXAgb2YgcnVsZW5hbWUsIG9wdGlvbnMgYXZhaWxhYmxlIGZvciBydWxlIGFuZCBjc3MgZm9yIGVhY2ggb3B0aW9uLlxuICpcbiAqICAqZmluZENzc1J1bGVzIGFuZCBjaGFuZ2VTaW5nbGVDc3MgcmVseSBvbiB0aGUgc2VsZWN0b3Igbm90IGNvbnRhaW5pbmcgYSBjb21tYS4qXG4gKlxuICogIFRPRE86IG1ha2UgdGhpcyBtb3JlIGZsZXhpYmxlIHdpdGggY2xldmVyZXIgbWF0Y2hpbmcgb2Ygc2VsZWN0b3JzLCBtZXJnaW5nIG9mIG9wdGlvbnNcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBwb3RlbnRpYWxSdWxlcyA9IHtcbiAgICBzdGF0dXNwYW5lbDoge1xuICAgICAgICBuYW1lOiBgI3N0YXR1c3BhbmVsYCxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgbm9uZTogYGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtgLFxuICAgICAgICAgICAgcmlnaHQ6IGByaWdodDogMDsgZGlzcGxheTogaW5saW5lO2AsXG4gICAgICAgICAgICBsZWZ0OiBgYCxcbiAgICAgICAgICAgIFwidG9wLWxlZnRcIjogYHRvcDogMmVtOyB6LWluZGV4OiAyOyBkaXNwbGF5OiBpbmxpbmU7YCxcbiAgICAgICAgICAgIFwidG9wLXJpZ2h0XCI6IGB0b3A6IDJlbTsgei1pbmRleDogMjsgcmlnaHQ6IDA7IGRpc3BsYXk6IGlubGluZTtgLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgaG92ZXJsaW5rOiB7XG4gICAgICAgIG5hbWU6IGBzdGF0dXNwYW5lbFt0eXBlPVwib3ZlckxpbmtcIl0sICNzdGF0dXNwYW5lbFt0eXBlPVwib3ZlckxpbmtcIl1gLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBub25lOiBgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O2AsXG4gICAgICAgICAgICByaWdodDogYHJpZ2h0OiAwOyBkaXNwbGF5OiBpbmxpbmU7YCxcbiAgICAgICAgICAgIGxlZnQ6IGBgLFxuICAgICAgICAgICAgXCJ0b3AtbGVmdFwiOiBgdG9wOiAyZW07IHotaW5kZXg6IDI7IGRpc3BsYXk6IGlubGluZTtgLFxuICAgICAgICAgICAgXCJ0b3AtcmlnaHRcIjogYHRvcDogMmVtOyB6LWluZGV4OiAyOyByaWdodDogMDsgZGlzcGxheTogaW5saW5lO2AsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB0YWJzdG9vbGJhcjoge1xuICAgICAgICBuYW1lOiBgI1RhYnNUb29sYmFyYCxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgbm9uZTogYHZpc2liaWxpdHk6IGNvbGxhcHNlO2AsXG4gICAgICAgICAgICBzaG93OiBgYCxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHRhYnN0b29sYmFydW5mb2N1c2VkOiB7XG4gICAgICAgIG5hbWU6IGA6cm9vdDpub3QoW2N1c3RvbWl6aW5nXSkgI25hdmlnYXRvci10b29sYm94Om5vdCg6aG92ZXIpOm5vdCg6Zm9jdXMtd2l0aGluKSAjVGFic1Rvb2xiYXJgLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBoaWRlOiBgdmlzaWJpbGl0eTogY29sbGFwc2U7YCxcbiAgICAgICAgICAgIHNob3c6IGBgLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgdGFiY291bnRlcjoge1xuICAgICAgICBuYW1lOiBgdGFic2AsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG9mZjogYGAsXG4gICAgICAgICAgICBvbjogYGNvdW50ZXItcmVzZXQ6IHRhYi1jb3VudGVyO2AsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB0YWJjb3VudGVyczoge1xuICAgICAgICBuYW1lOiBgLnRhYi1sYWJlbDo6YmVmb3JlYCxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgaGlkZTogYGAsXG4gICAgICAgICAgICBzaG93OiBgIGNvdW50ZXItaW5jcmVtZW50OiB0YWItY291bnRlcjtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogY291bnRlcih0YWItY291bnRlcikgXCIgLSBcIjtgLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgbmF2dG9vbGJveHVuZm9jdXNlZDoge1xuICAgICAgICBuYW1lOiBgOnJvb3Q6bm90KFtjdXN0b21pemluZ10pICNuYXZpZ2F0b3ItdG9vbGJveDpub3QoOmhvdmVyKTpub3QoOmZvY3VzLXdpdGhpbilgLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBoaWRlOiBgbWF4LWhlaWdodDogMXB4OyBtaW4taGVpZ2h0OiBjYWxjKDBweCk7IG92ZXJmbG93OiBoaWRkZW47YCxcbiAgICAgICAgICAgIHNob3c6IGBgLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgbmF2YmFydW5mb2N1c2VkOiB7XG4gICAgICAgIG5hbWU6IGA6cm9vdDpub3QoW2N1c3RvbWl6aW5nXSkgI25hdmlnYXRvci10b29sYm94Om5vdCg6aG92ZXIpOm5vdCg6Zm9jdXMtd2l0aGluKSAjbmF2LWJhcmAsXG4gICAgICAgIC8vIHRyaWRhY3R5bCBhdXRvIHNob3cgem9uZSBkb2Vzbid0IHNlZW0gdG8gbWFrZSBhIGRpZmZlcmVuY2VcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgaGlkZTogYG1heC1oZWlnaHQ6IDA7XG4gICAgICAgICAgICAgICAgICAgIG1pbi1oZWlnaHQ6IDAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICAgICAgICAtLXRyaWRhY3R5bC1hdXRvLXNob3ctem9uZTogMTBweDtcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogY2FsYygtMSAqIHZhcigtLXRyaWRhY3R5bC1hdXRvLXNob3ctem9uZSkpO1xuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwO2AsXG4gICAgICAgICAgICBzaG93OiBgYCxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIC8vIEFubm95aW5nIGJsYWNrIGxpbmUgYXQgdG9wIGluIGZ1bGxzY3JlZW5cbiAgICBuYXZiYXJhZnRlcjoge1xuICAgICAgICBuYW1lOiBgI25hdmlnYXRvci10b29sYm94OjphZnRlcmAsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGhpZGU6IGBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7YCxcbiAgICAgICAgICAgIHNob3c6IGBgLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgLy8gQWxsIGNoaWxkcmVuIGV4Y2VwdCBhZGQtb24gcGFuZWxzXG4gICAgbmF2YmFybm9uYWRkb25jaGlsZHJlbjoge1xuICAgICAgICBuYW1lOiBgOnJvb3Q6bm90KFtjdXN0b21pemluZ10pICNuYXYtYmFyID4gOm5vdCgjY3VzdG9taXphdGlvbnVpLXdpZGdldC1wYW5lbClgLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBoaWRlOiBgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O2AsXG4gICAgICAgICAgICBzaG93OiBgYCxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIC8vIFNldCBuYXZiYXIgaGVpZ2h0IHRvIDBcbiAgICBuYXZiYXJub2hlaWdodDoge1xuICAgICAgICBuYW1lOiBgOnJvb3Q6bm90KFtjdXN0b21pemluZ10pICNuYXYtYmFyYCxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgaGlkZTogYGAsXG4gICAgICAgICAgICBzaG93OiBgbWF4LWhlaWdodDogMDsgbWluLWhlaWdodDogMCAhaW1wb3J0YW50O2AsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICAvLyBUaGlzIGluaGVyaXRzIHRyYW5zcGFyZW5jeSBpZiB3ZSBhcmVuJ3QgY2FyZWZ1bFxuICAgIG1lbnViYXI6IHtcbiAgICAgICAgbmFtZTogYCNuYXZpZ2F0b3ItdG9vbGJveDpub3QoOmhvdmVyKTpub3QoOmZvY3VzLXdpdGhpbikgI3Rvb2xiYXItbWVudWJhciA+ICpgLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBncmV5OiBgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIzMiwgMjMyLCAyMzEpO2AsXG4gICAgICAgICAgICBkZWZhdWx0OiBgYCxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIC8vIFdpbmRvdyBkZWN0b3JhdGlvbnNcbiAgICB0aXRsZWJhcjoge1xuICAgICAgICBuYW1lOiBgI3RpdGxlYmFyYCxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgaGlkZTogYGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtgLFxuICAgICAgICAgICAgc2hvdzogYGAsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBwYWR3aGVubWF4aW1pc2VkOiB7XG4gICAgICAgIG5hbWU6IGAjbWFpbi13aW5kb3dbc2l6ZW1vZGU9XCJtYXhpbWl6ZWRcIl0gI2NvbnRlbnQtZGVja2AsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHNvbWU6IGBwYWRkaW5nLXRvcDogOHB4O2AsXG4gICAgICAgICAgICBub25lOiBgYCxcbiAgICAgICAgfSxcbiAgICB9LFxufVxuXG4vLyAgVmltcGVyYXRvcidzIG9wdGlvbnMgZm9yIHJlZmVyZW5jZTpcbi8vICA8dGFncz4nZ28nICdndWlvcHRpb25zJzwvdGFncz5cbi8vICA8c3BlYz4nZ3Vpb3B0aW9ucycgJ2dvJzwvc3BlYz5cblxuLy9cbi8vICBtICAgICAgICAgIE1lbnViYXJcbi8vICBUICAgICAgICAgIFRvb2xiYXJcbi8vICBCICAgICAgICAgIEJvb2ttYXJrIGJhclxuLy8gIEEgICAgICAgICAgQWRkLW9uIGJhclxuLy8gIG4gICAgICAgICAgVGFiIG51bWJlclxuLy8gIGIgICAgICAgICAgQm90dG9tIHNjcm9sbGJhclxuLy8gIHIgICAgICAgICAgUmlnaHQgc2Nyb2xsYmFyXG4vLyAgbCAgICAgICAgICBMZWZ0IHNjcm9sbGJhclxuLy9cbi8vICB3YXMganVzdCBhIHNpbXBsZSBzaG93L2hpZGUgaWYgdGhlIGNoYXJhY3RlcnMgYXBwZWFyZWQgaW4gdGhlIHNldHRpbmdcblxuLyoqIFJ1bGVzIHRoYXQgaW5kZXggaW50byBwb3RlbnRpYWxSdWxlcyBvciBtZXRhUnVsZXNcbiAqXG4gKiAgUGxlYXNlIGRvbid0IGFkZCBjeWNsZXMgdG8gdGhpcyB0YWJsZSA6KVxuICovXG5leHBvcnQgY29uc3QgbWV0YVJ1bGVzID0ge1xuICAgIGd1aToge1xuICAgICAgICBub25lOiB7XG4gICAgICAgICAgICBob3Zlcmxpbms6IFwibm9uZVwiLFxuICAgICAgICAgICAgdGFiczogXCJub25lXCIsXG4gICAgICAgICAgICBuYXZiYXI6IFwiYXV0b2hpZGVcIixcbiAgICAgICAgICAgIG1lbnViYXI6IFwiZ3JleVwiLFxuICAgICAgICAgICAgcGFkd2hlbm1heGltaXNlZDogXCJzb21lXCIsXG4gICAgICAgIH0sXG4gICAgICAgIGZ1bGw6IHtcbiAgICAgICAgICAgIGhvdmVybGluazogXCJsZWZ0XCIsXG4gICAgICAgICAgICB0YWJzOiBcImFsd2F5c1wiLFxuICAgICAgICAgICAgbmF2YmFyOiBcImFsd2F5c1wiLFxuICAgICAgICAgICAgbWVudWJhcjogXCJkZWZhdWx0XCIsXG4gICAgICAgICAgICBwYWR3aGVubWF4aW1pc2VkOiBcIm5vbmVcIixcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHRhYnM6IHtcbiAgICAgICAgbm9uZToge1xuICAgICAgICAgICAgdGFic3Rvb2xiYXI6IFwibm9uZVwiLFxuICAgICAgICAgICAgbmF2dG9vbGJveHVuZm9jdXNlZDogXCJoaWRlXCIsXG4gICAgICAgIH0sXG4gICAgICAgIGFsd2F5czoge1xuICAgICAgICAgICAgdGFic3Rvb2xiYXI6IFwic2hvd1wiLFxuICAgICAgICAgICAgdGFic3Rvb2xiYXJ1bmZvY3VzZWQ6IFwic2hvd1wiLFxuICAgICAgICAgICAgbmF2dG9vbGJveHVuZm9jdXNlZDogXCJzaG93XCIsXG4gICAgICAgIH0sXG4gICAgICAgIGF1dG9oaWRlOiB7XG4gICAgICAgICAgICB0YWJzdG9vbGJhcjogXCJzaG93XCIsXG4gICAgICAgICAgICB0YWJzdG9vbGJhcnVuZm9jdXNlZDogXCJoaWRlXCIsXG4gICAgICAgICAgICBuYXZ0b29sYm94dW5mb2N1c2VkOiBcImhpZGVcIixcbiAgICAgICAgfSxcbiAgICAgICAgY291bnQ6IHtcbiAgICAgICAgICAgIHRhYmNvdW50ZXI6IFwib25cIixcbiAgICAgICAgICAgIHRhYmNvdW50ZXJzOiBcInNob3dcIixcbiAgICAgICAgfSxcbiAgICAgICAgbm9jb3VudDoge1xuICAgICAgICAgICAgdGFiY291bnRlcjogXCJvZmZcIixcbiAgICAgICAgICAgIHRhYmNvdW50ZXJzOiBcImhpZGVcIixcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIG5hdmJhcjoge1xuICAgICAgICBhdXRvaGlkZToge1xuICAgICAgICAgICAgbmF2YmFydW5mb2N1c2VkOiBcImhpZGVcIixcbiAgICAgICAgICAgIG5hdnRvb2xib3h1bmZvY3VzZWQ6IFwiaGlkZVwiLFxuICAgICAgICAgICAgbmF2YmFyYWZ0ZXI6IFwiaGlkZVwiLFxuICAgICAgICAgICAgbmF2YmFybm9uYWRkb25jaGlsZHJlbjogXCJzaG93XCIsXG4gICAgICAgICAgICBuYXZiYXJub2hlaWdodDogXCJoaWRlXCIsXG4gICAgICAgIH0sXG4gICAgICAgIGFsd2F5czoge1xuICAgICAgICAgICAgbmF2YmFydW5mb2N1c2VkOiBcInNob3dcIixcbiAgICAgICAgICAgIG5hdnRvb2xib3h1bmZvY3VzZWQ6IFwic2hvd1wiLFxuICAgICAgICAgICAgbmF2YmFyYWZ0ZXI6IFwic2hvd1wiLFxuICAgICAgICAgICAgbmF2YmFybm9uYWRkb25jaGlsZHJlbjogXCJzaG93XCIsXG4gICAgICAgICAgICBuYXZiYXJub2hlaWdodDogXCJoaWRlXCIsXG4gICAgICAgIH0sXG4gICAgICAgIG5vbmU6IHtcbiAgICAgICAgICAgIG5hdmJhcnVuZm9jdXNlZDogXCJzaG93XCIsXG4gICAgICAgICAgICBuYXZ0b29sYm94dW5mb2N1c2VkOiBcInNob3dcIixcbiAgICAgICAgICAgIG5hdmJhcmFmdGVyOiBcImhpZGVcIixcbiAgICAgICAgICAgIG5hdmJhcm5vbmFkZG9uY2hpbGRyZW46IFwiaGlkZVwiLFxuICAgICAgICAgICAgbmF2YmFybm9oZWlnaHQ6IFwic2hvd1wiLFxuICAgICAgICB9LFxuICAgIH0sXG59XG5cbi8qKiBBZGQgZGVzaXJlZCBub24tbWV0YSBydWxlIHRvIHN0eWxlc2hlZXQgcmVwbGFjaW5nIGV4aXN0aW5nIHJ1bGUgd2l0aCB0aGUgc2FtZSBzZWxlY3RvciBpZiBwcmVzZW50ICovXG5leHBvcnQgZnVuY3Rpb24gY2hhbmdlU2luZ2xlQ3NzKFxuICAgIHJ1bGVuYW1lOiBzdHJpbmcsXG4gICAgb3B0aW9ubmFtZTogc3RyaW5nLFxuICAgIHNoZWV0OiBDU1MuU3R5bGVzaGVldCxcbik6IENTUy5TdHlsZXNoZWV0IHtcbiAgICBjb25zdCBzZWxlY3RvciA9IHBvdGVudGlhbFJ1bGVzW3J1bGVuYW1lXVtcIm5hbWVcIl1cbiAgICBjb25zdCBuZXdSdWxlID0gYCR7c2VsZWN0b3J9IHtcbiAgICAgICAgJHtwb3RlbnRpYWxSdWxlc1tydWxlbmFtZV1bXCJvcHRpb25zXCJdW29wdGlvbm5hbWVdfVxuICAgIH1gXG4gICAgY29uc3QgbWluaVNoZWV0ID0gQ1NTLnBhcnNlKG5ld1J1bGUpLnN0eWxlc2hlZXQucnVsZXNbMF1cblxuICAgIC8vIEZpbmQgcHJlLWV4aXN0aW5nIHJ1bGVzXG4gICAgY29uc3Qgb2xkUnVsZUluZGV4ZXMgPSBmaW5kQ3NzUnVsZXMobWluaVNoZWV0W1wic2VsZWN0b3JzXCJdLCBzaGVldClcbiAgICBpZiAob2xkUnVsZUluZGV4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBzaGVldC5zdHlsZXNoZWV0LnJ1bGVzW29sZFJ1bGVJbmRleGVzWzBdXSA9IG1pbmlTaGVldFxuICAgIH0gZWxzZSB7XG4gICAgICAgIHNoZWV0LnN0eWxlc2hlZXQucnVsZXMgPSBzaGVldC5zdHlsZXNoZWV0LnJ1bGVzLmNvbmNhdChtaW5pU2hlZXQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHNoZWV0XG59XG5cbi8qKiBBcHBseSBydWxlIHRvIHN0eWxlc2hlZXQuIHJ1bGVuYW1lLCBvcHRpb25uYW1lIGlkZW50aWZ5IGEgcnVsZS4gVGhleSBtYXkgYmUgbWV0YSBydWxlcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoYW5nZUNzcyhcbiAgICBydWxlbmFtZTogc3RyaW5nLFxuICAgIG9wdGlvbm5hbWU6IHN0cmluZyxcbiAgICBzaGVldDogQ1NTLlN0eWxlc2hlZXQsXG4pOiBDU1MuU3R5bGVzaGVldCB7XG4gICAgaWYgKHJ1bGVuYW1lIGluIG1ldGFSdWxlcykge1xuICAgICAgICBjb25zdCBtZXRhcnVsZSA9IG1ldGFSdWxlc1tydWxlbmFtZV1bb3B0aW9ubmFtZV1cbiAgICAgICAgZm9yIChjb25zdCBydWxlIG9mIE9iamVjdC5rZXlzKG1ldGFydWxlKSkge1xuICAgICAgICAgICAgLy8gaGF2ZSBhIG1ldGFydWxlIGNhbGwgaXRzZWxmIGZvciBob3VycyBvZiBmdW5cbiAgICAgICAgICAgIHNoZWV0ID0gY2hhbmdlQ3NzKHJ1bGUsIG1ldGFydWxlW3J1bGVdLCBzaGVldClcbiAgICAgICAgfVxuICAgIH0gZWxzZSBzaGVldCA9IGNoYW5nZVNpbmdsZUNzcyhydWxlbmFtZSwgb3B0aW9ubmFtZSwgc2hlZXQpXG4gICAgcmV0dXJuIHNoZWV0XG59XG4iLCIvKiogIyBFZGl0b3IgRnVuY3Rpb25zXG4gKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGZ1bmN0aW9ucyB0byBtYW5pcHVsYXRlIHRoZSBjb250ZW50IG9mIHRleHRhcmVhcy9pbnB1dCBmaWVsZHMvY29udGVudGVkaXRhYmxlIGVsZW1lbnRzLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIGJpbmQgdGhlbSB0byBrZXlib2FyZCBzaG9ydGN1dHMsIGJlIHN1cmUgdG8gcHJlZml4IHRoZW0gd2l0aCBcInRleHQuXCIuIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byBiaW5kIGNvbnRyb2wtYSB0byBgYmVnaW5uaW5nX29mX2xpbmVgIGluIGFsbCBtb2RlcywgdXNlOlxuICpcbiAqIGBgYFxuICogYmluZCAtLW1vZGU9ZXggPEMtYT4gdGV4dC5iZWdpbm5pbmdfb2ZfbGluZVxuICogYmluZCAtLW1vZGU9aW5wdXQgPEMtYT4gdGV4dC5iZWdpbm5pbmdfb2ZfbGluZVxuICogYmluZCAtLW1vZGU9aW5zZXJ0IDxDLWE+IHRleHQuYmVnaW5pbmdfb2ZfbGluZVxuICogYGBgXG4gKlxuICogQWxzbyBrZWVwIGluIG1pbmQgdGhhdCBpZiB5b3Ugd2FudCB0byBiaW5kIHNvbWV0aGluZyBpbiBpbnNlcnQgbW9kZSwgeW91J2xsIHByb2JhYmx5IGFsc28gd2FudCB0byBiaW5kIGl0IGluIGlucHV0IG1vZGUgKGluc2VydCBtb2RlIGlzIGVudGVyZWQgYnkgY2xpY2tpbmcgb24gdGV4dCBhcmVhcyB3aGlsZSBpbnB1dCBtb2RlIGlzIGVudGVyZWQgYnkgdXNpbmcgYGdpYCkuXG4gKlxuICogSWYgeW91J3JlIGxvb2tpbmcgZm9yIGNvbW1hbmQtbGluZSBvbmx5IGZ1bmN0aW9ucywgZ28gW3RoZXJlXSgvc3RhdGljL2RvY3MvbW9kdWxlcy9fc3JjX2NvbW1hbmRsaW5lX2ZyYW1lXy5odG1sKS5cbiAqXG4gKiBDb250cmFyeSB0byB0aGUgbWFpbiB0cmlkYWN0eWwgaGVscCBwYWdlLCB0aGlzIG9uZSBkb2Vzbid0IHRlbGwgeW91IHdoZXRoZXIgYSBzcGVjaWZpYyBmdW5jdGlvbiBpcyBib3VuZCB0byBzb21ldGhpbmcuIEZvciBub3csIHlvdSdsbCBoYXZlIHRvIG1ha2UgZG8gd2l0aCB3aXRoIGA6YmluZGAgYW5kIGA6dmlld2NvbmZpZ2AuXG4gKlxuICovXG4vKiogaWdub3JlIHRoaXMgbGluZSAqL1xuXG5pbXBvcnQgeyB3cmFwX2lucHV0LCBuZWVkc190ZXh0LCBnZXRXb3JkQm91bmRhcmllcywgd29yZEFmdGVyUG9zLCByb3QxM19oZWxwZXIgfSBmcm9tIFwiQHNyYy9saWIvZWRpdG9yX3V0aWxzXCJcblxuLyoqXG4gKiBCZWhhdmVzIGxpa2UgcmVhZGxpbmUncyBbZGVsZXRlX2NoYXJdKGh0dHA6Ly93ZWIubWl0LmVkdS9nbnUvZG9jL2h0bWwvcmxtYW5fMS5odG1sI1NFQzE0KSwgaS5lLiBkZWxldGVzIHRoZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjYXJldC5cbiAqKi9cbmV4cG9ydCBjb25zdCBkZWxldGVfY2hhciA9IHdyYXBfaW5wdXQoXG4gICAgbmVlZHNfdGV4dCgodGV4dCwgc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCkgPT4ge1xuICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgIT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgc2VsZWN0ZWQgdGV4dCwgdGhlbiB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGF0IGluc3RlYWQgb2YgYSBzaW5nbGUgY2hhclxuICAgICAgICAgICAgdGV4dCA9XG4gICAgICAgICAgICAgICAgdGV4dC5zdWJzdHJpbmcoMCwgc2VsZWN0aW9uU3RhcnQpICsgdGV4dC5zdWJzdHJpbmcoc2VsZWN0aW9uRW5kKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dCA9XG4gICAgICAgICAgICAgICAgdGV4dC5zdWJzdHJpbmcoMCwgc2VsZWN0aW9uU3RhcnQpICtcbiAgICAgICAgICAgICAgICB0ZXh0LnN1YnN0cmluZyhzZWxlY3Rpb25TdGFydCArIDEpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0ZXh0LCBzZWxlY3Rpb25TdGFydCwgbnVsbF1cbiAgICB9KSxcbilcblxuLyoqXG4gKiBCZWhhdmVzIGxpa2UgcmVhZGxpbmUncyBbZGVsZXRlX2JhY2t3YXJkX2NoYXJdKGh0dHA6Ly93ZWIubWl0LmVkdS9nbnUvZG9jL2h0bWwvcmxtYW5fMS5odG1sI1NFQzE0KSwgaS5lLiBkZWxldGVzIHRoZSBjaGFyYWN0ZXIgdG8gdGhlIGxlZnQgb2YgdGhlIGNhcmV0LlxuICoqL1xuZXhwb3J0IGNvbnN0IGRlbGV0ZV9iYWNrd2FyZF9jaGFyID0gd3JhcF9pbnB1dChcbiAgICBuZWVkc190ZXh0KCh0ZXh0LCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKSA9PiB7XG4gICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCAhPT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICB0ZXh0ID1cbiAgICAgICAgICAgICAgICB0ZXh0LnN1YnN0cmluZygwLCBzZWxlY3Rpb25TdGFydCkgKyB0ZXh0LnN1YnN0cmluZyhzZWxlY3Rpb25FbmQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0ID1cbiAgICAgICAgICAgICAgICB0ZXh0LnN1YnN0cmluZygwLCBzZWxlY3Rpb25TdGFydCAtIDEpICtcbiAgICAgICAgICAgICAgICB0ZXh0LnN1YnN0cmluZyhzZWxlY3Rpb25TdGFydClcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3Rpb25TdGFydCAtPSAxXG4gICAgICAgIHJldHVybiBbdGV4dCwgc2VsZWN0aW9uU3RhcnQsIG51bGxdXG4gICAgfSksXG4pXG5cbi8qKlxuICogQmVoYXZlcyBsaWtlIHJlYWRsaW5lJ3MgW3RhYl9pbnNlcnRdKGh0dHA6Ly93ZWIubWl0LmVkdS9nbnUvZG9jL2h0bWwvcmxtYW5fMS5odG1sI1NFQzE0KSwgaS5lLiBpbnNlcnRzIGEgdGFiIGNoYXJhY3RlciB0byB0aGUgbGVmdCBvZiB0aGUgY2FyZXQuXG4gKiovXG5leHBvcnQgY29uc3QgdGFiX2luc2VydCA9IHdyYXBfaW5wdXQoKHRleHQsIHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpID0+IHtcbiAgICBpZiAoc2VsZWN0aW9uU3RhcnQgIT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICB0ZXh0ID1cbiAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKDAsIHNlbGVjdGlvblN0YXJ0KSArXG4gICAgICAgICAgICBcIlxcdFwiICtcbiAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKHNlbGVjdGlvbkVuZClcbiAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0ID1cbiAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKDAsIHNlbGVjdGlvblN0YXJ0KSArXG4gICAgICAgICAgICBcIlxcdFwiICtcbiAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKHNlbGVjdGlvblN0YXJ0KVxuICAgIH1cbiAgICBzZWxlY3Rpb25TdGFydCArPSAxXG4gICAgcmV0dXJuIFt0ZXh0LCBzZWxlY3Rpb25TdGFydCwgbnVsbF1cbn0pXG5cbi8qKlxuICogQmVoYXZlcyBsaWtlIHJlYWRsaW5lJ3MgW3RyYW5zcG9zZV9jaGFyc10oaHR0cDovL3dlYi5taXQuZWR1L2dudS9kb2MvaHRtbC9ybG1hbl8xLmh0bWwjU0VDMTQpLCBpLmUuIHRyYW5zcG9zZXMgdGhlIGNoYXJhY3RlciB0byB0aGUgbGVmdCBvZiB0aGUgY2FyZXQgd2l0aCB0aGUgY2hhcmFjdGVyIHRvIHRoZSByaWdodCBvZiB0aGUgY2FyZXQgYW5kIHRoZW4gbW92ZXMgdGhlIGNhcmV0IG9uZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0LiBJZiB0aGVyZSBhcmUgbm8gY2hhcmFjdGVycyB0byB0aGUgcmlnaHQgb3IgdG8gdGhlIGxlZnQgb2YgdGhlIGNhcmV0LCB1c2VzIHRoZSB0d28gY2hhcmFjdGVycyB0aGUgY2xvc2VzdCB0byB0aGUgY2FyZXQuXG4gKiovXG5leHBvcnQgY29uc3QgdHJhbnNwb3NlX2NoYXJzID0gd3JhcF9pbnB1dChcbiAgICAodGV4dCwgc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCkgPT4ge1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggPCAyKSByZXR1cm4gW251bGwsIG51bGwsIG51bGxdXG4gICAgICAgIC8vIFdoZW4gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dCwgdHJhbnNwb3NlIHRoZSBmaXJzdCBhbmQgc2Vjb25kIGNoYXJhY3RlcnNcbiAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID09PSAwKSBzZWxlY3Rpb25TdGFydCA9IDFcbiAgICAgICAgLy8gV2hlbiBhdCB0aGUgZW5kIG9mIHRoZSB0ZXh0LCB0cmFuc3Bvc2UgdGhlIGxhc3QgYW5kIHNlY29uZC10by1sYXN0IGNoYXJhY3RlcnNcbiAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID49IHRleHQubGVuZ3RoKSBzZWxlY3Rpb25TdGFydCA9IHRleHQubGVuZ3RoIC0gMVxuXG4gICAgICAgIHRleHQgPVxuICAgICAgICAgICAgdGV4dC5zdWJzdHJpbmcoMCwgc2VsZWN0aW9uU3RhcnQgLSAxKSArXG4gICAgICAgICAgICB0ZXh0LnN1YnN0cmluZyhzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uU3RhcnQgKyAxKSArXG4gICAgICAgICAgICB0ZXh0LnN1YnN0cmluZyhzZWxlY3Rpb25TdGFydCAtIDEsIHNlbGVjdGlvblN0YXJ0KSArXG4gICAgICAgICAgICB0ZXh0LnN1YnN0cmluZyhzZWxlY3Rpb25TdGFydCArIDEpXG4gICAgICAgIHNlbGVjdGlvblN0YXJ0ICs9IDFcbiAgICAgICAgcmV0dXJuIFt0ZXh0LCBzZWxlY3Rpb25TdGFydCwgbnVsbF1cbiAgICB9LFxuKVxuXG4vKiogQGhpZGRlblxuICogQXBwbGllcyBhIGZ1bmN0aW9uIHRvIHRoZSB3b3JkIHRoZSBjYXJldCBpcyBpbiwgb3IgdG8gdGhlIG5leHQgd29yZCBpZiB0aGUgY2FyZXQgaXMgbm90IGluIGEgd29yZCwgb3IgdG8gdGhlIHByZXZpb3VzIHdvcmQgaWYgdGhlIGN1cnJlbnQgd29yZCBpcyBlbXB0eS5cbiAqL1xuZnVuY3Rpb24gYXBwbHlXb3JkKFxuICAgIHRleHQsXG4gICAgc2VsZWN0aW9uU3RhcnQsXG4gICAgc2VsZWN0aW9uRW5kLFxuICAgIGZuOiAoczogc3RyaW5nKSA9PiBzdHJpbmcsXG4pOiBbc3RyaW5nLCBudW1iZXIsIG51bWJlcl0ge1xuICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtudWxsLCBudWxsLCBudWxsXVxuICAgIC8vIElmIHRoZSBjYXJldCBpcyBhdCB0aGUgZW5kIG9mIHRoZSB0ZXh0LCBtb3ZlIGl0IGp1c3QgYmVmb3JlIHRoZSBsYXN0IGNoYXJhY3RlclxuICAgIGlmIChzZWxlY3Rpb25TdGFydCA+PSB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICBzZWxlY3Rpb25TdGFydCA9IHRleHQubGVuZ3RoIC0gMVxuICAgIH1cbiAgICBjb25zdCBib3VuZGFyaWVzID0gZ2V0V29yZEJvdW5kYXJpZXModGV4dCwgc2VsZWN0aW9uU3RhcnQsIGZhbHNlKVxuICAgIGNvbnN0IGJlZ2lubmluZyA9XG4gICAgICAgIHRleHQuc3Vic3RyaW5nKDAsIGJvdW5kYXJpZXNbMF0pICtcbiAgICAgICAgZm4odGV4dC5zdWJzdHJpbmcoYm91bmRhcmllc1swXSwgYm91bmRhcmllc1sxXSkpXG4gICAgdGV4dCA9IGJlZ2lubmluZyArIHRleHQuc3Vic3RyaW5nKGJvdW5kYXJpZXNbMV0pXG4gICAgc2VsZWN0aW9uU3RhcnQgPSBiZWdpbm5pbmcubGVuZ3RoICsgMVxuICAgIHJldHVybiBbdGV4dCwgc2VsZWN0aW9uU3RhcnQsIG51bGxdXG59XG5cbi8qKlxuICogQmVoYXZlcyBsaWtlIHJlYWRsaW5lJ3MgW3RyYW5zcG9zZV93b3Jkc10oaHR0cDovL3dlYi5taXQuZWR1L2dudS9kb2MvaHRtbC9ybG1hbl8xLmh0bWwjU0VDMTQpLiBCYXNpY2FsbHkgZXF1aXZhbGVudCB0byBbW2ltX3RyYW5zcG9zZV9jaGFyc11dLCBidXQgdXNpbmcgd29yZHMgYXMgZGVmaW5lZCBieSB0aGUgd29yZHBhdHRlcm4gc2V0dGluZy5cbiAqKi9cbmV4cG9ydCBjb25zdCB0cmFuc3Bvc2Vfd29yZHMgPSB3cmFwX2lucHV0KFxuICAgIG5lZWRzX3RleHQoKHRleHQsIHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpID0+IHtcbiAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID49IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25TdGFydCA9IHRleHQubGVuZ3RoIC0gMVxuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgdGhlIHdvcmQgdGhlIGNhcmV0IGlzIGluXG4gICAgICAgIGxldCBmaXJzdEJvdW5kYXJpZXMgPSBnZXRXb3JkQm91bmRhcmllcyh0ZXh0LCBzZWxlY3Rpb25TdGFydCwgZmFsc2UpXG4gICAgICAgIGxldCBzZWNvbmRCb3VuZGFyaWVzID0gZmlyc3RCb3VuZGFyaWVzXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgd29yZCBhZnRlciB0aGUgd29yZCB0aGUgY2FyZXQgaXMgaW4sIHVzZSBpdCBmb3IgdGhlIHRyYW5zc2VsZWN0aW9uU3RhcnRpdGlvbiwgb3RoZXJ3aXNlIHVzZSB0aGUgd29yZCBiZWZvcmUgaXRcbiAgICAgICAgY29uc3QgbmV4dFdvcmQgPSB3b3JkQWZ0ZXJQb3ModGV4dCwgZmlyc3RCb3VuZGFyaWVzWzFdKVxuICAgICAgICBpZiAobmV4dFdvcmQgPiAtMSkge1xuICAgICAgICAgICAgc2Vjb25kQm91bmRhcmllcyA9IGdldFdvcmRCb3VuZGFyaWVzKHRleHQsIG5leHRXb3JkLCBmYWxzZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpcnN0Qm91bmRhcmllcyA9IGdldFdvcmRCb3VuZGFyaWVzKFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgZmlyc3RCb3VuZGFyaWVzWzBdIC0gMSxcbiAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpcnN0V29yZCA9IHRleHQuc3Vic3RyaW5nKGZpcnN0Qm91bmRhcmllc1swXSwgZmlyc3RCb3VuZGFyaWVzWzFdKVxuICAgICAgICBjb25zdCBzZWNvbmRXb3JkID0gdGV4dC5zdWJzdHJpbmcoXG4gICAgICAgICAgICBzZWNvbmRCb3VuZGFyaWVzWzBdLFxuICAgICAgICAgICAgc2Vjb25kQm91bmRhcmllc1sxXSxcbiAgICAgICAgKVxuICAgICAgICBjb25zdCBiZWdpbm5pbmcgPVxuICAgICAgICAgICAgdGV4dC5zdWJzdHJpbmcoMCwgZmlyc3RCb3VuZGFyaWVzWzBdKSArXG4gICAgICAgICAgICBzZWNvbmRXb3JkICtcbiAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKGZpcnN0Qm91bmRhcmllc1sxXSwgc2Vjb25kQm91bmRhcmllc1swXSlcbiAgICAgICAgc2VsZWN0aW9uU3RhcnQgPSBiZWdpbm5pbmcubGVuZ3RoXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBiZWdpbm5pbmcgKyBmaXJzdFdvcmQgKyB0ZXh0LnN1YnN0cmluZyhzZWNvbmRCb3VuZGFyaWVzWzFdKSxcbiAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgXVxuICAgIH0pLFxuKVxuXG4vKipcbiAqIEJlaGF2ZXMgbGlrZSByZWFkbGluZSdzIFt1cGNhc2Vfd29yZF0oaHR0cDovL3dlYi5taXQuZWR1L2dudS9kb2MvaHRtbC9ybG1hbl8xLmh0bWwjU0VDMTQpLiBNYWtlcyB0aGUgd29yZCB0aGUgY2FyZXQgaXMgaW4gdXBwZXJjYXNlLlxuICoqL1xuZXhwb3J0IGNvbnN0IHVwY2FzZV93b3JkID0gd3JhcF9pbnB1dChcbiAgICBuZWVkc190ZXh0KCh0ZXh0LCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKSA9PiB7XG4gICAgICAgIHJldHVybiBhcHBseVdvcmQodGV4dCwgc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCwgd29yZCA9PlxuICAgICAgICAgICAgd29yZC50b1VwcGVyQ2FzZSgpLFxuICAgICAgICApXG4gICAgfSksXG4pXG5cbi8qKlxuICogQmVoYXZlcyBsaWtlIHJlYWRsaW5lJ3MgW2Rvd25jYXNlX3dvcmRdKGh0dHA6Ly93ZWIubWl0LmVkdS9nbnUvZG9jL2h0bWwvcmxtYW5fMS5odG1sI1NFQzE0KS4gTWFrZXMgdGhlIHdvcmQgdGhlIGNhcmV0IGlzIGluIGxvd2VyY2FzZS5cbiAqKi9cbmV4cG9ydCBjb25zdCBkb3duY2FzZV93b3JkID0gd3JhcF9pbnB1dChcbiAgICBuZWVkc190ZXh0KCh0ZXh0LCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKSA9PiB7XG4gICAgICAgIHJldHVybiBhcHBseVdvcmQodGV4dCwgc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCwgd29yZCA9PlxuICAgICAgICAgICAgd29yZC50b0xvd2VyQ2FzZSgpLFxuICAgICAgICApXG4gICAgfSksXG4pXG5cbi8qKlxuICogQmVoYXZlcyBsaWtlIHJlYWRsaW5lJ3MgW2NhcGl0YWxpemVfd29yZF0oaHR0cDovL3dlYi5taXQuZWR1L2dudS9kb2MvaHRtbC9ybG1hbl8xLmh0bWwjU0VDMTQpLiBNYWtlcyB0aGUgaW5pdGlhbCBjaGFyYWN0ZXIgb2YgdGhlIHdvcmQgdGhlIGNhcmV0IGlzIGluIHVwcGVyY2FzZS5cbiAqKi9cbmV4cG9ydCBjb25zdCBjYXBpdGFsaXplX3dvcmQgPSB3cmFwX2lucHV0KFxuICAgIG5lZWRzX3RleHQoKHRleHQsIHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpID0+IHtcbiAgICAgICAgcmV0dXJuIGFwcGx5V29yZChcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgIHNlbGVjdGlvbkVuZCxcbiAgICAgICAgICAgIHdvcmQgPT4gd29yZFswXS50b1VwcGVyQ2FzZSgpICsgd29yZC5zdWJzdHJpbmcoMSksXG4gICAgICAgIClcbiAgICB9KSxcbilcblxuLyoqXG4gKiBCZWhhdmVzIGxpa2UgcmVhZGxpbmUncyBba2lsbF9saW5lXShodHRwOi8vd2ViLm1pdC5lZHUvZ251L2RvYy9odG1sL3JsbWFuXzEuaHRtbCNTRUMxNSksIGkuZS4gZGVsZXRlcyBldmVyeSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjYXJldCB1bnRpbCByZWFjaGluZyBlaXRoZXIgdGhlIGVuZCBvZiB0aGUgdGV4dCBvciB0aGUgbmV3bGluZSBjaGFyYWN0ZXIgKFxcbikuXG4gKiovXG5leHBvcnQgY29uc3Qga2lsbF9saW5lID0gd3JhcF9pbnB1dChcbiAgICBuZWVkc190ZXh0KCh0ZXh0LCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKSA9PiB7XG4gICAgICAgIGxldCBuZXdMaW5lID0gdGV4dC5zdWJzdHJpbmcoc2VsZWN0aW9uU3RhcnQpLnNlYXJjaChcIlxcblwiKVxuICAgICAgICBpZiAobmV3TGluZSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjYXJldCBpcyByaWdodCBiZWZvcmUgdGhlIG5ld2xpbmUsIGtpbGwgdGhlIG5ld2xpbmVcbiAgICAgICAgICAgIGlmIChuZXdMaW5lID09PSAwKSBuZXdMaW5lID0gMVxuICAgICAgICAgICAgdGV4dCA9XG4gICAgICAgICAgICAgICAgdGV4dC5zdWJzdHJpbmcoMCwgc2VsZWN0aW9uU3RhcnQpICtcbiAgICAgICAgICAgICAgICB0ZXh0LnN1YnN0cmluZyhzZWxlY3Rpb25TdGFydCArIG5ld0xpbmUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgc2VsZWN0aW9uU3RhcnQpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0ZXh0LCBzZWxlY3Rpb25TdGFydCwgbnVsbF1cbiAgICB9KSxcbilcblxuLyoqXG4gKiBCZWhhdmVzIGxpa2UgcmVhZGxpbmUncyBbYmFja3dhcmRfa2lsbF9saW5lXShodHRwOi8vd2ViLm1pdC5lZHUvZ251L2RvYy9odG1sL3JsbWFuXzEuaHRtbCNTRUMxNSksIGkuZS4gZGVsZXRlcyBldmVyeSBjaGFyYWN0ZXIgdG8gdGhlIGxlZnQgb2YgdGhlIGNhcmV0IHVudGlsIGVpdGhlciB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0IGlzIGZvdW5kIG9yIGEgbmV3bGluZSBjaGFyYWN0ZXIgKFwiXFxuXCIpIGlzIHJlYWNoZWQuXG4gKiovXG5leHBvcnQgY29uc3QgYmFja3dhcmRfa2lsbF9saW5lID0gd3JhcF9pbnB1dChcbiAgICBuZWVkc190ZXh0KCh0ZXh0LCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKSA9PiB7XG4gICAgICAgIC8vIElmIHRoZSBjYXJldCBpcyBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgbGluZSwgam9pbiB0aGUgbGluZXNcbiAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID4gMCAmJiB0ZXh0W3NlbGVjdGlvblN0YXJ0IC0gMV0gPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdGV4dC5zdWJzdHJpbmcoMCwgc2VsZWN0aW9uU3RhcnQgLSAxKSArXG4gICAgICAgICAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKHNlbGVjdGlvblN0YXJ0KSxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gICAgICAgIGxldCBuZXdMaW5lXG4gICAgICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgbmV3bGluZVxuICAgICAgICBmb3IgKFxuICAgICAgICAgICAgbmV3TGluZSA9IHNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgbmV3TGluZSA+IDAgJiYgdGV4dFtuZXdMaW5lIC0gMV0gIT09IFwiXFxuXCI7XG4gICAgICAgICAgICAtLW5ld0xpbmVcbiAgICAgICAgKTtcbiAgICAgICAgLy8gUmVtb3ZlIGV2ZXJ5dGhpbmcgYmV0d2VlbiB0aGUgbmV3bGluZSBhbmQgdGhlIGNhcmV0XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0ZXh0LnN1YnN0cmluZygwLCBuZXdMaW5lKSArIHRleHQuc3Vic3RyaW5nKHNlbGVjdGlvblN0YXJ0KSxcbiAgICAgICAgICAgIG5ld0xpbmUsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICBdXG4gICAgfSksXG4pXG5cbi8qKlxuICogQmVoYXZlcyBsaWtlIHJlYWRsaW5lJ3MgW2tpbGxfd2hvbGVfbGluZV0oaHR0cDovL3dlYi5taXQuZWR1L2dudS9kb2MvaHRtbC9ybG1hbl8xLmh0bWwjU0VDMTUpLiBEZWxldGVzIGV2ZXJ5IGNoYXJhY3RlciBiZXR3ZWVuIHRoZSB0d28gbmV3bGluZXMgdGhlIGNhcmV0IGlzIGluLiBJZiBhIG5ld2xpbmUgY2FuJ3QgYmUgZm91bmQgb24gdGhlIGxlZnQgb2YgdGhlIGNhcmV0LCBldmVyeXRoaW5nIGlzIGRlbGV0ZWQgdW50aWwgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dCBpcyByZWFjaGVkLiBJZiBhIG5ld2xpbmUgY2FuJ3QgYmUgZm91bmQgb24gdGhlIHJpZ2h0LCBldmVyeXRoaW5nIGlzIGRlbGV0ZWQgdW50aWwgdGhlIGVuZCBvZiB0aGUgdGV4dCBpcyBmb3VuZC5cbiAqKi9cbmV4cG9ydCBjb25zdCBraWxsX3dob2xlX2xpbmUgPSB3cmFwX2lucHV0KFxuICAgIG5lZWRzX3RleHQoKHRleHQsIHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpID0+IHtcbiAgICAgICAgbGV0IGZpcnN0TmV3TGluZVxuICAgICAgICBsZXQgc2Vjb25kTmV3TGluZVxuICAgICAgICAvLyBGaW5kIHRoZSBuZXdsaW5lIGJlZm9yZSB0aGUgY2FyZXRcbiAgICAgICAgZm9yIChcbiAgICAgICAgICAgIGZpcnN0TmV3TGluZSA9IHNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgZmlyc3ROZXdMaW5lID4gMCAmJiB0ZXh0W2ZpcnN0TmV3TGluZSAtIDFdICE9PSBcIlxcblwiO1xuICAgICAgICAgICAgLS1maXJzdE5ld0xpbmVcbiAgICAgICAgKTtcbiAgICAgICAgLy8gRmluZCB0aGUgbmV3bGluZSBhZnRlciB0aGUgY2FyZXRcbiAgICAgICAgZm9yIChcbiAgICAgICAgICAgIHNlY29uZE5ld0xpbmUgPSBzZWxlY3Rpb25TdGFydDtcbiAgICAgICAgICAgIHNlY29uZE5ld0xpbmUgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0W3NlY29uZE5ld0xpbmUgLSAxXSAhPT0gXCJcXG5cIjtcbiAgICAgICAgICAgICsrc2Vjb25kTmV3TGluZVxuICAgICAgICApO1xuICAgICAgICAvLyBSZW1vdmUgZXZlcnl0aGluZyBiZXR3ZWVuIHRoZSBuZXdsaW5lIGFuZCB0aGUgY2FyZXRcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKDAsIGZpcnN0TmV3TGluZSkgKyB0ZXh0LnN1YnN0cmluZyhzZWNvbmROZXdMaW5lKSxcbiAgICAgICAgICAgIGZpcnN0TmV3TGluZSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgIF1cbiAgICB9KSxcbilcblxuLyoqXG4gKiBCZWhhdmVzIGxpa2UgcmVhZGxpbmUncyBba2lsbF93b3JkXShodHRwOi8vd2ViLm1pdC5lZHUvZ251L2RvYy9odG1sL3JsbWFuXzEuaHRtbCNTRUMxNSkuIERlbGV0ZXMgZXZlcnkgY2hhcmFjdGVyIGZyb20gdGhlIGNhcmV0IHRvIHRoZSBlbmQgb2YgYSB3b3JkLCB3aXRoIHdvcmRzIGJlaW5nIGRlZmluZWQgYnkgdGhlIHdvcmRwYXR0ZXJuIHNldHRpbmcuXG4gKiovXG5leHBvcnQgY29uc3Qga2lsbF93b3JkID0gd3JhcF9pbnB1dChcbiAgICBuZWVkc190ZXh0KCh0ZXh0LCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKSA9PiB7XG4gICAgICAgIGNvbnN0IGJvdW5kYXJpZXMgPSBnZXRXb3JkQm91bmRhcmllcyh0ZXh0LCBzZWxlY3Rpb25TdGFydCwgZmFsc2UpXG4gICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCA+IGJvdW5kYXJpZXNbMF0gJiYgc2VsZWN0aW9uU3RhcnQgPCBib3VuZGFyaWVzWzFdKVxuICAgICAgICAgICAgYm91bmRhcmllc1swXSA9IHNlbGVjdGlvblN0YXJ0XG4gICAgICAgIC8vIFJlbW92ZSBldmVyeXRoaW5nIGJldHdlZW4gdGhlIG5ld2xpbmUgYW5kIHRoZSBjYXJldFxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGV4dC5zdWJzdHJpbmcoMCwgYm91bmRhcmllc1swXSkgK1xuICAgICAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKGJvdW5kYXJpZXNbMV0gKyAxKSxcbiAgICAgICAgICAgIGJvdW5kYXJpZXNbMF0sXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICBdXG4gICAgfSksXG4pXG5cbi8qKlxuICogQmVoYXZlcyBsaWtlIHJlYWRsaW5lJ3MgW2JhY2t3YXJkX2tpbGxfd29yZF0oaHR0cDovL3dlYi5taXQuZWR1L2dudS9kb2MvaHRtbC9ybG1hbl8xLmh0bWwjU0VDMTUpLiBEZWxldGVzIGV2ZXJ5IGNoYXJhY3RlciBmcm9tIHRoZSBjYXJldCB0byB0aGUgYmVnaW5uaW5nIG9mIGEgd29yZCB3aXRoIHdvcmQgYmVpbmcgZGVmaW5lZCBieSB0aGUgd29yZHBhdHRlcm4gc2V0dGluZy5cbiAqKi9cbmV4cG9ydCBjb25zdCBiYWNrd2FyZF9raWxsX3dvcmQgPSB3cmFwX2lucHV0KFxuICAgIG5lZWRzX3RleHQoKHRleHQsIHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpID0+IHtcbiAgICAgICAgY29uc3QgYm91bmRhcmllcyA9IGdldFdvcmRCb3VuZGFyaWVzKHRleHQsIHNlbGVjdGlvblN0YXJ0LCB0cnVlKVxuICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPiBib3VuZGFyaWVzWzBdICYmIHNlbGVjdGlvblN0YXJ0IDwgYm91bmRhcmllc1sxXSlcbiAgICAgICAgICAgIGJvdW5kYXJpZXNbMV0gPSBzZWxlY3Rpb25TdGFydFxuICAgICAgICAvLyBSZW1vdmUgZXZlcnl0aGluZyBiZXR3ZWVuIHRoZSBuZXdsaW5lIGFuZCB0aGUgY2FyZXRcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKDAsIGJvdW5kYXJpZXNbMF0pICsgdGV4dC5zdWJzdHJpbmcoYm91bmRhcmllc1sxXSksXG4gICAgICAgICAgICBib3VuZGFyaWVzWzBdLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgXVxuICAgIH0pLFxuKVxuXG4vKipcbiAqIEJlaGF2ZXMgbGlrZSByZWFkbGluZSdzIFtiZWdpbm5pbmdfb2ZfbGluZV0oaHR0cDovL3dlYi5taXQuZWR1L2dudS9kb2MvaHRtbC9ybG1hbl8xLmh0bWwjU0VDMTIpLiBNb3ZlcyB0aGUgY2FyZXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSBmaXJzdCBuZXdsaW5lIGNoYXJhY3RlciBmb3VuZCBhdCB0aGUgbGVmdCBvZiB0aGUgY2FyZXQuIElmIG5vIG5ld2xpbmUgY2FuIGJlIGZvdW5kLCBtb3ZlIHRoZSBjYXJldCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICoqL1xuZXhwb3J0IGNvbnN0IGJlZ2lubmluZ19vZl9saW5lID0gd3JhcF9pbnB1dChcbiAgICBuZWVkc190ZXh0KCh0ZXh0LCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKSA9PiB7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAgIHRleHRbc2VsZWN0aW9uU3RhcnQgLSAxXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0ZXh0W3NlbGVjdGlvblN0YXJ0IC0gMV0gIT09IFwiXFxuXCJcbiAgICAgICAgKVxuICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQgLT0gMVxuICAgICAgICByZXR1cm4gW251bGwsIHNlbGVjdGlvblN0YXJ0LCBudWxsXVxuICAgIH0pLFxuKVxuXG4vKipcbiAqIEJlaGF2ZXMgbGlrZSByZWFkbGluZSdzIFtlbmRfb2ZfbGluZV0oaHR0cDovL3dlYi5taXQuZWR1L2dudS9kb2MvaHRtbC9ybG1hbl8xLmh0bWwjU0VDMTIpLiBNb3ZlcyB0aGUgY2FyZXQgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5ld2xpbmUgY2hhcmFjdGVyIGZvdW5kIGF0IHRoZSByaWdodCBvZiB0aGUgY2FyZXQuIElmIG5vIG5ld2xpbmUgY2FuIGJlIGZvdW5kLCBtb3ZlIHRoZSBjYXJldCB0byB0aGUgZW5kIG9mIHRoZSB0ZXh0LlxuICoqL1xuZXhwb3J0IGNvbnN0IGVuZF9vZl9saW5lID0gd3JhcF9pbnB1dChcbiAgICBuZWVkc190ZXh0KCh0ZXh0LCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKSA9PiB7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAgIHRleHRbc2VsZWN0aW9uU3RhcnRdICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRleHRbc2VsZWN0aW9uU3RhcnRdICE9PSBcIlxcblwiXG4gICAgICAgIClcbiAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0ICs9IDFcbiAgICAgICAgcmV0dXJuIFtudWxsLCBzZWxlY3Rpb25TdGFydCwgbnVsbF1cbiAgICB9KSxcbilcblxuLyoqXG4gKiBCZWhhdmVzIGxpa2UgcmVhZGxpbmUncyBbZm9yd2FyZF9jaGFyXShodHRwOi8vd2ViLm1pdC5lZHUvZ251L2RvYy9odG1sL3JsbWFuXzEuaHRtbCNTRUMxMikuIE1vdmVzIHRoZSBjYXJldCBvbmUgY2hhcmFjdGVyIHRvIHRoZSByaWdodC5cbiAqKi9cbmV4cG9ydCBjb25zdCBmb3J3YXJkX2NoYXIgPSB3cmFwX2lucHV0KCh0ZXh0LCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKSA9PiB7XG4gICAgcmV0dXJuIFtudWxsLCBzZWxlY3Rpb25TdGFydCArIDEsIG51bGxdXG59KVxuXG4vKipcbiAqIEJlaGF2ZXMgbGlrZSByZWFkbGluZSdzIFtiYWNrd2FyZF9jaGFyXShodHRwOi8vd2ViLm1pdC5lZHUvZ251L2RvYy9odG1sL3JsbWFuXzEuaHRtbCNTRUMxMikuIE1vdmVzIHRoZSBjYXJldCBvbmUgY2hhcmFjdGVyIHRvIHRoZSBsZWZ0LlxuICoqL1xuZXhwb3J0IGNvbnN0IGJhY2t3YXJkX2NoYXIgPSB3cmFwX2lucHV0KFxuICAgICh0ZXh0LCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKSA9PiB7XG4gICAgICAgIHJldHVybiBbbnVsbCwgc2VsZWN0aW9uU3RhcnQgLSAxLCBudWxsXVxuICAgIH0sXG4pXG5cbi8qKlxuICogQmVoYXZlcyBsaWtlIHJlYWRsaW5lJ3MgW2ZvcndhcmRfd29yZF0oaHR0cDovL3dlYi5taXQuZWR1L2dudS9kb2MvaHRtbC9ybG1hbl8xLmh0bWwjU0VDMTIpLiBNb3ZlcyB0aGUgY2FyZXQgb25lIHdvcmQgdG8gdGhlIHJpZ2h0LCB3aXRoIHdvcmRzIGJlaW5nIGRlZmluZWQgYnkgdGhlIHdvcmRwYXR0ZXJuIHNldHRpbmcuXG4gKiovXG5leHBvcnQgY29uc3QgZm9yd2FyZF93b3JkID0gd3JhcF9pbnB1dChcbiAgICBuZWVkc190ZXh0KCh0ZXh0LCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKSA9PiB7XG4gICAgICAgIGxldCBib3VuZGFyaWVzID0gZ2V0V29yZEJvdW5kYXJpZXModGV4dCwgc2VsZWN0aW9uU3RhcnQsIGZhbHNlKVxuICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPj0gYm91bmRhcmllc1swXSAmJiBzZWxlY3Rpb25TdGFydCA8IGJvdW5kYXJpZXNbMV0pXG4gICAgICAgICAgICBib3VuZGFyaWVzID0gZ2V0V29yZEJvdW5kYXJpZXModGV4dCwgYm91bmRhcmllc1sxXSwgZmFsc2UpXG4gICAgICAgIHJldHVybiBbbnVsbCwgYm91bmRhcmllc1swXSwgbnVsbF1cbiAgICB9KSxcbilcblxuLyoqXG4gKiBCZWhhdmVzIGxpa2UgcmVhZGxpbmUncyBbYmFja3dhcmRfd29yZF0oaHR0cDovL3dlYi5taXQuZWR1L2dudS9kb2MvaHRtbC9ybG1hbl8xLmh0bWwjU0VDMTIpLiBNb3ZlcyB0aGUgY2FyZXQgb25lIHdvcmQgdG8gdGhlIHJpZ2h0LCB3aXRoIHdvcmRzIGJlaW5nIGRlZmluZWQgYnkgdGhlIHdvcmRwYXR0ZXJuIHNldHRpbmcuXG4gKiovXG5leHBvcnQgY29uc3QgYmFja3dhcmRfd29yZCA9IHdyYXBfaW5wdXQoXG4gICAgKHRleHQsIHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpID0+IHtcbiAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID09PSAwKSByZXR1cm4gW251bGwsIG51bGwsIG51bGxdXG4gICAgICAgIGxldCBib3VuZGFyaWVzID0gZ2V0V29yZEJvdW5kYXJpZXModGV4dCwgc2VsZWN0aW9uU3RhcnQsIHRydWUpXG4gICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCA+PSBib3VuZGFyaWVzWzBdICYmIHNlbGVjdGlvblN0YXJ0IDwgYm91bmRhcmllc1sxXSlcbiAgICAgICAgICAgIGJvdW5kYXJpZXMgPSBnZXRXb3JkQm91bmRhcmllcyh0ZXh0LCBib3VuZGFyaWVzWzBdIC0gMSwgdHJ1ZSlcbiAgICAgICAgcmV0dXJuIFtudWxsLCBib3VuZGFyaWVzWzBdLCBudWxsXVxuICAgIH0sXG4pXG5cbi8qKlxuICogSW5zZXJ0IHRleHQgaW4gdGhlIGN1cnJlbnQgaW5wdXQuXG4gKiovXG5leHBvcnQgY29uc3QgaW5zZXJ0X3RleHQgPSB3cmFwX2lucHV0KFxuICAgICh0ZXh0LCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kLCBhcmcpID0+IHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRleHQuc2xpY2UoMCwgc2VsZWN0aW9uU3RhcnQpICsgYXJnICsgdGV4dC5zbGljZShzZWxlY3Rpb25FbmQpLFxuICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQgKyBhcmcubGVuZ3RoLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgXVxuICAgIH0sXG4pXG5cbmV4cG9ydCBjb25zdCByb3QxMyA9IHdyYXBfaW5wdXQoXG4gICAgKHRleHQsIHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpID0+IHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHJvdDEzX2hlbHBlcih0ZXh0LnNsaWNlKDAsIHNlbGVjdGlvblN0YXJ0KSArIHRleHQuc2xpY2Uoc2VsZWN0aW9uRW5kKSksXG4gICAgICAgICAgICBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgIF1cbiAgICB9LFxuKVxuIiwiXG4vLyBXZSBoYXZlIGEgc2luZ2xlIGRlcGVuZGVuY3kgb24gY29uZmlnOiBnZXR0aW5nIHRoZSB2YWx1ZSBvZiB0aGUgV09SRFBBVFRFUk4gc2V0dGluZ1xuLy8gUGVyaGFwcyB3ZSBjb3VsZCBmaW5kIGEgd2F5IHRvIGdldCByaWQgb2YgaXQ/XG5pbXBvcnQgKiBhcyBjb25maWcgZnJvbSBcIkBzcmMvbGliL2NvbmZpZ1wiXG5cbmV4cG9ydCB0eXBlIGVkaXRvcl9mdW5jdGlvbiA9IChcbiAgICB0ZXh0OiBzdHJpbmcsXG4gICAgc3RhcnQ6IG51bWJlcixcbiAgICBlbmQ6IG51bWJlcixcbiAgICBhcmc/OiBhbnksXG4pID0+IFtzdHJpbmcsIG51bWJlciwgbnVtYmVyXVxuXG4vKipcbiAqIEFwcGxpZXMgYSBmdW5jdGlvbiB0byBhbiBlbGVtZW50LiBJZiB0aGUgZWxlbWVudCBpcyBhbiBIVE1MSW5wdXRFbGVtZW50IGFuZCBpdHMgdHlwZSBpc24ndCBcInRleHRcIiwgaXQgaXMgZmlyc3QgdHVybmVkIGludG8gYSBcInRleHRcIiBlbGVtZW50LiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNvbWUgZWxlbWVudHMgKGUuZy4gXCJlbWFpbFwiKSBkbyBub3QgaGF2ZSBhIHNlbGVjdGlvblN0YXJ0L3NlbGVjdGlvbkVuZC5cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MSW5wdXRFbGVtZW50L3NldFNlbGVjdGlvblJhbmdlIC5cbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVRvRWxlbShlLCBmbikge1xuICAgIGxldCByZXN1bHRcbiAgICBpZiAoZSBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgJiYgZS50eXBlICE9PSBcInRleHRcIikge1xuICAgICAgICBjb25zdCB0ID0gZS50eXBlXG4gICAgICAgIGUudHlwZSA9IFwidGV4dFwiXG4gICAgICAgIHJlc3VsdCA9IGZuKGUpXG4gICAgICAgIGUudHlwZSA9IHRcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBmbihlKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogUmV0dXJucyB2YWx1ZXMgbmVjZXNzYXJ5IGZvciBlZGl0b3IgZnVuY3Rpb25zIHRvIHdvcmsgb24gdGV4dGFyZWEvaW5wdXQgZWxlbWVudHNcbiAqXG4gKiBAcGFyYW0gZSB0aGUgZWxlbWVudFxuICogQHJldHVybiBbc3RyaW5nLCBudW1iZXIsIG51bWJlcl0gVGhlIGNvbnRlbnQgb2YgdGhlIGVsZW1lbnQsIHRoZSBwb3NpdGlvbiBvZiB0aGUgY2FyZXQsIHRoZSBwb3NpdGlvbiBvZiB0aGUgZW5kIG9mIHRoZSB2aXN1YWwgc2VsZWN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaW1wbGVWYWx1ZXMoZTogYW55KSB7XG4gICAgcmV0dXJuIGFwcGx5VG9FbGVtKGUsIGUgPT4gW2UudmFsdWUsIGUuc2VsZWN0aW9uU3RhcnQsIGUuc2VsZWN0aW9uRW5kXSlcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHZhbHVlcyBuZWNlc3NhcnkgZm9yIGVkaXRvciBmdW5jdGlvbnMgdG8gd29yayBvbiBjb250ZW50RWRpdGFibGUgZWxlbWVudHNcbiAqXG4gKiBAcGFyYW0gZSBhIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50XG4gKiBAcmV0dXJuIFtzdHJpbmcsIG51bWJlciwgbnVtYmVyXSBUaGUgY29udGVudCBvZiB0aGUgZWxlbWVudCwgdGhlIHBvc2l0aW9uIG9mIHRoZSBjYXJldCwgdGhlIHBvc2l0aW9uIG9mIHRoZSBlbmQgb2YgdGhlIHZpc3VhbCBzZWxlY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRlbnRFZGl0YWJsZVZhbHVlcyhlOiBhbnkpOiBbc3RyaW5nLCBudW1iZXIsIG51bWJlcl0ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGUub3duZXJEb2N1bWVudC5nZXRTZWxlY3Rpb24oKVxuICAgIC8vIFRoZSBzZWxlY3Rpb24gbWlnaHQgYWN0dWFsbHkgbm90IGJlIGluIGUgc28gd2UgbmVlZCB0byBtYWtlIHN1cmUgaXQgaXNcbiAgICBsZXQgbiA9IHNlbGVjdGlvbi5hbmNob3JOb2RlXG4gICAgd2hpbGUgKG4gJiYgbiAhPT0gZSkgbiA9IG4ucGFyZW50Tm9kZVxuICAgIC8vIFRoZSBzZWxlY3Rpb24gaXNuJ3QgZm9yIGUsIHNvIHdlIGNhbid0IGRvIGFueXRoaW5nXG4gICAgaWYgKCFuKSByZXR1cm4gW251bGwsIG51bGwsIG51bGxdXG4gICAgLy8gc2VsZWN0aW9uIG1pZ2h0IHNwYW4gbXVsdGlwbGUgZWxlbWVudHMsIG1pZ2h0IG5vdCBzdGFydCB3aXRoIHRoZSBmaXJzdCBlbGVtZW50IGluIGUgb3IgZW5kIHdpdGggdGhlIGxhc3QgZWxlbWVudCBpbiBlIHNvIHRoZSBlYXNpZXN0IHdheSB0byBjb21wdXRlIGNhcmV0IHBvc2l0aW9uIGZyb20gYmVnaW5uaW5nIG9mIGUgaXMgdG8gZmlyc3QgY29tcHV0ZSBkaXN0YW5jZSBmcm9tIGNhcmV0IHRvIGVuZCBvZiBlLCB0aGVuIG1vdmUgYmVnaW5uaW5nIG9mIHNlbGVjdGlvbiB0byBiZWdpbm5pbmcgb2YgZSBhbmQgdGhlbiB1c2UgZGlzdGFuY2UgZnJvbSBlbmQgb2Ygc2VsZWN0aW9uIHRvIGNvbXB1dGUgZGlzdGFuY2UgZnJvbSBiZWdpbm5pbmcgb2Ygc2VsZWN0aW9uXG4gICAgY29uc3QgciA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApLmNsb25lUmFuZ2UoKVxuICAgIGNvbnN0IHNlbGVjdGlvbkxlbmd0aCA9IHIudG9TdHJpbmcoKS5sZW5ndGhcbiAgICByLnNldEVuZChlLCBlLmNoaWxkTm9kZXMubGVuZ3RoKVxuICAgIGNvbnN0IGxlbmd0aEZyb21DYXJldFRvRW5kT2ZUZXh0ID0gci50b1N0cmluZygpLmxlbmd0aFxuICAgIHIuc2V0U3RhcnQoZSwgMClcbiAgICBjb25zdCBzID0gci50b1N0cmluZygpXG4gICAgY29uc3QgY2FyZXRQb3MgPSBzLmxlbmd0aCAtIGxlbmd0aEZyb21DYXJldFRvRW5kT2ZUZXh0XG4gICAgcmV0dXJuIFtzLCBjYXJldFBvcywgY2FyZXRQb3MgKyBzZWxlY3Rpb25MZW5ndGhdXG59XG5cbi8qKlxuICogQ2hhbmdlIHRleHQgaW4gcmVndWxhciB0ZXh0YXJlYS9pbnB1dCBmaWVsZHMuIE5vdGU6IHRoaXMgZGVzdHJveXMgdGhlIGZpZWxkJ3MgaGlzdG9yeSAoaS5lLiBDLXogd29uJ3Qgd29yaykuXG4gKlxuICogQHBhcmFtIGUgVGhlIGVsZW1lbnRcbiAqIEBwYXJhbSB0ZXh0IFRoZSBuZXcgY29udGVudCBvZiB0aGUgZWxlbWVudCwgbnVsbCBpZiBpdCBzaG91bGRuJ3QgY2hhbmdlXG4gKiBAcGFyYW0gc3RhcnQgVGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgY2FyZXQsIG51bGwgaWYgdGhlIGNhcmV0IHNob3VsZG4ndCBtb3ZlXG4gKiBAcGFyYW0gZW5kIFRoZSBlbmQgb2YgdGhlIHZpc3VhbCBzZWxlY3Rpb24sIG51bGwgaWYgeW91IGp1c3Qgd2FudCB0byBtb3ZlIHRoZSBjYXJldFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0U2ltcGxlVmFsdWVzKGUsIHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gYXBwbHlUb0VsZW0oZSwgZSA9PiB7XG4gICAgICAgIGlmICh0ZXh0ICE9PSBudWxsKSBlLnZhbHVlID0gdGV4dFxuICAgICAgICBpZiAoc3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChlbmQgPT09IG51bGwpIGVuZCA9IHN0YXJ0XG4gICAgICAgICAgICBlLnNlbGVjdGlvblN0YXJ0ID0gc3RhcnRcbiAgICAgICAgICAgIGUuc2VsZWN0aW9uRW5kID0gZW5kXG4gICAgICAgIH1cbiAgICB9KVxufVxuXG4vKipcbiAqIENoYW5nZSB0ZXh0IGluIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50cyBpbiBhIG5vbi1kZXN0cnVjdGl2ZSB3YXkgKGkuZS4gQy16IHdpbGwgdW5kbyBjaGFuZ2VzKS5cbiAqIEBwYXJhbSBlIFRoZSBjb250ZW50IGVkaXRhYmxlIGVsZW1lbnRcbiAqIEBwYXJhbSB0ZXh0IFRoZSBuZXcgY29udGVudCB0aGUgZWxlbWVudCBzaG91bGQgaGF2ZS4gbnVsbCBpZiB5b3UganVzdCB3YW50IHRvIG1vdmUgdGhlIGNhcmV0IGFyb3VuZFxuICogQHBhcmFtIHN0YXJ0IFRoZSBuZXcgY2FyZXQgcG9zaXRpb24uIG51bGwgaWYgeW91IGp1c3Qgd2FudCB0byBjaGFuZ2UgdGV4dC5cbiAqIEBwYXJhbSBlbmQgVGhlIGVuZCBvZiB0aGUgdmlzdWFsIHNlbGVjdGlvbi4gbnVsbCBpZiB5b3UganVzdCB3YW50IHRvIG1vdmUgdGhlIGNhcmV0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0Q29udGVudEVkaXRhYmxlVmFsdWVzKGUsIHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBlLm93bmVyRG9jdW1lbnQuZ2V0U2VsZWN0aW9uKClcbiAgICBpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgPCAxKSB7XG4gICAgICAgIGNvbnN0IHIgPSBuZXcgUmFuZ2UoKVxuICAgICAgICByLnNldFN0YXJ0KGUsIDApXG4gICAgICAgIHIuc2V0RW5kKGUsIGUuY2hpbGROb2Rlcy5sZW5ndGgpXG4gICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyKVxuICAgIH1cbiAgICBpZiAodGV4dCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApXG4gICAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yTm9kZVxuICAgICAgICBjb25zdCBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXNOb2RlXG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KGFuY2hvck5vZGUsIDApXG4gICAgICAgIHJhbmdlLnNldEVuZEFmdGVyKGZvY3VzTm9kZSwgZm9jdXNOb2RlLmxlbmd0aClcbiAgICAgICAgZS5vd25lckRvY3VtZW50LmV4ZWNDb21tYW5kKFwiaW5zZXJ0VGV4dFwiLCBmYWxzZSwgdGV4dClcbiAgICB9XG4gICAgaWYgKHN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChlbmQgPT09IG51bGwpIGVuZCA9IHN0YXJ0XG4gICAgICAgIGxldCByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApXG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KHJhbmdlLnN0YXJ0Q29udGFpbmVyLCBzdGFydClcbiAgICAgICAgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKVxuICAgICAgICByYW5nZS5zZXRFbmQocmFuZ2Uuc3RhcnRDb250YWluZXIsIGVuZClcbiAgICB9XG59XG5cbi8qKlxuICogVGFrZSBhbiBlZGl0b3IgZnVuY3Rpb24gYXMgcGFyYW1ldGVyIGFuZCByZXR1cm4gaXQgd3JhcHBlZCBpbiBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBoYW5kbGUgZ3JhYmJpbmcgdGV4dCBhbmQgY2FyZXQgcG9zaXRpb24gZnJvbSB0aGUgSFRNTCBlbGVtZW50IGl0IHRha2VzIGFzIHBhcmFtZXRlclxuICpcbiAqIEBwYXJhbSBlZGl0b3JfZnVuY3Rpb24gQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgW3N0cmluZywgc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZF0gdHVwbGUgYXMgYXJndW1lbnQgYW5kIHJldHVybnMgYSBbc3RyaW5nLCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kXSB0dXBsZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBuZXcgc3RhdGUgb2YgdGhlIHRleHQuXG4gKlxuICogQHJldHVybiBib29sZWFuIFdoZXRoZXIgdGhlIGVkaXRvciBmdW5jdGlvbiB3YXMgYWN0dWFsbHkgY2FsbGVkIG9yIG5vdFxuICpcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwX2lucHV0KFxuICAgIGZuOiBlZGl0b3JfZnVuY3Rpb24sXG4pOiAoZTogSFRNTEVsZW1lbnQsIGFyZz86IGFueSkgPT4gYm9vbGVhbiB7XG4gICAgcmV0dXJuIChlOiBIVE1MRWxlbWVudCwgYXJnPzogYW55KSA9PiB7XG4gICAgICAgIGxldCBnZXRWYWx1ZXMgPSBnZXRTaW1wbGVWYWx1ZXNcbiAgICAgICAgbGV0IHNldFZhbHVlcyA9IHNldFNpbXBsZVZhbHVlc1xuICAgICAgICBpZiAoZS5pc0NvbnRlbnRFZGl0YWJsZSkge1xuICAgICAgICAgICAgZ2V0VmFsdWVzID0gZ2V0Q29udGVudEVkaXRhYmxlVmFsdWVzXG4gICAgICAgICAgICBzZXRWYWx1ZXMgPSBzZXRDb250ZW50RWRpdGFibGVWYWx1ZXNcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbb3JpZ1RleHQsIG9yaWdTdGFydCwgb3JpZ0VuZF0gPSBnZXRWYWx1ZXMoZSlcbiAgICAgICAgaWYgKG9yaWdUZXh0ID09PSBudWxsIHx8IG9yaWdTdGFydCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlXG4gICAgICAgIHNldFZhbHVlcyhlLCAuLi5mbihvcmlnVGV4dCwgb3JpZ1N0YXJ0LCBvcmlnRW5kLCBhcmcpKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbn1cblxuLyoqXG4gKiBUYWtlIGFuIGVkaXRvciBmdW5jdGlvbiBhcyBwYXJhbWV0ZXIgYW5kIHdyYXAgaXQgaW4gYSBmdW5jdGlvbiB0aGF0IHdpbGwgaGFuZGxlIGVycm9yIGNvbmRpdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5lZWRzX3RleHQoZm46IGVkaXRvcl9mdW5jdGlvbiwgYXJnPzogYW55KTogZWRpdG9yX2Z1bmN0aW9uIHtcbiAgICByZXR1cm4gKFxuICAgICAgICB0ZXh0OiBzdHJpbmcsXG4gICAgICAgIHNlbGVjdGlvblN0YXJ0OiBudW1iZXIsXG4gICAgICAgIHNlbGVjdGlvbkVuZDogbnVtYmVyLFxuICAgICAgICBhcmc/OiBhbnksXG4gICAgKSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRleHQubGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgICBzZWxlY3Rpb25TdGFydCA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQgPT09IHVuZGVmaW5lZFxuICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gW251bGwsIG51bGwsIG51bGxdXG4gICAgICAgIHJldHVybiBmbihcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgIHR5cGVvZiBzZWxlY3Rpb25FbmQgPT09IFwibnVtYmVyXCIgPyBzZWxlY3Rpb25FbmQgOiBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgIGFyZyxcbiAgICAgICAgKVxuICAgIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGxpbmUgYW5kIGNvbHVtbiBudW1iZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMaW5lQW5kQ29sTnVtYmVyKHRleHQ6IHN0cmluZywgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpOiBbc3RyaW5nLCBudW1iZXIsIG51bWJlcl0ge1xuICAgIGNvbnN0IGxpbmVzID0gdGV4dC5zcGxpdChcIlxcblwiKVxuICAgIGxldCB0b3RhbENoYXJzID0gMFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgLy8gKzEgYmVjYXVzZSB3ZSBhbHNvIG5lZWQgdG8gdGFrZSAnXFxuJyBpbnRvIGFjY291bnRcbiAgICAgICAgaWYgKHRvdGFsQ2hhcnMgKyBsaW5lc1tpXS5sZW5ndGggKyAxID4gc3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGV4dCwgaSArIDEsIHN0YXJ0IC0gdG90YWxDaGFyc11cbiAgICAgICAgfVxuICAgICAgICB0b3RhbENoYXJzICs9IGxpbmVzW2ldLmxlbmd0aCArIDFcbiAgICB9XG4gICAgcmV0dXJuIFt0ZXh0LCBsaW5lcy5sZW5ndGgsIDFdXG59XG5cbi8qKlxuICogRGV0ZWN0cyB0aGUgYm91bmRhcmllcyBvZiBhIHdvcmQgaW4gdGV4dCBhY2NvcmRpbmcgdG8gdGhlIHdvcmRwYXR0ZXJuIHNldHRpbmcuIElmIFBPU0lUSU9OIGlzIGluIGEgd29yZCwgdGhlIGJvdW5kYXJpZXMgb2YgdGhpcyB3b3JkIGFyZSByZXR1cm5lZC4gSWYgUE9TSVRJT04gaXMgb3V0IG9mIGEgd29yZCBhbmQgQkVGT1JFIGlzIHRydWUsIHRoZSB3b3JkIGJlZm9yZSBQT1NJVElPTiBpcyByZXR1cm5lZC4gSWYgQkVGT1JFIGlzIGZhbHNlLCB0aGUgd29yZCBhZnRlciB0aGUgY2FyZXQgaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRXb3JkQm91bmRhcmllcyhcbiAgICB0ZXh0OiBzdHJpbmcsXG4gICAgcG9zaXRpb246IG51bWJlcixcbiAgICBiZWZvcmU6IGJvb2xlYW4sXG4pOiBbbnVtYmVyLCBudW1iZXJdIHtcbiAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID4gdGV4dC5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBnZXRXb3JkQm91bmRhcmllczogcG9zaXRpb24gKCR7cG9zaXRpb259KSBzaG91bGQgYmUgd2l0aGluIHRleHQgKFwiJHt0ZXh0fVwiKSBib3VuZGFyaWVzICgwLCAke1xuICAgICAgICAgICAgICAgIHRleHQubGVuZ3RoXG4gICAgICAgICAgICB9KWAsXG4gICAgICAgIClcbiAgICBjb25zdCBwYXR0ZXJuID0gbmV3IFJlZ0V4cChjb25maWcuZ2V0KFwid29yZHBhdHRlcm5cIiksIFwiZ1wiKVxuICAgIGxldCBib3VuZGFyeTEgPSBwb3NpdGlvbiA8IHRleHQubGVuZ3RoID8gcG9zaXRpb24gOiB0ZXh0Lmxlbmd0aCAtIDFcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBiZWZvcmUgPyAtMSA6IDFcbiAgICAvLyBpZiB0aGUgY2FyZXQgaXMgbm90IGluIGEgd29yZCwgdHJ5IHRvIGZpbmQgdGhlIHdvcmQgYmVmb3JlIG9yIGFmdGVyIGl0XG4gICAgd2hpbGUgKFxuICAgICAgICBib3VuZGFyeTEgPj0gMCAmJlxuICAgICAgICBib3VuZGFyeTEgPCB0ZXh0Lmxlbmd0aCAmJlxuICAgICAgICAhdGV4dFtib3VuZGFyeTFdLm1hdGNoKHBhdHRlcm4pXG4gICAgKSB7XG4gICAgICAgIGJvdW5kYXJ5MSArPSBkaXJlY3Rpb25cbiAgICB9XG5cbiAgICBpZiAoYm91bmRhcnkxIDwgMCkgYm91bmRhcnkxID0gMFxuICAgIGVsc2UgaWYgKGJvdW5kYXJ5MSA+PSB0ZXh0Lmxlbmd0aCkgYm91bmRhcnkxID0gdGV4dC5sZW5ndGggLSAxXG5cbiAgICAvLyBpZiBhIHdvcmQgY291bGRuJ3QgYmUgZm91bmQgaW4gdGhpcyBkaXJlY3Rpb24sIHRyeSB0aGUgb3RoZXIgb25lXG4gICAgd2hpbGUgKFxuICAgICAgICBib3VuZGFyeTEgPj0gMCAmJlxuICAgICAgICBib3VuZGFyeTEgPCB0ZXh0Lmxlbmd0aCAmJlxuICAgICAgICAhdGV4dFtib3VuZGFyeTFdLm1hdGNoKHBhdHRlcm4pXG4gICAgKSB7XG4gICAgICAgIGJvdW5kYXJ5MSAtPSBkaXJlY3Rpb25cbiAgICB9XG5cbiAgICBpZiAoYm91bmRhcnkxIDwgMCkgYm91bmRhcnkxID0gMFxuICAgIGVsc2UgaWYgKGJvdW5kYXJ5MSA+PSB0ZXh0Lmxlbmd0aCkgYm91bmRhcnkxID0gdGV4dC5sZW5ndGggLSAxXG5cbiAgICBpZiAoIXRleHRbYm91bmRhcnkxXS5tYXRjaChwYXR0ZXJuKSkge1xuICAgICAgICAvLyB0aGVyZSBpcyBubyB3b3JkIGluIHRleHRcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYGdldFdvcmRCb3VuZGFyaWVzOiBubyBjaGFyYWN0ZXJzIG1hdGNoaW5nIHdvcmRwYXR0ZXJuICgke1xuICAgICAgICAgICAgICAgIHBhdHRlcm4uc291cmNlXG4gICAgICAgICAgICB9KSBpbiB0ZXh0ICgke3RleHR9KWAsXG4gICAgICAgIClcbiAgICB9XG5cbiAgICAvLyBub3cgdGhhdCB3ZSBrbm93IHRoZSBjYXJldCBpcyBpbiBhIHdvcmQgKGl0IGNvdWxkIGJlIGluIHRoZSBtaWRkbGUgZGVwZW5kaW5nIG9uIFBPU0lUSU9OISksIHRyeSB0byBmaW5kIGl0cyBiZWdpbm5pbmcvZW5kXG4gICAgd2hpbGUgKFxuICAgICAgICBib3VuZGFyeTEgPj0gMCAmJlxuICAgICAgICBib3VuZGFyeTEgPCB0ZXh0Lmxlbmd0aCAmJlxuICAgICAgICAhIXRleHRbYm91bmRhcnkxXS5tYXRjaChwYXR0ZXJuKVxuICAgICkge1xuICAgICAgICBib3VuZGFyeTEgKz0gZGlyZWN0aW9uXG4gICAgfVxuICAgIC8vIGJvdW5kYXJ5MSBpcyBub3cgb3V0c2lkZSBvZiB0aGUgd29yZCwgYnJpbmcgaXQgYmFjayBpbnNpZGUgb2YgaXRcbiAgICBib3VuZGFyeTEgLT0gZGlyZWN0aW9uXG5cbiAgICBsZXQgYm91bmRhcnkyID0gYm91bmRhcnkxXG4gICAgLy8gbm93IHRoYXQgd2Uga25vdyB0aGUgY2FyZXQgaXMgYXQgdGhlIGJlZ2lubmluZy9lbmQgb2YgYSB3b3JkLCB3ZSBuZWVkIHRvIGZpbmQgdGhlIG90aGVyIGJvdW5kYXJ5XG4gICAgd2hpbGUgKFxuICAgICAgICBib3VuZGFyeTIgPj0gMCAmJlxuICAgICAgICBib3VuZGFyeTIgPCB0ZXh0Lmxlbmd0aCAmJlxuICAgICAgICAhIXRleHRbYm91bmRhcnkyXS5tYXRjaChwYXR0ZXJuKVxuICAgICkge1xuICAgICAgICBib3VuZGFyeTIgLT0gZGlyZWN0aW9uXG4gICAgfVxuICAgIC8vIGJvdW5kYXJ5MiBpcyBvdXRzaWRlIG9mIHRoZSB3b3JkLCBicmluZyBpdCBiYWNrIGluXG4gICAgYm91bmRhcnkyICs9IGRpcmVjdGlvblxuXG4gICAgLy8gQWRkIDEgdG8gdGhlIGVuZCBib3VuZGFyeSBiZWNhdXNlIHRoZSBlbmQgb2YgYSB3b3JkIGlzIG1hcmtlZCBieSB0aGUgY2hhcmFjdGVyIGFmdGVyIHNhaWQgd29yZFxuICAgIGlmIChib3VuZGFyeTEgPiBib3VuZGFyeTIpIHJldHVybiBbYm91bmRhcnkyLCBib3VuZGFyeTEgKyAxXVxuICAgIHJldHVybiBbYm91bmRhcnkxLCBib3VuZGFyeTIgKyAxXVxufVxuXG4vKiogQGhpZGRlblxuICogRmluZHMgdGhlIG5leHQgd29yZCBhcyBkZWZpbmVkIGJ5IHRoZSB3b3JkcGF0dGVybiBzZXR0aW5nIGFmdGVyIFBPU0lUSU9OLiBJZiBQT1NJVElPTiBpcyBpbiBhIHdvcmQsIFBPU0lUSU9OIGlzIG1vdmVkIGZvcndhcmQgdW50aWwgaXQgaXMgb3V0IG9mIHRoZSB3b3JkLlxuICogQHJldHVybiBudW1iZXIgVGhlIHBvc2l0aW9uIG9mIHRoZSBuZXh0IHdvcmQgaW4gdGV4dCBvciAtMSBpZiB0aGUgbmV4dCB3b3JkIGNhbid0IGJlIGZvdW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gd29yZEFmdGVyUG9zKHRleHQ6IHN0cmluZywgcG9zaXRpb246IG51bWJlcikge1xuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgd29yZEFmdGVyUG9zOiBwb3NpdGlvbiAoJHtwb3NpdGlvbn0pIGlzIGxlc3MgdGhhdCAwYClcbiAgICBjb25zdCBwYXR0ZXJuID0gbmV3IFJlZ0V4cChjb25maWcuZ2V0KFwid29yZHBhdHRlcm5cIiksIFwiZ1wiKVxuICAgIC8vIG1vdmUgcG9zaXRpb24gb3V0IG9mIHRoZSBjdXJyZW50IHdvcmRcbiAgICB3aGlsZSAocG9zaXRpb24gPCB0ZXh0Lmxlbmd0aCAmJiAhIXRleHRbcG9zaXRpb25dLm1hdGNoKHBhdHRlcm4pKVxuICAgICAgICBwb3NpdGlvbiArPSAxXG4gICAgLy8gdHJ5IHRvIGZpbmQgY2hhcmFjdGVycyB0aGF0IG1hdGNoIHdvcmRwYXR0ZXJuXG4gICAgd2hpbGUgKHBvc2l0aW9uIDwgdGV4dC5sZW5ndGggJiYgIXRleHRbcG9zaXRpb25dLm1hdGNoKHBhdHRlcm4pKVxuICAgICAgICBwb3NpdGlvbiArPSAxXG4gICAgaWYgKHBvc2l0aW9uID49IHRleHQubGVuZ3RoKSByZXR1cm4gLTFcbiAgICByZXR1cm4gcG9zaXRpb25cbn1cblxuLyoqIEBoaWRkZW5cbiAqIFJvdHMgYnkgMTMuXG4gKi9cbmV4cG9ydCBjb25zdCByb3QxM19oZWxwZXIgPSAoczogc3RyaW5nLCBuOiBudW1iZXIgPSAxMyk6IHN0cmluZyA9PiB7XG4gICAgbGV0IHNhID0gcy5zcGxpdChcIlwiKVxuICAgIHNhID0gc2EubWFwKHggPT4gY2hhcmVzYXIoeCwgbikpXG4gICAgcmV0dXJuIHNhLmpvaW4oXCJcIilcbn1cblxuZXhwb3J0IGNvbnN0IGNoYXJlc2FyID0gKGM6IHN0cmluZywgbjogbnVtYmVyID0gMTMpOiBzdHJpbmcgPT4ge1xuICAgIGNvbnN0IGNuID0gYy5jaGFyQ29kZUF0KDApXG4gICAgaWYgKGNuID49IDY1ICYmIGNuIDw9IDkwKVxuICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKCgoY24gLSA2NSkgKyBuKSAlIDI2KSArIDY1KVxuICAgIGlmIChjbiA+PSA5NyAmJiBjbiA8PSAxMjIpXG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoKGNuIC0gOTcpICsgbikgJSAyNikgKyA5NylcbiAgICByZXR1cm4gY1xufVxuIiwiOyhmdW5jdGlvbih3aW5kb3cpIHtcbiAgICBcInVzZSBzdHJpY3RcIlxuXG4gICAgLy8gdGVzdCBmb3IgZXM2IHN1cHBvcnQgb2YgbmVlZGVkIGZ1bmN0aW9uYWxpdHlcbiAgICB0cnkge1xuICAgICAgICAvLyBzcHJlYWQgb3BlcmF0b3IgYW5kIHRlbXBsYXRlIHN0cmluZ3Mgc3VwcG9ydFxuICAgICAgICA7KGZ1bmN0aW9uIHRlc3RTcHJlYWRPcEFuZFRlbXBsYXRlKCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gZnVuY3Rpb24gdGFnKHN0cmluZ3MsIC4uLnZhbHVlcykge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFnYHRlc3RgXG4gICAgICAgIH0pKClcblxuICAgICAgICAvLyB0ZW1wbGF0ZSB0YWcgYW5kIEFycmF5LmZyb20gc3VwcG9ydFxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAgIFwiY29udGVudFwiIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKSAmJlxuICAgICAgICAgICAgICAgIFwiZnJvbVwiIGluIEFycmF5XG4gICAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKClcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gbWlzc2luZyBzdXBwb3J0O1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIFwiWW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdGhlIG5lZWRlZCBmdW5jdGlvbmFsaXR5IHRvIHVzZSB0aGUgaHRtbCB0YWdnZWQgdGVtcGxhdGVcIixcbiAgICAgICAgKVxuICAgICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdy5odG1sID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGNvbnN0YW50c1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGNvbnN0IFNVQlNUSVRVVElPTl9JTkRFWCA9IFwic3Vic3RpdHV0aW9uaW5kZXg6XCIgLy8gdGFnIG5hbWVzIGFyZSBhbHdheXMgYWxsIGxvd2VyY2FzZVxuICAgICAgICBjb25zdCBTVUJTVElUVVRJT05fUkVHRVggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgU1VCU1RJVFVUSU9OX0lOREVYICsgXCIoWzAtOV0rKTpcIixcbiAgICAgICAgICAgIFwiZ1wiLFxuICAgICAgICApXG5cbiAgICAgICAgLy8gcmVqZWN0aW9uIHN0cmluZyBpcyB1c2VkIHRvIHJlcGxhY2UgeHNzIGF0dGFja3MgdGhhdCBjYW5ub3QgYmUgZXNjYXBlZCBlaXRoZXJcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgZXNjYXBlZCBzdHJpbmcgaXMgc3RpbGwgZXhlY3V0YWJsZVxuICAgICAgICAvLyAoZS5nLiBzZXRUaW1lb3V0KC8qIGVzY2FwZWQgc3RyaW5nICovKSkgb3IgYmVjYXVzZSBpdCBwcm9kdWNlcyBpbnZhbGlkIHJlc3VsdHNcbiAgICAgICAgLy8gKGUuZy4gPGgke3hzc30+IHdoZXJlIHhzcz0nPjxzY3JpcHQ+YWxlcnQoMTMzNyk8L3NjcmlwdCcpXG4gICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vY2xvc3VyZS90ZW1wbGF0ZXMvZG9jcy9zZWN1cml0eSNpbl90YWdzX2FuZF9hdHRyc1xuICAgICAgICBjb25zdCBSRUpFQ1RJT05fU1RSSU5HID0gXCJ6WHNzUHJldmVudGVkelwiXG5cbiAgICAgICAgLy8gd2hpY2ggY2hhcmFjdGVycyBzaG91bGQgYmUgZW5jb2RlZCBpbiB3aGljaCBjb250ZXh0c1xuICAgICAgICBjb25zdCBFTkNPRElOR1MgPSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGU6IHtcbiAgICAgICAgICAgICAgICBcIiZcIjogXCImYW1wO1wiLFxuICAgICAgICAgICAgICAgIFwiPFwiOiBcIiZsdDtcIixcbiAgICAgICAgICAgICAgICBcIj5cIjogXCImZ3Q7XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXJpOiB7XG4gICAgICAgICAgICAgICAgXCImXCI6IFwiJmFtcDtcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH1cblxuICAgICAgICAvLyB3aGljaCBhdHRyaWJ1dGVzIGFyZSBET00gTGV2ZWwgMCBldmVudHNcbiAgICAgICAgLy8gdGFrZW4gZnJvbSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9ET01fZXZlbnRzI0RPTV9MZXZlbF8wXG4gICAgICAgIGNvbnN0IERPTV9FVkVOVFMgPSBbXG4gICAgICAgICAgICBcIm9uY2xpY2tcIixcbiAgICAgICAgICAgIFwib25kYmxjbGlja1wiLFxuICAgICAgICAgICAgXCJvbm1vdXNlZG93blwiLFxuICAgICAgICAgICAgXCJvbm1vdXNldXBcIixcbiAgICAgICAgICAgIFwib25tb3VzZW92ZXJcIixcbiAgICAgICAgICAgIFwib25tb3VzZW1vdmVcIixcbiAgICAgICAgICAgIFwib25tb3VzZW91dFwiLFxuICAgICAgICAgICAgXCJvbmRyYWdzdGFydFwiLFxuICAgICAgICAgICAgXCJvbmRyYWdcIixcbiAgICAgICAgICAgIFwib25kcmFnZW50ZXJcIixcbiAgICAgICAgICAgIFwib25kcmFnbGVhdmVcIixcbiAgICAgICAgICAgIFwib25kcmFnb3ZlclwiLFxuICAgICAgICAgICAgXCJvbmRyb3BcIixcbiAgICAgICAgICAgIFwib25kcmFnZW5kXCIsXG4gICAgICAgICAgICBcIm9ua2V5ZG93blwiLFxuICAgICAgICAgICAgXCJvbmtleXByZXNzXCIsXG4gICAgICAgICAgICBcIm9ua2V5dXBcIixcbiAgICAgICAgICAgIFwib25sb2FkXCIsXG4gICAgICAgICAgICBcIm9udW5sb2FkXCIsXG4gICAgICAgICAgICBcIm9uYWJvcnRcIixcbiAgICAgICAgICAgIFwib25lcnJvclwiLFxuICAgICAgICAgICAgXCJvbnJlc2l6ZVwiLFxuICAgICAgICAgICAgXCJvbnNjcm9sbFwiLFxuICAgICAgICAgICAgXCJvbnNlbGVjdFwiLFxuICAgICAgICAgICAgXCJvbmNoYW5nZVwiLFxuICAgICAgICAgICAgXCJvbnN1Ym1pdFwiLFxuICAgICAgICAgICAgXCJvbnJlc2V0XCIsXG4gICAgICAgICAgICBcIm9uZm9jdXNcIixcbiAgICAgICAgICAgIFwib25ibHVyXCIsXG4gICAgICAgICAgICBcIm9ucG9pbnRlcmRvd25cIixcbiAgICAgICAgICAgIFwib25wb2ludGVydXBcIixcbiAgICAgICAgICAgIFwib25wb2ludGVyY2FuY2VsXCIsXG4gICAgICAgICAgICBcIm9ucG9pbnRlcm1vdmVcIixcbiAgICAgICAgICAgIFwib25wb2ludGVyb3ZlclwiLFxuICAgICAgICAgICAgXCJvbnBvaW50ZXJvdXRcIixcbiAgICAgICAgICAgIFwib25wb2ludGVyZW50ZXJcIixcbiAgICAgICAgICAgIFwib25wb2ludGVybGVhdmVcIixcbiAgICAgICAgICAgIFwib25nb3Rwb2ludGVyY2FwdHVyZVwiLFxuICAgICAgICAgICAgXCJvbmxvc3Rwb2ludGVyY2FwdHVyZVwiLFxuICAgICAgICAgICAgXCJvbmN1dFwiLFxuICAgICAgICAgICAgXCJvbmNvcHlcIixcbiAgICAgICAgICAgIFwib25wYXN0ZVwiLFxuICAgICAgICAgICAgXCJvbmJlZm9yZWN1dFwiLFxuICAgICAgICAgICAgXCJvbmJlZm9yZWNvcHlcIixcbiAgICAgICAgICAgIFwib25iZWZvcmVwYXN0ZVwiLFxuICAgICAgICAgICAgXCJvbmFmdGVydXBkYXRlXCIsXG4gICAgICAgICAgICBcIm9uYmVmb3JldXBkYXRlXCIsXG4gICAgICAgICAgICBcIm9uY2VsbGNoYW5nZVwiLFxuICAgICAgICAgICAgXCJvbmRhdGFhdmFpbGFibGVcIixcbiAgICAgICAgICAgIFwib25kYXRhc2V0Y2hhbmdlZFwiLFxuICAgICAgICAgICAgXCJvbmRhdGFzZXRjb21wbGV0ZVwiLFxuICAgICAgICAgICAgXCJvbmVycm9ydXBkYXRlXCIsXG4gICAgICAgICAgICBcIm9ucm93ZW50ZXJcIixcbiAgICAgICAgICAgIFwib25yb3dleGl0XCIsXG4gICAgICAgICAgICBcIm9ucm93c2RlbGV0ZVwiLFxuICAgICAgICAgICAgXCJvbnJvd2luc2VydGVkXCIsXG4gICAgICAgICAgICBcIm9uY29udGV4dG1lbnVcIixcbiAgICAgICAgICAgIFwib25kcmFnXCIsXG4gICAgICAgICAgICBcIm9uZHJhZ3N0YXJ0XCIsXG4gICAgICAgICAgICBcIm9uZHJhZ2VudGVyXCIsXG4gICAgICAgICAgICBcIm9uZHJhZ292ZXJcIixcbiAgICAgICAgICAgIFwib25kcmFnbGVhdmVcIixcbiAgICAgICAgICAgIFwib25kcmFnZW5kXCIsXG4gICAgICAgICAgICBcIm9uZHJvcFwiLFxuICAgICAgICAgICAgXCJvbnNlbGVjdHN0YXJ0XCIsXG4gICAgICAgICAgICBcImhlbHBcIixcbiAgICAgICAgICAgIFwib25iZWZvcmV1bmxvYWRcIixcbiAgICAgICAgICAgIFwib25zdG9wXCIsXG4gICAgICAgICAgICBcImJlZm9yZWVkaXRmb2N1c1wiLFxuICAgICAgICAgICAgXCJvbnN0YXJ0XCIsXG4gICAgICAgICAgICBcIm9uZmluaXNoXCIsXG4gICAgICAgICAgICBcIm9uYm91bmNlXCIsXG4gICAgICAgICAgICBcIm9uYmVmb3JlcHJpbnRcIixcbiAgICAgICAgICAgIFwib25hZnRlcnByaW50XCIsXG4gICAgICAgICAgICBcIm9ucHJvcGVydHljaGFuZ2VcIixcbiAgICAgICAgICAgIFwib25maWx0ZXJjaGFuZ2VcIixcbiAgICAgICAgICAgIFwib25yZWFkeXN0YXRlY2hhbmdlXCIsXG4gICAgICAgICAgICBcIm9ubG9zZWNhcHR1cmVcIixcbiAgICAgICAgICAgIFwiRE9NTW91c2VTY3JvbGxcIixcbiAgICAgICAgICAgIFwib25kcmFnZHJvcFwiLFxuICAgICAgICAgICAgXCJvbmRyYWdlbnRlclwiLFxuICAgICAgICAgICAgXCJvbmRyYWdleGl0XCIsXG4gICAgICAgICAgICBcIm9uZHJhZ2dlc3R1cmVcIixcbiAgICAgICAgICAgIFwib25kcmFnb3ZlclwiLFxuICAgICAgICAgICAgXCJvbmNsb3NlXCIsXG4gICAgICAgICAgICBcIm9uY29tbWFuZFwiLFxuICAgICAgICAgICAgXCJvbmlucHV0XCIsXG4gICAgICAgICAgICBcIkRPTU1lbnVJdGVtQWN0aXZlXCIsXG4gICAgICAgICAgICBcIkRPTU1lbnVJdGVtSW5hY3RpdmVcIixcbiAgICAgICAgICAgIFwib25jb250ZXh0bWVudVwiLFxuICAgICAgICAgICAgXCJvbm92ZXJmbG93XCIsXG4gICAgICAgICAgICBcIm9ub3ZlcmZsb3djaGFuZ2VkXCIsXG4gICAgICAgICAgICBcIm9udW5kZXJmbG93XCIsXG4gICAgICAgICAgICBcIm9ucG9wdXBoaWRkZW5cIixcbiAgICAgICAgICAgIFwib25wb3B1cGhpZGluZ1wiLFxuICAgICAgICAgICAgXCJvbnBvcHVwc2hvd2luZ1wiLFxuICAgICAgICAgICAgXCJvbnBvcHVwc2hvd25cIixcbiAgICAgICAgICAgIFwib25icm9hZGNhc3RcIixcbiAgICAgICAgICAgIFwib25jb21tYW5kdXBkYXRlXCIsXG4gICAgICAgIF1cblxuICAgICAgICAvLyB3aGljaCBhdHRyaWJ1dGVzIHRha2UgVVJJc1xuICAgICAgICAvLyB0YWtlbiBmcm9tIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNC9pbmRleC9hdHRyaWJ1dGVzLmh0bWxcbiAgICAgICAgY29uc3QgVVJJX0FUVFJJQlVURVMgPSBbXG4gICAgICAgICAgICBcImFjdGlvblwiLFxuICAgICAgICAgICAgXCJiYWNrZ3JvdW5kXCIsXG4gICAgICAgICAgICBcImNpdGVcIixcbiAgICAgICAgICAgIFwiY2xhc3NpZFwiLFxuICAgICAgICAgICAgXCJjb2RlYmFzZVwiLFxuICAgICAgICAgICAgXCJkYXRhXCIsXG4gICAgICAgICAgICBcImhyZWZcIixcbiAgICAgICAgICAgIFwibG9uZ2Rlc2NcIixcbiAgICAgICAgICAgIFwicHJvZmlsZVwiLFxuICAgICAgICAgICAgXCJzcmNcIixcbiAgICAgICAgICAgIFwidXNlbWFwXCIsXG4gICAgICAgIF1cblxuICAgICAgICBjb25zdCBFTkNPRElOR1NfUkVHRVggPSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGU6IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgXCJbXCIgKyBPYmplY3Qua2V5cyhFTkNPRElOR1MuYXR0cmlidXRlKS5qb2luKFwiXCIpICsgXCJdXCIsXG4gICAgICAgICAgICAgICAgXCJnXCIsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgdXJpOiBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgIFwiW1wiICsgT2JqZWN0LmtleXMoRU5DT0RJTkdTLnVyaSkuam9pbihcIlwiKSArIFwiXVwiLFxuICAgICAgICAgICAgICAgIFwiZ1wiLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgYWxsIGF0dHJpYnV0ZXMgYWZ0ZXIgdGhlIGZpcnN0IHdoaXRlc3BhY2UgKHdoaWNoIHdvdWxkIGZvbGxvdyB0aGUgdGFnXG4gICAgICAgIC8vIG5hbWUuIE9ubHkgdXNlZCB3aGVuIHRoZSBET00gaGFzIGJlZW4gY2xvYmJlcmVkIHRvIHN0aWxsIHBhcnNlIGF0dHJpYnV0ZXNcbiAgICAgICAgY29uc3QgQVRUUklCVVRFX1BBUlNFUl9SRUdFWCA9IC9cXHMoW15cIj49XFxzXSspKD86PVwiW15cIl0rXCIpPy9nXG5cbiAgICAgICAgLy8gdGVzdCBpZiBhIGphdmFzY3JpcHQgc3Vic3RpdHV0aW9uIGlzIHdyYXBwZWQgd2l0aCBxdW90ZXNcbiAgICAgICAgY29uc3QgV1JBUFBFRF9XSVRIX1FVT1RFU19SRUdFWCA9IC9eKCd8XCIpW1xcc1xcU10qXFwxJC9cblxuICAgICAgICAvLyBhbGxvdyBjdXN0b20gYXR0cmlidXRlIG5hbWVzIHRoYXQgc3RhcnQgb3IgZW5kIHdpdGggdXJsIG9yIHVpIHRvIGRvIHVyaSBlc2NhcGluZ1xuICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2Nsb3N1cmUvdGVtcGxhdGVzL2RvY3Mvc2VjdXJpdHkjaW5fdXJsc1xuICAgICAgICBjb25zdCBDVVNUT01fVVJJX0FUVFJJQlVURVNfUkVHRVggPSAvXFxidXJbaWxdfHVyW2lsXXM/JC9pXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gcHJpdmF0ZSBmdW5jdGlvbnNcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRXNjYXBlIEhUTUwgZW50aXRpZXMgaW4gYW4gYXR0cmlidXRlLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gU3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGVuY29kZUF0dHJpYnV0ZUhUTUxFbnRpdGllcyhzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZShFTkNPRElOR1NfUkVHRVguYXR0cmlidXRlLCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFTkNPRElOR1MuYXR0cmlidXRlW21hdGNoXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFc2NhcGUgZW50aXRpZXMgaW4gYSBVUkkuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBVUkkgdG8gZXNjYXBlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZW5jb2RlVVJJRW50aXRpZXMoc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoRU5DT0RJTkdTX1JFR0VYLnVyaSwgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRU5DT0RJTkdTLnVyaVttYXRjaF1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBodG1sIHRhZ2dlZCB0ZW1wbGF0ZSBmdW5jdGlvblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTYWZlbHkgY29udmVydCBhIERPTSBzdHJpbmcgaW50byBET00gbm9kZXMgdXNpbmcgYnkgdXNpbmcgRTRIIGFuZCBjb250ZXh0dWFsXG4gICAgICAgICAqIGF1dG8tZXNjYXBpbmcgdGVjaG5pcXVlcyB0byBwcmV2ZW50IHhzcyBhdHRhY2tzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBzdHJpbmdzIC0gU2FmZSBzdHJpbmcgbGl0ZXJhbHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVzIC0gVW5zYWZlIHN1YnN0aXR1dGlvbiBleHByZXNzaW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB3aW5kb3cuaHRtbCA9IGZ1bmN0aW9uKHN0cmluZ3MsIC4uLnZhbHVlcykge1xuICAgICAgICAgICAgLy8gYnJlYWsgZWFybHkgaWYgY2FsbGVkIHdpdGggZW1wdHkgY29udGVudFxuICAgICAgICAgICAgaWYgKCFzdHJpbmdzWzBdICYmIHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXBsYWNlIGEgc3RyaW5nIHdpdGggc3Vic3RpdHV0aW9uIHBsYWNlaG9sZGVycyB3aXRoIGl0cyBzdWJzdGl0dXRpb24gdmFsdWVzLlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2ggLSBNYXRjaGVkIHN1YnN0aXR1dGlvbiBwbGFjZWhvbGRlci5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbmRleCAtIFN1YnN0aXR1dGlvbiBwbGFjZWhvbGRlciBpbmRleC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gcmVwbGFjZVN1YnN0aXR1dGlvbihtYXRjaCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzW3BhcnNlSW50KGluZGV4LCAxMCldXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCBwbGFjZWhvbGRlcnMgaW50byB0aGUgZ2VuZXJhdGVkIHN0cmluZyBzbyB3ZSBjYW4gcnVuIGl0IHRocm91Z2ggdGhlXG4gICAgICAgICAgICAvLyBIVE1MIHBhcnNlciB3aXRob3V0IGFueSBtYWxpY2lvdXMgY29udGVudC5cbiAgICAgICAgICAgIC8vICh0aGlzIHBhcnRpY3VsYXIgcGxhY2Vob2xkZXIgd2lsbCBldmVuIHdvcmsgd2hlbiB1c2VkIHRvIGNyZWF0ZSBhIERPTSBlbGVtZW50KVxuICAgICAgICAgICAgbGV0IHN0ciA9IHN0cmluZ3NbMF1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IFNVQlNUSVRVVElPTl9JTkRFWCArIGkgKyBcIjpcIiArIHN0cmluZ3NbaSArIDFdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRlbXBsYXRlIHRhZ3MgYWxsb3cgYW55IEhUTUwgKGV2ZW4gPHRyPiBlbGVtZW50cyBvdXQgb2YgY29udGV4dClcbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L3RlbXBsYXRlXG4gICAgICAgICAgICBsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIilcbiAgICAgICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHN0clxuXG4gICAgICAgICAgICAvLyBmaW5kIGFsbCBzdWJzdGl0dXRpb24gdmFsdWVzIGFuZCBzYWZlbHkgZW5jb2RlIHRoZW0gdXNpbmcgRE9NIEFQSXMgYW5kXG4gICAgICAgICAgICAvLyBjb250ZXh0dWFsIGF1dG8tZXNjYXBpbmdcbiAgICAgICAgICAgIGxldCB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVOb2RlSXRlcmF0b3IoXG4gICAgICAgICAgICAgICAgdGVtcGxhdGUuY29udGVudCxcbiAgICAgICAgICAgICAgICBOb2RlRmlsdGVyLlNIT1dfQUxMLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgbGV0IG5vZGVcbiAgICAgICAgICAgIHdoaWxlICgobm9kZSA9IHdhbGtlci5uZXh0Tm9kZSgpKSkge1xuICAgICAgICAgICAgICAgIGxldCB0YWcgPSBudWxsXG4gICAgICAgICAgICAgICAgbGV0IGF0dHJpYnV0ZXNUb1JlbW92ZSA9IFtdXG5cbiAgICAgICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgICAgIC8vIG5vZGUgbmFtZSBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgbGV0IG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVOYW1lLmluZGV4T2YoU1VCU1RJVFVUSU9OX0lOREVYKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZU5hbWUgPSBub2RlTmFtZS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgU1VCU1RJVFVUSU9OX1JFR0VYLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZVN1YnN0aXR1dGlvbixcbiAgICAgICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZUVsZW1lbnQoKSBzaG91bGQgbm90IG5lZWQgdG8gYmUgZXNjYXBlZCB0byBwcmV2ZW50IFhTUz9cblxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHRhZyBuYW1lIGlzIGludmFsaWQgKGUuZy4geHNzIHRyaWVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGVzY2FwZSBvdXQgb2YgdGhlIHRhZyB1c2luZyAnPjxzY3JpcHQ+YWxlcnQoMTMzNyk8L3NjcmlwdD48JylcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5zdGVhZCBvZiByZXBsYWNpbmcgdGhlIHRhZyBuYW1lIHdlJ2xsIGp1c3QgbGV0IHRoZSBlcnJvciBiZSB0aHJvd25cbiAgICAgICAgICAgICAgICAgICAgdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlTmFtZSlcblxuICAgICAgICAgICAgICAgICAgICAvLyBtYXJrIHRoYXQgdGhpcyBub2RlIG5lZWRzIHRvIGJlIGNsZWFuZWQgdXAgbGF0ZXIgd2l0aCB0aGUgbmV3bHlcbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlZCBub2RlXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX3JlcGxhY2VkV2l0aCA9IHRhZ1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSBpbnNlcnRCZWZvcmUoKSBpbnN0ZWFkIG9mIHJlcGxhY2VDaGlsZCgpIHNvIHRoYXQgdGhlIG5vZGUgSXRlcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9lc24ndCB0aGluayB0aGUgbmV3IHRhZyBzaG91bGQgYmUgdGhlIG5leHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRhZywgbm9kZSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIHNjcmlwdCB0YWdzOlxuICAgICAgICAgICAgICAgIC8vIHVzaW5nIGlubmVySFRNTCB3aXRoIGEgc3RyaW5nIHRoYXQgY29udGFpbnMgYSBzY3JpcHQgdGFnIGNhdXNlcyB0aGUgc2NyaXB0XG4gICAgICAgICAgICAgICAgLy8gdGFnIHRvIG5vdCBiZSBleGVjdXRlZCB3aGVuIGFkZGVkIHRvIHRoZSBET00uIFdlJ2xsIG5lZWQgdG8gY3JlYXRlIGEgc2NyaXB0XG4gICAgICAgICAgICAgICAgLy8gdGFnIGFuZCBhcHBlbmQgaXRzIGNvbnRlbnRzIHdoaWNoIHdpbGwgbWFrZSBpdCBleGVjdXRlIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICAvLyBAc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTE5NzU3NS9jYW4tc2NyaXB0cy1iZS1pbnNlcnRlZC13aXRoLWlubmVyaHRtbFxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT09IFwiU0NSSVBUXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIilcbiAgICAgICAgICAgICAgICAgICAgdGFnID0gc2NyaXB0XG5cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fcmVwbGFjZWRXaXRoID0gc2NyaXB0XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2NyaXB0LCBub2RlKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAgICAgLy8gYXR0cmlidXRlIHN1YnN0aXR1dGlvblxuICAgICAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICBsZXQgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGF0dHJpYnV0ZXMgcHJvcGVydHkgaXMgbm90IG9mIHR5cGUgTmFtZWROb2RlTWFwIHRoZW4gdGhlIERPTVxuICAgICAgICAgICAgICAgICAgICAvLyBoYXMgYmVlbiBjbG9iYmVyZWQuIEUuZy4gPGZvcm0+PGlucHV0IG5hbWU9XCJhdHRyaWJ1dGVzXCI+PC9mb3JtPi5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UnbGwgbWFudWFsbHkgYnVpbGQgdXAgYW4gYXJyYXkgb2Ygb2JqZWN0cyB0aGF0IG1pbWljIHRoZSBBdHRyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9iamVjdCBzbyB0aGUgbG9vcCB3aWxsIHN0aWxsIHdvcmsgYXMgZXhwZWN0ZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmICghKG5vZGUuYXR0cmlidXRlcyBpbnN0YW5jZW9mIE5hbWVkTm9kZU1hcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpcnN0IGNsb25lIHRoZSBub2RlIHNvIHdlIGNhbiBpc29sYXRlIGl0IGZyb20gYW55IGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IG5vZGUuY2xvbmVOb2RlKClcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFyc2UgdGhlIG5vZGUgc3RyaW5nIGZvciBhbGwgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGF0dHJpYnV0ZU1hdGNoZXMgPSB0ZW1wLm91dGVySFRNTC5tYXRjaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBVFRSSUJVVEVfUEFSU0VSX1JFR0VYLFxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgYWxsIGF0dHJpYnV0ZSBuYW1lcyBhbmQgdGhlaXIgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyaWJ1dGVNYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVNYXRjaGVzW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmltKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNwbGl0KFwiPVwiKVswXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhdHRyaWJ1dGVWYWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGF0dHJpYnV0ZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhdHRyaWJ1dGVWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2luZG93cyAxMCBGaXJlZm94IDQ0IHdpbGwgc2hpZnQgdGhlIGF0dHJpYnV0ZXMgTmFtZWROb2RlTWFwIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHVzaCB0aGUgYXR0cmlidXRlIHRvIHRoZSBlbmQgd2hlbiB1c2luZyBzZXRBdHRyaWJ1dGUoKS4gV2UnbGwgaGF2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gY2xvbmUgdGhlIE5hbWVkTm9kZU1hcCBzbyB0aGUgb3JkZXIgaXNuJ3QgY2hhbmdlZCBmb3Igc2V0QXR0cmlidXRlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBBcnJheS5mcm9tKG5vZGUuYXR0cmlidXRlcylcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaV1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuYW1lID0gYXR0cmlidXRlLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhhc1N1YnN0aXR1dGlvbiA9IGZhbHNlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5hbWUgaGFzIHN1YnN0aXR1dGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUuaW5kZXhPZihTVUJTVElUVVRJT05fSU5ERVgpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNVQlNUSVRVVElPTl9SRUdFWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZVN1YnN0aXR1dGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc3Vic3RpdHV0aW9uIHdhcyB3aXRoIGEgbm9uLWVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lICYmIHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1N1YnN0aXR1dGlvbiA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgb2xkIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNUb1JlbW92ZS5wdXNoKGF0dHJpYnV0ZS5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZSBoYXMgc3Vic3RpdHV0aW9uIC0gb25seSBjaGVjayBpZiBuYW1lIGV4aXN0cyAob25seSBoYXBwZW5zXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIG5hbWUgaXMgYSBzdWJzdGl0dXRpb24gd2l0aCBhbiBlbXB0eSB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lICYmIHZhbHVlLmluZGV4T2YoU1VCU1RJVFVUSU9OX0lOREVYKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNTdWJzdGl0dXRpb24gPSB0cnVlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBhbiB1cmkgYXR0cmlidXRlIGhhcyBiZWVuIHJlamVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzUmVqZWN0ZWQgPSBmYWxzZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKFNVQlNUSVRVVElPTl9SRUdFWCwgZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZWplY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdWJzdGl0dXRpb25WYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbcGFyc2VJbnQoaW5kZXgsIDEwKV1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250ZXh0dWFsIGF1dG8tZXNjYXBpbmc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGF0dHJpYnV0ZSBpcyBhIERPTSBMZXZlbCAwIGV2ZW50IHRoZW4gd2UgbmVlZCB0byBlbnN1cmUgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgcXVvdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERPTV9FVkVOVFMuaW5kZXhPZihuYW1lKSAhPT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBzdWJzdGl0dXRpb25WYWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIVdSQVBQRURfV0lUSF9RVU9URVNfUkVHRVgudGVzdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25WYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25WYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wiJyArIHN1YnN0aXR1dGlvblZhbHVlICsgJ1wiJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGV4dHVhbCBhdXRvLWVzY2FwaW5nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgYXR0cmlidXRlIGlzIGEgdXJpIGF0dHJpYnV0ZSB0aGVuIHdlIG5lZWQgdG8gdXJpIGVuY29kZSBpdCBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGJhZCBwcm90b2NvbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVUklfQVRUUklCVVRFUy5pbmRleE9mKG5hbWUpICE9PSAtMSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ1VTVE9NX1VSSV9BVFRSSUJVVEVTX1JFR0VYLnRlc3QobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwZXJjZW50IGVuY29kZSBpZiB0aGUgdmFsdWUgaXMgaW5zaWRlIG9mIGEgcXVlcnkgcGFyYW1ldGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcXVlcnlQYXJhbUluZGV4ID0gdmFsdWUuaW5kZXhPZihcIj1cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtSW5kZXggIT09IC0xICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID4gcXVlcnlQYXJhbUluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25WYWx1ZSA9IGVuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9uVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbnRpdHkgZW5jb2RlIGlmIHZhbHVlIGlzIHBhcnQgb2YgdGhlIFVSTFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9uVmFsdWUgPSBlbmNvZGVVUkkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUVudGl0aWVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9uVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBhbGxvdyB0aGUgOiB3aGVuIHVzZWQgYWZ0ZXIgaHR0cCBvciBodHRwcyBvdGhlcndpc2UgcmVqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGVudGlyZSB1cmwgKHdpbGwgbm90IGFsbG93IGFueSAnamF2YXNjcmlwdDonIG9yIGZpbHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2YXNpb24gdGVjaG5pcXVlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25WYWx1ZS5pbmRleE9mKFwiOlwiKSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF1dGhvcml6ZWRfcHJvdG9jb2xzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJodHRwOi8vXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImh0dHBzOi8vXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1vei1leHRlbnNpb246Ly9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWJvdXQ6Ly9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkYXRhOmltYWdlL2pwZztiYXNlNjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkYXRhOmltYWdlL3gtaWNvbjtiYXNlNjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBzdWJzdGl0dXRpb25WYWx1ZSBkb2Vzbid0IHN0YXJ0IHdpdGggYW55IG9mIHRoZSBhdXRob3JpemVkIHByb3RvY29sc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhYXV0aG9yaXplZF9wcm90b2NvbHMuZmluZChwID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9uVmFsdWUuc3RhcnRzV2l0aChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUmVqZWN0ZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250ZXh0dWFsIGF1dG8tZXNjYXBpbmc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhUTUwgZW5jb2RlIGF0dHJpYnV0ZSB2YWx1ZSBpZiBpdCBpcyBub3QgYSBVUkwgb3IgVVJJIHRvIHByZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRE9NIExldmVsIDAgZXZlbnQgaGFuZGxlcnMgZnJvbSBleGVjdXRpbmcgeHNzIGNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygc3Vic3RpdHV0aW9uVmFsdWUgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25WYWx1ZSA9IGVuY29kZUF0dHJpYnV0ZUhUTUxFbnRpdGllcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25WYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzdGl0dXRpb25WYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZWplY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiI1wiICsgUkVKRUNUSU9OX1NUUklOR1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBhdHRyaWJ1dGUgdG8gdGhlIG5ldyB0YWcgb3IgcmVwbGFjZSBpdCBvbiB0aGUgY3VycmVudCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXRBdHRyaWJ1dGUoKSBkb2VzIG5vdCBuZWVkIHRvIGJlIGVzY2FwZWQgdG8gcHJldmVudCBYU1Mgc2luY2UgaXQgZG9lc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsIG9mIHRoYXQgZm9yIHVzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9ET00tYmFzZWRfWFNTXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFnIHx8IGhhc1N1YnN0aXR1dGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbCA9IHRhZyB8fCBub2RlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvcHRpb25hbCBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZS5zdWJzdHIoLTEpID09PSBcIj9cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSlcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShuYW1lLCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBwbGFjZWhvbGRlciBhdHRyaWJ1dGVzIG91dHNpZGUgb2YgdGhlIGF0dHJpYnV0ZSBsb29wIHNpbmNlIGl0XG4gICAgICAgICAgICAgICAgLy8gd2lsbCBtb2RpZnkgdGhlIGF0dHJpYnV0ZXMgTmFtZWROb2RlTWFwIGluZGljZXMuXG4gICAgICAgICAgICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3RyYWtlci9odG1sLXRhZ2dlZC10ZW1wbGF0ZS9pc3N1ZXMvMTNcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzVG9SZW1vdmUuZm9yRWFjaChmdW5jdGlvbihhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKVxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAvLyBhcHBlbmQgdGhlIGN1cnJlbnQgbm9kZSB0byBhIHJlcGxhY2VkIHBhcmVudFxuICAgICAgICAgICAgICAgIGxldCBwYXJlbnROb2RlXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSAmJiBub2RlLnBhcmVudE5vZGUuX3JlcGxhY2VkV2l0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlXG4gICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5fcmVwbGFjZWRXaXRoLmFwcGVuZENoaWxkKG5vZGUpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBvbGQgbm9kZSBmcm9tIHRoZSBET01cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIChub2RlLl9yZXBsYWNlZFdpdGggJiYgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgOyhwYXJlbnROb2RlIHx8IG5vZGUpLnJlbW92ZSgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgICAgICAvLyB0ZXh0IGNvbnRlbnQgc3Vic3RpdHV0aW9uXG4gICAgICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5ub2RlVHlwZSA9PT0gMyAmJlxuICAgICAgICAgICAgICAgICAgICBub2RlLm5vZGVWYWx1ZS5pbmRleE9mKFNVQlNUSVRVVElPTl9JTkRFWCkgIT09IC0xXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBub2RlVmFsdWUgPSBub2RlLm5vZGVWYWx1ZS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgU1VCU1RJVFVUSU9OX1JFR0VYLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZVN1YnN0aXR1dGlvbixcbiAgICAgICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZVRleHROb2RlKCkgc2hvdWxkIG5vdCBuZWVkIHRvIGJlIGVzY2FwZWQgdG8gcHJldmVudCBYU1M/XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZVZhbHVlKVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBwYXJlbnQgbm9kZSBoYXMgYWxyZWFkeSBnb25lIHRocm91Z2ggdGhlIGl0ZXJhdG9yLCB3ZSBjYW4gdXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2VDaGlsZCgpIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh0ZXh0LCBub2RlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBkb2N1bWVudEZyYWdtZW50IGZvciBtdWx0aXBsZSBub2Rlc1xuICAgICAgICAgICAgaWYgKHRlbXBsYXRlLmNvbnRlbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlLmNvbnRlbnRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlLmNvbnRlbnQuZmlyc3RDaGlsZFxuICAgICAgICB9XG4gICAgfVxufSkod2luZG93KVxuIiwiaW1wb3J0IFwiQHNyYy9saWIvbnVtYmVyLm1vZFwiXG5cbmV4cG9ydCBmdW5jdGlvbiBoZWFkKGl0ZXIpIHtcbiAgICBpdGVyID0gaXRlcltTeW1ib2wuaXRlcmF0b3JdKClcbiAgICBjb25zdCByZXN1bHQgPSBpdGVyLm5leHQoKVxuICAgIGlmIChyZXN1bHQuZG9uZSkgdGhyb3cgUmFuZ2VFcnJvcihcIkVtcHR5IGl0ZXJhdG9yIGhhcyBubyBoZWFkL3RhaWxcIilcbiAgICBlbHNlIHJldHVybiByZXN1bHQudmFsdWVcbn1cblxuLyoqIEdldCB0aGUgbGFzdCBpdGVtIG9mIGFuIGFycmF5IG9yIGl0ZXJhYmxlICovXG5leHBvcnQgZnVuY3Rpb24gdGFpbChpdGVyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlcikpIHtcbiAgICAgICAgaWYgKGl0ZXIubGVuZ3RoIDwgMSkgdGhyb3cgUmFuZ2VFcnJvcihcIkVtcHR5IGl0ZXJhdG9yIGhhcyBubyBoZWFkL3RhaWxcIilcbiAgICAgICAgcmV0dXJuIGl0ZXJbaXRlci5sZW5ndGggLSAxXVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlLXVzZSBlcnJvciBoYW5kbGluZyBpbiBoZWFkKClcbiAgICAgICAgbGV0IGxhc3QgPSBoZWFkKGl0ZXIpXG4gICAgICAgIGZvciAobGFzdCBvZiBpdGVyKTtcbiAgICAgICAgcmV0dXJuIGxhc3RcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogZmlsdGVyKGl0ZXIsIHByZWRpY2F0ZSkge1xuICAgIGZvciAoY29uc3QgdiBvZiBpdGVyKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUodikpIHlpZWxkIHZcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kKGl0ZXIsIHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBoZWFkKGZpbHRlcihpdGVyLCBwcmVkaWNhdGUpKVxufVxuXG4vKiogWmlwIHNvbWUgYXJyYXlzIHRvZ2V0aGVyXG5cbiAgICBJZiB5b3UgbmVlZCB2YXJpYWJsZSBsZW5ndGggYXJncywgeW91IG5lZWQgaXppcCBmb3Igbm93LlxuXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHppcCguLi5hcnJheXMpIHtcbiAgICAvLyBNYWtlIGFuIGFycmF5IG9mIGxlbmd0aCB2YWx1ZXNcbiAgICAvLyBUT0RPOiBFeHBsYWluIGhvdyB0aGlzIHdvcmtzXG4gICAgcmV0dXJuIFsuLi5BcnJheShhcnJheXNbMF0ubGVuZ3RoKV0ubWFwKChfLCBpKSA9PiBhcnJheXMubWFwKGEgPT4gYVtpXSkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiogcmFuZ2UobGVuZ3RoKSB7XG4gICAgaWYgKGxlbmd0aCA8IDApIHJldHVyblxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgeWllbGQgaW5kZXhcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogZW51bWVyYXRlKGl0ZXJhYmxlKSB7XG4gICAgbGV0IGluZGV4ID0gMFxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBpdGVyYWJsZSkge1xuICAgICAgICB5aWVsZCBbaW5kZXgsIGVsZW1lbnRdXG4gICAgICAgIGluZGV4KytcbiAgICB9XG59XG5cbi8qIFppcCBhcmJpdHJhcnkgaXRlcmF0b3JzIHRvZ2V0aGVyICovXG5leHBvcnQgZnVuY3Rpb24qIGl6aXAoLi4uYXJyYXlzKSB7XG4gICAgY29uc3QgaXRlcmF0b3JzID0gYXJyYXlzLm1hcChlID0+IGVbU3ltYm9sLml0ZXJhdG9yXSgpKVxuICAgIGNvbnN0IGJveCA9IEFycmF5KGFycmF5cy5sZW5ndGgpXG4gICAgZm9yIChsZXQgdiBvZiBpdGVyYXRvcnNbMF0pIHtcbiAgICAgICAgYm94WzBdID0gdlxuICAgICAgICBsZXQgaVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChbaSwgdl0gb2YgZW51bWVyYXRlKGl0ZXJhdG9ycy5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgICAgICBib3hbaSArIDFdID0gaGVhZCh2KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgWy4uLmJveF1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qIFRlc3QgaWYgdHdvIGl0ZXJhYmxlcyBhcmUgZXF1YWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBpdGVyRXEoLi4uYXJyYXlzKSB7XG4gICAgZm9yIChjb25zdCBhIG9mIHppcCguLi5hcnJheXMpKSB7XG4gICAgICAgIGlmICghYS5yZWR1Y2UoKHgsIHkpID0+IHggPT09IHkpKSByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHplcm9zKG4pIHtcbiAgICByZXR1cm4gbmV3IEFycmF5KG4pLmZpbGwoMClcbn1cblxuLyoqIGlzbGljZShpdGVyLCBzdG9wKSA9IEdpdmUgdGhlIGZpcnN0IGBzdG9wYCBlbGVtZW50c1xuICAgIGlzbGljZShpdGVyLCBzdGFydCwgc3RvcClcbiAgICAgICAgc2tpcCBgc3RhcnRgIGVsZW1lbnRzLCB0aGVuIGdpdmUgYHN0b3AgLSBzdGFydGAgZWxlbWVudHMsXG4gICAgICAgIHVubGVzcyBgc3RvcGAgaXMgbnVsbCwgdGhlbiBlbWl0IGluZGVmaW5pdGVseVxuXG4gICAgSWYgdGhlIGl0ZXJhdG9yIHJ1bnMgb3V0IGVhcmx5IHNvIHdpbGwgdGhpcy5cbiovXG5leHBvcnQgZnVuY3Rpb24qIGlzbGljZShpdGVyYWJsZSwgc3RhcnQ6IG51bWJlciwgc3RvcD86IG51bWJlcikge1xuICAgIGNvbnN0IGl0ZXIgPSBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdKClcblxuICAgIC8vIElmIHN0b3AgaXMgbm90IGRlZmluZWQgdGhlbiB0aGV5J3JlIHVzaW5nIHRoZSB0d28gYXJndW1lbnQgdmFyaWFudFxuICAgIGlmIChzdG9wID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3RvcCA9IHN0YXJ0XG4gICAgICAgIHN0YXJ0ID0gMFxuICAgIH1cblxuICAgIC8vIFNraXAgZWxlbWVudHMgdW50aWwgc3RhcnRcbiAgICBmb3IgKGNvbnN0IF8gb2YgcmFuZ2Uoc3RhcnQpKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGl0ZXIubmV4dCgpXG4gICAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gRW1pdCBlbGVtZW50c1xuICAgIGlmIChzdG9wID09PSBudWxsKSB7XG4gICAgICAgIHlpZWxkKiBpdGVyXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RvcDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBpdGVyLm5leHQoKVxuICAgICAgICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm5cbiAgICAgICAgICAgIGVsc2UgeWllbGQgcmVzLnZhbHVlXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogY2hhaW4oLi4uaXRlcmFibGVzKSB7XG4gICAgZm9yIChjb25zdCBpdGVyIG9mIGl0ZXJhYmxlcykge1xuICAgICAgICB5aWVsZCogaXRlcltTeW1ib2wuaXRlcmF0b3JdKClcbiAgICB9XG59XG5cbi8qKiBBbGwgcGVybXV0YXRpb25zIG9mIG4gaXRlbXMgZnJvbSBhcnJheSAqL1xuZXhwb3J0IGZ1bmN0aW9uKiBwZXJtdXRhdGlvbnNXaXRoUmVwbGFjZW1lbnQoYXJyLCBuKSB7XG4gICAgY29uc3QgbGVuID0gYXJyLmxlbmd0aFxuICAgIGNvbnN0IGNvdW50ZXJzID0gemVyb3MobilcbiAgICBsZXQgaW5kZXggPSAxXG4gICAgZm9yIChjb25zdCBfIG9mIHJhbmdlKE1hdGgucG93KGxlbiwgbikpKSB7XG4gICAgICAgIHlpZWxkIGNvdW50ZXJzLm1hcChpID0+IGFycltpXSlcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHJhbmdlKGNvdW50ZXJzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIGlmIChpbmRleC5tb2QoTWF0aC5wb3cobGVuLCBjb3VudGVycy5sZW5ndGggLSAxIC0gaSkpID09PSAwKVxuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2ldID0gKGNvdW50ZXJzW2ldICsgMSkubW9kKGxlbilcbiAgICAgICAgfVxuICAgICAgICBpbmRleCsrXG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24qIG1hcChhcnIsIGZ1bmMpIHtcbiAgICBmb3IgKGNvbnN0IHYgb2YgYXJyKSB5aWVsZCBmdW5jKHYpXG59XG5cbi8vIFJldHVybnMgYW4gYXJyYXkgb2YgdW5pcXVlIGVsZW1lbnRzLlxuZXhwb3J0IGZ1bmN0aW9uIHVuaXF1ZShhcnIpIHtcbiAgICByZXR1cm4gYXJyLnJlZHVjZSgoYWNjLCBjdXIpID0+IHtcbiAgICAgICAgaWYgKCFhY2MuaW5jbHVkZXMoY3VyKSkgYWNjLnB1c2goY3VyKVxuICAgICAgICByZXR1cm4gYWNjXG4gICAgfSwgW10pXG59XG5cbi8qKiBZaWVsZCB2YWx1ZXMgdGhhdCBhcmUgdW5pcXVlIHVuZGVyIGhhc2hlcih2YWx1ZSkgKi9cbmV4cG9ydCBmdW5jdGlvbiogdW5pcXVlQnkoYXJyLCBoYXNoZXIpIHtcbiAgICBjb25zdCBoYXNoZXMgPSBuZXcgU2V0KClcbiAgICBmb3IgKGNvbnN0IGUgb2YgYXJyKSB7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBoYXNoZXIoZSlcbiAgICAgICAgaWYgKCFoYXNoZXMuaGFzKGhhc2gpKSB7XG4gICAgICAgICAgICB5aWVsZCBlXG4gICAgICAgICAgICBoYXNoZXMuYWRkKGhhc2gpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuKGFycikge1xuICAgIGxldCByZXN1bHQgPSBbXVxuICAgIGZvciAoY29uc3QgZWxlbSBvZiBhcnIpIHtcbiAgICAgICAgaWYgKGVsZW0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChmbGF0dGVuKGVsZW0pKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZWxlbSlcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKiBEcm9wIGZyb20gaXRlcmFibGUgdW50aWwgcHJlZGljYXRlIGlzIGZhbHNlICovXG5leHBvcnQgZnVuY3Rpb24qIGRyb3B3aGlsZShpdGVyYWJsZSwgcHJlZGljYXRlKSB7XG4gICAgbGV0IGFsbG1hdGNoZWQgPSB0cnVlXG4gICAgZm9yIChjb25zdCBlbGVtIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgIGlmICghKGFsbG1hdGNoZWQgJiYgcHJlZGljYXRlKGVsZW0pKSkge1xuICAgICAgICAgICAgYWxsbWF0Y2hlZCA9IGZhbHNlXG4gICAgICAgICAgICB5aWVsZCBlbGVtXG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKiBUYWtlIGZyb20gaXRlcmFibGUgdW50aWwgcHJlZGljYXRlIGlzIGZhbHNlICovXG5leHBvcnQgZnVuY3Rpb24qIHRha2V3aGlsZShpdGVyYWJsZSwgcHJlZGljYXRlKSB7XG4gICAgZm9yIChjb25zdCBlbGVtIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoZWxlbSkpIHtcbiAgICAgICAgICAgIHlpZWxkIGVsZW1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyoqIEtleS1zZXF1ZW5jZSBwYXJzZXJcblxuICAgIElmIGBtYXBgIGlzIGEgTWFwIG9mIGBNaW5pbWFsS2V5W11gIHRvIG9iamVjdHMgKGV4c3RycyBvciBjYWxsYmFja3MpXG4gICAgYW5kIGBrZXlzZXFgIGlzIGFuIGFycmF5IG9mIFtbTWluaW1hbEtleV1dIGNvbXBhdGlibGUgb2JqZWN0cy4uLlxuXG4gICAgIC0gYHBhcnNlKGtleXNlcSwgbWFwKWAgcmV0dXJucyB0aGUgbWFwcGVkIG9iamVjdCBhbmQgYSBjb3VudCBPUiBhIHByZWZpeFxuICAgICAgIG9mIGBNaW5pbWFsS2V5W11gIChwb3NzaWJseSBlbXB0eSkgdGhhdCwgaWYgbW9yZSBrZXlzIGFyZSBwcmVzc2VkLCBjb3VsZFxuICAgICAgIG1hcCB0byBhbiBvYmplY3QuXG4gICAgIC0gYGNvbXBsZXRpb25zKGtleXNlcSwgbWFwKWAgcmV0dXJucyB0aGUgZnJhZ21lbnQgb2YgYG1hcGAgdGhhdCBrZXlzZXEgaXNcbiAgICAgICBhIHZhbGlkIHByZWZpeCBvZi5cbiAgICAgLSBgbWFwc3RyVG9LZXlTZXFgIGdlbmVyYXRlcyBLZXlTZXF1ZW5jZXMgZm9yIHRoZSByZXN0IG9mIHRoZSBBUEkuXG5cbiAgICBObyBrZXkgc2VxdWVuY2UgaW4gYSBgbWFwYCBtYXkgYmUgYSBwcmVmaXggb2YgYW5vdGhlciBrZXkgc2VxdWVuY2UgaW4gdGhhdFxuICAgIG1hcC4gVGhpcyBpcyBhIHBvaW50IG9mIGRpZmZlcmVuY2UgZnJvbSBWaW0gdGhhdCByZW1vdmVzIGFueSB0aW1lLWRlcGVuZGVuY2VcbiAgICBpbiB0aGUgcGFyc2VyLiBWaW1wZXJhdG9yLCBQZW50YWRhY3R5bCwgc2FrYS1rZXksIGV0YywgYWxsIHNoYXJlIHRoaXNcbiAgICBsaW1pdGF0aW9uLlxuXG4gICAgSWYgYSBrZXkgaXMgcmVwcmVzZW50ZWQgYnkgYSBzaW5nbGUgY2hhcmFjdGVyIHRoZW4gdGhlIHNoaWZ0IG1vZGlmaWVyIHN0YXRlXG4gICAgaXMgaWdub3JlZCB1bmxlc3Mgb3RoZXIgbW9kaWZpZXJzIGFyZSBhbHNvIHByZXNlbnQuXG5cbiovXG5cbi8qKiAqL1xuaW1wb3J0IHsgZmlsdGVyLCBmaW5kLCBpemlwIH0gZnJvbSBcIkBzcmMvbGliL2l0ZXJ0b29sc1wiXG5pbXBvcnQgeyBQYXJzZXIgfSBmcm9tIFwiQHNyYy9saWIvbmVhcmxleV91dGlsc1wiXG5pbXBvcnQgKiBhcyBicmFja2V0ZXhwcl9ncmFtbWFyIGZyb20gXCJAc3JjL2dyYW1tYXJzLy5icmFja2V0ZXhwci5nZW5lcmF0ZWRcIlxuY29uc3QgYnJhY2tldGV4cHJfcGFyc2VyID0gbmV3IFBhcnNlcihicmFja2V0ZXhwcl9ncmFtbWFyKVxuXG4vLyB7e3sgR2VuZXJhbCB0eXBlc1xuXG5leHBvcnQgaW50ZXJmYWNlIEtleU1vZGlmaWVycyB7XG4gICAgYWx0S2V5PzogYm9vbGVhblxuICAgIGN0cmxLZXk/OiBib29sZWFuXG4gICAgbWV0YUtleT86IGJvb2xlYW5cbiAgICBzaGlmdEtleT86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNsYXNzIE1pbmltYWxLZXkge1xuICAgIHJlYWRvbmx5IGFsdEtleSA9IGZhbHNlXG4gICAgcmVhZG9ubHkgY3RybEtleSA9IGZhbHNlXG4gICAgcmVhZG9ubHkgbWV0YUtleSA9IGZhbHNlXG4gICAgcmVhZG9ubHkgc2hpZnRLZXkgPSBmYWxzZVxuXG4gICAgY29uc3RydWN0b3IocmVhZG9ubHkga2V5OiBzdHJpbmcsIG1vZGlmaWVycz86IEtleU1vZGlmaWVycykge1xuICAgICAgICBpZiAobW9kaWZpZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbW9kIG9mIE9iamVjdC5rZXlzKG1vZGlmaWVycykpIHtcbiAgICAgICAgICAgICAgICB0aGlzW21vZF0gPSBtb2RpZmllcnNbbW9kXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIERvZXMgdGhpcyBrZXkgbWF0Y2ggYSBnaXZlbiBNaW5pbWFsS2V5IGV4dGVuZGluZyBvYmplY3Q/ICovXG4gICAgcHVibGljIG1hdGNoKGtleWV2ZW50KSB7XG4gICAgICAgIC8vICdpbicgZG9lc24ndCBpbmNsdWRlIHByb3RvdHlwZXMsIHNvIGl0J3Mgc2FmZSBmb3IgdGhpcyBvYmplY3QuXG4gICAgICAgIGZvciAoY29uc3QgYXR0ciBpbiB0aGlzKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBjaGVjayBzaGlmdEtleSBmb3Igbm9ybWFsIGtleXMuXG4gICAgICAgICAgICBpZiAoYXR0ciA9PT0gXCJzaGlmdEtleVwiICYmIHRoaXMua2V5Lmxlbmd0aCA9PT0gMSkgY29udGludWVcbiAgICAgICAgICAgIGlmICh0aGlzW2F0dHJdICE9PSBrZXlldmVudFthdHRyXSkgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBwdWJsaWMgdG9NYXBzdHIoKSB7XG4gICAgICAgIGxldCBzdHIgPSBcIlwiXG4gICAgICAgIGxldCBuZWVkc0JyYWNrZXRzID0gdGhpcy5rZXkubGVuZ3RoID4gMVxuXG4gICAgICAgIC8vIEZvcm1hdCBtb2RpZmllcnNcbiAgICAgICAgY29uc3QgbW9kaWZpZXJzID0gbmV3IE1hcChbXG4gICAgICAgICAgICBbXCJBXCIsIFwiYWx0S2V5XCJdLFxuICAgICAgICAgICAgW1wiQ1wiLCBcImN0cmxLZXlcIl0sXG4gICAgICAgICAgICBbXCJNXCIsIFwibWV0YUtleVwiXSxcbiAgICAgICAgICAgIFtcIlNcIiwgXCJzaGlmdEtleVwiXSxcbiAgICAgICAgXSlcbiAgICAgICAgZm9yIChjb25zdCBbbGV0dGVyLCBhdHRyXSBvZiBtb2RpZmllcnMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAodGhpc1thdHRyXSkge1xuICAgICAgICAgICAgICAgIHN0ciArPSBsZXR0ZXJcbiAgICAgICAgICAgICAgICBuZWVkc0JyYWNrZXRzID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgIHN0ciArPSBcIi1cIlxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGtleSA9IHRoaXMua2V5XG4gICAgICAgIGlmIChrZXkgPT09IFwiIFwiKSB7XG4gICAgICAgICAgICBrZXkgPSBcIlNwYWNlXCJcbiAgICAgICAgICAgIG5lZWRzQnJhY2tldHMgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3JtYXQgdGhlIHJlc3RcbiAgICAgICAgc3RyICs9IGtleVxuICAgICAgICBpZiAobmVlZHNCcmFja2V0cykge1xuICAgICAgICAgICAgc3RyID0gXCI8XCIgKyBzdHIgKyBcIj5cIlxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0clxuICAgIH1cbn1cblxuZXhwb3J0IHR5cGUgS2V5RXZlbnRMaWtlID0gTWluaW1hbEtleSB8IEtleWJvYXJkRXZlbnRcblxuLy8gfX19XG5cbi8vIHt7eyBwYXJzZXIgYW5kIGNvbXBsZXRpb25zXG5cbnR5cGUgTWFwVGFyZ2V0ID0gc3RyaW5nIHwgKCguLi5hcmdzOiBhbnlbXSkgPT4gYW55KVxudHlwZSBLZXlNYXAgPSBNYXA8TWluaW1hbEtleVtdLCBNYXBUYXJnZXQ+XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VyUmVzcG9uc2Uge1xuICAgIGtleXM/OiBLZXlFdmVudExpa2VbXVxuICAgIHZhbHVlPzogYW55XG4gICAgZXhzdHI/OiBhbnlcbiAgICBpc01hdGNoOiBib29sZWFuXG4gICAgbnVtZXJpY1ByZWZpeD86IG51bWJlclxufVxuXG5mdW5jdGlvbiBzcGxpdE51bWVyaWNQcmVmaXgoa2V5c2VxOiBLZXlFdmVudExpa2VbXSk6IFtLZXlFdmVudExpa2VbXSwgS2V5RXZlbnRMaWtlW11dIHtcbiAgICAvLyBJZiB0aGUgZmlyc3Qga2V5IGlzIGluIDE6OSwgcGFydGl0aW9uIGFsbCBudW1iZXJzIHVudGlsIHlvdSByZWFjaCBhIG5vbi1udW1iZXIuXG4gICAgaWYgKCFoYXNNb2RpZmllcnMoa2V5c2VxWzBdKSAmJiBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOV0uaW5jbHVkZXMoTnVtYmVyKGtleXNlcVswXS5rZXkpKSkge1xuICAgICAgICBjb25zdCBwcmVmaXggPSBba2V5c2VxWzBdXVxuICAgICAgICBmb3IgKGNvbnN0IGtlIG9mIGtleXNlcS5zbGljZSgxKSkge1xuICAgICAgICAgICAgaWYgKCFoYXNNb2RpZmllcnMoa2UpICYmIFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5XS5pbmNsdWRlcyhOdW1iZXIoa2Uua2V5KSkpXG4gICAgICAgICAgICAgICAgcHJlZml4LnB1c2goa2UpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN0ID0ga2V5c2VxLnNsaWNlKHByZWZpeC5sZW5ndGgpXG4gICAgICAgIHJldHVybiBbcHJlZml4LCByZXN0XVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbW10sIGtleXNlcV1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZShrZXlzZXE6IEtleUV2ZW50TGlrZVtdLCBtYXA6IEtleU1hcCk6IFBhcnNlclJlc3BvbnNlIHtcbiAgICAvLyBSZW1vdmUgYmFyZSBtb2RpZmllcnNcbiAgICBrZXlzZXEgPSBrZXlzZXEuZmlsdGVyKFxuICAgICAgICBrZXkgPT5cbiAgICAgICAgICAgICFbXCJDb250cm9sXCIsIFwiU2hpZnRcIiwgXCJBbHRcIiwgXCJBbHRHcmFwaFwiLCBcIk1ldGFcIl0uaW5jbHVkZXMoa2V5LmtleSksXG4gICAgKVxuXG4gICAgLy8gSWYgdGhlIGtleXNlcSBpcyBub3cgZW1wdHksIGFib3J0LlxuICAgIGlmIChrZXlzZXEubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4geyBrZXlzOiBbXSwgaXNNYXRjaDogZmFsc2UgfVxuXG4gICAgLy8gU3BsaXQgaW50byBudW1lcmljIHByZWZpeCBhbmQgbm9uLW51bWVyaWMgc3VmZml4XG4gICAgbGV0IG51bWVyaWNQcmVmaXg6IEtleUV2ZW50TGlrZVtdXG4gICAgW251bWVyaWNQcmVmaXgsIGtleXNlcV0gPSBzcGxpdE51bWVyaWNQcmVmaXgoa2V5c2VxKVxuXG4gICAgLy8gSWYga2V5c2VxIGlzIGEgcHJlZml4IG9mIGEga2V5IGluIG1hcCwgcHJvY2VlZCwgZWxzZSB0cnkgZHJvcHBpbmcga2V5c1xuICAgIC8vIGZyb20ga2V5c2VxIHVudGlsIGl0IGlzIGVtcHR5IG9yIGlzIGEgcHJlZml4LlxuICAgIGxldCBwb3NzaWJsZU1hcHBpbmdzID0gY29tcGxldGlvbnMoa2V5c2VxLCBtYXApXG4gICAgd2hpbGUgKHBvc3NpYmxlTWFwcGluZ3Muc2l6ZSA9PT0gMCAmJiBrZXlzZXEubGVuZ3RoID4gMCkge1xuICAgICAgICBrZXlzZXEuc2hpZnQoKVxuICAgICAgICBudW1lcmljUHJlZml4ID0gW11cbiAgICAgICAgcG9zc2libGVNYXBwaW5ncyA9IGNvbXBsZXRpb25zKGtleXNlcSwgbWFwKVxuICAgIH1cblxuICAgIGlmIChwb3NzaWJsZU1hcHBpbmdzLnNpemUgPiAwKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGFueSBvZiB0aGUgbWFwcGluZ3MgaXMgYSBwZXJmZWN0IG1hdGNoICh0aGlzIHdpbGwgb25seVxuICAgICAgICAvLyBoYXBwZW4gaWYgc29tZSBzZXF1ZW5jZXMgaW4gdGhlIEtleU1hcCBhcmUgcHJlZml4ZXMgb2Ygb3RoZXIgc2VxcykuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwZXJmZWN0ID0gZmluZChcbiAgICAgICAgICAgICAgICBwb3NzaWJsZU1hcHBpbmdzLFxuICAgICAgICAgICAgICAgIChbaywgdl0pID0+IGsubGVuZ3RoID09PSBrZXlzZXEubGVuZ3RoLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGVyZmVjdFsxXSxcbiAgICAgICAgICAgICAgICBleHN0cjogcGVyZmVjdFsxXSArIG51bWVyaWNQcmVmaXhUb0V4c3RyU3VmZml4KG51bWVyaWNQcmVmaXgpLFxuICAgICAgICAgICAgICAgIGlzTWF0Y2g6IHRydWUsXG4gICAgICAgICAgICAgICAgbnVtZXJpY1ByZWZpeDogbnVtZXJpY1ByZWZpeC5sZW5ndGggPyBOdW1iZXIobnVtZXJpY1ByZWZpeC5tYXAoa2UgPT4ga2Uua2V5KS5qb2luKFwiXCIpKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIFJhbmdlRXJyb3IpKSB0aHJvdyBlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBrZXlzZXEgaXMgdGhlIGxvbmdlc3Qgc3VmZml4IG9mIGtleXNlcSB0aGF0IGlzIHRoZSBwcmVmaXggb2YgYVxuICAgIC8vIGNvbW1hbmQsIG51bWVyaWNQcmVmaXggaXMgYSBudW1lcmljIHByZWZpeCBvZiB0aGF0LiBXZSB3YW50IHRvXG4gICAgLy8gcHJlc2VydmUgdGhhdCB3aG9sZSB0aGluZywgc28gY29uY2F0IHRoZW0gYmFjayB0b2dldGhlciBiZWZvcmVcbiAgICAvLyByZXR1cm5pbmcuXG4gICAgcmV0dXJuIHsga2V5czogbnVtZXJpY1ByZWZpeC5jb25jYXQoa2V5c2VxKSwgaXNNYXRjaDoga2V5c2VxLmxlbmd0aCA+IDAgfVxufVxuXG4vKiogVHJ1ZSBpZiBzZXExIGlzIGEgcHJlZml4IG9yIGVxdWFsIHRvIHNlcTIgKi9cbmZ1bmN0aW9uIHByZWZpeGVzKHNlcTE6IEtleUV2ZW50TGlrZVtdLCBzZXEyOiBNaW5pbWFsS2V5W10pIHtcbiAgICBpZiAoc2VxMS5sZW5ndGggPiBzZXEyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXkxLCBrZXkyXSBvZiBpemlwKHNlcTEsIHNlcTIpKSB7XG4gICAgICAgICAgICBpZiAoIWtleTIubWF0Y2goa2V5MSkpIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxufVxuXG4vKiogcmV0dXJucyB0aGUgZnJhZ21lbnQgb2YgYG1hcGAgdGhhdCBrZXlzZXEgaXMgYSB2YWxpZCBwcmVmaXggb2YuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcGxldGlvbnMoa2V5c2VxOiBLZXlFdmVudExpa2VbXSwgbWFwOiBLZXlNYXApOiBLZXlNYXAge1xuICAgIHJldHVybiBuZXcgTWFwKFxuICAgICAgICBmaWx0ZXIobWFwLmVudHJpZXMoKSwgKFtrcywgbWFwdGFyZ2V0XSkgPT4gcHJlZml4ZXMoa2V5c2VxLCBrcykpLFxuICAgIClcbn1cblxuLy8gfX19XG5cbi8vIHt7eyBtYXBTdHJUb0tleVNlcSBzdHVmZlxuXG4vKiogRXhwYW5kIHNwZWNpYWwga2V5IGFsaWFzZXMgdGhhdCBWaW0gcHJvdmlkZXMgdG8gY2Fub25pY2FsIHZhbHVlc1xuXG4gICAgVmltIGFsaWFzZXMgYXJlIGNhc2UgaW5zZW5zaXRpdmUuXG4qL1xuZnVuY3Rpb24gZXhwYW5kQWxpYXNlcyhrZXk6IHN0cmluZykge1xuICAgIC8vIFZpbSBjb21wYXRpYmlsaXR5IGFsaWFzZXNcbiAgICBjb25zdCBhbGlhc2VzID0ge1xuICAgICAgICBjcjogXCJFbnRlclwiLFxuICAgICAgICBlc2M6IFwiRXNjYXBlXCIsXG4gICAgICAgIHJldHVybjogXCJFbnRlclwiLFxuICAgICAgICBlbnRlcjogXCJFbnRlclwiLFxuICAgICAgICBzcGFjZTogXCIgXCIsXG4gICAgICAgIGJhcjogXCJ8XCIsXG4gICAgICAgIGRlbDogXCJEZWxldGVcIixcbiAgICAgICAgYnM6IFwiQmFja3NwYWNlXCIsXG4gICAgICAgIGx0OiBcIjxcIixcbiAgICB9XG4gICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpIGluIGFsaWFzZXMpIHJldHVybiBhbGlhc2VzW2tleS50b0xvd2VyQ2FzZSgpXVxuICAgIGVsc2UgcmV0dXJuIGtleVxufVxuXG4vKiogU3RyaW5nIHN0YXJ0aW5nIHdpdGggYSBgPGAgdG8gTWluaW1hbEtleSBhbmQgcmVtYWluZGVyLlxuXG4gICAgQnJhY2tldCBleHByZXNzaW9ucyBnZW5lcmFsbHkgc3RhcnQgd2l0aCBhIGA8YCBjb250YWluIG5vIGFuZ2xlIGJyYWNrZXRzIG9yXG4gICAgd2hpdGVzcGFjZSBhbmQgZW5kIHdpdGggYSBgPi5gIFRoZXNlIHNwZWNpYWwtY2FzZWQgZXhwcmVzc2lvbnMgYXJlIGFsc29cbiAgICBwZXJtaXR0ZWQ6IGA8e21vZGlmaWVyfTw+YCwgYDx7bW9kaWZpZXJ9Pj5gLCBhbmQgYDx7bW9kaWZpZXJ9LT5gLlxuXG4gICAgSWYgdGhlIHN0cmluZyBwYXNzZWQgZG9lcyBub3QgbWF0Y2ggdGhpcyBkZWZpbml0aW9uLCBpdCBpcyB0cmVhdGVkIGFzIGFcbiAgICBsaXRlcmFsIGA8LmBcblxuICAgIEJhY2t1cyBOYXVyIGFwcHJveGltYXRpb246XG5cbiAgICBgYGBcbiAgICAgICAgLSBicmFja2V0ZXhwciA6Oj0gJzwnIG1vZGlmaWVyPyBrZXkgJz4nXG4gICAgICAgIC0gbW9kaWZpZXIgOjo9ICdtJ3wncyd8J2EnfCdjJyAnLSdcbiAgICAgICAgLSBrZXkgOjo9ICc8J3wnPid8L1teXFxzPD4tXSsvXG4gICAgYGBgXG5cbiAgICBTZWUgYHNyYy9ncmFtbWFycy9icmFja2V0RXhwci5uZWAgZm9yIHRoZSBjYW5vbmljYWwgZGVmaW5pdGlvbi5cblxuICAgIE1vZGlmaWVycyBhcmUgY2FzZSBpbnNlbnNpdGl2ZS5cblxuICAgIFNvbWUgY2FzZSBpbnNlbnNpdGl2ZSB2aW0gY29tcGF0aWJpbGl0eSBhbGlhc2VzIGFyZSBhbHNvIGRlZmluZWQsIHNlZVxuICAgIFtbZXhwYW5kQWxpYXNlc11dLlxuXG4gICAgQ29tcGF0aWJpbGl0eSBicmVha3M6XG5cbiAgICBTaGlmdCArIGtleSBtdXN0IHVzZSB0aGUgY29ycmVjdCBjYXBpdGFsaXNhdGlvbiBvZiBrZXk6XG4gICAgICAgIGA8Uy1qPiAhPSBKLCA8Uy1KPiA9PSBKYC5cblxuICAgIEluIFZpbSBgPEEteD4gPT0gPE0teD5gIG9uIG1vc3Qgc3lzdGVtcy4gTm90IHNvIGhlcmU6IHdlIGNhbid0IGRldGVjdFxuICAgIHBsYXRmb3JtLCBzbyBqdXN0IGhhdmUgdG8gdXNlIHdoYXQgdGhlIGJyb3dzZXIgZ2l2ZXMgdXMuXG5cbiAgICBWaW0gaGFzIGEgcHJlZGVmaW5lZCBsaXN0IG9mIHNwZWNpYWwga2V5IHNlcXVlbmNlcywgd2UgZG9uJ3Q6IHRoZXJlIGFyZSB0b29cbiAgICBtYW55IChhbmQgdGhleSdyZSBub24tc3RhbmRhcmQpIFsxXS5cblxuICAgIEluIHRoZSBmdXR1cmUsIHdlIG1heSBqdXN0IHVzZSB0aGUgbmFtZXMgYXMgZGVmaW5lZCBpbiBrZXlOYW1lTGlzdC5oIFsyXS5cblxuICAgIEluIFZpbSwgeW91J3JlIHN0aWxsIGFsbG93ZWQgdG8gdXNlIGA8bHQ+YCB3aXRoaW4gYW5nbGVkIGJyYWNrZXRzOlxuICAgICAgICBgPE0tPD4gPT0gPE0tbHQ+ID09IDxNLTxsdD4+YFxuICAgIEhlcmUgb25seSB0aGUgZmlyc3QgdHdvIHdpbGwgd29yay5cblxuICAgIFJlc3RyaWN0aW9uczpcblxuICAgIEl0IGlzIG5vdCBwb3NzaWJsZSB0byBtYXAgdG8gYSBrZXlldmVudCB0aGF0IGFjdHVhbGx5IHNlbmRzIHRoZSBrZXkgdmFsdWVcbiAgICBvZiBhbnkgb2YgdGhlIGFsaWFzZXMgb3IgdG8gYW55IG11bHRpLWNoYXJhY3RlciBzZXF1ZW5jZSBjb250YWluaW5nIGEgc3BhY2VcbiAgICBvciBgPi5gIEl0IGlzIHVubGlrZWx5IHRoYXQgYnJvd3NlcnMgd2lsbCBldmVyIGRvIGVpdGhlciBvZiB0aG9zZSB0aGluZ3MuXG5cbiAgICBbMV06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L2tleS9LZXlfVmFsdWVzXG4gICAgWzJdOiBodHRwczovL3NlYXJjaGZveC5vcmcvbW96aWxsYS1jZW50cmFsL3NvdXJjZS9kb20vZXZlbnRzL0tleU5hbWVMaXN0LmhcblxuKi9cbmV4cG9ydCBmdW5jdGlvbiBicmFja2V0ZXhwclRvS2V5KGlucHV0U3RyKSB7XG4gICAgaWYgKGlucHV0U3RyLmluZGV4T2YoXCI+XCIpID4gMCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgW1xuICAgICAgICAgICAgICAgIFttb2RpZmllcnMsIGtleV0sXG4gICAgICAgICAgICAgICAgcmVtYWluZGVyLFxuICAgICAgICAgICAgXSA9IGJyYWNrZXRleHByX3BhcnNlci5mZWVkVW50aWxFcnJvcihpbnB1dFN0cilcbiAgICAgICAgICAgIHJldHVybiBbbmV3IE1pbmltYWxLZXkoZXhwYW5kQWxpYXNlcyhrZXkpLCBtb2RpZmllcnMpLCByZW1haW5kZXJdXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIE5vIHZhbGlkIGJyYWNrZXRFeHByXG4gICAgICAgICAgICByZXR1cm4gW25ldyBNaW5pbWFsS2V5KFwiPFwiKSwgaW5wdXRTdHIuc2xpY2UoMSldXG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBObyBlbmQgYnJhY2tldCB0byBtYXRjaCA9PSBubyB2YWxpZCBicmFja2V0RXhwclxuICAgICAgICByZXR1cm4gW25ldyBNaW5pbWFsS2V5KFwiPFwiKSwgaW5wdXRTdHIuc2xpY2UoMSldXG4gICAgfVxufVxuXG4vKiogR2VuZXJhdGUgS2V5U2VxdWVuY2VzIGZvciB0aGUgcmVzdCBvZiB0aGUgQVBJLlxuXG4gICAgQSBtYXAgZXhwcmVzc2lvbiBpcyBzb21ldGhpbmcgbGlrZTpcblxuICAgIGBgYFxuICAgIGogc2Nyb2xsbGluZSAxMFxuICAgIDxDLWY+IHNjcm9sbHBhZ2UgMC41XG4gICAgPEMtZD4gc2Nyb2xscGFnZSAwLjVcbiAgICA8Qy0vPjxDLW4+IG1vZGUgbm9ybWFsXG4gICAgYGBgXG5cbiAgICBBIG1hcHN0ciBpcyB0aGUgYml0IGJlZm9yZSB0aGUgc3BhY2UuXG5cbiAgICBtYXBzdHJUb0tleXNlcSB0dXJucyBhIG1hcHN0ciBpbnRvIGEga2V5U2VxdWVuY2UgdGhhdCBsb29rcyBsaWtlIHRoaXM6XG5cbiAgICBgYGBcbiAgICBbTWluaW1hbEtleSB7a2V5OiAnaid9XVxuICAgIFtNaW5pbWFsS2V5IHtrZXk6ICdmJywgY3RybEtleTogdHJ1ZX1dXG4gICAgW01pbmltYWxLZXkge2tleTogJ2QnLCBjdHJsS2V5OiB0cnVlfV1cbiAgICBbTWluaW1hbEtleSB7a2V5OiAnLycsIGN0cmxLZXk6IHRydWV9LCBNaW5pbWFsS2V5IHtrZXk6ICduJywgY3RybEtleTogdHJ1ZX1dXG4gICAgYGBgXG5cbiAgICAoQWxsIGZvdXIge21vZGlmaWVyfUtleSBmbGFncyBhcmUgYWN0dWFsbHkgcHJvdmlkZWQgb24gYWxsIE1pbmltYWxLZXlzKVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBzdHJUb0tleXNlcShtYXBzdHI6IHN0cmluZyk6IE1pbmltYWxLZXlbXSB7XG4gICAgY29uc3Qga2V5c2VxOiBNaW5pbWFsS2V5W10gPSBbXVxuICAgIGxldCBrZXk6IE1pbmltYWxLZXlcbiAgICAvLyBSZWR1Y2UgbWFwc3RyIGJ5IG9uZSBjaGFyYWN0ZXIgb3Igb25lIGJyYWNrZXQgZXhwcmVzc2lvbiBwZXIgaXRlcmF0aW9uXG4gICAgd2hpbGUgKG1hcHN0ci5sZW5ndGgpIHtcbiAgICAgICAgaWYgKG1hcHN0clswXSA9PT0gXCI8XCIpIHtcbiAgICAgICAgICAgIFtrZXksIG1hcHN0cl0gPSBicmFja2V0ZXhwclRvS2V5KG1hcHN0cilcbiAgICAgICAgICAgIGtleXNlcS5wdXNoKGtleSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleXNlcS5wdXNoKG5ldyBNaW5pbWFsS2V5KG1hcHN0clswXSkpXG4gICAgICAgICAgICBtYXBzdHIgPSBtYXBzdHIuc2xpY2UoMSlcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5c2VxXG59XG5cbi8qKiBDb252ZXJ0IGEgbWFwIG9mIG1hcHN0cnMgKGUuZy4gZnJvbSBjb25maWcpIHRvIGEgS2V5TWFwICovXG5leHBvcnQgZnVuY3Rpb24gbWFwc3RyTWFwVG9LZXlNYXAobWFwc3RyTWFwOiBNYXA8c3RyaW5nLCBNYXBUYXJnZXQ+KTogS2V5TWFwIHtcbiAgICBjb25zdCBuZXdLZXlNYXAgPSBuZXcgTWFwKClcbiAgICBmb3IgKGNvbnN0IFttYXBzdHIsIHRhcmdldF0gb2YgbWFwc3RyTWFwLmVudHJpZXMoKSkge1xuICAgICAgICBuZXdLZXlNYXAuc2V0KG1hcHN0clRvS2V5c2VxKG1hcHN0ciksIHRhcmdldClcbiAgICB9XG4gICAgcmV0dXJuIG5ld0tleU1hcFxufVxuXG4vLyB9fX1cblxuLy8ge3t7IFV0aWxpdHkgZnVuY3Rpb25zIGZvciBkZWFsaW5nIHdpdGggS2V5Ym9hcmRFdmVudHNcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc01vZGlmaWVycyhrZXlFdmVudDogS2V5RXZlbnRMaWtlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAga2V5RXZlbnQuY3RybEtleSB8fFxuICAgICAgICBrZXlFdmVudC5hbHRLZXkgfHxcbiAgICAgICAga2V5RXZlbnQubWV0YUtleSB8fFxuICAgICAgICBrZXlFdmVudC5zaGlmdEtleVxuICAgIClcbn1cblxuLyoqIHNoaWZ0S2V5IGlzIHRydWUgZm9yIGFueSBjYXBpdGFsIGxldHRlciwgbW9zdCBudW1iZXJzLCBldGMuIEdlbmVyYWxseSBjYXJlIGFib3V0IG90aGVyIG1vZGlmaWVycy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNOb25TaGlmdE1vZGlmaWVycyhrZXlFdmVudDogS2V5RXZlbnRMaWtlKSB7XG4gICAgcmV0dXJuIGtleUV2ZW50LmN0cmxLZXkgfHwga2V5RXZlbnQuYWx0S2V5IHx8IGtleUV2ZW50Lm1ldGFLZXlcbn1cblxuLyoqIEEgc2ltcGxlIGtleSBldmVudCBpcyBhIG5vbi1zcGVjaWFsIGtleSAobGVuZ3RoIDEpIHRoYXQgaXMgbm90IG1vZGlmaWVkIGJ5IGN0cmwsIGFsdCwgb3Igc2hpZnQuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTaW1wbGVLZXkoa2V5RXZlbnQ6IEtleUV2ZW50TGlrZSkge1xuICAgIHJldHVybiAhKGtleUV2ZW50LmtleS5sZW5ndGggPiAxIHx8IGhhc05vblNoaWZ0TW9kaWZpZXJzKGtleUV2ZW50KSlcbn1cblxuZnVuY3Rpb24gbnVtZXJpY1ByZWZpeFRvRXhzdHJTdWZmaXgobnVtZXJpY1ByZWZpeDogS2V5RXZlbnRMaWtlW10pIHtcbiAgICBpZiAobnVtZXJpY1ByZWZpeC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBcIiBcIiArIG51bWVyaWNQcmVmaXgubWFwKGsgPT4gay5rZXkpLmpvaW4oXCJcIilcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJcIlxuICAgIH1cbn1cblxuLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBnaXZlbiBzZXQgb2Yga2V5RXZlbnRzIChpbiBwbGFjZSkgYXMgc3BlY2lmaWVkIGJ5XG4gKiB0aGUgZ2l2ZW4ga2V5IHRyYW5zbGF0aW9uIG1hcC4gQWxsIGtleXMgKmFuZCogdmFsdWVzIGluIHRoZSBrZXlcbiAqIHRyYW5zbGF0aW9uIG1hcCBtdXN0IGJlIGxlbmd0aC0xIHN0cmluZ3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGVLZXlzVXNpbmdLZXlUcmFuc2xhdGVNYXAoXG4gICAga2V5RXZlbnRzOiBLZXlFdmVudExpa2VbXSxcbiAgICBrZXl0cmFuc2xhdGVtYXA6IHsgW2lua2V5OiBzdHJpbmddOiBzdHJpbmcgfSxcbikge1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBrZXlFdmVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IGtleUV2ZW50ID0ga2V5RXZlbnRzW2luZGV4XVxuICAgICAgICBjb25zdCBuZXdrZXkgPSBrZXl0cmFuc2xhdGVtYXBba2V5RXZlbnQua2V5XVxuXG4gICAgICAgIC8vIEtleWJvYXJkRXZlbnRzIGNhbid0IGhhdmUgYmVlbiB0cmFuc2xhdGVkLCBNaW5pbWFsS2V5cyBtYXlcbiAgICAgICAgLy8gaGF2ZSBiZWVuLiBXZSBjYW4ndCBhZGQgYW55dGhpbmcgdG8gdGhlIE1pbmltYWxLZXkgd2l0aG91dFxuICAgICAgICAvLyBicmVha2luZyBhIHRvbiBvZiBvdGhlciBzdHVmZiwgc28gaW5zdGVhZCB3ZSdsbCBqdXN0IGFzc3VtZVxuICAgICAgICAvLyB0aGF0IHRoZSBvbmx5IHdheSB3ZSd2ZSBnb3R0ZW4gYSBNaW5pbWFsS2V5IGlzIGlmIHRoZSBrZXlcbiAgICAgICAgLy8gaGFzIGFscmVhZHkgYmVlbiB0cmFuc2xhdGVkLiBXZSBlcnIgd2F5IG9uIHRoZSBzaWRlIG9mXG4gICAgICAgIC8vIHNhZmV0eSBiZWNhc2UgdHJhbnNsYXRpbmcgYW55dGhpbmcgbW9yZSB0aGFuIG9uY2Ugd291bGRcbiAgICAgICAgLy8gYWxtb3N0IGNlcnRhaW5seSBtZWFuIG9zY2lsbGF0aW9ucyBhbmQgb3RoZXIgc3VwZXItd2VpcmRcbiAgICAgICAgLy8gYnJlYWthZ2UuXG4gICAgICAgIGNvbnN0IG5ldmVyVHJhbnNsYXRlZCA9IGtleUV2ZW50IGluc3RhbmNlb2YgS2V5Ym9hcmRFdmVudFxuICAgICAgICBpZiAobmV2ZXJUcmFuc2xhdGVkICYmIG5ld2tleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBXZSBjYW4ndCB1cGRhdGUgdGhlIGtleUV2ZW50IGluIHBsYWNlLiBIb3dldmVyLCB0aGVcbiAgICAgICAgICAgIC8vIGVudGlyZSBwaXBlbGluZSB3b3JrcyB3aXRoIE1pbmltYWxLZXlzIGFsbCB0aGUgd2F5XG4gICAgICAgICAgICAvLyB0aHJvdWdoLCBzbyB3ZSBqdXN0IHN3YXAgdGhlIGtleSBldmVudCBvdXQgZm9yIGEgbmV3XG4gICAgICAgICAgICAvLyBNaW5pbWFsS2V5IHdpdGggdGhlIHJpZ2h0IGtleSBhbmQgbW9kaWZpZXJzIGNvcGllZCBmcm9tXG4gICAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwuXG4gICAgICAgICAgICBrZXlFdmVudHNbaW5kZXhdID0gbmV3IE1pbmltYWxLZXkobmV3a2V5LCB7XG4gICAgICAgICAgICAgICAgYWx0S2V5OiBrZXlFdmVudC5hbHRLZXksXG4gICAgICAgICAgICAgICAgY3RybEtleToga2V5RXZlbnQuY3RybEtleSxcbiAgICAgICAgICAgICAgICBtZXRhS2V5OiBrZXlFdmVudC5tZXRhS2V5LFxuICAgICAgICAgICAgICAgIHNoaWZ0S2V5OiBrZXlFdmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIH19fVxuIiwiLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBsb2dnaW5nXG4gKi9cblxuaW1wb3J0ICogYXMgQ29uZmlnIGZyb20gXCJAc3JjL2xpYi9jb25maWdcIlxuXG5jb25zdCBMZXZlbFRvTnVtID0gbmV3IE1hcDxDb25maWcuTG9nZ2luZ0xldmVsLCBudW1iZXI+KClcbkxldmVsVG9OdW0uc2V0KFwibmV2ZXJcIiwgMClcbkxldmVsVG9OdW0uc2V0KFwiZXJyb3JcIiwgMSlcbkxldmVsVG9OdW0uc2V0KFwid2FybmluZ1wiLCAyKVxuTGV2ZWxUb051bS5zZXQoXCJpbmZvXCIsIDMpXG5MZXZlbFRvTnVtLnNldChcImRlYnVnXCIsIDQpXG5cbmV4cG9ydCBjbGFzcyBMb2dnZXIge1xuICAgIC8qKlxuICAgICAqIENvbmZpZy1hd2FyZSBMb2dnZXIgY2xhc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9nTW9kdWxlICAgICB0aGUgbG9nZ2luZyBtb2R1bGUgbmFtZTogdGhpcyBpcyB1ZWQgdG8gbG9vayB1cCB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmVkL2RlZmF1bHQgbGV2ZWwgaW4gdGhlIHVzZXIgY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBsb2dNb2R1bGUpIHt9XG5cbiAgICAvKipcbiAgICAgKiBDb25maWctYXdhcmUgbG9nZ2luZyBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsZXZlbCAgICAgICAgIHRoZSBsZXZlbCBvZiB0aGUgbG9nZ2luZyAtIGlmIDw9IGNvbmZpZ3VyZWQsIHRoZSBtZXNzYWdlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBzaG93blxuICAgICAqXG4gICAgICogQHJldHVybiAgICAgICAgICAgICAgbG9nZ2luZyBmdW5jdGlvbjogdGhpcyBpcyByZXR1cm5lZCBhcyBhIGZ1bmN0aW9uIHRvXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgcmV0YWluIHRoZSBjYWxsIHNpdGVcbiAgICAgKi9cbiAgICBwcml2YXRlIGxvZyhsZXZlbDogQ29uZmlnLkxvZ2dpbmdMZXZlbCkge1xuICAgICAgICBjb25zdCBjb25maWdlZExldmVsID0gQ29uZmlnLmdldChcImxvZ2dpbmdcIiwgdGhpcy5sb2dNb2R1bGUpXG5cbiAgICAgICAgaWYgKExldmVsVG9OdW0uZ2V0KGxldmVsKSA8PSBMZXZlbFRvTnVtLmdldChjb25maWdlZExldmVsKSkge1xuICAgICAgICAgICAgLy8gaGFuZCBvdmVyIHRvIGNvbnNvbGUubG9nLCBlcnJvciBvciBkZWJ1ZyBhcyBuZWVkZWRcbiAgICAgICAgICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogcmVwbGljYXRlIHRoaXMgZm9yIG90aGVyIGxldmVscywgZG9uJ3Qgc3RlYWwgZm9jdXNcbiAgICAgICAgICAgICAgICAgICAgLy8gd29yayBvdXQgaG93IHRvIGltcG9ydCBtZXNzYWdpbmcvd2ViZXh0IHdpdGhvdXQgYnJlYWtpbmcgZXZlcnl0aGluZ1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXN5bmMgKC4uLm1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoLi4ubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBicm93c2VyLnJ1bnRpbWUuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY29udHJvbGxlcl9iYWNrZ3JvdW5kXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogXCJhY2NlcHRFeENtZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcImZpbGxjbWRsaW5lX25vZm9jdXMgIyBcIiArIG1lc3NhZ2Uuam9pbihcIiBcIildLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJ3YXJuaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm5cbiAgICAgICAgICAgICAgICBjYXNlIFwiaW5mb1wiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc29sZS5sb2dcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGVidWdcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUuZGVidWdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRvIG5vdGhpbmcgd2l0aCB0aGUgbWVzc2FnZVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge31cbiAgICB9XG5cbiAgICAvLyBUaGVzZSBhcmUgYWxsIGdldHRlcnMgc28gdGhhdCBsb2dnZXIuZGVidWcgPSBjb25zb2xlLmRlYnVnIGFuZFxuICAgIC8vIGxvZ2dlci5kZWJ1ZygnYmxhaCcpIHRyYW5zbGF0ZXMgaW50byBjb25zb2xlLmRlYnVnKCdibGFoJykgd2l0aCB0aGVcbiAgICAvLyBmaWxlbmFtZSBhbmQgbGluZSBjb3JyZWN0LlxuICAgIHB1YmxpYyBnZXQgZGVidWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZyhcImRlYnVnXCIpXG4gICAgfVxuICAgIHB1YmxpYyBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nKFwiaW5mb1wiKVxuICAgIH1cbiAgICBwdWJsaWMgZ2V0IHdhcm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZyhcIndhcm5pbmdcIilcbiAgICB9XG4gICAgcHVibGljIGdldCBlcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nKFwiZXJyb3JcIilcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExvZ2dlclxuIiwiZXhwb3J0IGZ1bmN0aW9uIGxvZyh4LCBiYXNlKSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5sb2coYmFzZSlcbn1cblxuLy8gQ29waWVkIGZyb20gTnVtZXJpYyBKYXZhc2NyaXB0IHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3Nsb2lzZWwvbnVtZXJpYy9ibG9iLzY1NmZhMTI1NGJlNTQwZjQyODcxMDczOGNhOWMxNTM5NjI1Nzc3ZjEvc3JjL251bWVyaWMuanMjTDkyMlxuZXhwb3J0IGZ1bmN0aW9uIGxpbnNwYWNlKGE6IG51bWJlciwgYjogbnVtYmVyLCBuPzogbnVtYmVyKSB7XG4gICAgaWYgKHR5cGVvZiBuID09PSBcInVuZGVmaW5lZFwiKSBuID0gTWF0aC5tYXgoTWF0aC5yb3VuZChiIC0gYSkgKyAxLCAxKVxuICAgIGlmIChuIDwgMikge1xuICAgICAgICByZXR1cm4gbiA9PT0gMSA/IFthXSA6IFtdXG4gICAgfVxuICAgIGxldCBpXG4gICAgY29uc3QgcmV0ID0gQXJyYXkobilcbiAgICBuLS1cbiAgICBmb3IgKGkgPSBuOyBpID49IDA7IGktLSkge1xuICAgICAgICByZXRbaV0gPSAoaSAqIGIgKyAobiAtIGkpICogYSkgLyBuXG4gICAgfVxuICAgIHJldHVybiByZXRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1Y2tldHModmFsdWVzOiBudW1iZXJbXSwgbnVtQnVja2V0czogbnVtYmVyKTogbnVtYmVyW10ge1xuICAgIGNvbnN0IG1pbiA9IHZhbHVlcy5yZWR1Y2UoKGEsIGIpID0+IE1hdGgubWluKGEsIGIpKVxuICAgIGNvbnN0IG1heCA9IHZhbHVlcy5yZWR1Y2UoKGEsIGIpID0+IE1hdGgubWF4KGEsIGIpKVxuICAgIHJldHVybiBsaW5zcGFjZShtaW4sIG1heCwgbnVtQnVja2V0cylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1Y2tldGl6ZShcbiAgICB2YWx1ZXM6IG51bWJlcltdLFxuICAgIGJ1Y2tldHM6IG51bWJlcltdLFxuKTogTWFwPG51bWJlciwgbnVtYmVyPiB7XG4gICAgLy8gSW5pdCByZXN1bHQgc3RvcmFnZVxuICAgIGNvbnN0IHJlc3VsdDogTWFwPG51bWJlciwgbnVtYmVyPiA9IG5ldyBNYXA8bnVtYmVyLCBudW1iZXI+KClcbiAgICBmb3IgKGNvbnN0IGJ1Y2tldHZhbCBvZiBidWNrZXRzKSB7XG4gICAgICAgIHJlc3VsdC5zZXQoYnVja2V0dmFsLCAwKVxuICAgIH1cblxuICAgIC8vIFdlIHBsYWNlIGEgdmFsdWUgaW4gYSBidWNrZXQgYnkgZ29pbmcgdGhyb3VnaCB0aGUgYnVja2V0cyBmcm9tXG4gICAgLy8gc21hbGxlc3QgdG8gbGFyZ2VzdCwgZmluZGluZyB0aGUgc21hbGxlc3QgYnVja2V0IHRoYXQncyBsYXJnZXJcbiAgICAvLyB0aGFuIG9yIGVxdWFsIHRvIHRoYW4gdGhlIHZhbHVlLiBUaGlzIHdpbGwgaGF2ZSB0aGUgZm9sbG93aW5nXG4gICAgLy8gcmVzdWx0czpcbiAgICAvL1xuICAgIC8vICogQSB2YWx1ZSB0aGF0J3MgbGFyZ2VyIHRoYW4gYWxsIGJ1Y2tldCB2YWx1ZXMgd2lsbCBub3QgYmVcbiAgICAvLyAgIHBsYWNlZCBhdCBhbGwuXG4gICAgLy8gKiBBIHZhbHVlIHdpdGggZXhhY3RseSB0aGUgdmFsdWUgb2YgdGhlIGxhcmdlc3QgYnVja2V0IHdpbGwgYmVcbiAgICAvLyAgIHBsYWNlZCBpbiB0aGUgbGFyZ2VzdCBidWNrZXQuXG4gICAgLy8gKiBBIHZhbHVlIHdpdGggZXhhY3RseSB0aGUgdmFsdWUgb2YgdGhlIHNtYWxsZXN0IGJ1Y2tldCB3aWxsIGJlXG4gICAgLy8gICBwbGFjZWQgaW4gdGhlIHNtYWxsZXN0IGJ1Y2tldC5cbiAgICAvLyAqIEEgdmFsdWUgdGhhdCdzIHNtYWxsZXIgdGhhbiBhbGwgYnVja2V0IHZhbHVlcyB3aWxsIGJlIHBsYWNlZFxuICAgIC8vICAgaW4gdGhlIHNtYWxsZXN0IGJ1Y2tldC5cbiAgICAvL1xuICAgIC8vIElmIHdlIGJ1aWxkIG91ciBidWNrZXRzIGFzIGxpbnNwYWNlKG1pbih2YWx1ZXMpLCBtYXgodmFsdWVzKSksXG4gICAgLy8gdGhlbiB0aGlzIG1lYW5zIHRoYXQgdGhlIGxhcmdlc3QgYnVja2V0IGlzIGd1YXJhbnRlZWQgdG8gaGF2ZVxuICAgIC8vIGV4YWN0bHkgb25lIGVsZW1lbnQgaW4gaXQuXG4gICAgY29uc3QgcGxhY2VWYWx1ZSA9ICh2YWw6IG51bWJlcikgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGJ1Y2tldHZhbCBvZiBidWNrZXRzKSB7XG4gICAgICAgICAgICBpZiAoYnVja2V0dmFsID49IHZhbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoYnVja2V0dmFsLCByZXN1bHQuZ2V0KGJ1Y2tldHZhbCkgKyAxKVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnVja2V0aXplIGV2ZXJ5IHZhbHVlLlxuICAgIGZvciAoY29uc3QgdmFsIG9mIHZhbHVlcykge1xuICAgICAgICBwbGFjZVZhbHVlKHZhbClcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4ganVzdCB0aGUgY291bnRzIGluIGVhY2ggYnVja2V0XG4gICAgcmV0dXJuIHJlc3VsdFxufVxuIiwiaW1wb3J0IHsgYnJvd3NlckJnLCBhY3RpdmVUYWJJZCwgb3duVGFiSWQsIGdldENvbnRleHQgfSBmcm9tIFwiQHNyYy9saWIvd2ViZXh0XCJcbmltcG9ydCBMb2dnZXIgZnJvbSBcIkBzcmMvbGliL2xvZ2dpbmdcIlxuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcihcIm1lc3NhZ2luZ1wiKVxuXG5leHBvcnQgdHlwZSBUYWJNZXNzYWdlVHlwZSA9XG4gICAgfCBcImVkaXRvcmZuX2NvbnRlbnRcIlxuICAgIHwgXCJleGNtZF9jb250ZW50XCJcbiAgICB8IFwiY29udHJvbGxlcl9jb250ZW50XCJcbiAgICB8IFwiY29tbWFuZGxpbmVfY29udGVudFwiXG4gICAgfCBcImZpbmRpbmdfY29udGVudFwiXG4gICAgfCBcImNvbW1hbmRsaW5lX2NtZFwiXG4gICAgfCBcImNvbW1hbmRsaW5lX2ZyYW1lXCJcbmV4cG9ydCB0eXBlIE5vblRhYk1lc3NhZ2VUeXBlID1cbiAgICB8IFwib3dudGFiX2JhY2tncm91bmRcIlxuICAgIHwgXCJleGNtZF9iYWNrZ3JvdW5kXCJcbiAgICB8IFwiY29udHJvbGxlcl9iYWNrZ3JvdW5kXCJcbiAgICB8IFwiYnJvd3Nlcl9wcm94eV9iYWNrZ3JvdW5kXCJcbiAgICB8IFwiZG93bmxvYWRfYmFja2dyb3VuZFwiXG4gICAgfCBcInBlcmZvcm1hbmNlX2JhY2tncm91bmRcIlxuZXhwb3J0IHR5cGUgTWVzc2FnZVR5cGUgPSBUYWJNZXNzYWdlVHlwZSB8IE5vblRhYk1lc3NhZ2VUeXBlXG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZSB7XG4gICAgdHlwZTogTWVzc2FnZVR5cGVcbiAgICAvLyBhbmQgb3RoZXIgdW5rbm93biBhdHRyaWJ1dGVzLi4uXG4gICAgW2tleTogc3RyaW5nXTogYW55XG59XG5cbmV4cG9ydCB0eXBlIGxpc3RlbmVyID0gKFxuICAgIG1lc3NhZ2U6IE1lc3NhZ2UsXG4gICAgc2VuZGVyPyxcbiAgICBzZW5kUmVzcG9uc2U/LFxuKSA9PiB2b2lkIHwgUHJvbWlzZTxhbnk+XG5cbi8vIENhbGxzIG1ldGhvZHMgb24gb2JqIHRoYXQgbWF0Y2ggLmNvbW1hbmQgYW5kIHNlbmRzIHJlc3BvbnNlcyBiYWNrXG5leHBvcnQgZnVuY3Rpb24gYXR0cmlidXRlQ2FsbGVyKG9iaikge1xuICAgIGZ1bmN0aW9uIGhhbmRsZXIobWVzc2FnZTogTWVzc2FnZSwgc2VuZGVyLCBzZW5kUmVzcG9uc2UpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKG1lc3NhZ2UpXG5cbiAgICAgICAgLy8gQXJncyBtYXkgYmUgdW5kZWZpbmVkLCBidXQgeW91IGNhbid0IHNwcmVhZCB1bmRlZmluZWQuLi5cbiAgICAgICAgaWYgKG1lc3NhZ2UuYXJncyA9PT0gdW5kZWZpbmVkKSBtZXNzYWdlLmFyZ3MgPSBbXVxuXG4gICAgICAgIC8vIENhbGwgY29tbWFuZCBvbiBvYmpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gb2JqW21lc3NhZ2UuY29tbWFuZF0oLi4ubWVzc2FnZS5hcmdzKVxuXG4gICAgICAgICAgICAvLyBSZXR1cm4gcmVzcG9uc2UgdG8gc2VuZGVyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiUmV0dXJuaW5nIHByb21pc2UuLi5cIiwgcmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKHJlc3BvbnNlKVxuICAgICAgICAgICAgICAgIC8vIERvY3Mgc2F5IHlvdSBzaG91bGQgYmUgYWJsZSB0byByZXR1cm4gYSBwcm9taXNlLCBidXQgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGRvZXNuJ3Qgd29yay5cbiAgICAgICAgICAgICAgICAvKiByZXR1cm4gcmVzcG9uc2UgKi9cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlJldHVybmluZyBzeW5jaHJvbm91c2x5Li4uXCIsIHJlc3BvbnNlKVxuICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZShyZXNwb25zZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgIGBFcnJvciBwcm9jZXNzaW5nICR7bWVzc2FnZS5jb21tYW5kfSgke21lc3NhZ2UuYXJnc30pYCxcbiAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZXJcbn1cblxuLyoqIFNlbmQgYSBtZXNzYWdlIHRvIG5vbi1jb250ZW50IHNjcmlwdHMgKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtZXNzYWdlKHR5cGU6IE5vblRhYk1lc3NhZ2VUeXBlLCBjb21tYW5kLCBhcmdzPykge1xuICAgIHJldHVybiBicm93c2VyLnJ1bnRpbWUuc2VuZE1lc3NhZ2UoeyB0eXBlLCBjb21tYW5kLCBhcmdzIH0gYXMgTWVzc2FnZSlcbn1cblxuLyoqIE1lc3NhZ2UgdGhlIGFjdGl2ZSB0YWIgb2YgdGhlIGN1cnJlbnRXaW5kb3cgKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtZXNzYWdlQWN0aXZlVGFiKFxuICAgIHR5cGU6IFRhYk1lc3NhZ2VUeXBlLFxuICAgIGNvbW1hbmQ6IHN0cmluZyxcbiAgICBhcmdzPzogYW55W10sXG4pIHtcbiAgICByZXR1cm4gbWVzc2FnZVRhYihhd2FpdCBhY3RpdmVUYWJJZCgpLCB0eXBlLCBjb21tYW5kLCBhcmdzKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbWVzc2FnZVRhYih0YWJJZCwgdHlwZTogVGFiTWVzc2FnZVR5cGUsIGNvbW1hbmQsIGFyZ3M/KSB7XG4gICAgY29uc3QgbWVzc2FnZTogTWVzc2FnZSA9IHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY29tbWFuZCxcbiAgICAgICAgYXJncyxcbiAgICB9XG4gICAgcmV0dXJuIGJyb3dzZXJCZy50YWJzLnNlbmRNZXNzYWdlKHRhYklkLCBtZXNzYWdlKVxufVxuXG5sZXQgX293blRhYklkXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbWVzc2FnZU93blRhYih0eXBlOiBUYWJNZXNzYWdlVHlwZSwgY29tbWFuZCwgYXJncz8pIHtcbiAgICBpZiAoX293blRhYklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgX293blRhYklkID0gYXdhaXQgb3duVGFiSWQoKVxuICAgIH1cbiAgICBpZiAoX293blRhYklkID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IG1lc3NhZ2Ugb3duIHRhYjogX293blRhYklkIGlzIHVuZGVmaW5lZFwiKVxuICAgIHJldHVybiBtZXNzYWdlVGFiKF9vd25UYWJJZCwgdHlwZSwgY29tbWFuZCwgYXJncylcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1lc3NhZ2VBbGxUYWJzKFxuICAgIHR5cGU6IFRhYk1lc3NhZ2VUeXBlLFxuICAgIGNvbW1hbmQ6IHN0cmluZyxcbiAgICBhcmdzPzogYW55W10sXG4pIHtcbiAgICBjb25zdCByZXNwb25zZXMgPSBbXVxuICAgIGZvciAoY29uc3QgdGFiIG9mIGF3YWl0IGJyb3dzZXJCZy50YWJzLnF1ZXJ5KHt9KSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcG9uc2VzLnB1c2goYXdhaXQgbWVzc2FnZVRhYih0YWIuaWQsIHR5cGUsIGNvbW1hbmQsIGFyZ3MpKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoZSlcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2VzXG59XG5cbmNvbnN0IGxpc3RlbmVycyA9IG5ldyBNYXA8c3RyaW5nLCBTZXQ8bGlzdGVuZXI+PigpXG5cbi8qKiBSZWdpc3RlciBhIGxpc3RlbmVyIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBtZXNzYWdlIHdpdGggdHlwZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGU6IE1lc3NhZ2VUeXBlLCBjYWxsYmFjazogbGlzdGVuZXIpIHtcbiAgICBpZiAoIWxpc3RlbmVycy5nZXQodHlwZSkpIHtcbiAgICAgICAgbGlzdGVuZXJzLnNldCh0eXBlLCBuZXcgU2V0KCkpXG4gICAgfVxuICAgIGxpc3RlbmVycy5nZXQodHlwZSkuYWRkKGNhbGxiYWNrKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGxpc3RlbmVycy5nZXQodHlwZSkuZGVsZXRlKGNhbGxiYWNrKVxuICAgIH1cbn1cblxuaWYgKGdldENvbnRleHQoKSA9PT0gXCJiYWNrZ3JvdW5kXCIpIHtcbiAgICAvLyBXYXJuaW5nOiBsaWIvd2ViZXh0LnRzOm93blRhYigpIHJlbGllcyBvbiB0aGlzIGxpc3RlbmVyIGJlaW5nIGFkZGVkIGluIG9yZGVyIHRvIHdvcmtcbiAgICBhZGRMaXN0ZW5lcihcIm93bnRhYl9iYWNrZ3JvdW5kXCIsIChtZXNzYWdlLCBzZW5kZXIsIHNlbmRSZXNwb25zZSkgPT4ge1xuICAgICAgICBjb25zdCB4ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBzZW5kZXIudGFiKVxuICAgICAgICB4Lm11dGVkSW5mbyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgc2VuZGVyLnRhYi5tdXRlZEluZm8pXG4gICAgICAgIHguc2hhcmluZ1N0YXRlID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICBzZW5kZXIudGFiLnNoYXJpbmdTdGF0ZSxcbiAgICAgICAgKVxuICAgICAgICBzZW5kUmVzcG9uc2UoUHJvbWlzZS5yZXNvbHZlKHgpKVxuICAgIH0pXG59XG5cbi8qKiBSZWN2IGEgbWVzc2FnZSBmcm9tIHJ1bnRpbWUub25NZXNzYWdlIGFuZCBzZW5kIHRvIGFsbCBsaXN0ZW5lcnMgKi9cbmZ1bmN0aW9uIG9uTWVzc2FnZShtZXNzYWdlLCBzZW5kZXIsIHNlbmRSZXNwb25zZSkge1xuICAgIGlmIChsaXN0ZW5lcnMuZ2V0KG1lc3NhZ2UudHlwZSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMuZ2V0KG1lc3NhZ2UudHlwZSkpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKG1lc3NhZ2UsIHNlbmRlciwgc2VuZFJlc3BvbnNlKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5icm93c2VyLnJ1bnRpbWUub25NZXNzYWdlLmFkZExpc3RlbmVyKG9uTWVzc2FnZSlcbiIsIi8qKlxuICogQmFja2dyb3VuZCBmdW5jdGlvbnMgZm9yIHRoZSBuYXRpdmUgbWVzc2VuZ2VyIGludGVyZmFjZVxuICovXG5cbmltcG9ydCAqIGFzIHNlbXZlckNvbXBhcmUgZnJvbSBcInNlbXZlci1jb21wYXJlXCJcbmltcG9ydCAqIGFzIGNvbmZpZyBmcm9tIFwiQHNyYy9saWIvY29uZmlnXCJcbmltcG9ydCB7IGJyb3dzZXJCZywgZ2V0Q29udGV4dCB9IGZyb20gXCJAc3JjL2xpYi93ZWJleHRcIlxuXG5pbXBvcnQgTG9nZ2VyIGZyb20gXCJAc3JjL2xpYi9sb2dnaW5nXCJcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoXCJuYXRpdmVcIilcblxuY29uc3QgTkFUSVZFX05BTUUgPSBcInRyaWRhY3R5bFwiXG50eXBlIE1lc3NhZ2VDb21tYW5kID1cbiAgICB8IFwidmVyc2lvblwiXG4gICAgfCBcInJ1blwiXG4gICAgfCBcInJlYWRcIlxuICAgIHwgXCJ3cml0ZVwiXG4gICAgfCBcIndyaXRlcmNcIlxuICAgIHwgXCJ0ZW1wXCJcbiAgICB8IFwibGlzdF9kaXJcIlxuICAgIHwgXCJta2RpclwiXG4gICAgfCBcIm1vdmVcIlxuICAgIHwgXCJldmFsXCJcbiAgICB8IFwiZ2V0Y29uZmlnXCJcbiAgICB8IFwiZ2V0Y29uZmlncGF0aFwiXG4gICAgfCBcImVudlwiXG4gICAgfCBcIndpbl9maXJlZm94X3Jlc3RhcnRcIlxuaW50ZXJmYWNlIE1lc3NhZ2VSZXNwIHtcbiAgICBjbWQ6IHN0cmluZ1xuICAgIHZlcnNpb246IG51bWJlciB8IG51bGxcbiAgICBjb250ZW50OiBzdHJpbmcgfCBudWxsXG4gICAgY29kZTogbnVtYmVyIHwgbnVsbFxuICAgIGVycm9yOiBzdHJpbmcgfCBudWxsXG59XG5cbi8qKlxuICogUG9zdHMgdXNpbmcgdGhlIG9uZS10aW1lIG1lc3NhZ2UgQVBJOyBuYXRpdmUgaXMga2lsbGVkIGFmdGVyIG1lc3NhZ2UgcmV0dXJuc1xuICovXG5hc3luYyBmdW5jdGlvbiBzZW5kTmF0aXZlTXNnKFxuICAgIGNtZDogTWVzc2FnZUNvbW1hbmQsXG4gICAgb3B0czogb2JqZWN0LFxuICAgIHF1aWV0ID0gZmFsc2UsXG4pOiBQcm9taXNlPE1lc3NhZ2VSZXNwPiB7XG4gICAgY29uc3Qgc2VuZCA9IE9iamVjdC5hc3NpZ24oeyBjbWQgfSwgb3B0cylcbiAgICBsZXQgcmVzcFxuICAgIGxvZ2dlci5pbmZvKGBTZW5kaW5nIG1lc3NhZ2U6ICR7SlNPTi5zdHJpbmdpZnkoc2VuZCl9YClcblxuICAgIHRyeSB7XG4gICAgICAgIHJlc3AgPSBhd2FpdCBicm93c2VyQmcucnVudGltZS5zZW5kTmF0aXZlTWVzc2FnZShOQVRJVkVfTkFNRSwgc2VuZClcbiAgICAgICAgbG9nZ2VyLmluZm8oYFJlY2VpdmVkIHJlc3BvbnNlOmAsIHJlc3ApXG4gICAgICAgIHJldHVybiByZXNwIGFzIE1lc3NhZ2VSZXNwXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoIXF1aWV0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJGYWlsZWQgdG8gc2VuZCBtZXNzYWdlIHRvIG5hdGl2ZSBtZXNzZW5nZXIuIElmIGl0IGlzIGNvcnJlY3RseSBpbnN0YWxsZWQgKHJ1biBgOm5hdGl2ZWApLCBwbGVhc2UgcmVwb3J0IHRoaXMgYnVnIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS90cmlkYWN0eWwvdHJpZGFjdHlsL2lzc3VlcyAuXCIsXG4gICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRyY3BhdGgoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBzZW5kTmF0aXZlTXNnKFwiZ2V0Y29uZmlncGF0aFwiLCB7fSlcblxuICAgIGlmIChyZXMuY29kZSAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiZ2V0cmNwYXRoIGVycm9yOiBcIiArIHJlcy5jb2RlKVxuXG4gICAgcmV0dXJuIHJlcy5jb250ZW50XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRyYygpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHNlbmROYXRpdmVNc2coXCJnZXRjb25maWdcIiwge30pXG5cbiAgICBpZiAocmVzLmNvbnRlbnQgJiYgIXJlcy5lcnJvcikge1xuICAgICAgICBsb2dnZXIuaW5mbyhgU3VjY2Vzc2Z1bGx5IHJldHJpZXZlZCBmcyBjb25maWc6XFxuJHtyZXMuY29udGVudH1gKVxuICAgICAgICByZXR1cm4gcmVzLmNvbnRlbnRcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIYXZlIHRvIG1ha2UgdGhpcyBhIHdhcm5pbmcgYXMgYXN5bmMgZXhjZXB0aW9ucyBhcHBhcmVudGx5IGRvbid0IGdldCBjYXVnaHRcbiAgICAgICAgbG9nZ2VyLmluZm8oYEVycm9yIGluIHJldHJpZXZpbmcgY29uZmlnOiAke3Jlcy5lcnJvcn1gKVxuICAgIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE5hdGl2ZU1lc3NlbmdlclZlcnNpb24oXG4gICAgcXVpZXQgPSBmYWxzZSxcbik6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgc2VuZE5hdGl2ZU1zZyhcInZlcnNpb25cIiwge30sIHF1aWV0KVxuICAgIGlmIChyZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocXVpZXQpIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgdGhyb3cgYEVycm9yIHJldHJpZXZpbmcgdmVyc2lvbjogJHtyZXMuZXJyb3J9YFxuICAgIH1cbiAgICBpZiAocmVzLnZlcnNpb24gJiYgIXJlcy5lcnJvcikge1xuICAgICAgICBsb2dnZXIuaW5mbyhgTmF0aXZlIHZlcnNpb246ICR7cmVzLnZlcnNpb259YClcbiAgICAgICAgcmV0dXJuIHJlcy52ZXJzaW9uXG4gICAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QmVzdEVkaXRvcigpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGxldCBndWlfY2FuZGlkYXRlcyA9IFtdXG4gICAgbGV0IHRlcm1fZW11bGF0b3JzID0gW11cbiAgICBsZXQgdHVpX2VkaXRvcnMgPSBbXVxuICAgIGxldCBsYXN0X3Jlc29ydHMgPSBbXVxuICAgIGlmICgoYXdhaXQgYnJvd3NlckJnLnJ1bnRpbWUuZ2V0UGxhdGZvcm1JbmZvKCkpLm9zID09PSBcIm1hY1wiKSB7XG4gICAgICAgIGd1aV9jYW5kaWRhdGVzID0gW1xuICAgICAgICAgICAgXCIvQXBwbGljYXRpb25zL01hY1ZpbS5hcHAvQ29udGVudHMvYmluL212aW0gLWZcIixcbiAgICAgICAgICAgIFwiL3Vzci9sb2NhbC9iaW4vdmltciAtLXdhaXQgLS1udmltICtvbmx5XCIsXG4gICAgICAgIF1cbiAgICAgICAgLy8gaWYgYW55b25lIGtub3dzIG9mIGFueSBcInNlbnNpYmxlXCIgdGVybWluYWxzIHRoYXQgbGV0IHlvdSBzZW5kIHRoZW0gY29tbWFuZHMgdG8gcnVuLFxuICAgICAgICAvLyBwbGVhc2UgbGV0IHVzIGtub3cgaW4gaXNzdWUgIzQ1MSFcbiAgICAgICAgdGVybV9lbXVsYXRvcnMgPSBbXG4gICAgICAgICAgICBcIi9BcHBsaWNhdGlvbnMvY29vbC1yZXRyby10ZXJtLmFwcC9Db250ZW50cy9NYWNPUy9jb29sLXJldHJvLXRlcm0gLWVcIixcbiAgICAgICAgXVxuICAgICAgICBsYXN0X3Jlc29ydHMgPSBbXCJvcGVuIC1uV3RcIl1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUZW1wdGVkIHRvIHB1dCB0aGlzIGJlaGluZCBhbm90aGVyIGNvbmZpZyBzZXR0aW5nOiBwcmVmZXJndWlcbiAgICAgICAgZ3VpX2NhbmRpZGF0ZXMgPSBbXCJndmltIC1mXCJdXG5cbiAgICAgICAgLy8gd2UgZ2VuZXJhbGx5IHRyeSB0byBnaXZlIHRoZSB0ZXJtaW5hbCB0aGUgY2xhc3MgXCJ0cmlkYWN0eWxfZWRpdG9yXCIgc28gdGhhdFxuICAgICAgICAvLyBpdCBjYW4gYmUgbWFkZSBmbG9hdGluZywgZS5nIGluIGkzOlxuICAgICAgICAvLyBmb3Jfd2luZG93IFtjbGFzcz1cInRyaWRhY3R5bF9lZGl0b3JcIl0gZmxvYXRpbmcgZW5hYmxlIGJvcmRlciBwaXhlbCAxXG4gICAgICAgIHRlcm1fZW11bGF0b3JzID0gW1xuICAgICAgICAgICAgXCJzdCAtYyB0cmlkYWN0eWxfZWRpdG9yXCIsXG4gICAgICAgICAgICBcInh0ZXJtIC1jbGFzcyB0cmlkYWN0eWxfZWRpdG9yIC1lXCIsXG4gICAgICAgICAgICBcInV4dGVybSAtY2xhc3MgdHJpZGFjdHlsX2VkaXRvciAtZVwiLFxuICAgICAgICAgICAgXCJ1cnh2dCAtZVwiLFxuICAgICAgICAgICAgXCJhbGFjcml0dHkgLWVcIiwgLy8gYWxhY3JpdHR5IGlzIG5pY2UgYnV0IHRha2VzIGFnZXMgdG8gc3RhcnQgYW5kIGRvZXNuJ3Qgc3VwcG9ydCBjbGFzc1xuICAgICAgICAgICAgLy8gVGVybWluYXRvciBhbmQgdGVybWl0ZSByZXF1aXJlICAtZSBjb21tYW5kcyB0byBiZSBpbiBxdW90ZXNcbiAgICAgICAgICAgICd0ZXJtaW5hdG9yIC11IC1lIFwiJWNcIicsXG4gICAgICAgICAgICAndGVybWl0ZSAtLWNsYXNzIHRyaWRhY3R5bF9lZGl0b3IgLWUgXCIlY1wiJyxcbiAgICAgICAgICAgIFwic2FrdXJhIC0tY2xhc3MgdHJpZGFjdHlsX2VkaXRvciAtZVwiLFxuICAgICAgICAgICAgXCJsaWx5dGVybSAtZVwiLFxuICAgICAgICAgICAgXCJtbHRlcm0gLWVcIixcbiAgICAgICAgICAgIFwicm94dGVybSAtZVwiLFxuICAgICAgICAgICAgXCJjb29sLXJldHJvLXRlcm0gLWVcIixcbiAgICAgICAgICAgIC8vIEdub21lLXRlcm1pbmFsIGRvZXNuJ3Qgd29yayBjb25zaXN0ZW50bHksIHNlZSBpc3N1ZSAjMTAzNVxuICAgICAgICAgICAgLy8gXCJkYnVzLWxhdW5jaCBnbm9tZS10ZXJtaW5hbCAtLVwiLFxuXG4gICAgICAgICAgICAvLyBJIHdhbnRlZCB0byBwdXQgaHlwZXIuanMgaGVyZSBhcyBhIGpva2UgYnV0IHlvdSBjYW4ndCBzdGFydCBpdCBydW5uaW5nIGEgY29tbWFuZCxcbiAgICAgICAgICAgIC8vIHdoaWNoIGlzIGEgZmFyIGJldHRlciBqb2tlOiBhIHRlcm1pbmFsIGVtdWxhdG9yIHRoYXQgeW91IGNhbid0IHNlbmQgY29tbWFuZHMgdG8uXG4gICAgICAgICAgICAvLyBZb3Ugd2luIHRoaXMgdGltZSwgd2ViIGFydGlzYW5zLlxuICAgICAgICBdXG4gICAgICAgIGxhc3RfcmVzb3J0cyA9IFtcbiAgICAgICAgICAgIFwiZW1hY3NcIixcbiAgICAgICAgICAgIFwiZ2VkaXRcIixcbiAgICAgICAgICAgIFwia2F0ZVwiLFxuICAgICAgICAgICAgXCJhYml3b3JkXCIsXG4gICAgICAgICAgICBcInN1YmxpbWVcIixcbiAgICAgICAgICAgIFwiYXRvbSAtd1wiLFxuICAgICAgICBdXG4gICAgfVxuXG4gICAgdHVpX2VkaXRvcnMgPSBbXCJ2aW0gJWZcIiwgXCJudmltICVmXCIsIFwibmFubyAlZlwiLCBcImVtYWNzIC1udyAlZlwiXVxuXG4gICAgLy8gQ29uc2lkZXIgR1VJIGVkaXRvcnNcbiAgICBsZXQgY21kID0gYXdhaXQgZmlyc3RpbnBhdGgoZ3VpX2NhbmRpZGF0ZXMpXG5cbiAgICBpZiAoY21kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gVHJ5IHRvIGZpbmQgYSB0ZXJtaW5hbCBlbXVsYXRvclxuICAgICAgICBjbWQgPSBhd2FpdCBmaXJzdGlucGF0aCh0ZXJtX2VtdWxhdG9ycylcbiAgICAgICAgaWYgKGNtZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBhbmQgYSB0ZXh0IGVkaXRvclxuICAgICAgICAgICAgY29uc3QgdHVpY21kID0gYXdhaXQgZmlyc3RpbnBhdGgodHVpX2VkaXRvcnMpXG4gICAgICAgICAgICBpZiAoY21kLmluY2x1ZGVzKFwiJWNcIikpIHtcbiAgICAgICAgICAgICAgICBjbWQgPSBjbWQucmVwbGFjZShcIiVjXCIsIHR1aWNtZClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY21kID0gY21kICsgXCIgXCIgKyB0dWljbWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG9yIGZhbGwgYmFjayB0byBzb21lIHJlYWxseSBzdHVwaWQgc3R1ZmZcbiAgICAgICAgICAgIGNtZCA9IGF3YWl0IGZpcnN0aW5wYXRoKGxhc3RfcmVzb3J0cylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbWRcbn1cblxuLyoqXG4gKiBVc2VkIGludGVybmFsbHkgdG8gZ2F0ZSBvZmYgZnVuY3Rpb25zIHRoYXQgdXNlIHRoZSBuYXRpdmUgbWVzc2VuZ2VyLiBHaXZlcyBhXG4gKiBoZWxwZnVsIGVycm9yIG1lc3NhZ2UgaW4gdGhlIGNvbW1hbmQgbGluZSBpZiB0aGUgbmF0aXZlIG1lc3NlbmdlciBpcyBub3RcbiAqIGluc3RhbGxlZCwgb3IgaXMgdGhlIHdyb25nIHZlcnNpb24uXG4gKlxuICogQGFyZyB2ZXJzaW9uOiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG1pbmltYWwgcmVxdWlyZWQgdmVyc2lvbi5cbiAqIEBhcmcgaW50ZXJhY3RpdmU6IFRydWUgaWYgYSBtZXNzYWdlIHNob3VsZCBiZSBkaXNwbGF5ZWQgb24gdmVyc2lvbiBtaXNtYXRjaC5cbiAqIEByZXR1cm4gZmFsc2UgaWYgdGhlIHJlcXVpcmVkIHZlcnNpb24gaXMgaGlnaGVyIHRoYW4gdGhlIGN1cnJlbnRseSBhdmFpbGFibGVcbiAqIG5hdGl2ZSBtZXNzZW5nZXIgdmVyc2lvbi5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG5hdGl2ZWdhdGUoXG4gICAgdmVyc2lvbiA9IFwiMFwiLFxuICAgIGludGVyYWN0aXZlID0gdHJ1ZSxcbiAgICBkZXNpcmVkT1MgPSBbXCJtYWNcIiwgXCJ3aW5cIiwgXCJsaW51eFwiLCBcIm9wZW5ic2RcIl0sXG4gICAgLy8gZGVzaXJlZE9TID0gW1wibWFjXCIsIFwid2luXCIsIFwiYW5kcm9pZFwiLCBcImNyb3NcIiwgXCJsaW51eFwiLCBcIm9wZW5ic2RcIl1cbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghZGVzaXJlZE9TLmluY2x1ZGVzKChhd2FpdCBicm93c2VyQmcucnVudGltZS5nZXRQbGF0Zm9ybUluZm8oKSkub3MpKSB7XG4gICAgICAgIGlmIChpbnRlcmFjdGl2ZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiIyBUcmlkYWN0eWwncyBuYXRpdmUgbWVzc2VuZ2VyIGRvZXNuJ3Qgc3VwcG9ydCB5b3VyIG9wZXJhdGluZyBzeXN0ZW0sIHlldC5cIixcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWN0dWFsVmVyc2lvbiA9IGF3YWl0IGdldE5hdGl2ZU1lc3NlbmdlclZlcnNpb24oKVxuICAgICAgICBpZiAoYWN0dWFsVmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoc2VtdmVyQ29tcGFyZSh2ZXJzaW9uLCBhY3R1YWxWZXJzaW9uKSA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJhY3RpdmUpXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIyBQbGVhc2UgdXBkYXRlIHRvIG5hdGl2ZSBtZXNzZW5nZXIgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb24gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLCBmb3IgZXhhbXBsZSBieSBydW5uaW5nIGA6dXBkYXRlbmF0aXZlYC5cIixcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGFkZCB1cGRhdGUgcHJvY2VkdXJlIGFuZCBkb2N1bWVudCBoZXJlLlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSBlbHNlIGlmIChpbnRlcmFjdGl2ZSlcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiMgTmF0aXZlIG1lc3NlbmdlciBub3QgZm91bmQuIFBsZWFzZSBydW4gYDppbnN0YWxsbmF0aXZlYCBhbmQgZm9sbG93IHRoZSBpbnN0cnVjdGlvbnMuXCIsXG4gICAgICAgICAgICApXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGludGVyYWN0aXZlKVxuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiIyBOYXRpdmUgbWVzc2VuZ2VyIG5vdCBmb3VuZC4gUGxlYXNlIHJ1biBgOmluc3RhbGxuYXRpdmVgIGFuZCBmb2xsb3cgdGhlIGluc3RydWN0aW9ucy5cIixcbiAgICAgICAgICAgIClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5wYXRoKGNtZCkge1xuICAgIGNvbnN0IHBhdGhjbWQgPVxuICAgICAgICAoYXdhaXQgYnJvd3NlckJnLnJ1bnRpbWUuZ2V0UGxhdGZvcm1JbmZvKCkpLm9zID09PSBcIndpblwiXG4gICAgICAgICAgICA/IFwid2hlcmUgXCJcbiAgICAgICAgICAgIDogXCJ3aGljaCBcIlxuICAgIHJldHVybiAoYXdhaXQgcnVuKHBhdGhjbWQgKyBjbWQuc3BsaXQoXCIgXCIpWzBdKSkuY29kZSA9PT0gMFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmlyc3RpbnBhdGgoY21kYXJyYXkpIHtcbiAgICBsZXQgaW5kID0gMFxuICAgIGxldCBjbWQgPSBjbWRhcnJheVtpbmRdXG4gICAgLy8gVHJ5IHRvIGZpbmQgYSB0ZXh0IGVkaXRvclxuICAgIHdoaWxlICghKGF3YWl0IGlucGF0aChjbWQuc3BsaXQoXCIgXCIpWzBdKSkpIHtcbiAgICAgICAgaW5kKytcbiAgICAgICAgY21kID0gY21kYXJyYXlbaW5kXVxuICAgICAgICBpZiAoY21kID09PSB1bmRlZmluZWQpIGJyZWFrXG4gICAgfVxuICAgIHJldHVybiBjbWRcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVkaXRvcihmaWxlOiBzdHJpbmcsIGxpbmU6IG51bWJlciwgY29sOiBudW1iZXIsIGNvbnRlbnQ/OiBzdHJpbmcpIHtcbiAgICBpZiAoY29udGVudCAhPT0gdW5kZWZpbmVkKSBhd2FpdCB3cml0ZShmaWxlLCBjb250ZW50KVxuICAgIGNvbnN0IGVkaXRvcmNtZCA9XG4gICAgICAgIChjb25maWcuZ2V0KFwiZWRpdG9yY21kXCIpID09PSBcImF1dG9cIlxuICAgICAgICAgICAgPyBhd2FpdCBnZXRCZXN0RWRpdG9yKClcbiAgICAgICAgICAgIDogY29uZmlnLmdldChcImVkaXRvcmNtZFwiKSlcbiAgICAgICAgLnJlcGxhY2UoLyVsLywgbGluZSlcbiAgICAgICAgLnJlcGxhY2UoLyVjLywgY29sKVxuICAgIGxldCBleGVjXG4gICAgaWYgKGVkaXRvcmNtZC5pbmRleE9mKFwiJWZcIikgIT09IC0xKSB7XG4gICAgICAgIGV4ZWMgPSBhd2FpdCBydW4oZWRpdG9yY21kLnJlcGxhY2UoLyVmLywgZmlsZSkpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZXhlYyA9IGF3YWl0IHJ1bihlZGl0b3JjbWQgKyBcIiBcIiArIGZpbGUpXG4gICAgfVxuICAgIGlmIChleGVjLmNvZGUgIT0gMClcbiAgICAgICAgcmV0dXJuIGV4ZWNcbiAgICByZXR1cm4gcmVhZChmaWxlKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZChmaWxlOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gc2VuZE5hdGl2ZU1zZyhcInJlYWRcIiwgeyBmaWxlIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICB0aHJvdyBgRmFpbGVkIHRvIHJlYWQgJHtmaWxlfS4gJHtlfWBcbiAgICB9KVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd3JpdGUoZmlsZTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gc2VuZE5hdGl2ZU1zZyhcIndyaXRlXCIsIHsgZmlsZSwgY29udGVudCB9KS5jYXRjaChlID0+IHtcbiAgICAgICAgdGhyb3cgYEZhaWxlZCB0byB3cml0ZSAnJHtjb250ZW50fScgdG8gJyR7ZmlsZX0nLiAke2V9YFxuICAgIH0pXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3cml0ZXJjKGZpbGU6IHN0cmluZywgZm9yY2U6IGJvb2xlYW4sIGNvbnRlbnQ6IHN0cmluZykge1xuICAgIHJldHVybiBzZW5kTmF0aXZlTXNnKFwid3JpdGVyY1wiLCB7IGZpbGUsIGZvcmNlLCBjb250ZW50IH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICB0aHJvdyBgRmFpbGVkIHRvIHdyaXRlICcke2NvbnRlbnR9JyB0byAnJHtmaWxlfScuICR7ZX1gXG4gICAgfSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1rZGlyKGRpcjogc3RyaW5nLCBleGlzdF9vazogYm9vbGVhbikge1xuICAgIHJldHVybiBzZW5kTmF0aXZlTXNnKFwibWtkaXJcIiwgeyBkaXIsIGV4aXN0X29rIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICB0aHJvdyBgRmFpbGVkIHRvIGNyZWF0ZSBkaXJlY3RvcnkgJyR7ZGlyfScuICR7ZX1gXG4gICAgfSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRlbXAoY29udGVudDogc3RyaW5nLCBwcmVmaXg6IHN0cmluZykge1xuICAgIHJldHVybiBzZW5kTmF0aXZlTXNnKFwidGVtcFwiLCB7IGNvbnRlbnQsIHByZWZpeCB9KS5jYXRjaChlID0+IHtcbiAgICAgICAgdGhyb3cgYEZhaWxlZCB0byB3cml0ZSAnJHtjb250ZW50fScgdG8gdGVtcCBmaWxlICcke3ByZWZpeH0nLiAke2V9YFxuICAgIH0pXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtb3ZlKGZyb206IHN0cmluZywgdG86IHN0cmluZykge1xuICAgIHJldHVybiBzZW5kTmF0aXZlTXNnKFwibW92ZVwiLCB7IGZyb20sIHRvIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICB0aHJvdyBgRmFpbGVkIHRvIG1vdmUgJyR7ZnJvbX0nIHRvICcke3RvfScuICR7ZX0uYFxuICAgIH0pXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsaXN0RGlyKGRpcjogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHNlbmROYXRpdmVNc2coXCJsaXN0X2RpclwiLCB7IHBhdGg6IGRpciB9KS5jYXRjaChlID0+IHtcbiAgICAgICAgdGhyb3cgYEZhaWxlZCB0byByZWFkIGRpcmVjdG9yeSAnJHtkaXJ9Jy4gJHtlfWBcbiAgICB9KVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2luRmlyZWZveFJlc3RhcnQoXG4gICAgcHJvZmlsZWRpcjogc3RyaW5nLFxuICAgIGJyb3dzZXJjbWQ6IHN0cmluZyxcbikge1xuICAgIGNvbnN0IHJlcXVpcmVkX3ZlcnNpb24gPSBcIjAuMS42XCJcblxuICAgIGlmICghKGF3YWl0IG5hdGl2ZWdhdGUocmVxdWlyZWRfdmVyc2lvbiwgZmFsc2UpKSkge1xuICAgICAgICB0aHJvdyBgJ3Jlc3RhcnQnIG9uIFdpbmRvd3MgbmVlZHMgbmF0aXZlIG1lc3NlbmdlciB2ZXJzaW9uID49ICR7cmVxdWlyZWRfdmVyc2lvbn0uYFxuICAgIH1cblxuICAgIHJldHVybiBzZW5kTmF0aXZlTXNnKFwid2luX2ZpcmVmb3hfcmVzdGFydFwiLCB7IHByb2ZpbGVkaXIsIGJyb3dzZXJjbWQgfSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJ1bihjb21tYW5kOiBzdHJpbmcsIGNvbnRlbnQgPSBcIlwiKSB7XG4gICAgY29uc3QgbXNnID0gYXdhaXQgc2VuZE5hdGl2ZU1zZyhcInJ1blwiLCB7IGNvbW1hbmQsIGNvbnRlbnQgfSlcbiAgICBsb2dnZXIuaW5mbyhtc2cpXG4gICAgcmV0dXJuIG1zZ1xufVxuXG4vKiogRXZhbHVhdGVzIGEgc3RyaW5nIGluIHRoZSBuYXRpdmUgbWVzc2VuZ2VyLiBUaGlzIGhhcyB0byBiZSBweXRob24gY29kZS4gSWZcbiAqICB5b3Ugd2FudCB0byBydW4gc2hlbGwgc3RyaW5ncywgdXNlIHJ1bigpIGluc3RlYWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBweWV2YWwoY29tbWFuZDogc3RyaW5nKTogUHJvbWlzZTxNZXNzYWdlUmVzcD4ge1xuICAgIHJldHVybiBzZW5kTmF0aXZlTXNnKFwiZXZhbFwiLCB7IGNvbW1hbmQgfSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldGVudih2YXJpYWJsZTogc3RyaW5nKSB7XG4gICAgY29uc3QgcmVxdWlyZWRfdmVyc2lvbiA9IFwiMC4xLjJcIlxuXG4gICAgaWYgKCEoYXdhaXQgbmF0aXZlZ2F0ZShyZXF1aXJlZF92ZXJzaW9uLCBmYWxzZSkpKSB7XG4gICAgICAgIHRocm93IGAnZ2V0ZW52JyBuZWVkcyBuYXRpdmUgbWVzc2VuZ2VyIHZlcnNpb24gPj0gJHtyZXF1aXJlZF92ZXJzaW9ufS5gXG4gICAgfVxuXG4gICAgcmV0dXJuIChhd2FpdCBzZW5kTmF0aXZlTXNnKFwiZW52XCIsIHsgdmFyOiB2YXJpYWJsZSB9KSkuY29udGVudFxufVxuXG4vKiogQ2FsbHMgYW4gZXh0ZXJuYWwgcHJvZ3JhbSwgdG8gZWl0aGVyIHNldCBvciBnZXQgdGhlIGNvbnRlbnQgb2YgdGhlIFggc2VsZWN0aW9uLlxuICogIFdoZW4gc2V0dGluZyB0aGUgc2VsZWN0aW9uIG9yIGlmIGdldHRpbmcgaXQgZmFpbGVkLCB3aWxsIHJldHVybiBhbiBlbXB0eSBzdHJpbmcuXG4gKiovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2xpcGJvYXJkKFxuICAgIGFjdGlvbjogXCJzZXRcIiB8IFwiZ2V0XCIsXG4gICAgc3RyOiBzdHJpbmcsXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGxldCBjbGlwY21kID0gYXdhaXQgY29uZmlnLmdldChcImV4dGVybmFsY2xpcGJvYXJkY21kXCIpXG4gICAgaWYgKGNsaXBjbWQgPT09IFwiYXV0b1wiKSBjbGlwY21kID0gYXdhaXQgZmlyc3RpbnBhdGgoW1wieHNlbFwiLCBcInhjbGlwXCJdKVxuXG4gICAgaWYgKGNsaXBjbWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGFuIGV4dGVybmFsIGNsaXBib2FyZCBleGVjdXRhYmxlXCIpXG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbiA9PT0gXCJnZXRcIikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBydW4oY2xpcGNtZCArIFwiIC1vXCIpXG4gICAgICAgIGlmIChyZXN1bHQuY29kZSAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBFeHRlcm5hbCBjb21tYW5kIGZhaWxlZCB3aXRoIGNvZGUgJHtyZXN1bHQuY29kZX06ICR7Y2xpcGNtZH1gLFxuICAgICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuY29udGVudFxuICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSBcInNldFwiKSB7XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkX3ZlcnNpb24gPSBcIjAuMS43XCJcbiAgICAgICAgaWYgKGF3YWl0IG5hdGl2ZWdhdGUocmVxdWlyZWRfdmVyc2lvbiwgZmFsc2UpKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBydW4oYCR7Y2xpcGNtZH0gLWlgLCBzdHIpXG4gICAgICAgICAgICBpZiAocmVzdWx0LmNvZGUgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgRXh0ZXJuYWwgY29tbWFuZCBmYWlsZWQgd2l0aCBjb2RlICR7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuY29kZVxuICAgICAgICAgICAgICAgICAgICB9OiAke2NsaXBjbWR9YCxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gXCJcIlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIGhhY2t5IG9sZCBmYXNoaW9uZWQgd2F5XG5cbiAgICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIHByZXRlbmQgdGhhdCB3ZSBkb24ndCBrbm93IGFib3V0IHN0ZGluLCBhbmQgd2UgbmVlZCB0byBpbnNlcnQgc3RyLCB3aGljaCB3ZSBjYW4ndCB0cnVzdCwgaW50byB0aGUgY2xpcGNtZFxuICAgICAgICAgICAgLy8gSW4gb3JkZXIgdG8gZG8gdGhpcyBzYWZlbHkgd2UnbGwgdXNlIGhlcmUgZG9jdW1lbnRzOlxuICAgICAgICAgICAgLy8gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzAwOTY5NTM5OS91dGlsaXRpZXMveGN1X2NoYXAwMi5odG1sI3RhZ18wMl8wN18wNFxuXG4gICAgICAgICAgICAvLyBGaW5kIGEgZGVsaW1pdGVyIHRoYXQgaXNuJ3QgaW4gc3RyXG4gICAgICAgICAgICBsZXQgaGVyZWRvYyA9IFwiVFJJREFDVFlMXCJcbiAgICAgICAgICAgIHdoaWxlIChzdHIuc2VhcmNoKGhlcmVkb2MpICE9PSAtMSlcbiAgICAgICAgICAgICAgICBoZXJlZG9jICs9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwKVxuXG4gICAgICAgICAgICAvLyBVc2UgZGVsaW1pdGVyIHRvIGluc2VydCBzdHIgaW50byBjbGlwY21kJ3Mgc3RkaW5cbiAgICAgICAgICAgIC8vIFdlIHVzZSBzZWQgdG8gcmVtb3ZlIHRoZSBuZXdsaW5lIGFkZGVkIGJ5IHRoZSBoZXJlIGRvY3VtZW50XG4gICAgICAgICAgICBjbGlwY21kID0gYHNlZCAteiAncy8uJC8vJyA8PCcke2hlcmVkb2N9JyB8ICR7Y2xpcGNtZH0gLWkgXFxuJHtzdHJ9XFxuJHtoZXJlZG9jfWBcbiAgICAgICAgICAgIGF3YWl0IHJ1bihjbGlwY21kKVxuICAgICAgICAgICAgcmV0dXJuIFwiXCJcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGFjdGlvbiFcIilcbn1cblxuLyoqIFRoaXMgcmV0dXJucyB0aGUgY29tbWFuZGxpbmUgdGhhdCB3YXMgdXNlZCB0byBzdGFydCBmaXJlZm94LlxuIFlvdSdsbCBnZXQgYm90aCBmaXJlZm94IGJpbmFyeSAobm90IG5lY2Vzc2FyaWx5IGFuIGFic29sdXRlIHBhdGgpIGFuZCBmbGFncyAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZmX2NtZGxpbmUoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIC8vIFVzaW5nICcgYW5kICsgcmF0aGVyIHRoYXQgYCBiZWNhdXNlIHdlIGRvbid0IHdhbnQgbmV3bGluZXNcbiAgICBpZiAoKGF3YWl0IGJyb3dzZXJCZy5ydW50aW1lLmdldFBsYXRmb3JtSW5mbygpKS5vcyA9PT0gXCJ3aW5cIikge1xuICAgICAgICB0aHJvdyBgRXJyb3I6IFwiZmZfY21kbGluZSgpIGlzIGN1cnJlbnRseSBicm9rZW4gb24gV2luZG93cyBhbmQgc2hvdWxkIGJlIGF2b2lkZWQuXCJgXG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgcHlldmFsKFxuICAgICAgICAgICAgJ2hhbmRsZU1lc3NhZ2Uoe1wiY21kXCI6IFwicnVuXCIsICcgK1xuICAgICAgICAgICAgICAgICdcImNvbW1hbmRcIjogXCJwcyAtcCBcIiArIHN0cihvcy5nZXRwcGlkKCkpICsgXCIgLW9hcmdzPVwifSlbXCJjb250ZW50XCJdJyxcbiAgICAgICAgKVxuICAgICAgICByZXR1cm4gb3V0cHV0LmNvbnRlbnQudHJpbSgpLnNwbGl0KFwiIFwiKVxuICAgIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlUHJvZmlsZXNJbmkoY29udGVudDogc3RyaW5nLCBiYXNlUGF0aDogc3RyaW5nKSB7XG4gICAgY29uc3QgbGluZXMgPSBjb250ZW50LnNwbGl0KFwiXFxuXCIpXG4gICAgbGV0IGN1cnJlbnQgPSBcIkdlbmVyYWxcIlxuICAgIGNvbnN0IHJlc3VsdCA9IHt9XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IGxpbmUubWF0Y2goL15cXFsoW15cXF1dKylcXF0kLylcbiAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gbWF0Y2hbMV1cbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW50XSA9IHt9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaCA9IGxpbmUubWF0Y2goL14oW149XSspPShbXj1dKykkLylcbiAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtjdXJyZW50XVttYXRjaFsxXV0gPSBtYXRjaFsyXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgcHJvZmlsZU5hbWUgb2YgT2JqZWN0LmtleXMocmVzdWx0KSkge1xuICAgICAgICBjb25zdCBwcm9maWxlID0gcmVzdWx0W3Byb2ZpbGVOYW1lXVxuICAgICAgICAvLyBOZXcgcHJvZmlsZXMuaW5pIGhhdmUgYSB1c2VsZXNzIHNlY3Rpb24gYXQgdGhlIHRvcFxuICAgICAgICBpZiAocHJvZmlsZS5QYXRoID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVsZXRlIHJlc3VsdFtwcm9maWxlTmFtZV1cbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgLy8gT24gd2luZG93cywgcHJvZmlsZXMuaW5pIHBhdGhzIHdpbGwgYmUgZXhwcmVzc2VkIHdpdGggYC9gLCBidXQgd2UncmVcbiAgICAgICAgLy8gb24gd2luZG93cywgc28gd2UgbmVlZCBgXFxgXG4gICAgICAgIGlmICgoYXdhaXQgYnJvd3NlckJnLnJ1bnRpbWUuZ2V0UGxhdGZvcm1JbmZvKCkpLm9zID09PSBcIndpblwiKSB7XG4gICAgICAgICAgICBwcm9maWxlLlBhdGggPSBwcm9maWxlLlBhdGgucmVwbGFjZShcIi9cIiwgXCJcXFxcXCIpXG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJvZmlsZS5Jc1JlbGF0aXZlIGNhbiBiZSAwLCAxIG9yIHVuZGVmaW5lZFxuICAgICAgICBpZiAocHJvZmlsZS5Jc1JlbGF0aXZlID09PSBcIjFcIikge1xuICAgICAgICAgICAgcHJvZmlsZS5yZWxhdGl2ZVBhdGggPSBwcm9maWxlLlBhdGhcbiAgICAgICAgICAgIHByb2ZpbGUuYWJzb2x1dGVQYXRoID0gYmFzZVBhdGggKyBwcm9maWxlLnJlbGF0aXZlUGF0aFxuICAgICAgICB9IGVsc2UgaWYgKHByb2ZpbGUuSXNSZWxhdGl2ZSA9PT0gXCIwXCIpIHtcbiAgICAgICAgICAgIGlmIChwcm9maWxlLlBhdGguc3Vic3RyaW5nKDAsIGJhc2VQYXRoLmxlbmd0aCkgIT09IGJhc2VQYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgRXJyb3IgcGFyc2luZyBwcm9maWxlcyBpbmk6IGJhc2VQYXRoIFwiJHtiYXNlUGF0aH1cIiBkb2Vzbid0IG1hdGNoIHByb2ZpbGUgcGF0aCAke1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZmlsZS5QYXRoXG4gICAgICAgICAgICAgICAgICAgIH1gLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2ZpbGUucmVsYXRpdmVQYXRoID0gcHJvZmlsZS5QYXRoLnN1YnN0cmluZyhiYXNlUGF0aC5sZW5ndGgpXG4gICAgICAgICAgICBwcm9maWxlLmFic29sdXRlUGF0aCA9IHByb2ZpbGUuUGF0aFxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEZpcmVmb3hEaXIoKSB7XG4gICAgc3dpdGNoICgoYXdhaXQgYnJvd3NlckJnLnJ1bnRpbWUuZ2V0UGxhdGZvcm1JbmZvKCkpLm9zKSB7XG4gICAgICAgIGNhc2UgXCJ3aW5cIjpcbiAgICAgICAgICAgIHJldHVybiBnZXRlbnYoXCJBUFBEQVRBXCIpLnRoZW4ocGF0aCA9PiBwYXRoICsgXCJcXFxcTW96aWxsYVxcXFxGaXJlZm94XFxcXFwiKVxuICAgICAgICBjYXNlIFwibWFjXCI6XG4gICAgICAgICAgICByZXR1cm4gZ2V0ZW52KFwiSE9NRVwiKS50aGVuKFxuICAgICAgICAgICAgICAgIHBhdGggPT4gcGF0aCArIFwiL0xpYnJhcnkvQXBwbGljYXRpb24gU3VwcG9ydC9GaXJlZm94L1wiLFxuICAgICAgICAgICAgKVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGdldGVudihcIkhPTUVcIikudGhlbihwYXRoID0+IHBhdGggKyBcIi8ubW96aWxsYS9maXJlZm94L1wiKVxuICAgIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFByb2ZpbGVVbmNhY2hlZCgpIHtcbiAgICBjb25zdCBmZkRpciA9IGF3YWl0IGdldEZpcmVmb3hEaXIoKVxuICAgIGNvbnN0IGluaVBhdGggPSBmZkRpciArIFwicHJvZmlsZXMuaW5pXCJcbiAgICBsZXQgaW5pT2JqZWN0ID0ge31cbiAgICBsZXQgaW5pU3VjY2VlZGVkID0gZmFsc2VcbiAgICBjb25zdCBpbmlDb250ZW50ID0gYXdhaXQgcmVhZChpbmlQYXRoKVxuICAgIGlmIChpbmlDb250ZW50LmNvZGUgPT09IDAgJiYgaW5pQ29udGVudC5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluaU9iamVjdCA9IGF3YWl0IHBhcnNlUHJvZmlsZXNJbmkoaW5pQ29udGVudC5jb250ZW50LCBmZkRpcilcbiAgICAgICAgICAgIGluaVN1Y2NlZWRlZCA9IHRydWVcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gICAgY29uc3QgY3VyUHJvZmlsZURpciA9IGNvbmZpZy5nZXQoXCJwcm9maWxlZGlyXCIpXG5cbiAgICAvLyBGaXJzdCwgdHJ5IHRvIHNlZSBpZiB0aGUgJ3Byb2ZpbGVkaXInIHNldHRpbmcgbWF0Y2hlcyBhIHByb2ZpbGUgaW4gcHJvZmlsZS5pbmlcbiAgICBpZiAoY3VyUHJvZmlsZURpciAhPT0gXCJhdXRvXCIpIHtcbiAgICAgICAgaWYgKGluaVN1Y2NlZWRlZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9maWxlTmFtZSBvZiBPYmplY3Qua2V5cyhpbmlPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvZmlsZSA9IGluaU9iamVjdFtwcm9maWxlTmFtZV1cbiAgICAgICAgICAgICAgICBpZiAocHJvZmlsZS5hYnNvbHV0ZVBhdGggPT09IGN1clByb2ZpbGVEaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2ZpbGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIE5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIElzUmVsYXRpdmU6IFwiMFwiLFxuICAgICAgICAgICAgUGF0aDogY3VyUHJvZmlsZURpcixcbiAgICAgICAgICAgIHJlbGF0aXZlUGF0aDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYWJzb2x1dGVQYXRoOiBjdXJQcm9maWxlRGlyLFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlbiwgdHJ5IHRvIGZpbmQgYSBwcm9maWxlIHBhdGggaW4gdGhlIGFyZ3VtZW50cyBnaXZlbiB0byBGaXJlZm94XG4gICAgY29uc3QgY21kbGluZSA9IGF3YWl0IGZmX2NtZGxpbmUoKS5jYXRjaChlID0+IFwiXCIpXG4gICAgbGV0IHByb2ZpbGUgPSBjbWRsaW5lLmluZGV4T2YoXCItLXByb2ZpbGVcIilcbiAgICBpZiAocHJvZmlsZSA9PT0gLTEpXG4gICAgICAgIHByb2ZpbGUgPSBjbWRsaW5lLmluZGV4T2YoXCItcHJvZmlsZVwiKVxuICAgIGlmIChwcm9maWxlID49IDAgJiYgcHJvZmlsZSA8IGNtZGxpbmUubGVuZ3RoIC0gMSkge1xuICAgICAgICBjb25zdCBwcm9maWxlUGF0aCA9IGNtZGxpbmVbcHJvZmlsZSArIDFdXG4gICAgICAgIGlmIChpbmlTdWNjZWVkZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvZmlsZU5hbWUgb2YgT2JqZWN0LmtleXMoaW5pT2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb2ZpbGUgPSBpbmlPYmplY3RbcHJvZmlsZU5hbWVdXG4gICAgICAgICAgICAgICAgaWYgKHByb2ZpbGUuYWJzb2x1dGVQYXRoID09PSBwcm9maWxlUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvZmlsZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXZSdyZSBydW5uaW5nIGluIGEgcHJvZmlsZSB0aGF0IGlzbid0IHN0b3JlZCBpbiBwcm9maWxlcy5pbmlcbiAgICAgICAgLy8gTGV0J3MgZmlsbCBpbiB0aGUgZGVmYXVsdCBpbmZvIHByb2ZpbGUuaW5pIHByb2ZpbGVzIGhhdmUgYW55d2F5XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBOYW1lOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBJc1JlbGF0aXZlOiBcIjBcIixcbiAgICAgICAgICAgIFBhdGg6IHByb2ZpbGVQYXRoLFxuICAgICAgICAgICAgcmVsYXRpdmVQYXRoOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhYnNvbHV0ZVBhdGg6IHByb2ZpbGVQYXRoLFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluaVN1Y2NlZWRlZCkge1xuICAgICAgICAvLyBUcnkgdG8gZmluZCBhIHByb2ZpbGUgbmFtZSBpbiBmaXJlZm94J3MgYXJndW1lbnRzXG4gICAgICAgIGxldCBwID0gY21kbGluZS5pbmRleE9mKFwiLXBcIilcbiAgICAgICAgaWYgKHAgPT09IC0xKSBwID0gY21kbGluZS5pbmRleE9mKFwiLVBcIilcbiAgICAgICAgaWYgKHAgPj0gMCAmJiBwIDwgY21kbGluZS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBjb25zdCBwTmFtZSA9IGNtZGxpbmVbcCArIDFdXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb2ZpbGVOYW1lIG9mIE9iamVjdC5rZXlzKGluaU9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9maWxlID0gaW5pT2JqZWN0W3Byb2ZpbGVOYW1lXVxuICAgICAgICAgICAgICAgIGlmIChwcm9maWxlLk5hbWUgPT09IHBOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9maWxlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBuYXRpdmUudHM6Z2V0UHJvZmlsZSgpIDogJyR7XG4gICAgICAgICAgICAgICAgICAgIGNtZGxpbmVbcF1cbiAgICAgICAgICAgICAgICB9JyBmb3VuZCBpbiBjb21tYW5kIGxpbmUgYXJndW1lbnRzIGJ1dCBubyBtYXRjaGluZyBwcm9maWxlIG5hbWUgZm91bmQgaW4gXCIke2luaVBhdGh9XCJgLFxuICAgICAgICAgICAgKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RpbGwgbm90aGluZywgdHJ5IHRvIGZpbmQgYSBwcm9maWxlIGluIHVzZVxuICAgIGxldCBoYWNreV9wcm9maWxlX2ZpbmRlciA9IGBmaW5kIFwiJHtmZkRpcn1cIiAtbWF4ZGVwdGggMiAtbmFtZSBsb2NrYFxuICAgIGlmICgoYXdhaXQgYnJvd3NlckJnLnJ1bnRpbWUuZ2V0UGxhdGZvcm1JbmZvKCkpLm9zID09PSBcIm1hY1wiKVxuICAgICAgICBoYWNreV9wcm9maWxlX2ZpbmRlciA9IGBmaW5kIFwiJHtmZkRpcn1cIiAtbWF4ZGVwdGggMiAtbmFtZSAucGFyZW50bG9ja2BcbiAgICBjb25zdCBwcm9maWxlY21kID0gYXdhaXQgcnVuKGhhY2t5X3Byb2ZpbGVfZmluZGVyKVxuICAgIGlmIChwcm9maWxlY21kLmNvZGUgPT09IDAgJiYgcHJvZmlsZWNtZC5jb250ZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgbmV3bGluZVxuICAgICAgICBwcm9maWxlY21kLmNvbnRlbnQgPSBwcm9maWxlY21kLmNvbnRlbnQudHJpbSgpXG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgb25seSBvbmUgcHJvZmlsZSBpbiB1c2UsIHVzZSB0aGF0IHRvIGZpbmQgdGhlIHJpZ2h0IHByb2ZpbGVcbiAgICAgICAgaWYgKHByb2ZpbGVjbWQuY29udGVudC5zcGxpdChcIlxcblwiKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBwcm9maWxlY21kLmNvbnRlbnRcbiAgICAgICAgICAgICAgICAuc3BsaXQoXCIvXCIpXG4gICAgICAgICAgICAgICAgLnNsaWNlKDAsIC0xKVxuICAgICAgICAgICAgICAgIC5qb2luKFwiL1wiKVxuICAgICAgICAgICAgaWYgKGluaVN1Y2NlZWRlZCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvZmlsZU5hbWUgb2YgT2JqZWN0LmtleXMoaW5pT2JqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9maWxlID0gaW5pT2JqZWN0W3Byb2ZpbGVOYW1lXVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvZmlsZS5hYnNvbHV0ZVBhdGggPT09IHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9maWxlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIE5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBJc1JlbGF0aXZlOiBcIjBcIixcbiAgICAgICAgICAgICAgICBQYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHJlbGF0aXZlUGF0aDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGFic29sdXRlUGF0aDogcGF0aCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbmlTdWNjZWVkZWQpIHtcbiAgICAgICAgLy8gTXVsdGlwbGUgcHJvZmlsZXMgdXNlZCBidXQgbm8gLXAgb3IgLS1wcm9maWxlLCB0aGlzIG1lYW5zIHRoYXQgd2UncmUgdXNpbmcgdGhlIGRlZmF1bHQgcHJvZmlsZVxuICAgICAgICBmb3IgKGNvbnN0IHByb2ZpbGVOYW1lIG9mIE9iamVjdC5rZXlzKGluaU9iamVjdCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2ZpbGUgPSBpbmlPYmplY3RbcHJvZmlsZU5hbWVdXG4gICAgICAgICAgICBpZiAocHJvZmlsZS5EZWZhdWx0ID09PSAxIHx8IHByb2ZpbGUuRGVmYXVsdCA9PT0gXCIxXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvZmlsZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ291bGRuJ3QgZGVkdWNlIHdoaWNoIHByb2ZpbGUgeW91IHdhbnQuIFNlZSAnOmhlbHAgcHJvZmlsZWRpcidgLFxuICAgIClcbn1cblxuLy8gRGlzayBvcGVyYXRpb25zIGFyZSBleHRyZW1lbHkgc2xvdyBvbiB3aW5kb3dzLCBsZXQncyBjYWNoZSBvdXIgcHJvZmlsZSBpbmZvXG5sZXQgY2FjaGVkUHJvZmlsZVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFByb2ZpbGUoKSB7XG4gICAgaWYgKGNhY2hlZFByb2ZpbGUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgY2FjaGVkUHJvZmlsZSA9IGF3YWl0IGdldFByb2ZpbGVVbmNhY2hlZCgpXG4gICAgcmV0dXJuIGNhY2hlZFByb2ZpbGVcbn1cbi8vIEl0IG1ha2VzIHNlbnNlIHRvIHByZS1mZXRjaCB0aGlzIHZhbHVlIGluIHRoZSBiYWNrZ3JvdW5kIHNjcmlwdCBiZWNhdXNlIGl0J3Ncbi8vIGxvbmctbGl2ZWQuIE90aGVyIGNvbnRleHRzIGFyZSBjcmVhdGVkIGFuZCBkZXN0cm95ZWQgYWxsIHRoZSB0aW1lIHNvIHdlXG4vLyBkb24ndCB3YW50IHRvIHByZS1mZXRjaCBpbiB0aGVzZS5cbmlmIChnZXRDb250ZXh0KCkgPT09IFwiYmFja2dyb3VuZFwiKSB7XG4gICAgZ2V0UHJvZmlsZSgpXG59XG5jb25maWcuYWRkQ2hhbmdlTGlzdGVuZXIoXCJwcm9maWxlZGlyXCIsIChwcmV2LCBjdXIpID0+IHtcbiAgICBjYWNoZWRQcm9maWxlID0gdW5kZWZpbmVkXG4gICAgZ2V0UHJvZmlsZSgpXG59KVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvZmlsZU5hbWUoKSB7XG4gICAgcmV0dXJuIGdldFByb2ZpbGUoKS50aGVuKHAgPT4gcC5OYW1lKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvZmlsZURpcigpIHtcbiAgICBjb25zdCBwcm9maWxlZGlyID0gY29uZmlnLmdldChcInByb2ZpbGVkaXJcIilcbiAgICBpZiAocHJvZmlsZWRpciAhPT0gXCJhdXRvXCIpIHJldHVybiBQcm9taXNlLnJlc29sdmUocHJvZmlsZWRpcilcbiAgICByZXR1cm4gZ2V0UHJvZmlsZSgpLnRoZW4ocCA9PiBwLmFic29sdXRlUGF0aClcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlUHJlZnMocHJlZkZpbGVDb250ZW50OiBzdHJpbmcpIHtcbiAgICAvLyAgVGhpcyBSZWdFeHAgY3VycmVudGx5IG9ubHkgZGVhbHMgd2l0aCBcIiBidXQgZm9yIGNvcnJlY3RuZXNzIGl0IHNob3VsZFxuICAgIC8vICBhbHNvIGRlYWwgd2l0aCAnIGFuZCBgXG4gICAgLy8gIFdlIGNvdWxkIGFsc28ganVzdCBnaXZlIHVwIG9uIHBhcnNpbmcgYW5kIGV2YWwoKSB0aGUgd2hvbGUgdGhpbmdcbiAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgIC9eKHVzZXJffHN0aWNreV98bG9jayk/W3BQXXJlZlxcKFwiKFteXCJdKylcIixcXHMqXCI/KFteXFwpXSs/KVwiP1xcKTskLyxcbiAgICApXG4gICAgLy8gRnJhZ2lsZSBwYXJzaW5nXG4gICAgcmV0dXJuIHByZWZGaWxlQ29udGVudC5zcGxpdChcIlxcblwiKS5yZWR1Y2UoKHByZWZzLCBsaW5lKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBsaW5lLm1hdGNoKHJlZ2V4KVxuICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleSA9IG1hdGNoZXNbMl1cbiAgICAgICAgbGV0IHZhbHVlID0gbWF0Y2hlc1szXVxuICAgICAgICAvLyB2YWx1ZSA9IFwiIG1lYW5zIHRoYXQgaXQgc2hvdWxkIGJlIGFuIGVtcHR5IHN0cmluZ1xuICAgICAgICBpZiAodmFsdWUgPT09ICdcIicpIHZhbHVlID0gXCJcIlxuICAgICAgICBwcmVmc1trZXldID0gdmFsdWVcbiAgICAgICAgcmV0dXJuIHByZWZzXG4gICAgfSwge30pXG59XG5cbi8qKiBXaGVuIGdpdmVuIHRoZSBuYW1lIG9mIGEgZmlyZWZveCBwcmVmZXJlbmNlIGZpbGUsIHdpbGwgbG9hZCBzYWlkIGZpbGUgYW5kXG4gKiAgcmV0dXJuIGEgcHJvbWlzZSBmb3IgYW4gb2JqZWN0IHRoZSBrZXlzIG9mIHdoaWNoIGNvcnJlc3BvbmQgdG8gcHJlZmVyZW5jZVxuICogIG5hbWVzIGFuZCB0aGUgdmFsdWVzIG9mIHdoaWNoIGNvcnJlc3BvbmQgdG8gcHJlZmVyZW5jZSB2YWx1ZXMuXG4gKiAgV2hlbiB0aGUgZmlsZSBjb3VsZG4ndCBiZSBsb2FkZWQgb3IgZG9lc24ndCBjb250YWluIGFueSBwcmVmZXJlbmNlcywgd2lsbFxuICogIHJldHVybiBhIHByb21pc2UgZm9yIGFuIGVtcHR5IG9iamVjdC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRQcmVmcyhmaWxlbmFtZSk6IFByb21pc2U8eyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlYWQoZmlsZW5hbWUpXG4gICAgaWYgKHJlc3VsdC5jb2RlICE9PSAwKSByZXR1cm4ge31cbiAgICByZXR1cm4gcGFyc2VQcmVmcyhyZXN1bHQuY29udGVudClcbn1cblxubGV0IGNhY2hlZF9wcmVmcyA9IG51bGxcblxuLyoqIFJldHVybnMgYSBwcm9taXNlIGZvciBhbiBvYmplY3QgdGhhdCBzaG91bGQgY29udGFpbiBldmVyeSBhYm91dDpjb25maWdcbiAqICBzZXR0aW5nLlxuICpcbiAqICBQZXJmb3JtYW5jZSBpcyBzbG93IHNvIHdlIG5lZWQgdG8gY2FjaGUgdGhlIHJlc3VsdHMuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcmVmcygpOiBQcm9taXNlPHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0+IHtcbiAgICBpZiAoY2FjaGVkX3ByZWZzICE9PSBudWxsKSByZXR1cm4gY2FjaGVkX3ByZWZzXG4gICAgY29uc3QgcHJvZmlsZSA9IChhd2FpdCBnZXRQcm9maWxlRGlyKCkpICsgXCIvXCJcbiAgICBjb25zdCBwcmVmRmlsZXMgPSBbXG4gICAgICAgIC8vIERlYmlhbiBoYXMgdGhlc2VcbiAgICAgICAgXCIvdXNyL3NoYXJlL2ZpcmVmb3gvYnJvd3Nlci9kZWZhdWx0cy9wcmVmZXJlbmNlcy9maXJlZm94LmpzXCIsXG4gICAgICAgIFwiL3Vzci9zaGFyZS9maXJlZm94L2Jyb3dzZXIvZGVmYXVsdHMvcHJlZmVyZW5jZXMvZGVidWdnZXIuanNcIixcbiAgICAgICAgXCIvdXNyL3NoYXJlL2ZpcmVmb3gvYnJvd3Nlci9kZWZhdWx0cy9wcmVmZXJlbmNlcy9kZXZ0b29scy1zdGFydHVwLXByZWZzLmpzXCIsXG4gICAgICAgIFwiL3Vzci9zaGFyZS9maXJlZm94L2Jyb3dzZXIvZGVmYXVsdHMvcHJlZmVyZW5jZXMvZGV2dG9vbHMuanNcIixcbiAgICAgICAgXCIvdXNyL3NoYXJlL2ZpcmVmb3gvYnJvd3Nlci9kZWZhdWx0cy9wcmVmZXJlbmNlcy9maXJlZm94LWJyYW5kaW5nLmpzXCIsXG4gICAgICAgIFwiL3Vzci9zaGFyZS9maXJlZm94L2Jyb3dzZXIvZGVmYXVsdHMvcHJlZmVyZW5jZXMvdmVuZG9yLmpzXCIsXG4gICAgICAgIFwiL3Vzci9zaGFyZS9maXJlZm94L2Jyb3dzZXIvZGVmYXVsdHMvcHJlZmVyZW5jZXMvZmlyZWZveC5qc1wiLFxuICAgICAgICBcIi9ldGMvZmlyZWZveC9maXJlZm94LmpzXCIsXG4gICAgICAgIC8vIFByZWYgZmlsZXMgY2FuIGJlIGZvdW5kIGhlcmU6XG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvTW96aWxsYS9QcmVmZXJlbmNlcy9BX2JyaWVmX2d1aWRlX3RvX01vemlsbGFfcHJlZmVyZW5jZXNcbiAgICAgICAgcHJvZmlsZSArIFwiZ3JlcHJlZi5qc1wiLFxuICAgICAgICBwcm9maWxlICsgXCJzZXJ2aWNlcy9jb21tb24vc2VydmljZXMtY29tbW9uLmpzXCIsXG4gICAgICAgIHByb2ZpbGUgKyBcImRlZmF1bHRzL3ByZWYvc2VydmljZXMtc3luYy5qc1wiLFxuICAgICAgICBwcm9maWxlICsgXCJicm93c2VyL2FwcC9wcm9maWxlL2NoYW5uZWwtcHJlZnMuanNcIixcbiAgICAgICAgcHJvZmlsZSArIFwiYnJvd3Nlci9hcHAvcHJvZmlsZS9maXJlZm94LmpzXCIsXG4gICAgICAgIHByb2ZpbGUgKyBcImJyb3dzZXIvYXBwL3Byb2ZpbGUvZmlyZWZveC1icmFuZGluZy5qc1wiLFxuICAgICAgICBwcm9maWxlICsgXCJicm93c2VyL2RlZmF1bHRzL3ByZWZlcmVuY2VzL2ZpcmVmb3gtbDEwbi5qc1wiLFxuICAgICAgICBwcm9maWxlICsgXCJwcmVmcy5qc1wiLFxuICAgICAgICBwcm9maWxlICsgXCJ1c2VyLmpzXCIsXG4gICAgXVxuICAgIGNvbnN0IHByb21pc2VzID0gW11cbiAgICAvLyBTdGFydGluZyBhbGwgcHJvbWlzZXMgYmVmb3JlIGF3YWl0aW5nIGJlY2F1c2Ugd2Ugd2FudCB0aGUgY2FsbHMgdG8gYmVcbiAgICAvLyBtYWRlIGluIHBhcmFsbGVsXG4gICAgZm9yIChjb25zdCBmaWxlIG9mIHByZWZGaWxlcykge1xuICAgICAgICBwcm9taXNlcy5wdXNoKGxvYWRQcmVmcyhmaWxlKSlcbiAgICB9XG4gICAgY2FjaGVkX3ByZWZzID0gcHJvbWlzZXMucmVkdWNlKGFzeW5jIChhLCBiKSA9PlxuICAgICAgICBPYmplY3QuYXNzaWduKGF3YWl0IGEsIGF3YWl0IGIpLFxuICAgIClcbiAgICByZXR1cm4gY2FjaGVkX3ByZWZzXG59XG5cbi8qKiBSZXR1cm5zIHRoZSB2YWx1ZSBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgYWJvdXQ6Y29uZmlnIHNldHRpbmcgKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcmVmKG5hbWU6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIChhd2FpdCBnZXRQcmVmcygpKVtuYW1lXVxufVxuXG4vKiogRmV0Y2hlcyBhIGNvbmZpZyBvcHRpb24gZnJvbSB0aGUgY29uZmlnLiBJZiB0aGUgb3B0aW9uIGlzIHVuZGVmaW5lZCwgZmV0Y2hcbiAqICBhIHByZWZlcmVuY2UgZnJvbSBwcmVmZXJlbmNlcy4gSXQgd291bGQgbWFrZSBtb3JlIHNlbnNlIGZvciB0aGlzIGZ1bmN0aW9uIHRvXG4gKiAgYmUgaW4gY29uZmlnLnRzIGJ1dCB0aGlzIHdvdWxkIHJlcXVpcmUgaW1wb3J0aW5nIHRoaXMgZmlsZSBpbiBjb25maWcudHMgYW5kXG4gKiAgV2VicGFjayBkb2Vzbid0IGxpa2UgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q29uZkVsc2VQcmVmKFxuICAgIGNvbmZOYW1lOiBzdHJpbmcsXG4gICAgcHJlZk5hbWU6IHN0cmluZyxcbik6IFByb21pc2U8YW55PiB7XG4gICAgbGV0IG9wdGlvbiA9IGF3YWl0IGNvbmZpZy5nZXRBc3luY0R5bmFtaWMoY29uZk5hbWUpXG4gICAgaWYgKG9wdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvcHRpb24gPSBhd2FpdCBnZXRQcmVmKHByZWZOYW1lKVxuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9uXG59XG5cbi8qKiBGZXRjaGVzIGEgY29uZmlnIG9wdGlvbiBmcm9tIHRoZSBjb25maWcuIElmIHRoZSBvcHRpb24gaXMgdW5kZWZpbmVkLCBmZXRjaFxuICogIHByZWZOYW1lIGZyb20gdGhlIHByZWZlcmVuY2VzLiBJZiBwcmVmTmFtZSBpcyB1bmRlZmluZWQgdG9vLCByZXR1cm4gYVxuICogIGRlZmF1bHQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb25mRWxzZVByZWZFbHNlRGVmYXVsdChcbiAgICBjb25mTmFtZTogc3RyaW5nLFxuICAgIHByZWZOYW1lOiBzdHJpbmcsXG4gICAgZGVmOiBhbnksXG4pOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IG9wdGlvbiA9IGF3YWl0IGdldENvbmZFbHNlUHJlZihjb25mTmFtZSwgcHJlZk5hbWUpXG4gICAgaWYgKG9wdGlvbiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZGVmXG4gICAgcmV0dXJuIG9wdGlvblxufVxuXG4vKiogV3JpdGVzIGEgcHJlZmVyZW5jZSB0byB1c2VyLmpzICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd3JpdGVQcmVmKG5hbWU6IHN0cmluZywgdmFsdWU6IGFueSkge1xuICAgIGlmIChjYWNoZWRfcHJlZnMpIGNhY2hlZF9wcmVmc1tuYW1lXSA9IHZhbHVlXG5cbiAgICBjb25zdCBmaWxlID0gKGF3YWl0IGdldFByb2ZpbGVEaXIoKSkgKyBcIi91c2VyLmpzXCJcbiAgICAvLyBObyBuZWVkIHRvIGNoZWNrIHRoZSByZXR1cm4gY29kZSBiZWNhdXNlIHJlYWQgcmV0dXJucyBcIlwiIHdoZW4gZmFpbGluZyB0b1xuICAgIC8vIHJlYWQgYSBmaWxlXG4gICAgY29uc3QgdGV4dCA9IChhd2FpdCByZWFkKGZpbGUpKS5jb250ZW50XG4gICAgY29uc3QgcHJlZlBvcyA9IHRleHQuaW5kZXhPZihgcHJlZihcIiR7bmFtZX1cIixgKVxuICAgIGlmIChwcmVmUG9zIDwgMCkge1xuICAgICAgICB3cml0ZShmaWxlLCBgJHt0ZXh0fVxcbnVzZXJfcHJlZihcIiR7bmFtZX1cIiwgJHt2YWx1ZX0pO1xcbmApXG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHN1YnN0ciA9IHRleHQuc3Vic3RyaW5nKHByZWZQb3MpXG4gICAgICAgIGNvbnN0IHByZWZFbmQgPSBzdWJzdHIuaW5kZXhPZihcIjtcXG5cIilcbiAgICAgICAgc3Vic3RyID0gdGV4dC5zdWJzdHJpbmcocHJlZlBvcywgcHJlZlBvcyArIHByZWZFbmQpXG4gICAgICAgIHdyaXRlKGZpbGUsIHRleHQucmVwbGFjZShzdWJzdHIsIGBwcmVmKFwiJHtuYW1lfVwiLCAke3ZhbHVlfSlgKSlcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBuZWFybGV5IGZyb20gXCJuZWFybGV5XCJcblxuLyoqIEZyaWVuZGxpZXIgaW50ZXJmYWNlIGFyb3VuZCBuZWFybGV5IHBhcnNlcnMgKi9cbmV4cG9ydCBjbGFzcyBQYXJzZXIge1xuICAgIHByaXZhdGUgcGFyc2VyXG4gICAgcHJpdmF0ZSBpbml0aWFsX3N0YXRlXG4gICAgLyogcHVibGljIHJlc3VsdHMgKi9cblxuICAgIGNvbnN0cnVjdG9yKGdyYW1tYXIpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBuZXcgbmVhcmxleS5QYXJzZXIobmVhcmxleS5HcmFtbWFyLmZyb21Db21waWxlZChncmFtbWFyKSlcbiAgICAgICAgdGhpcy5pbml0aWFsX3N0YXRlID0gdGhpcy5wYXJzZXIuc2F2ZSgpXG4gICAgICAgIC8qIHRoaXMucmVzdWx0cyA9IHRoaXMucGFyc2VyLnJlc3VsdHMgKi9cbiAgICB9XG5cbiAgICBmZWVkVW50aWxFcnJvcihpbnB1dCkge1xuICAgICAgICBsZXQgbGFzdFJlc3VsdFxuICAgICAgICBsZXQgY29uc3VtZWRJbmRleCA9IDBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdmFsIG9mIGlucHV0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZXIuZmVlZCh2YWwpXG4gICAgICAgICAgICAgICAgbGFzdFJlc3VsdCA9IHRoaXMucGFyc2VyLnJlc3VsdHNbMF1cbiAgICAgICAgICAgICAgICBjb25zdW1lZEluZGV4KytcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKVxuICAgICAgICAgICAgaWYgKGxhc3RSZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiRXJyb3I6IG5vIHJlc3VsdCFcIlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2xhc3RSZXN1bHQsIGlucHV0LnNsaWNlKGNvbnN1bWVkSW5kZXgpXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZXNldCgpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIucmVzdG9yZSh0aGlzLmluaXRpYWxfc3RhdGUpXG4gICAgfVxuXG4gICAgLyogZmVlZChpbnB1dCkgeyAqL1xuICAgIC8qICAgICByZXR1cm4gdGhpcy5wYXJzZXIuZmVlZChpbnB1dCkgKi9cbiAgICAvKiB9ICovXG59XG4iLCIvKlxuICogQ2xhbXAgYSBudW1iZXIgbiBiZXR3ZWVuIHR3byB2YWx1ZXMgbG8sIGhpXG4gKiBzdWNoIHRoYXQgaWYgbiBpcyBpbiBbbG8sIGhpXSwgd2UgcmV0dXJuIG5cbiAqIG90aGVyd2lzZSBpZiBuIDwgbG8sIHJldHVybiBsb1xuICogZWxzZSByZXR1cm4gaGkuXG4gKi9cbk51bWJlci5wcm90b3R5cGUuY2xhbXAgPSBmdW5jdGlvbihsbzogbnVtYmVyLCBoaTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5tYXgobG8sIE1hdGgubWluKHRoaXMsIGhpKSlcbn1cblxuZXhwb3J0IHt9XG4iLCIvKiogTnVtYmVyIHRoZW9yeS1mcmllbmRseSBtb2R1bG8gaW1wbGVtZW50YXRpb25cblxuICAgIElmIGRpdmlzb3IgaXMgcG9zaXRpdmUsIHJldHVybiB2YWx1ZSB3aWxsIGJlIHRvby5cbiovXG5OdW1iZXIucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uKG46IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIGtudXRoX21vZCh0aGlzLCBuKVxufVxuXG4vKiogVGFrZXMgc2lnbiBvZiBkaXZpc29yIC0tIGluY2wuIHJldHVybmluZyAtMCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtudXRoX21vZChkaXZpZGVuZCwgZGl2aXNvcikge1xuICAgIHJldHVybiBkaXZpZGVuZCAtIGRpdmlzb3IgKiBNYXRoLmZsb29yKGRpdmlkZW5kIC8gZGl2aXNvcilcbn1cblxuLyoqIEVxdWl2YWxlbnQgdG8ga251dGhfbW9kIGJ1dCBkb2Vzbid0IHJldHVybiAtMCAqL1xuZXhwb3J0IGZ1bmN0aW9uIG15X21vZChkaXZpZGVuZCwgZGl2aXNvcikge1xuICAgIHJldHVybiAoZGl2aWRlbmQgJSBkaXZpc29yICsgZGl2aXNvcikgJSBkaXZpc29yXG59XG5cbi8qKiBBbHdheXMgZ2l2ZXMgYSBwb3NpdGl2ZSByZXN1bHQuXG5cbiAgICBFcXVpdmFsZW50IHRvIGtudXRoX21vZCB3aGVuIGRpdmlzb3IgaXMgK3ZlXG4gICAgRXF1aXZhbGVudCB0byAlIHdoZW4gZGl2aWRlbmQgaXMgK3ZlXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGV1Y2xpZF9tb2QoZGl2aWRlbmQsIGRpdmlzb3IpIHtcbiAgICBjb25zdCBhYnNfZGl2aXNvciA9IE1hdGguYWJzKGRpdmlzb3IpXG4gICAgY29uc3QgcXVvdGllbnQgPSBNYXRoLmZsb29yKGRpdmlkZW5kIC8gYWJzX2Rpdmlzb3IpXG4gICAgcmV0dXJuIGRpdmlkZW5kIC0gYWJzX2Rpdmlzb3IgKiBxdW90aWVudFxufVxuXG5leHBvcnQge31cbiIsIi8qKiBVUkwgaGFuZGxpbmcgdXRsaXR5IGZ1bmN0aW9uc1xuICovXG5cbi8qKiBJbmNyZW1lbnQgdGhlIGxhc3QgbnVtYmVyIGluIGEgVVJMLlxuICpcbiAqIChwZXJoYXBzIHRoaXMgY291bGQgYmUgbWFkZSBzbyB5b3UgY2FuIHNlbGVjdCB0aGUgXCJudGhcIiBudW1iZXIgaW4gYVxuICogVVJMIHJhdGhlciB0aGFuIGp1c3QgdGhlIGxhc3Qgb25lPylcbiAqXG4gKiBAcGFyYW0gdXJsICAgICAgIHRoZSBVUkwgdG8gaW5jcmVtZW50XG4gKiBAcGFyYW0gY291bnQgICAgIGluY3JlbWVudCBzdGVwIHRvIGFkdmFuY2UgYnkgKGNhbiBiZSBuZWdhdGl2ZSlcbiAqIEByZXR1cm4gICAgICAgICAgdGhlIGluY3JlbWVudGVkIFVSTCwgb3IgbnVsbCBpZiBjYW5ub3QgYmUgaW5jcmVtZW50ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluY3JlbWVudFVybCh1cmwsIGNvdW50KSB7XG4gICAgLy8gRmluZCB0aGUgZmluYWwgbnVtYmVyIGluIGEgVVJMXG4gICAgY29uc3QgbWF0Y2hlcyA9IHVybC5tYXRjaCgvKC4qPykoXFxkKykoXFxEKikkLylcblxuICAgIC8vIG5vIG51bWJlciBpbiBVUkwgLSBub3RoaW5nIHRvIGRvIGhlcmVcbiAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGNvbnN0IFssIHByZSwgbnVtYmVyLCBwb3N0XSA9IG1hdGNoZXNcbiAgICBjb25zdCBuZXdOdW1iZXIgPSBwYXJzZUludChudW1iZXIsIDEwKSArIGNvdW50XG4gICAgbGV0IG5ld051bWJlclN0ciA9IFN0cmluZyhuZXdOdW1iZXIgPiAwID8gbmV3TnVtYmVyIDogMClcblxuICAgIC8vIFJlLXBhZCBudW1iZXJzIHRoYXQgd2VyZSB6ZXJvLXBhZGRlZCB0byBiZSB0aGUgc2FtZSBsZW5ndGg6XG4gICAgLy8gMDAwOSArIDEgPT4gMDAxMFxuICAgIGlmIChudW1iZXIubWF0Y2goL14wLykpIHtcbiAgICAgICAgd2hpbGUgKG5ld051bWJlclN0ci5sZW5ndGggPCBudW1iZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBuZXdOdW1iZXJTdHIgPSBcIjBcIiArIG5ld051bWJlclN0clxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZSArIG5ld051bWJlclN0ciArIHBvc3Rcbn1cblxuLyoqIEdldCB0aGUgcm9vdCBvZiBhIFVSTFxuICpcbiAqIEBwYXJhbSB1cmwgICB0aGUgdXJsIHRvIGZpbmQgdGhlIHJvb3Qgb2ZcbiAqIEByZXR1cm4gICAgICB0aGUgcm9vdCBvZiB0aGUgVVJMLCBvciB0aGUgb3JpZ2luYWwgVVJMIHdoZW4gdGhlIFVSTCBpc24ndFxuICogICAgICAgICAgICAgIHN1aXRhYmxlIGZvciBmaW5kaW5nIHRoZSByb290IG9mLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXJsUm9vdCh1cmwpIHtcbiAgICAvLyBleGNsdWRlIHRoZXNlIHNwZWNpYWwgcHJvdG9jb2xzIGZvciBub3c7XG4gICAgaWYgKC8oYWJvdXR8bWFpbHRvKTovLnRlc3QodXJsLnByb3RvY29sKSkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8vIHRoaXMgd29ya3MgZXZlbiBmb3IgZmlsZTovLy8gd2hlcmUgdGhlIHJvb3QgaXMgXCJcIlxuICAgIHJldHVybiBuZXcgVVJMKHVybC5wcm90b2NvbCArIFwiLy9cIiArICh1cmwuaG9zdCB8fCBcIlwiKSlcbn1cblxuLyoqIEdldCB0aGUgcGFyZW50IG9mIHRoZSBjdXJyZW50IFVSTC4gUGFyZW50IGlzIGRldGVybWluZWQgYXM6XG4gKlxuICogKiBpZiB0aGVyZSBpcyBhIGhhc2ggZnJhZ21lbnQsIHN0cmlwIHRoYXQsIG9yXG4gKiAqIElmIHRoZXJlIGlzIGEgcXVlcnkgc3RyaW5nLCBzdHJpcCB0aGF0LCBvclxuICogKiBSZW1vdmUgb25lIGxldmVsIGZyb20gdGhlIHBhdGggaWYgdGhlcmUgaXMgb25lLCBvclxuICogKiBSZW1vdmUgb25lIHN1YmRvbWFpbiBmcm9tIHRoZSBmcm9udCBpZiB0aGVyZSBpcyBvbmVcbiAqXG4gKiBAcGFyYW0gdXJsICAgICAgICAgICAgICAgdGhlIFVSTCB0byBnZXQgdGhlIHBhcmVudCBvZlxuICogQHBhcmFtIHRyYWlsaW5nU2xhc2ggICAgIHdoZXRoZXIgdGhlIHJldHVybmVkIFVSTCBoYXMgYSB0cmFpbGluZyBzbGFzaFxuICogQHBhcmFtIGNvdW50ICAgICAgICAgICAgIGhvdyBtYW55IFwiZ2VuZXJhdGlvbnNcIiB5b3Ugd2lzaCB0byBnbyBiYWNrICgxID0gcGFyZW50LCAyID0gZ3JhbmRwYXJlbnQsIGV0Yy4pXG4gKiBAcmV0dXJuICAgICAgICAgICAgICAgICAgdGhlIHBhcmVudCBvZiB0aGUgVVJMLCBvciBudWxsIGlmIHRoZXJlIGlzIG5vIHBhcmVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXJsUGFyZW50KHVybCwgdHJhaWxpbmdTbGFzaCwgY291bnQgPSAxKSB7XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uLlxuICAgIGZ1bmN0aW9uIGd1cChwYXJlbnQsIHRyYWlsaW5nU2xhc2gsIGNvdW50KSB7XG4gICAgICAgIGlmIChjb3VudCA8IDEpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyBzbGFzaChzKSBpZiBkZXNpcmVkXG4gICAgICAgICAgICBpZiAoIXRyYWlsaW5nU2xhc2gpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgMSBvciBtb3JlIHRyYWlsaW5nIHNsYXNoZXNcbiAgICAgICAgICAgICAgICBwYXJlbnQucGF0aG5hbWUgPSBwYXJlbnQucGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudFxuICAgICAgICB9XG4gICAgICAgIC8vIHN0cmlwLCBpbiB0dXJuLCBoYXNoL2ZyYWdtZW50IGFuZCBxdWVyeS9zZWFyY2hcbiAgICAgICAgaWYgKHBhcmVudC5oYXNoKSB7XG4gICAgICAgICAgICBwYXJlbnQuaGFzaCA9IFwiXCJcbiAgICAgICAgICAgIHJldHVybiBndXAocGFyZW50LCB0cmFpbGluZ1NsYXNoLCBjb3VudCAtIDEpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudC5zZWFyY2gpIHtcbiAgICAgICAgICAgIHBhcmVudC5zZWFyY2ggPSBcIlwiXG4gICAgICAgICAgICByZXR1cm4gZ3VwKHBhcmVudCwgdHJhaWxpbmdTbGFzaCwgY291bnQgLSAxKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW1wdHkgcGF0aCBpcyAnLydcbiAgICAgICAgaWYgKHBhcmVudC5wYXRobmFtZSAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyBzbGFzaGVzIGFuZCBldmVyeXRoaW5nIHRvIHRoZSBuZXh0IHNsYXNoOlxuICAgICAgICAgICAgcGFyZW50LnBhdGhuYW1lID0gcGFyZW50LnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSo/XFwvKiQvLCBcIi9cIilcbiAgICAgICAgICAgIHJldHVybiBndXAocGFyZW50LCB0cmFpbGluZ1NsYXNoLCBjb3VudCAtIDEpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdHJpcCBvZmYgdGhlIGZpcnN0IHN1YmRvbWFpbiBpZiB0aGVyZSBpcyBvbmVcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZG9tYWlucyA9IHBhcmVudC5ob3N0LnNwbGl0KFwiLlwiKVxuXG4gICAgICAgICAgICAvLyBtb3JlIHRoYW4gZG9tYWluICsgVExEXG4gICAgICAgICAgICBpZiAoZG9tYWlucy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9tYWlucy5wb3AoKVxuICAgICAgICAgICAgICAgIHBhcmVudC5ob3N0ID0gZG9tYWlucy5zbGljZSgxKS5qb2luKFwiLlwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBndXAocGFyZW50LCB0cmFpbGluZ1NsYXNoLCBjb3VudCAtIDEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3RoaW5nIHRvIHRyaW0gb2ZmIFVSTCwgc28gbm8gcGFyZW50XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLy8gZXhjbHVkZSB0aGVzZSBzcGVjaWFsIHByb3RvY29scyB3aGVyZSBwYXJlbnRzIGRvbid0IHJlYWxseSBtYWtlIHNlbnNlXG4gICAgaWYgKC8oYWJvdXR8bWFpbHRvKTovLnRlc3QodXJsLnByb3RvY29sKSkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudCA9IG5ldyBVUkwodXJsKVxuICAgIHJldHVybiBndXAocGFyZW50LCB0cmFpbGluZ1NsYXNoLCBjb3VudClcbn1cblxuLyoqIFZlcnkgaW5jb21wbGV0ZSBsb29rdXAgb2YgZXh0ZW5zaW9uIGZvciBjb21tb24gbWltZSB0eXBlcyB0aGF0IG1pZ2h0IGJlXG4gKiBlbmNvdW50ZXJlZCB3aGVuIHNhdmluZyBlbGVtZW50cyBvbiBhIHBhZ2UuIFRoZXJlIGFyZSBOUE0gbGlicyBmb3IgdGhpcyxcbiAqIGJ1dCB0aGlzIHNob3VsZCBjb3ZlciA5OSUgb2YgYmFzaWMgY2FzZXNcbiAqXG4gKiBAcGFyYW0gbWltZSAgbWltZSB0eXBlIHRvIGdldCBleHRlbnNpb24gZm9yIChlZyAnaW1hZ2UvcG5nJylcbiAqXG4gKiBAcmV0dXJuIGFuIGV4dGVuc2lvbiBmb3IgdGhhdCBtaW1ldHlwZSwgb3IgdW5kZWZpbmVkIGlmIHRoYXQgdHlwZSBpcyBub3RcbiAqIHN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiBnZXRFeHRlbnNpb25Gb3JNaW1ldHlwZShtaW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHR5cGVzID0ge1xuICAgICAgICBcImltYWdlL3BuZ1wiOiBcIi5wbmdcIixcbiAgICAgICAgXCJpbWFnZS9qcGVnXCI6IFwiLmpwZ1wiLFxuICAgICAgICBcImltYWdlL2dpZlwiOiBcIi5naWZcIixcbiAgICAgICAgXCJpbWFnZS94LWljb25cIjogXCIuaWNvXCIsXG4gICAgICAgIFwiaW1hZ2Uvc3ZnK3htbFwiOiBcIi5zdmdcIixcbiAgICAgICAgXCJpbWFnZS90aWZmXCI6IFwiLnRpZmZcIixcbiAgICAgICAgXCJpbWFnZS93ZWJwXCI6IFwiLndlYnBcIixcblxuICAgICAgICBcInRleHQvcGxhaW5cIjogXCIudHh0XCIsXG4gICAgICAgIFwidGV4dC9odG1sXCI6IFwiLmh0bWxcIixcbiAgICAgICAgXCJ0ZXh0L2Nzc1wiOiBcIi5jc3NcIixcbiAgICAgICAgXCJ0ZXh0L2NzdlwiOiBcIi5jc3ZcIixcbiAgICAgICAgXCJ0ZXh0L2NhbGVuZGFyXCI6IFwiLmljc1wiLFxuXG4gICAgICAgIFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCI6IFwiLmJpblwiLFxuICAgICAgICBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIjogXCIuanNcIixcbiAgICAgICAgXCJhcHBsaWNhdGlvbi94aHRtbCt4bWxcIjogXCIueGh0bWxcIixcblxuICAgICAgICBcImZvbnQvb3RmXCI6IFwiLm90ZlwiLFxuICAgICAgICBcImZvbnQvd29mZlwiOiBcIi53b2ZmXCIsXG4gICAgICAgIFwiZm9udC93b2ZmMlwiOiBcIi53b2ZmMlwiLFxuICAgICAgICBcImZvbnQvdHRmXCI6IFwiLnR0ZlwiLFxuICAgIH1cblxuICAgIHJldHVybiB0eXBlc1ttaW1lXSB8fCBcIlwiXG59XG5cbi8qKiBHZXQgYSBzdWl0YWJsZSBkZWZhdWx0IGZpbGVuYW1lIGZvciBhIGdpdmVuIFVSTFxuICpcbiAqIElmIHRoZSBVUkw6XG4gKiAgLSBpcyBhIGRhdGEgVVJMLCBjb25zdHJ1Y3QgZnJvbSB0aGUgZGF0YSBhbmQgbWltZXR5cGVcbiAqICAtIGhhcyBhIHBhdGgsIHVzZSB0aGUgbGFzdCBwYXJ0IG9mIHRoYXQgKGVnIGltYWdlLnBuZywgaW5kZXguaHRtbClcbiAqICAtIG90aGVyd2lzZSwgdXNlIHRoZSBob3N0bmFtZSBvZiB0aGUgVVJMXG4gKiAgLSBpZiB0aGF0IGZhaWxzLCBcImRvd25sb2FkXCJcbiAqXG4gKiBAcGFyYW0gVVJMICAgdGhlIFVSTCB0byBtYWtlIGEgZmlsZW5hbWUgZm9yXG4gKiBAcmV0dXJuICAgICAgdGhlIGZpbGVuYW1lIGFjY29yZGluZyB0byB0aGUgYWJvdmUgcnVsZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERvd25sb2FkRmlsZW5hbWVGb3JVcmwodXJsOiBVUkwpOiBzdHJpbmcge1xuICAgIC8vIGZvciBhIGRhdGEgVVJMLCB3ZSBoYXZlIG5vIHJlYWxseSB1c2VmdWwgbmFtaW5nIGRhdGEgaW50cmluc2ljIHRvIHRoZVxuICAgIC8vIGRhdGEsIHNvIHdlIGNvbnN0cnVjdCBvbmUgdXNpbmcgdGhlIGRhdGEgYW5kIGd1ZXNzaW5nIGFuIGV4dGVuc2lvblxuICAgIC8vIGZyb20gYW55IG1pbWV0eXBlXG4gICAgaWYgKHVybC5wcm90b2NvbCA9PT0gXCJkYXRhOlwiKSB7XG4gICAgICAgIC8vIGRhdGE6WzxtZWRpYXR5cGU+XVs7YmFzZTY0XSw8ZGF0YT5cbiAgICAgICAgY29uc3QgW3ByZWZpeCwgZGF0YV0gPSB1cmwucGF0aG5hbWUuc3BsaXQoXCIsXCIsIDIpXG5cbiAgICAgICAgY29uc3QgW21lZGlhdHlwZSwgYjY0XSA9IHByZWZpeC5zcGxpdChcIjtcIiwgMilcblxuICAgICAgICAvLyB0YWtlIGEgMTUtY2hhciBwcmVmaXggb2YgdGhlIGRhdGEgYXMgYSByZWFzb25hYmx5IHVuaXF1ZSBuYW1lXG4gICAgICAgIC8vIHNhbml0aXplIGluIGEgdmVyeSByb3VnaCBtYW5uZXJcbiAgICAgICAgbGV0IGZpbGVuYW1lID0gZGF0YVxuICAgICAgICAgICAgLnNsaWNlKDAsIDE1KVxuICAgICAgICAgICAgLnJlcGxhY2UoL1teYS16QS1aMC05X1xcLV0vZywgXCJfXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvX3syLH0vZywgXCJfXCIpXG5cbiAgICAgICAgLy8gYWRkIGEgYmFzZTY0IHByZWZpeCBhbmQgdGhlIGV4dGVuc2lvblxuICAgICAgICBmaWxlbmFtZSA9XG4gICAgICAgICAgICAoYjY0ID8gYjY0ICsgXCItXCIgOiBcIlwiKSArXG4gICAgICAgICAgICBmaWxlbmFtZSArXG4gICAgICAgICAgICBnZXRFeHRlbnNpb25Gb3JNaW1ldHlwZShtZWRpYXR5cGUpXG5cbiAgICAgICAgcmV0dXJuIGZpbGVuYW1lXG4gICAgfVxuXG4gICAgLy8gaWYgdGhlcmUncyBhIHVzZWZ1bCBwYXRoLCB1c2UgdGhhdCBkaXJlY3RseVxuICAgIGlmICh1cmwucGF0aG5hbWUgIT09IFwiL1wiKSB7XG4gICAgICAgIGNvbnN0IHBhdGhzID0gdXJsLnBhdGhuYW1lLnNwbGl0KFwiL1wiKS5zbGljZSgxKVxuXG4gICAgICAgIC8vIHBvcCBvZmYgZW1wdHkgcGF0IGJoIHRhaWxzXG4gICAgICAgIC8vIGUuZy4gaHR0cHM6Ly93d3cubW96aWxsYS5vcmcvZW4tR0IvZmlyZWZveC9uZXcvXG4gICAgICAgIHdoaWxlIChwYXRocy5sZW5ndGggJiYgIXBhdGhzW3BhdGhzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICBwYXRocy5wb3AoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhdGhzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhdGhzLnNsaWNlKC0xKVswXVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlcmUncyBubyBwYXRoLCB1c2UgdGhlIGRvbWFpbiAob3RoZXJ3aXNlIHRoZSBGRi1wcm92aWRlZFxuICAgIC8vIGRlZmF1bHQgaXMganVzdCBcImRvd25sb2FkXCJcbiAgICByZXR1cm4gdXJsLmhvc3RuYW1lIHx8IFwiZG93bmxvYWRcIlxufVxuXG4vKipcbiAqIEdldCBhbiBBcnJheSBvZiB0aGUgcXVlcmllcyBpbiBhIFVSTC5cbiAqXG4gKiBUaGVzZSBjb3VsZCBiZSBsaWtlIFwicXVlcnlcIiBvciBcInF1ZXJ5PXZhbFwiXG4gKi9cbmZ1bmN0aW9uIGdldFVybFF1ZXJpZXModXJsOiBVUkwpOiBzdHJpbmdbXSB7XG4gICAgbGV0IHF5cyA9IFtdXG5cbiAgICBpZiAodXJsLnNlYXJjaCkge1xuICAgICAgICAvLyBnZXQgZWFjaCBxdWVyeSBzZXBhcmF0ZWx5LCBsZWF2ZSB0aGUgXCI/XCIgb2ZmXG4gICAgICAgIHF5cyA9IHVybC5zZWFyY2guc2xpY2UoMSkuc3BsaXQoXCImXCIpXG4gICAgfVxuXG4gICAgcmV0dXJuIHF5c1xufVxuXG4vKipcbiAqIFVwZGF0ZSBhIFVSTCB3aXRoIGEgbmV3IGFycmF5IG9mIHF1ZXJpZXNcbiAqL1xuZnVuY3Rpb24gc2V0VXJsUXVlcmllcyh1cmw6IFVSTCwgcXlzOiBzdHJpbmdbXSkge1xuICAgIHVybC5zZWFyY2ggPSBcIlwiXG5cbiAgICBpZiAocXlzLmxlbmd0aCkge1xuICAgICAgICAvLyByZWJ1aWxkIHN0cmluZyB3aXRoIHRoZSBmaWx0ZXJlZCBsaXN0XG4gICAgICAgIHVybC5zZWFyY2ggPSBcIj9cIiArIHF5cy5qb2luKFwiJlwiKVxuICAgIH1cbn1cblxuLyoqXG4gKiBEZWxldGUgYSBxdWVyeSAoYW5kIGl0cyB2YWx1ZSkgaW4gYSBVUkxcbiAqXG4gKiBJZiBhIHF1ZXJ5IGFwcGVhcnMgbXVsdGlwbGUgdGltZXMgKHdoaWNoIGlzIGEgYml0IG9kZCksXG4gKiBhbGwgaW5zdGFuY2VzIGFyZSByZW1vdmVkXG4gKlxuICogQHBhcmFtIHVybCAgICAgICAgICAgdGhlIFVSTCB0byBhY3Qgb25cbiAqIEBwYXJhbSBxdWVyeSAgICAgICAgIHRoZSBxdWVyeSB0byBkZWxldGVcbiAqXG4gKiBAcmV0dXJuICAgICAgICAgICAgICB0aGUgbW9kaWZpZWQgVVJMXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVRdWVyeSh1cmw6IFVSTCwgbWF0Y2hRdWVyeTogc3RyaW5nKTogVVJMIHtcbiAgICBjb25zdCBuZXdVcmwgPSBuZXcgVVJMKHVybC5ocmVmKVxuXG4gICAgY29uc3QgcXlzID0gZ2V0VXJsUXVlcmllcyh1cmwpXG5cbiAgICBjb25zdCBuZXdfcXlzID0gcXlzLmZpbHRlcihxID0+IHtcbiAgICAgICAgcmV0dXJuIHEuc3BsaXQoXCI9XCIpWzBdICE9PSBtYXRjaFF1ZXJ5XG4gICAgfSlcblxuICAgIHNldFVybFF1ZXJpZXMobmV3VXJsLCBuZXdfcXlzKVxuXG4gICAgcmV0dXJuIG5ld1VybFxufVxuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIG9mIGEgcXVlcnkgaW4gYSBVUkwgd2l0aCBhIHNwZWNpZmljIG9uZVxuICpcbiAqIEBwYXJhbSB1cmwgICAgICAgICAgIHRoZSBVUkwgdG8gYWN0IG9uXG4gKiBAcGFyYW0gbWF0Y2hRdWVyeSAgICB0aGUgcXVlcnkga2V5IHRvIHNldCB0aGUgdmFsdWUgZm9yXG4gKiBAcGFyYW0gdmFsdWUgICAgICAgICB0aGUgdmFsdWUgdG8gdXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRRdWVyeVZhbHVlKFxuICAgIHVybDogVVJMLFxuICAgIG1hdGNoUXVlcnk6IHN0cmluZyxcbiAgICB2YWx1ZTogc3RyaW5nLFxuKTogVVJMIHtcbiAgICBjb25zdCBuZXdVcmwgPSBuZXcgVVJMKHVybC5ocmVmKVxuXG4gICAgLy8gZ2V0IGVhY2ggcXVlcnkgc2VwYXJhdGVseSwgbGVhdmUgdGhlIFwiP1wiIG9mZlxuICAgIGNvbnN0IHF5cyA9IGdldFVybFF1ZXJpZXModXJsKVxuXG4gICAgLy8gaWYgdGhlIHF1ZXJ5IGV4aXN0cyBqdXN0IHJlcGxhY2UgaXRcbiAgICBpZiAocXlzLm1hcChxID0+IHEuc3BsaXQoXCI9XCIpWzBdKS5pbmNsdWRlcyhtYXRjaFF1ZXJ5KSkge1xuICAgICAgICByZXR1cm4gcmVwbGFjZVF1ZXJ5VmFsdWUodXJsLCBtYXRjaFF1ZXJ5LCB2YWx1ZSlcbiAgICB9XG5cbiAgICAvLyB0aGUgcXVlcnkgZG9lcyBub3QgZXhpc3Qgc28gYWRkIGl0XG4gICAgcXlzLnB1c2gobWF0Y2hRdWVyeSArIFwiPVwiICsgdmFsdWUpXG4gICAgc2V0VXJsUXVlcmllcyhuZXdVcmwsIHF5cylcblxuICAgIHJldHVybiBuZXdVcmxcbn1cblxuLyoqXG4gKiBSZXBsYWNlIHRoZSB2YWx1ZSBvZiBhIHF1ZXJ5IGluIGEgVVJMIHdpdGggYSBuZXcgb25lXG4gKlxuICogQHBhcmFtIHVybCAgICAgICAgICAgdGhlIFVSTCB0byBhY3Qgb25cbiAqIEBwYXJhbSBtYXRjaFF1ZXJ5ICAgIHRoZSBxdWVyeSBrZXkgdG8gcmVwbGFjZSB0aGUgdmFsdWUgZm9yXG4gKiBAcGFyYW0gbmV3VmFsICAgICAgICB0aGUgbmV3IHZhbHVlIHRvIHVzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZVF1ZXJ5VmFsdWUoXG4gICAgdXJsOiBVUkwsXG4gICAgbWF0Y2hRdWVyeTogc3RyaW5nLFxuICAgIG5ld1ZhbDogc3RyaW5nLFxuKTogVVJMIHtcbiAgICBjb25zdCBuZXdVcmwgPSBuZXcgVVJMKHVybC5ocmVmKVxuXG4gICAgLy8gZ2V0IGVhY2ggcXVlcnkgc2VwYXJhdGVseSwgbGVhdmUgdGhlIFwiP1wiIG9mZlxuICAgIGNvbnN0IHF5cyA9IGdldFVybFF1ZXJpZXModXJsKVxuXG4gICAgY29uc3QgbmV3X3F5cyA9IHF5cy5tYXAocSA9PiB7XG4gICAgICAgIGNvbnN0IFtrZXldID0gcS5zcGxpdChcIj1cIilcblxuICAgICAgICAvLyBmb3VuZCBhIG1hdGNoaW5nIHF1ZXJ5IGtleVxuICAgICAgICBpZiAocS5zcGxpdChcIj1cIilbMF0gPT09IG1hdGNoUXVlcnkpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiBrZXk9dmFsIG9yIGtleSBhcyBuZWVkZWRcbiAgICAgICAgICAgIGlmIChuZXdWYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5ICsgXCI9XCIgKyBuZXdWYWxcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG9uJ3QgdG91Y2ggaXRcbiAgICAgICAgcmV0dXJuIHFcbiAgICB9KVxuXG4gICAgc2V0VXJsUXVlcmllcyhuZXdVcmwsIG5ld19xeXMpXG5cbiAgICByZXR1cm4gbmV3VXJsXG59XG5cbi8qKlxuICogR3JhZnQgYSBuZXcgcGF0aCBvbnRvIHNvbWUgcGFyZW50IG9mIHRoZSBjdXJyZW50IFVSTFxuICpcbiAqIEUuZy4gZ3JhZnRpbmcgXCJieS1uYW1lL2Zvb2JhclwiIG9udG8gdGhlIDJuZCBwYXJlbnQgcGF0aDpcbiAqICAgICAgZXhhbXBsZS5jb20vaXRlbXMvYnktaWQvNDIgLT4gZXhhbXBsZS5jb20vaXRlbXMvYnktbmFtZS9mb29iYXJcbiAqXG4gKiBAcGFyYW0gdXJsICAgICAgIHRoZSBVUkwgdG8gbW9kaWZ5XG4gKiBAcGFyYW0gbmV3VGFpbCAgIHRoZSBuZXcgXCJncmFmdGVkXCIgVVJMIHBhdGggdGFpbFxuICogQHBhcmFtIGxldmVsICAgICB0aGUgZ3JhZnQgcG9pbnQgaW4gdGVybXMgb2YgcGF0aCBsZXZlbHNcbiAqICAgICAgICAgICAgICAgICAgICAgID49IDA6IHN0YXJ0IGF0IC8gYW5kIGNvdW50IHJpZ2h0XG4gKiAgICAgICAgICAgICAgICAgICAgICA8MDogc3RhcnQgYXQgdGhlIGN1cnJlbnQgcGF0aCBhbmQgY291bnQgbGVmdFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ3JhZnRVcmxQYXRoKHVybDogVVJMLCBuZXdUYWlsOiBzdHJpbmcsIGxldmVsOiBudW1iZXIpIHtcbiAgICBjb25zdCBuZXdVcmwgPSBuZXcgVVJMKHVybC5ocmVmKVxuXG4gICAgLy8gcGF0aCBwYXJ0cywgaWdub3JlIGZpcnN0IC9cbiAgICBjb25zdCBwYXRoUGFydHMgPSB1cmwucGF0aG5hbWUuc3BsaXQoXCIvXCIpLnNwbGljZSgxKVxuXG4gICAgLy8gbW9yZSBsZXZlbHMgdGhhbiB3ZSBjYW4gaGFuZGxlXG4gICAgLy8gKHJlbWVtYmVyLCBpZiBsZXZlbCA8MCwgd2Ugc3RhcnQgYXQgLTEpXG4gICAgaWYgKFxuICAgICAgICAobGV2ZWwgPj0gMCAmJiBsZXZlbCA+IHBhdGhQYXJ0cy5sZW5ndGgpIHx8XG4gICAgICAgIChsZXZlbCA8IDAgJiYgLWxldmVsIC0gMSA+IHBhdGhQYXJ0cy5sZW5ndGgpXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgY29uc3QgZ3JhZnRQb2ludCA9IGxldmVsID49IDAgPyBsZXZlbCA6IHBhdGhQYXJ0cy5sZW5ndGggKyBsZXZlbCArIDFcblxuICAgIC8vIGxvcCBvZmYgcGFydHMgYWZ0ZXIgdGhlIGdyYWZ0IHBvaW50XG4gICAgcGF0aFBhcnRzLnNwbGljZShncmFmdFBvaW50LCBwYXRoUGFydHMubGVuZ3RoIC0gZ3JhZnRQb2ludClcblxuICAgIC8vIGV4dGVuZCBwYXJ0IGFycmF5IHdpdGggbmV3IHBhcnRzXG4gICAgcGF0aFBhcnRzLnB1c2goLi4ubmV3VGFpbC5zcGxpdChcIi9cIikpXG5cbiAgICBuZXdVcmwucGF0aG5hbWUgPSBwYXRoUGFydHMuam9pbihcIi9cIilcblxuICAgIHJldHVybiBuZXdVcmxcbn1cblxuLyoqXG4gKiBJbnRlcnBvbGF0ZXMgYSBxdWVyeSBvciBvdGhlciBzZWFyY2ggaXRlbSBpbnRvIGEgVVJMXG4gKlxuICogSWYgdGhlIFVSTCBwYXR0ZXJuIGNvbnRhaW5zIFwiJXNcIiwgdGhlIHF1ZXJ5IGlzIGludGVycG9sYXRlZCB0aGVyZS4gSWYgbm90LFxuICogaXQgaXMgYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiB0aGUgcGF0dGVybi5cbiAqXG4gKiBJZiB0aGUgaW50ZXJwb2xhdGlvbiBwb2ludCBpcyBpbiB0aGUgcXVlcnkgc3RyaW5nIG9mIHRoZSBVUkwsIGl0IGlzXG4gKiBwZXJjZW50IGVuY29kZWQsIG90aGVyd2lzZSBpdCBpcyBpcyBpbnNlcnRlZCB2ZXJiYXRpbS5cbiAqXG4gKiBAcGFyYW0gdXJsUGF0dGVybiAgICAgICAgYSBVUkwgdG8gaW50ZXJwb2xhdGUvYXBwZW5kIGEgcXVlcnkgdG9cbiAqIEBwYXJhbSBxdWVyeSAgICAgICAgICAgICBhIHF1ZXJ5IHRvIGludGVycG9sYXRlL2FwcGVuZCBpbnRvIHRoZSBVUkxcbiAqXG4gKiBAcmV0dXJuICAgICAgICAgICAgICAgICAgdGhlIFVSTCB3aXRoIHRoZSBxdWVyeSBlbmNvZGVkIChpZiBuZWVkZWQpIGFuZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydGVkIGF0IHRoZSByZWxldmFudCBwb2ludFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJwb2xhdGVTZWFyY2hJdGVtKHVybFBhdHRlcm46IFVSTCwgcXVlcnk6IHN0cmluZyk6IFVSTCB7XG4gICAgY29uc3QgaGFzSW50ZXJwb2xhdGlvblBvaW50ID0gdXJsUGF0dGVybi5ocmVmLmluY2x1ZGVzKFwiJXNcIilcblxuICAgIGxldCBxdWVyeVdvcmRzID0gcXVlcnkuc3BsaXQoXCIgXCIpXG5cbiAgICAvLyBwZXJjZW50LWVuY29kZSBpZiB0aGVyZXMgYSAlcyBpbiB0aGUgcXVlcnkgc3RyaW5nLCBvciBpZiB3ZSdyZSBhcHBwZW5kaW5nXG4gICAgLy8gYW5kIHRoZXJlJ3MgYSBxdWVyeSBzdHJpbmdcbiAgICBpZiAoXG4gICAgICAgIChoYXNJbnRlcnBvbGF0aW9uUG9pbnQgJiYgdXJsUGF0dGVybi5zZWFyY2guaW5jbHVkZXMoXCIlc1wiKSkgfHxcbiAgICAgICAgdXJsUGF0dGVybi5zZWFyY2ggIT09IFwiXCJcbiAgICApIHtcbiAgICAgICAgcXVlcnkgPSBlbmNvZGVVUklDb21wb25lbnQocXVlcnkpXG4gICAgICAgIHF1ZXJ5V29yZHMgPSBxdWVyeVdvcmRzLm1hcCh3ID0+IGVuY29kZVVSSUNvbXBvbmVudCh3KSlcbiAgICB9XG5cbiAgICAvLyByZXBsYWNlIG9yIGFwcGVuZCBhcyBuZWVkZWRcbiAgICBpZiAoaGFzSW50ZXJwb2xhdGlvblBvaW50KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdGluZ1VSTCA9IG5ldyBVUkwoXG4gICAgICAgICAgICB1cmxQYXR0ZXJuLmhyZWYucmVwbGFjZSgvJXNcXGQrL2csIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KHguc2xpY2UoMiksIDEwKSAtIDFcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gcXVlcnlXb3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCJcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnlXb3Jkc1tpbmRleF1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICApXG5cbiAgICAgICAgcmV0dXJuIG5ldyBVUkwocmVzdWx0aW5nVVJMLmhyZWYucmVwbGFjZShcIiVzXCIsIHF1ZXJ5KSlcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFVSTCh1cmxQYXR0ZXJuLmhyZWYgKyBxdWVyeSlcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBjb252ZXJ0IGZyb20gXCJAc3JjL2xpYi9jb252ZXJ0XCJcbmltcG9ydCBicm93c2VyUHJveHkgZnJvbSBcIkBzcmMvbGliL2Jyb3dzZXJfcHJveHlcIlxuaW1wb3J0ICogYXMgY29uZmlnIGZyb20gXCJAc3JjL2xpYi9jb25maWdcIlxuaW1wb3J0ICogYXMgVXJsVXRpbCBmcm9tIFwiQHNyYy9saWIvdXJsX3V0aWxcIlxuXG5leHBvcnQgZnVuY3Rpb24gaW5Db250ZW50U2NyaXB0KCkge1xuICAgIHJldHVybiBnZXRDb250ZXh0KCkgPT09IFwiY29udGVudFwiXG59XG5cbi8qKiBXZWJFeHQgY29kZSBjYW4gYmUgcnVuIGZyb20gdGhyZWUgY29udGV4dHM6XG5cbiAgICBDb250ZW50IHNjcmlwdFxuICAgIEV4dGVuc2lvbiBwYWdlXG4gICAgQmFja2dyb3VuZCBwYWdlXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gICAgaWYgKCFicm93c2VyLnRhYnMpIHtcbiAgICAgICAgcmV0dXJuIFwiY29udGVudFwiXG4gICAgfSBlbHNlIGlmIChcbiAgICAgICAgYnJvd3Nlci5ydW50aW1lLmdldFVSTChcIl9nZW5lcmF0ZWRfYmFja2dyb3VuZF9wYWdlLmh0bWxcIikgPT09XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBcImJhY2tncm91bmRcIlxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcImV4dGVuc2lvblwiXG4gICAgfVxufVxuXG5leHBvcnQgbGV0IGJyb3dzZXJCZ1xuXG4vLyBNYWtlIHRoaXMgbGlicmFyeSB3b3JrIGZvciBib3RoIGNvbnRlbnQgYW5kIGJhY2tncm91bmQuXG5pZiAoaW5Db250ZW50U2NyaXB0KCkpIHtcbiAgICBicm93c2VyQmcgPSBicm93c2VyUHJveHlcbn0gZWxzZSB7XG4gICAgYnJvd3NlckJnID0gYnJvd3NlclxufVxuXG4vKiogVGhlIGZpcnN0IGFjdGl2ZSB0YWIgaW4gdGhlIGN1cnJlbnRXaW5kb3cuXG4gKlxuICogVE9ETzogSGlnaGxhbmRlciB0aGVvcnk6IENhbiB0aGVyZSBldmVyIGJlIG1vcmUgdGhhbiBvbmU/XG4gKlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWN0aXZlVGFiKCkge1xuICAgIHJldHVybiAoYXdhaXQgYnJvd3NlckJnLnRhYnMucXVlcnkoe1xuICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICAgIGN1cnJlbnRXaW5kb3c6IHRydWUsXG4gICAgfSkpWzBdXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhY3RpdmVUYWJJZCgpIHtcbiAgICByZXR1cm4gKGF3YWl0IGFjdGl2ZVRhYigpKS5pZFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWN0aXZlVGFiQ29udGFpbmVySWQoKSB7XG4gICAgcmV0dXJuIChhd2FpdCBhY3RpdmVUYWIoKSkuY29va2llU3RvcmVJZFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gb3duVGFiKCkge1xuICAgIC8vIFdhcm5pbmc6IHRoaXMgcmVsaWVzIG9uIHRoZSBvd250YWJfYmFja2dyb3VuZCBsaXN0ZW5lciBiZWluZyBzZXQgaW4gbWVzc2FnaW5nLnRzIGluIG9yZGVyIHRvIHdvcmtcbiAgICByZXR1cm4gYnJvd3Nlci5ydW50aW1lLnNlbmRNZXNzYWdlKHsgdHlwZTogXCJvd250YWJfYmFja2dyb3VuZFwiIH0pXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBvd25UYWJJZCgpIHtcbiAgICByZXR1cm4gKGF3YWl0IG93blRhYigpKS5pZFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gb3duVGFiQ29udGFpbmVyKCkge1xuICAgIHJldHVybiBicm93c2VyQmcuY29udGV4dHVhbElkZW50aXRpZXMuZ2V0KChhd2FpdCBvd25UYWIoKSkuY29va2llU3RvcmVJZClcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFjdGl2ZVRhYkNvbnRhaW5lcigpIHtcbiAgICBjb25zdCBjb250YWluZXJJZCA9IGF3YWl0IGFjdGl2ZVRhYkNvbnRhaW5lcklkKClcbiAgICBpZiAoY29udGFpbmVySWQgIT09IFwiZmlyZWZveC1kZWZhdWx0XCIpXG4gICAgICAgIHJldHVybiBicm93c2VyQmcuY29udGV4dHVhbElkZW50aXRpZXMuZ2V0KGNvbnRhaW5lcklkKVxuICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJmaXJlZm94LWRlZmF1bHQgaXMgbm90IGEgdmFsaWQgY29udGV4dHVhbElkZW50aXR5IChhY3RpdmVUYWJDb250YWluZXIpXCIsXG4gICAgICAgIClcbn1cblxuLyoqIENvbXBhcmUgbWFqb3IgZmlyZWZveCB2ZXJzaW9ucyAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZpcmVmb3hWZXJzaW9uQXRMZWFzdChkZXNpcmVkbWFqb3I6IG51bWJlcikge1xuICAgIGNvbnN0IHZlcnNpb25zdHIgPSAoYXdhaXQgYnJvd3NlckJnLnJ1bnRpbWUuZ2V0QnJvd3NlckluZm8oKSkudmVyc2lvblxuICAgIGNvbnN0IGFjdHVhbG1ham9yID0gY29udmVydC50b051bWJlcih2ZXJzaW9uc3RyLnNwbGl0KFwiLlwiKVswXSlcbiAgICByZXR1cm4gYWN0dWFsbWFqb3IgPj0gZGVzaXJlZG1ham9yXG59XG5cbi8qKiBTaW1wbGVyIHRhYnMuY3JlYXRlIG9wdGlvbi5cblxuICAgIElmIHJlbGF0ZWQgPSB0cnVlICYmIHJlbGF0ZWRvcGVucG9zID0gJ3JlbGF0ZWQnIHRoZW4gb3BlbiBhIG5ldyB0YWIgd2l0aFxuICAgIHNvbWUgVVJMIGFzIGlmIHRoYXQgVVJMIGhhZCBiZWVuIG1pZGRsZSBjbGlja2VkIG9uIHRoZSBjdXJyZW50IHRhYi4gSWZcbiAgICByZWxhdGVkb3BlbnBvcyA9ICduZXh0Jywgb3BlbiBpdCBhcyB0aGUgbmV4dCB0YWIuIElmICdsYXN0Jywgb3BlbiBpdCBsYXN0XG4gICAgYW5kIGRvbid0IHRlbGwgRmlyZWZveCB3aG8gb3BlbmVkIGl0LlxuXG4gICAgU2ltaWxhcmx5IGZvciB0YWJvcGVucG9zLCBidXQgb25seSB0ZWxsIEZGIHRoYXQgdGhlIG5ld3RhYiBpcyByZWxhdGVkIHRvXG4gICAgdGhlIGFjdGl2ZVRhYiBpZiB0YWJvcGVucG9zID09ICdyZWxhdGVkJy5cblxuICAgIGkuZS4gcGxhY2UgdGhhdCB0YWIganVzdCBhZnRlciB0aGUgY3VycmVudCB0YWIgYW5kIHNldCBvcGVuZXJUYWJJZFxuKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBvcGVuSW5OZXdUYWIoXG4gICAgdXJsOiBzdHJpbmcsXG4gICAga3dhcmdzOiB7IGFjdGl2ZT87IHJlbGF0ZWQ/OyBjb29raWVTdG9yZUlkPyB9ID0ge1xuICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICAgIHJlbGF0ZWQ6IGZhbHNlLFxuICAgICAgICBjb29raWVTdG9yZUlkOiB1bmRlZmluZWQsXG4gICAgfSxcbikge1xuICAgIGNvbnN0IHRoaXNUYWIgPSBhd2FpdCBhY3RpdmVUYWIoKVxuICAgIGNvbnN0IG9wdGlvbnM6IGFueSA9IHtcbiAgICAgICAgYWN0aXZlOiBrd2FyZ3MuYWN0aXZlLFxuICAgICAgICB1cmwsXG4gICAgICAgIGNvb2tpZVN0b3JlSWQ6IGt3YXJncy5jb29raWVTdG9yZUlkLFxuICAgIH1cblxuICAgIC8vIEJlIG5pY2UgdG8gYmVocm1hbm4sICMzNDJcbiAgICBsZXQgcG9zXG4gICAgaWYgKGt3YXJncy5yZWxhdGVkKSBwb3MgPSBjb25maWcuZ2V0KFwicmVsYXRlZG9wZW5wb3NcIilcbiAgICBlbHNlIHBvcyA9IGNvbmZpZy5nZXQoXCJ0YWJvcGVucG9zXCIpXG4gICAgc3dpdGNoIChwb3MpIHtcbiAgICAgICAgY2FzZSBcIm5leHRcIjpcbiAgICAgICAgICAgIG9wdGlvbnMuaW5kZXggPSB0aGlzVGFiLmluZGV4ICsgMVxuICAgICAgICAgICAgaWYgKGt3YXJncy5yZWxhdGVkICYmIChhd2FpdCBmaXJlZm94VmVyc2lvbkF0TGVhc3QoNTcpKSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9wZW5lclRhYklkID0gdGhpc1RhYi5pZFxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSBcImxhc3RcIjpcbiAgICAgICAgICAgIC8vIEluZmluaXR5IGNhbid0IGJlIHNlcmlhbGlzZWQsIGFwcGFyZW50bHkuXG4gICAgICAgICAgICBvcHRpb25zLmluZGV4ID0gKGF3YWl0IGJyb3dzZXJCZy50YWJzLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICBjdXJyZW50V2luZG93OiB0cnVlLFxuICAgICAgICAgICAgfSkpLmxlbmd0aFxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSBcInJlbGF0ZWRcIjpcbiAgICAgICAgICAgIGlmIChhd2FpdCBmaXJlZm94VmVyc2lvbkF0TGVhc3QoNTcpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vcGVuZXJUYWJJZCA9IHRoaXNUYWIuaWRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5pbmRleCA9IHRoaXNUYWIuaW5kZXggKyAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgIH1cblxuICAgIHJldHVybiBicm93c2VyQmcudGFicy5jcmVhdGUob3B0aW9ucylcbn1cblxuLy8gbGF6aWx5IGNvcGllZCBmcm9tIGV4Y21kcy50cycgd2lub3BlbiAtIGZvcmNlVVJJIHJlYWxseSBvdWdodCB0byBiZSBtb3ZlZCB0byBsaWIvd2ViZXh0XG4vLyBTaG91bGQgY29uc2lkZXIgY2hhbmdpbmcgaW50ZXJmYWNlIG9mIHRoaXMgdG8gbWF0Y2ggb3BlbkluTmV3VGFiIG9yIHZpY2UgdmVyc2FcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBvcGVuSW5OZXdXaW5kb3coY3JlYXRlRGF0YSA9IHt9KSB7XG4gICAgYnJvd3NlckJnLndpbmRvd3MuY3JlYXRlKGNyZWF0ZURhdGEpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBvcGVuSW5UYWIodGFiLCBvcHRzID0ge30sIHN0cmFycjogc3RyaW5nW10pIHtcbiAgICBsZXQgYWRkcmVzcyA9IHN0cmFyci5qb2luKFwiIFwiKVxuXG4gICAgaWYgKGFkZHJlc3MgPT09IFwiXCIpIHtcbiAgICAgICAgYWRkcmVzcyA9IGNvbmZpZy5nZXQoXCJuZXd0YWJcIilcbiAgICB9XG5cbiAgICBjb25zdCBpbmRleCA9IGFkZHJlc3MuaW5kZXhPZihcIiBcIilcbiAgICBsZXQgZmlyc3RXb3JkID0gYWRkcmVzc1xuICAgIGlmIChpbmRleCA+IC0xKSBmaXJzdFdvcmQgPSBhZGRyZXNzLnN1YnN0cigwLCBpbmRleClcblxuICAgIGlmIChmaXJzdFdvcmQgPT09IFwiXCIpIHtcbiAgICAgICAgLy8gTm8gcXVlcnksIG5vIG5ld3RhYiBzZXQsIHRoZSB1c2VyIGlzIGFza2luZyBmb3IgVHJpZGFjdHlsJ3MgbmV3dGFiIHBhZ2VcbiAgICAgICAgcmV0dXJuIGJyb3dzZXJCZy50YWJzLnVwZGF0ZShcbiAgICAgICAgICAgIHRhYi5pZCxcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oeyB1cmw6IFwiL3N0YXRpYy9uZXd0YWIuaHRtbFwiIH0sIG9wdHMpLFxuICAgICAgICApXG4gICAgfVxuXG4gICAgLy8gUGVyaGFwcyB0aGUgdXNlciB0eXBlZCBhIFVSTD9cbiAgICBpZiAoL15bYS16QS1aMC05Ky4tXSs6W15cXHM6XS8udGVzdChhZGRyZXNzKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGJyb3dzZXJCZy50YWJzLnVwZGF0ZShcbiAgICAgICAgICAgICAgICB0YWIuaWQsXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7IHVybDogbmV3IFVSTChhZGRyZXNzKS5ocmVmIH0sIG9wdHMpLFxuICAgICAgICAgICAgKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBOb3QgYSBwcm9ibGVtLCB3ZSdsbCB0cmVhdCBhZGRyZXNzIGFzIGEgcmVndWxhciBzZWFyY2ggcXVlcnlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGArIDFgIGJlY2F1c2Ugd2Ugd2FudCB0byBnZXQgcmlkIG9mIHRoZSBzcGFjZVxuICAgIGNvbnN0IHJlc3QgPSBhZGRyZXNzLnN1YnN0cihmaXJzdFdvcmQubGVuZ3RoICsgMSlcbiAgICBjb25zdCBzZWFyY2h1cmxzID0gY29uZmlnLmdldChcInNlYXJjaHVybHNcIilcbiAgICBpZiAoc2VhcmNodXJsc1tmaXJzdFdvcmRdKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IFVybFV0aWwuaW50ZXJwb2xhdGVTZWFyY2hJdGVtKFxuICAgICAgICAgICAgbmV3IFVSTChzZWFyY2h1cmxzW2ZpcnN0V29yZF0pLFxuICAgICAgICAgICAgcmVzdCxcbiAgICAgICAgKVxuICAgICAgICAvLyBmaXJzdFdvcmQgaXMgYSBzZWFyY2h1cmwsIHNvIGxldCdzIHVzZSB0aGF0XG4gICAgICAgIHJldHVybiBicm93c2VyQmcudGFicy51cGRhdGUoXG4gICAgICAgICAgICB0YWIuaWQsXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHsgdXJsOiB1cmwuaHJlZiB9LCBvcHRzKSxcbiAgICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IHNlYXJjaEVuZ2luZXMgPSBhd2FpdCBicm93c2VyQmcuc2VhcmNoLmdldCgpXG4gICAgbGV0IGVuZ2luZSA9IHNlYXJjaEVuZ2luZXMuZmluZChlbmdpbmUgPT4gZW5naW5lLmFsaWFzID09PSBmaXJzdFdvcmQpXG4gICAgLy8gTWF5YmUgZmlyc3RXb3JkIGlzIHRoZSBuYW1lIG9mIGEgZmlyZWZveCBzZWFyY2ggZW5naW5lP1xuICAgIGlmIChlbmdpbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gYnJvd3NlckJnLnNlYXJjaC5zZWFyY2goe1xuICAgICAgICAgICAgdGFiSWQ6IHRhYi5pZCxcbiAgICAgICAgICAgIGVuZ2luZTogZW5naW5lLm5hbWUsXG4gICAgICAgICAgICBxdWVyeTogcmVzdCxcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBNYXliZSBpdCdzIGEgZG9tYWluIHdpdGhvdXQgcHJvdG9jb2xcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKFwiaHR0cDovL1wiICsgYWRkcmVzcylcbiAgICAgICAgLy8gSWdub3JlIHVubGlrZWx5IGRvbWFpbnNcbiAgICAgICAgaWYgKHVybC5ob3N0bmFtZS5pbmNsdWRlcyhcIi5cIikgfHwgdXJsLnBvcnQgfHwgdXJsLnBhc3N3b3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gYnJvd3NlckJnLnRhYnMudXBkYXRlKFxuICAgICAgICAgICAgICAgIHRhYi5pZCxcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHsgdXJsOiB1cmwuaHJlZiB9LCBvcHRzKSxcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAvLyBMZXQncyBkZWZhdWx0IHRvIHRoZSB1c2VyJ3Mgc2VhcmNoIGVuZ2luZSB0aGVuXG5cbiAgICAvLyBpZiBmaXJzdFdvcmQgaXMgXCJzZWFyY2hcIiwgcmVtb3ZlIGl0IGZyb20gdGhlIHF1ZXJ5LlxuICAgIC8vIFRoaXMgYWxsb3dzIHVzZXJzIHRvIHNlYXJjaCBmb3IgYSBVUkwgb3IgYSB3b3JkIHRoZXkgZGVmaW5lZCBhcyBzZWFyY2h1cmxcbiAgICBsZXQgcXVlcnlTdHJpbmcgPSBhZGRyZXNzXG4gICAgaWYgKGZpcnN0V29yZCA9PT0gXCJzZWFyY2hcIikge1xuICAgICAgICBxdWVyeVN0cmluZyA9IHJlc3RcbiAgICB9XG5cbiAgICBjb25zdCBlbmdpbmVuYW1lID0gY29uZmlnLmdldChcInNlYXJjaGVuZ2luZVwiKVxuICAgIC8vIGZpcnN0V29yZCBpcyBuZWl0aGVyIGEgc2VhcmNodXJsIG5vciBhIHNlYXJjaCBlbmdpbmUsIGxldCdzIHNlZSBpZiBhIHNlYXJjaCBlbmdpbmUgaGFzIGJlZW4gZGVmaW5lZCBpbiBUcmlkYWN0eWxcbiAgICBpZiAoZW5naW5lbmFtZSkge1xuICAgICAgICBpZiAoc2VhcmNodXJsc1tlbmdpbmVuYW1lXSkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gVXJsVXRpbC5pbnRlcnBvbGF0ZVNlYXJjaEl0ZW0oXG4gICAgICAgICAgICAgICAgbmV3IFVSTChzZWFyY2h1cmxzW2VuZ2luZW5hbWVdKSxcbiAgICAgICAgICAgICAgICBxdWVyeVN0cmluZyxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiBicm93c2VyQmcudGFicy51cGRhdGUoXG4gICAgICAgICAgICAgICAgdGFiLmlkLFxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oeyB1cmw6IHVybC5ocmVmIH0sIG9wdHMpLFxuICAgICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgZW5naW5lID0gc2VhcmNoRW5naW5lcy5maW5kKGVuZ2luZSA9PiBlbmdpbmUuYWxpYXMgPT09IGVuZ2luZW5hbWUpXG4gICAgICAgIGlmIChlbmdpbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJyb3dzZXJCZy5zZWFyY2guc2VhcmNoKHtcbiAgICAgICAgICAgICAgICB0YWJJZDogdGFiLmlkLFxuICAgICAgICAgICAgICAgIGVuZ2luZTogZW5naW5lLm5hbWUsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5U3RyaW5nLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vIHNlYXJjaCBlbmdpbmUgaGFzIGJlZW4gZGVmaW5lZCBpbiBUcmlkYWN0eWwsIGxldCdzIHVzZSBmaXJlZm94J3MgZGVmYXVsdCBzZWFyY2ggZW5naW5lXG4gICAgcmV0dXJuIGJyb3dzZXJCZy5zZWFyY2guc2VhcmNoKHsgdGFiSWQ6IHRhYi5pZCwgcXVlcnk6IHF1ZXJ5U3RyaW5nIH0pXG59XG4iLCIvKiogVHJpZGFjdHlsIGhlbHBlciBtb2RlICovXG5cbmltcG9ydCAqIGFzIGNvbmZpZyBmcm9tIFwiQHNyYy9saWIvY29uZmlnXCJcbmltcG9ydCAqIGFzIGtleXNlcSBmcm9tIFwiQHNyYy9saWIva2V5c2VxXCJcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlcihjb25mLCBrZXlzKToga2V5c2VxLlBhcnNlclJlc3BvbnNlIHtcbiAgICBsZXQgbWFwczogYW55ID0gY29uZmlnLmdldChjb25mKVxuICAgIGlmIChtYXBzID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihcIk5vIGJpbmRzIGRlZmluZWQgZm9yIHRoaXMgbW9kZS4gUmVsb2FkIHBhZ2Ugd2l0aCA8Qy1yPiBhbmQgYWRkIGJpbmRzLCBlLmcuIDpiaW5kIC0tbW9kZT1bbW9kZV0gPEVzYz4gbW9kZSBub3JtYWxcIilcblxuICAgIC8vIElmIHNvIGNvbmZpZ3VyZWQsIHRyYW5zbGF0ZSBrZXlzIHVzaW5nIHRoZSBrZXkgdHJhbnNsYXRpb24gbWFwXG4gICAgaWYgKGNvbmZpZy5nZXQoXCJrZXl0cmFuc2xhdGVtb2Rlc1wiKVtjb25mXSA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgY29uc3QgdHJhbnNsYXRpb25tYXAgPSBjb25maWcuZ2V0KFwia2V5dHJhbnNsYXRlbWFwXCIpXG4gICAgICAgIGtleXNlcS50cmFuc2xhdGVLZXlzVXNpbmdLZXlUcmFuc2xhdGVNYXAoa2V5cywgdHJhbnNsYXRpb25tYXApXG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIHVuYm91bmQga2V5c1xuICAgIG1hcHMgPSBPYmplY3QuZW50cmllcyhtYXBzKS5maWx0ZXIoKFtrLCB2XSkgPT4gdiAhPT0gXCJcIilcbiAgICAvLyBDb252ZXJ0IHRvIEtleU1hcFxuICAgIG1hcHMgPSBrZXlzZXEubWFwc3RyTWFwVG9LZXlNYXAobmV3IE1hcChtYXBzKSlcblxuICAgIHJldHVybiBrZXlzZXEucGFyc2Uoa2V5cywgbWFwcylcbn1cbiIsIi8qKlxuICogTGlicmFyeSB1c2VkIGZvciBtZWFzdXJpbmcgcGVyZm9ybWFuY2UuIFRoZSBiYXNpYyBzdGVwcyBhcmUgYXMgZm9sbG93czpcbiAqXG4gKiAxLiBTZXQgdXAgYSBwZXJzaXN0ZW50IFN0YXRzTG9nZ2VyIG9iamVjdCB0byBzdG9yZSBzYW1wbGVzLlxuICogMi4gSW52b2tlIGxpc3RlbkZvckNvdW50ZXJzIHdpdGggdGhlIFN0YXRzTG9nZ2VyIHRvIHN0YXJ0IGxvZ2dpbmdcbiAqICAgIHBlcmZvcm1hbmNlIGNvdW50ZXJzIHRvIHRoZSBzdGF0cyBsb2dnZXIuXG4gKiAzLiBJZiB5b3UgaGF2ZSBvdGhlciBzY3JpcHRzIChjb250ZW50LCBpZnJhbWVzLCB3ZWIgd29ya2VycywgZXRjKSxcbiAqICAgIHNldCB1cCB0byByZWNlaXZlIHN0YXRzIGZyb20gdGhvc2Ugb3RoZXIgc291cmNlczpcbiAqICAgICogU2V0IHRoZSBzdGF0cyBsb2dnZXIgdXAgd2l0aCBhbiBhdHRyaWJ1dGVDYWxsZXIgcmVjZWl2aW5nIG1lc3NhZ2VzIGFzXG4gKiAgICAgIFwicGVyZm9ybWFuY2VfYmFja2dyb3VuZFwiLlxuICogICAgKiBGb3IgZWFjaCBvdGhlciBjb250ZXh0LCBpbnZva2UgbGlzdGVuRm9yQ291bnRlcnMgd2l0aG91dCBhcmd1bWVudHMgYW5kXG4gKiAgICAgIGhvbGQgb24gdG8gdGhlIHJlc3VsdGluZyBvYmplY3QuXG4gKiA0LiBJbnN0cnVtZW50IG1ldGhvZHMgdXNpbmcgdGhlIEBtZWFzdXJlZCBvciBAbWVhc3VyZWRBc3luY1xuICogICAgZGVjb3JhdG9ycyAoZm9yIGNsYXNzIG1ldGhvZHMpIG9yIGJ5IHVzaW5nIE1hcmtlciBvYmplY3RzIGluXG4gKiAgICB5b3VyIGZ1bmN0aW9ucy5cbiAqIDUuIENvbGxlY3QgZGF0YSFcbiAqIDYuIFVzZSBnZXRFbnRyaWVzIHRvIHJldHJpZXZlIGRhdGEgZnJvbSB0aGUgc3RhdHNMb2dnZXIuXG4gKi9cblxuaW1wb3J0ICogYXMgbWVzc2FnaW5nIGZyb20gXCJAc3JjL2xpYi9tZXNzYWdpbmdcIlxuaW1wb3J0ICogYXMgY29uZmlnIGZyb20gXCJAc3JjL2xpYi9jb25maWdcIlxuaW1wb3J0ICogYXMgbWF0aCBmcm9tIFwiQHNyYy9saWIvbWF0aFwiXG5pbXBvcnQgKiBhcyBsb2dnaW5nIGZyb20gXCJAc3JjL2xpYi9sb2dnaW5nXCJcblxuY29uc3QgbG9nZ2VyID0gbmV3IGxvZ2dpbmcuTG9nZ2VyKFwicGVyZm9ybWFuY2VcIilcblxuLyoqXG4gKiBEZWNvcmF0b3IgZm9yIHBlcmZvcm1hbmNlIG1lYXN1cmluZy4gSWYgcGVyZm9ybWFuY2UgaXMgZW5hYmxlZCxcbiAqIHdyYXBzIHRoZSBmdW5jdGlvbiBjYWxsIHdpdGggcGVyZm9ybWFuY2UgbWFya3MgYW5kIGEgbWVhc3VyZSB0aGF0XG4gKiBjYW4gYmUgdXNlZCBmb3IgcHJvZmlsaW5nLiBUaGUgbWFyaydzIG93bmVyTmFtZSB3aWxsIGJlIHRoZSBuYW1lIG9mXG4gKiB0aGUgY29udGFpbmluZyBjbGFzcyBhbmQgdGhlIGZ1bmN0aW9uTmFtZSB3aWxsIGJlIHRoZSBuYW1lIG9mIHRoZVxuICogZnVuY3Rpb24uIEZvciBleGFtcGxlOlxuICpcbiAqIGNsYXNzIEZvbyB7XG4gKiAgIEBQZXJmLm1lYXN1cmVkXG4gKiAgIGZ1bmN0aW9uIGRvRm9vcygpIHsgc3R1ZmYoKSB9XG4gKiB9XG4gKlxuICogVGhlc2UgY291bnRlcnMgY2FuIGJlIG9idGFpbmVkIHVzaW5nIGxpc3RlbkZvckNvdW50ZXJzIGFuZCBhXG4gKiBTdGF0c0xvZ2dlci5cbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZWFzdXJlZChcbiAgICBjbHM6IGFueSxcbiAgICBwcm9wZXJ0eUtleTogc3RyaW5nLFxuICAgIGRlc2NyaXB0b3I6IFByb3BlcnR5RGVzY3JpcHRvcixcbik6IFByb3BlcnR5RGVzY3JpcHRvciB7XG4gICAgaWYgKCFwZXJmb3JtYW5jZUFwaUF2YWlsYWJsZSgpKSByZXR1cm5cblxuICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gZGVzY3JpcHRvci52YWx1ZVxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbih0aGlzLCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IG1hcmtlciA9IG5ldyBNYXJrZXIoY2xzLmNvbnN0cnVjdG9yLm5hbWUsIHByb3BlcnR5S2V5KS5zdGFydCgpXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG9yaWdpbmFsTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAgIG1hcmtlci5lbmQoKVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICAgIHJldHVybiBkZXNjcmlwdG9yXG59XG5cbi8qKlxuICogTGlrZSB0aGUgQG1lYXN1cmVkIGRlY29yYXRvciwgYnV0IHByb3Blcmx5IGhhbmRsZXMgYXN5bmMgZnVuY3Rpb25zXG4gKiBieSBjaGFpbmluZyBhIHJlc29sdXRpb24gb250byB0aGUgcHJvbWlzZSB0aGF0IG1hcmtzIGNvbXBsZXRpb25cbiAqIHdoZW4gdGhlIGZ1bmN0aW9uIHJlc29sdmVzIGl0cyBwcm9taXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVhc3VyZWRBc3luYyhcbiAgICBjbHM6IGFueSxcbiAgICBwcm9wZXJ0eUtleTogc3RyaW5nLFxuICAgIGRlc2NyaXB0b3I6IFByb3BlcnR5RGVzY3JpcHRvcixcbik6IFByb3BlcnR5RGVzY3JpcHRvciB7XG4gICAgaWYgKCFwZXJmb3JtYW5jZUFwaUF2YWlsYWJsZSgpKSByZXR1cm5cblxuICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gZGVzY3JpcHRvci52YWx1ZVxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBhc3luYyBmdW5jdGlvbih0aGlzLCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IG1hcmtlciA9IG5ldyBNYXJrZXIoY2xzLmNvbnN0cnVjdG9yLm5hbWUsIHByb3BlcnR5S2V5KS5zdGFydCgpXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG9yaWdpbmFsTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAgIG1hcmtlci5lbmQoKVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICAgIHJldHVybiBkZXNjcmlwdG9yXG59XG5cbi8qKlxuICogQ29udmVuaWVuY2Ugb2JqZWN0IGZvciBjb2xsZWN0aW5nIHRpbWluZyBpbmZvcm1hdGlvbi4gQ3JlYXRlIGl0IGFuZFxuICogY2FsbCBzdGFydCgpIHRvIGNyZWF0ZSBhIG1hcmsgZW50cnkgZm9yIHRoZSBzdGFydCBvZiB0aGUgZHVyYXRpb25cbiAqIHRvIG1lYXN1cmUuIExhdGVyLCBjYWxsIGVuZCgpIHRvIGNyZWF0ZSBhIG1hcmsgZW50cnkgZm9yIHRoZSBlbmQgb2ZcbiAqIHRoZSBkdXJhdGlvbiBhbmQgYSBtZWFzdXJlIGVudHJ5IGZvciB0aGUgZHVyYXRpb24gZnJvbSB0aGUgc3RhcnRcbiAqIG1hcmsgdG8gdGhlIGVuZCBtYXJrLiBNYXJrcyBhcmUgZ2l2ZW4gYSB1bmlxdWUgaWRlbnRpZmllciB0byBlbnN1cmVcbiAqIHRoYXQgYXN5bmMsIG11bHRpLXRocmVhZGVkLCBvciByZWVudHJhbnQgY29kZSBkb2Vzbid0IGhhdmUgY29sbGlzaW9ucy5cbiAqXG4gKiBXQVJOSU5HISBXaWxsIFNJTEVOVExZIERFQUNUSVZBVEUgSVRTRUxGIGlmIHRoZSBcInBlcmZjb3VudGVyc1wiXG4gKiBjb25maWcgb3B0aW9uIGlzIG5vdCBzZXQgdG8gXCJ0cnVlXCIhIFRoaXMgaXMgZG9uZSB0byBtaW5pbWl6ZSB0aGVcbiAqIHBlcmZvcm1hbmNlIG92ZXJoZWFkIG9mIGluc3RydW1lbnRhdGlvbiB3aGVuIHBlcmZvcm1hbmNlIGNvdW50ZXJzXG4gKiBhcmUgdHVybmVkIG9mZi5cbiAqXG4gKiBUaGUgb3duZXJOYW1lIGFuZCBmdW5jdGlvbk5hbWUgYXJlIGVuY29kZWQgaW50byB0aGUgbmFtZSBvZiB0aGVcbiAqIHBlcmZvcm1hbmNlIGVudHJ5IGluIGEgd2F5IHRoYXQgYWxsb3dzIGVudHJpZXMgdG8gYmUgcmV0cmlldmVkXG4gKiB1c2luZyBTdGF0c0ZpbHRlcnMuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgTWFya2VyIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgb3duZXJOYW1lOiBzdHJpbmcsXG4gICAgICAgIGZ1bmN0aW9uTmFtZTogc3RyaW5nLFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IGFjdGl2ZTogYm9vbGVhbiA9IHBlcmZvcm1hbmNlQXBpQXZhaWxhYmxlKCkgJiZcbiAgICAgICAgICAgIGNvbmZpZy5nZXQoXCJwZXJmY291bnRlcnNcIikgPT09IFwidHJ1ZVwiLFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IG1ldHJpY05hbWU6IE1ldHJpY05hbWUgPSBuZXcgTWV0cmljTmFtZShcbiAgICAgICAgICAgIG93bmVyTmFtZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgKSxcbiAgICApIHt9XG5cbiAgICBwdWJsaWMgc3RhcnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpIHJldHVybiB0aGlzXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICAgIFwiTWFya2luZyBzdGFydHBvaW50IG9mIHBlcmZvcm1hbmNlIGNvdW50ZXIgZm9yICVvXCIsXG4gICAgICAgICAgICB0aGlzLm1ldHJpY05hbWUsXG4gICAgICAgIClcbiAgICAgICAgcGVyZm9ybWFuY2UubWFyayh0aGlzLm1ldHJpY05hbWUuc3RhcnROYW1lKVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHB1YmxpYyBlbmQoKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpIHJldHVybiB0aGlzXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICAgIFwiTWFya2luZyBlbmRwb2ludCBvZiBwZXJmb3JtYW5jZSBjb3VudGVyIGZvciAlb1wiLFxuICAgICAgICAgICAgdGhpcy5tZXRyaWNOYW1lLFxuICAgICAgICApXG4gICAgICAgIHBlcmZvcm1hbmNlLm1hcmsodGhpcy5tZXRyaWNOYW1lLmVuZE5hbWUpXG4gICAgICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoXG4gICAgICAgICAgICB0aGlzLm1ldHJpY05hbWUuZnVsbE5hbWUsXG4gICAgICAgICAgICB0aGlzLm1ldHJpY05hbWUuc3RhcnROYW1lLFxuICAgICAgICAgICAgdGhpcy5tZXRyaWNOYW1lLmVuZE5hbWUsXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG59XG5cbi8qKlxuICogU3RhcnQgbGlzdGVuaW5nIGZvciBwZXJmb3JtYW5jZSBjb3VudGVycy4gTm90ZSB0aGF0IHlvdSBfbXVzdF9cbiAqIGF0dGFjaCB0aGUgcmV0dXJuZWQgUGVyZm9ybWFuY2VPYnNlcnZlciB0byBzb21lIGxvbmctbGl2ZWQgb2JqZWN0XG4gKiBsaWtlIHRoZSB3aW5kb3c7IHRoZXJlJ3Mgc29tZSBraW5kIG9mIGJ1ZyB0aGF0IGNhdXNlc1xuICogUGVyZm9ybWFuY2VPYnNlcnZlcnMgdG8gYmUgaW5jb3JyZWN0bHkgZ2FyYmFnZS1jb2xsZWN0ZWQgZXZlbiBpZlxuICogdGhleSdyZSBzdGlsbCBhdHRhY2hlZCBhbmQgb2JzZXJ2aW5nLlxuICpcbiAqIEBwYXJhbSBzdGF0c0xvZ2dlciBJZiBnaXZlbiwgc3RhdHMgd2lsbCBiZSBsb2dnZWQgZGlyZWN0bHkgdG8gdGhlXG4gKiBnaXZlbiBzdGF0cyBsb2dnZXIuIElmIGFic2VudCwgc3RhdHMgd2lsbCBiZSBzZW50IHRvIHRoZVxuICogcGVyZm9ybWFuY2VfYmFja2dyb3VuZCByZWNlaXZlciB1c2luZyBtZXNzYWdpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW5Gb3JDb3VudGVycyhcbiAgICBzdGF0c0xvZ2dlcj86IFN0YXRzTG9nZ2VyLFxuKTogUGVyZm9ybWFuY2VPYnNlcnZlciB7XG4gICAgbGV0IGNhbGxiYWNrOiAoXG4gICAgICAgIGxpc3Q6IFBlcmZvcm1hbmNlT2JzZXJ2ZXJFbnRyeUxpc3QsXG4gICAgICAgIG9ic2VydmVyOiBQZXJmb3JtYW5jZU9ic2VydmVyLFxuICAgICkgPT4gdm9pZFxuICAgIGlmIChzdGF0c0xvZ2dlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbGxiYWNrID0gKGxpc3QsIG9ic2VydmVyKSA9PiB7XG4gICAgICAgICAgICBzZW5kU3RhdHMobGlzdC5nZXRFbnRyaWVzKCkpXG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayA9IChsaXN0LCBvYnNlcnZlcikgPT4ge1xuICAgICAgICAgICAgc3RhdHNMb2dnZXIucHVzaExpc3QobGlzdC5nZXRFbnRyaWVzKCkpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwZXJmT2JzZXJ2ZXIgPSBuZXcgUGVyZm9ybWFuY2VPYnNlcnZlcihjYWxsYmFjaylcbiAgICBwZXJmT2JzZXJ2ZXIub2JzZXJ2ZSh7IGVudHJ5VHlwZXM6IFtcIm1hcmtcIiwgXCJtZWFzdXJlXCJdIH0pXG4gICAgcmV0dXJuIHBlcmZPYnNlcnZlclxufVxuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIGZpbHRlcmluZyBwZXJmb3JtYW5jZSBzYW1wbGVzLlxuICovXG5leHBvcnQgdHlwZSBTdGF0c0ZpbHRlckNvbmZpZyA9XG4gICAgLy8gYSBmaWx0ZXIgd2l0aCBraW5kIGZ1bmN0aW9uTmFtZSBwZXJtaXRzIG9ubHkgc2FtcGxlcyB3aXRoXG4gICAgLy8gZnVuY3Rpb25OYW1lIGVxdWFsIHRvIHRoZSBnaXZlbiBmdW5jdGlvbk5hbWUuXG4gICAgfCB7IGtpbmQ6IFwiZnVuY3Rpb25OYW1lXCI7IGZ1bmN0aW9uTmFtZTogc3RyaW5nIH1cbiAgICAvLyBhIGZpbHRlciB3aXRoIGtpbmQgb3duZXJOYW1lIHBlcm1pdHMgb25seSBzYW1wbGVzIHdpdGhcbiAgICAvLyBvd25lck5hbWUgZXF1YWwgdG8gdGhlIGdpdmVuIG93bmVyTmFtZS5cbiAgICB8IHsga2luZDogXCJvd25lck5hbWVcIjsgb3duZXJOYW1lOiBzdHJpbmcgfVxuICAgIC8vIGEgZmlsdGVyIHdpdGgga2luZCBldmVudFR5cGUgcGVybWl0cyBvbmx5IHNhbXBsZXMgb2YgdGhlIGdpdmVuXG4gICAgLy8gZXZlbnRUeXBlLlxuICAgIHwgeyBraW5kOiBcImV2ZW50VHlwZVwiOyBldmVudFR5cGU6IFwic3RhcnRcIiB8IFwiZW5kXCIgfCBcIm1lYXN1cmVcIiB9XG5cbi8qKlxuICogU3RvcmVzIGEgYm91bmRlZC1zaXplIGJ1ZmZlciBvZiBwZXJmb3JtYW5jZSBlbnRyaWVzIGFuZCBwcm92aWRlc1xuICogY29udmVuaWVuY2UgZnVuY3Rpb25zIGZvciBhY2Nlc3Npbmcgc3Vic2V0cyBvZiB0aGUgYnVmZmVyLiBWZXJ5XG4gKiBzaW1wbGUgY2lyY3VsYXIgYnVmZmVyLlxuICovXG5leHBvcnQgY2xhc3MgU3RhdHNMb2dnZXIge1xuICAgIC8vIFRPRE86IENvbnNpZGVyIG1hcHBpbmcgZWFjaCBuYW1lIHRvIGEgc3ltYm9sIGFuZCBzdG9yaW5nIHRoZVxuICAgIC8vIG1hcHBlZCBzeW1ib2wgaW5zdGVhZCBvZiB0aGUgbmFtZSBzbyB3ZSdyZSBzdG9yaW5nIG1vcmUgbGlrZSA1MFxuICAgIC8vIGJ5dGVzIHBlciBzYW1wbGUgaW5zdGVhZCBvZiAxMzAgQF9AXG4gICAgcHVibGljIGJ1ZmZlcjogUGVyZm9ybWFuY2VFbnRyeVtdID0gW11cbiAgICBwcml2YXRlIGlkeDogbnVtYmVyID0gMFxuICAgIHByaXZhdGUgYnVmZmVyc2l6ZTogbnVtYmVyID0gMTAwMDBcbiAgICBwcml2YXRlIGxhc3RFcnJvcjogbnVtYmVyID0gMFxuXG4gICAgLyoqXG4gICAgICogVGFyZ2V0IGZvciByZWNlaXZpbmcgc3RhdHMgZW50cmllcyBmcm9tIG90aGVyIHRocmVhZHMgLSB0aGVyZVxuICAgICAqIHdhcyBzb21lIGlzc3VlIHdpdGggZW5jb2RpbmcgdGhhdCBJIGNvdWxkbid0IGZpZ3VyZSBvdXQgc28gSVxuICAgICAqIGp1c3Qga2x1ZGdlZCBpdC5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVjZWl2ZVN0YXRzSnNvbihlbnRyaWVzSnNvbjogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMucHVzaExpc3QoSlNPTi5wYXJzZShlbnRyaWVzSnNvbikgYXMgUGVyZm9ybWFuY2VFbnRyeVtdKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZ2VzdHMgdGhlIGdpdmVuIHBlcmZvcm1hbmNlIGVudHJpZXMgaW50byB0aGUgYnVmZmVyLlxuICAgICAqL1xuICAgIHB1YmxpYyBwdXNoTGlzdChlbnRyaWVzOiBQZXJmb3JtYW5jZUVudHJ5W10pIHtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hFbnRyeShlbnRyeSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb25seSBlbnRyaWVzIHRoYXQgbWF0Y2ggX2FsbF8gb2YgdGhlIGdpdmVuIGZpbHRlclxuICAgICAqIGNvbmZpZ3MuXG4gICAgICovXG4gICAgcHVibGljIGdldEVudHJpZXMoLi4uZmlsdGVyQ29uZmlnczogU3RhdHNGaWx0ZXJDb25maWdbXSkge1xuICAgICAgICAvLyBFeHBsaWNpdCBzdHJlYW0gZnVzaW9uLCB3aGVlZWVlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZWxsLCBzb3J0IG9mLiBXZSdyZSBub3QgZnVzaW5nIGFsbCB0aGUgd2F5IHVwIHRvIHRoZSByZWdleFxuICAgICAgICAvLyBtYXRjaCwgc28gdGhhdCdzIGEgdG9uIG9mIGR1cGxpY2F0ZWQgd29yay4gTm90IHRoYXQgaXRcbiAgICAgICAgLy8gbWF0dGVycywgc2luY2UgdGhpcyBzaG91bGQgb25seSBldmVyIGJlIGludm9rZWQgd2hlbiBhXG4gICAgICAgIC8vIGRldmVsb3BlciBhc2tzIGZvciBkYXRhLlxuICAgICAgICBjb25zdCBmaWx0ZXJzOiBTdGF0c0ZpbHRlcltdID0gZmlsdGVyQ29uZmlncy5tYXAoXG4gICAgICAgICAgICBmYyA9PiBuZXcgU3RhdHNGaWx0ZXIoZmMpLFxuICAgICAgICApXG4gICAgICAgIGNvbnN0IGZpbHRlckZ1bjogKGlucHV0OiBQZXJmb3JtYW5jZUVudHJ5KSA9PiBib29sZWFuID0gZSA9PlxuICAgICAgICAgICAgZmlsdGVycy5ldmVyeShmID0+IGYubWF0Y2hlcyhlKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmZpbHRlcihmaWx0ZXJGdW4pXG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVCdWZmZXJzaXplKCkge1xuICAgICAgICAvLyBDaGFuZ2luZyB0aGUgYnVmZmVyIGxlbmd0aCB3aGlsZSB0aGlzIGlzIHJ1bm5pbmcgd2lsbFxuICAgICAgICAvLyBwcm9iYWJseSByZXN1bHQgaW4gd2VpcmRuZXNzLCBidXQgdGhhdCBzaG91bGRuJ3QgYmUgYSBtYWpvclxuICAgICAgICAvLyBpc3N1ZSAtIGl0J3Mgbm90IGxpa2Ugd2UgbmVlZCB0aGVzZSB0byBiZSBpbiBvcmRlciBvclxuICAgICAgICAvLyBvdGhlcndpc2UgY29oZXJlbnQsIHdlJ3JlIGp1c3QgdHJ5aW5nIHRvIHN0b3JlIGEgYmlnIHBpbGVcbiAgICAgICAgLy8gb2YgcmVjZW50LWlzaCBzYW1wbGVzLlxuICAgICAgICBjb25zdCBwZXJmc2FtcGxlcyA9IE51bWJlcihjb25maWcuZ2V0KFwicGVyZnNhbXBsZXNcIikpXG4gICAgICAgIC8vIENoZWNrIGZvciBOYU4gb3Igbm9uLWludGVnZXJcbiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIocGVyZnNhbXBsZXMpKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcnNpemUgPSBwZXJmc2FtcGxlc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBjb3VsZCBiZSBjYWxsZWQgYSBodW5kcmVkIHRpbWVzIGEgc2Vjb25kXG4gICAgICAgICAgICAvLyBhbmQgd291bGQgZXJyb3Igb3V0IGV2ZXJ5IHNpbmdsZSB0aW1lIGlmIHNvbWVvbmUgaGFzXG4gICAgICAgICAgICAvLyBnaXZlbiBhbiBpbnZhbGlkIGNvbmZpZywgc28gcmF0ZS1saW1pdCB0aGUgZXJyb3IgbG9nIC1cbiAgICAgICAgICAgIC8vIG9uZSBldmVyeSBmaXZlIHNlY29uZHMuXG4gICAgICAgICAgICBpZiAocGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLmxhc3RFcnJvciA+IDUwMDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RFcnJvciA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcInBlcmZzYW1wbGVzIG11c3QgYmUgYW4gaW50ZWdlciwgaXMgJU9cIixcbiAgICAgICAgICAgICAgICAgICAgcGVyZnNhbXBsZXMsXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwdXNoRW50cnkoZW50cnk6IFBlcmZvcm1hbmNlRW50cnkpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgICAgICAgXCJQdXNoaW5nIHBlcmZvcm1hbmNlIGVudHJ5ICVvIGludG8gcGVyZm9ybWFuY2UgY291bnRlcnNcIixcbiAgICAgICAgICAgIGVudHJ5LFxuICAgICAgICApXG5cbiAgICAgICAgLy8gRHJvcCBzYW1wbGVzIHRoYXQgYXJlbid0IGZvciB0cmlkYWN0eWwsIHNpbmNlIHBlcmZvcm1hbmNlXG4gICAgICAgIC8vIGV2ZW50cyBhcmUgZ2xvYmFsIGFuZCB0aGVyZSBhcmUgc29tZSBiYWRseS1iZWhhdmVkXG4gICAgICAgIC8vIGxpYnJhcmllcyBzcGFtbWluZyB0aGVtIGFsbCBvdmVyIG91ciBvd24gZGF0YS5cbiAgICAgICAgaWYgKCFlbnRyeS5uYW1lLnN0YXJ0c1dpdGgoVFJJX1BFUkZPUk1BTkNFX05BTUVfUFJFRklYKSkgcmV0dXJuXG5cbiAgICAgICAgLy8gV2UgZGVwZW5kIG9uIGFycmF5cyBhdXRvLXZpdmlmeWluZyB3aGVuIGVsZW1lbnRzIHBhc3QgdGhlXG4gICAgICAgIC8vIGVuZCBhcmUgc2V0IHRvIG1ha2UgdGhpcyBlYXN5LlxuICAgICAgICB0aGlzLmJ1ZmZlclt0aGlzLmlkeF0gPSBlbnRyeVxuICAgICAgICB0aGlzLmluY3JlbWVudElkeCgpXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbmNyZW1lbnRJZHgoKSB7XG4gICAgICAgIHRoaXMuaWR4ID0gKHRoaXMuaWR4ICsgMSkgJSB0aGlzLmJ1ZmZlcnNpemVcbiAgICB9XG5cbn1cblxuLyoqXG4gKiBQcmV0dHktcHJpbnRzIGEgcGlsZSBvZiBwZXJmb3JtYW5jZSBzYW1wbGVzIG9mIHR5cGUgbWVhc3VyZSAob3RoZXJzXG4gKiB3b24ndCB3b3JrIGJlY2F1c2UgdGhleSBoYXZlIGR1cmF0aW9uIHplcm8gb3IgdW5kZWZpbmVkKSBhcyBhXG4gKiBob3Jpem9udGFsIEFTQ0lJIGhpc3RvZ3JhbS4gVXNlZnVsIGlmIHlvdSBqdXN0IHdhbnQgYmFzaWNcbiAqIHN0YXRpc3RpY3MgYWJvdXQgcGVyZm9ybWFuY2UgYW5kIGRvbid0IHdhbnQgdG8gc3BlbmQgYSBidW5jaCBvZlxuICogdGltZSBtdWNraW5nIGFib3V0IGluIHB5dGhvbiBvciBqdWxpYS5cbiAqXG4gKiBBIHZlcnkgc21hbGwgZXhhbXBsZSBvZiB3aGF0IHlvdSdsbCBnZXQ6XG4gKlxuICogICAwICAgICAjIyMjXG4gKiAgIDEyNSAgICMjIyMjIyMjIyNcbiAqICAgMjUwICAgIyMjIyMjIyMjIyMjIyMjXG4gKiAgIDM3NSAgICMjIyMjI1xuICogICA1MDAgICAjI1xuICpcbiAqIEBwYXJhbSBzYW1wbGVzIEEgc2V0IG9mIHNhbXBsZXMgdG8gcGxvdC5cbiAqIEBwYXJhbSBidWNrZXRzIFRoZSBudW1iZXIgb2YgYmlucyB0byBkaXZpZGUgdGhlIHNhbXBsZXMgaW50by5cbiAqIEBwYXJhbSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIGNoYXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyU3RhdHNIaXN0b2dyYW0oXG4gICAgc2FtcGxlczogUGVyZm9ybWFuY2VFbnRyeVtdLFxuICAgIGJ1Y2tldHM6IG51bWJlciA9IDE1LFxuICAgIHdpZHRoOiBudW1iZXIgPSA4MCxcbik6IHN0cmluZyB7XG4gICAgY29uc3QgZHVyczogbnVtYmVyW10gPSBzYW1wbGVzLm1hcChzYW1wbGUgPT4gc2FtcGxlLmR1cmF0aW9uKVxuXG4gICAgY29uc3QgbWluID0gZHVycy5yZWR1Y2UoKGEsIGIpID0+IE1hdGgubWluKGEsIGIpKVxuICAgIGNvbnN0IG1heCA9IGR1cnMucmVkdWNlKChhLCBiKSA9PiBNYXRoLm1heChhLCBiKSlcblxuICAgIGNvbnN0IGJ1Y2tldHZhbHM6IG51bWJlcltdID0gbWF0aC5saW5zcGFjZShtaW4sIG1heCwgYnVja2V0cylcblxuICAgIGNvbnN0IGJ1Y2tldGVkOiBNYXA8bnVtYmVyLCBudW1iZXI+ID0gbWF0aC5idWNrZXRpemUoZHVycywgYnVja2V0dmFscylcbiAgICBjb25zdCBtYXhjb3VudDogbnVtYmVyID0gQXJyYXkuZnJvbShidWNrZXRlZC52YWx1ZXMoKSkucmVkdWNlKFxuICAgICAgICAoYSwgYikgPT4gTWF0aC5tYXgoYSwgYiksXG4gICAgICAgIDAsXG4gICAgKVxuXG4gICAgY29uc3QgbGFiZWx3aWR0aCA9IDIwXG4gICAgY29uc3QgYmFyd2lkdGggPSB3aWR0aCAtIGxhYmVsd2lkdGhcbiAgICBjb25zdCB0b2JhcndpZHRoID0gbiA9PiAoYmFyd2lkdGggKiBuKSAvIG1heGNvdW50XG5cbiAgICBjb25zdCByZXN1bHQgPSBbXVxuICAgIGZvciAoY29uc3QgW2J1Y2tldHZhbCwgYnVja2V0Y291bnRdIG9mIGJ1Y2tldGVkLmVudHJpZXMoKSkge1xuICAgICAgICBjb25zdCBiYXIgPSBcIiNcIi5yZXBlYXQodG9iYXJ3aWR0aChidWNrZXRjb3VudCkpXG4gICAgICAgIGNvbnN0IGxhYmVsID0gYnVja2V0dmFsLnRvU3RyaW5nKCkucGFkRW5kKGxhYmVsd2lkdGgpXG4gICAgICAgIHJlc3VsdC5wdXNoKGxhYmVsICsgYmFyKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCJcXG5cIilcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGZpbHRlcmluZyBvZiBwZXJmb3JtYW5jZSBlbnRyaWVzIHVzaW5nIHRoZVxuICogU3RhdHNGaWx0ZXJDb25maWcuIEV4cG9zZWQgc28gdXNlcnMgb2YgdGhlIGxpYnJhcnkgY2FuIGRvIG1vcmVcbiAqIGZpbHRlcmluZyB0aGVtc2VsdmVzIGlmIHRoZXkgd2FudCB0by5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0YXRzRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGNvbmZpZzogU3RhdHNGaWx0ZXJDb25maWcpIHt9XG5cbiAgICBtYXRjaGVzKGVudHJ5OiBQZXJmb3JtYW5jZUVudHJ5KTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IG1ldHJpY05hbWVJbmZvID0gZXh0cmFjdE1ldHJpY05hbWUoZW50cnkubmFtZSlcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5jb25maWcua2luZCA9PT0gXCJmdW5jdGlvbk5hbWVcIiAmJlxuICAgICAgICAgICAgdGhpcy5jb25maWcuZnVuY3Rpb25OYW1lICE9PSBtZXRyaWNOYW1lSW5mby5mdW5jdGlvbk5hbWVcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5raW5kID09PSBcIm93bmVyTmFtZVwiICYmXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5vd25lck5hbWUgIT09IG1ldHJpY05hbWVJbmZvLm93bmVyTmFtZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmtpbmQgPT09IFwiZXZlbnRUeXBlXCIgJiZcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmV2ZW50VHlwZSAhPT0gZW50cnkuZW50cnlUeXBlXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG59XG5cbmNvbnN0IFRSSV9QRVJGT1JNQU5DRV9OQU1FX1BSRUZJWDogc3RyaW5nID0gXCJ0cmlcIlxuXG5mdW5jdGlvbiBwZXJmb3JtYW5jZUFwaUF2YWlsYWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcGVyZm9ybWFuY2UubWFyayAhPT0gdW5kZWZpbmVkXG59XG5cbmludGVyZmFjZSBNZXRyaWNOYW1lSW5mbyB7XG4gICAgb3duZXJOYW1lOiBzdHJpbmdcbiAgICBmdW5jdGlvbk5hbWU6IHN0cmluZ1xuICAgIHVuaXF1ZVN1ZmZpeDogc3RyaW5nXG59XG5cbmNvbnN0IGV4dHJhY3RSZWdFeHAgPSBuZXcgUmVnRXhwKFxuICAgIGBeJHtUUklfUEVSRk9STUFOQ0VfTkFNRV9QUkVGSVh9YCArXG4gICAgICAgIC8vIG93bmVyIG5hbWVcbiAgICAgICAgYC8oW14vXSspYCArXG4gICAgICAgIC8vIGZ1bmN0aW9uIG5hbWVcbiAgICAgICAgYC8oW146XSspYCArXG4gICAgICAgIC8vIHVuaXF1ZSBzdWZmaXhcbiAgICAgICAgYDooW146XSspYCxcbiAgICAvLyBObyBuZWVkIHRvIGhhbmRsZSA6c3RhcnQvOmVuZFxuICAgIC8vIGJlY2F1c2Ugd2UgY2FuIGdldCB0aGF0IGZyb20gdGhlXG4gICAgLy8gc2FtcGxlIGl0c2VsZi5cbilcbmZ1bmN0aW9uIGV4dHJhY3RNZXRyaWNOYW1lKGNvdW50ZXJOYW1lOiBzdHJpbmcpOiBNZXRyaWNOYW1lSW5mbyB7XG4gICAgY29uc3QgbWF0Y2hyZXN1bHQgPSBjb3VudGVyTmFtZS5tYXRjaChleHRyYWN0UmVnRXhwKVxuICAgIGlmICghbWF0Y2hyZXN1bHQpIHJldHVyblxuICAgIGNvbnN0IFtvd25lck5hbWUsIGZ1bmN0aW9uTmFtZSwgdW5pcXVlU3VmZml4XSA9IG1hdGNocmVzdWx0LnNsaWNlKDEpXG5cbiAgICByZXR1cm4ge1xuICAgICAgICBvd25lck5hbWUsXG4gICAgICAgIGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgdW5pcXVlU3VmZml4LFxuICAgIH1cbn1cblxuY2xhc3MgTWV0cmljTmFtZSB7XG4gICAgcHVibGljIHJlYWRvbmx5IGZ1bGxOYW1lOiBzdHJpbmdcbiAgICBwdWJsaWMgcmVhZG9ubHkgc3RhcnROYW1lOiBzdHJpbmdcbiAgICBwdWJsaWMgcmVhZG9ubHkgZW5kTmFtZTogc3RyaW5nXG5cbiAgICBjb25zdHJ1Y3Rvcihvd25lck5hbWU6IHN0cmluZywgZnVuY3Rpb25OYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgdW5pcXVlU3VmZml4ID0gTWF0aC5mbG9vcihcbiAgICAgICAgICAgIE1hdGgucmFuZG9tKCkgKiBNYXRoLmZsb29yKDFlNiksXG4gICAgICAgICkudG9TdHJpbmcoKVxuXG4gICAgICAgIHRoaXMuZnVsbE5hbWUgPSBgJHtUUklfUEVSRk9STUFOQ0VfTkFNRV9QUkVGSVh9LyR7b3duZXJOYW1lfS8ke2Z1bmN0aW9uTmFtZX06JHt1bmlxdWVTdWZmaXh9YFxuICAgICAgICB0aGlzLnN0YXJ0TmFtZSA9IGAke3RoaXMuZnVsbE5hbWV9OnN0YXJ0YFxuICAgICAgICB0aGlzLmVuZE5hbWUgPSBgJHt0aGlzLmZ1bGxOYW1lfTplbmRgXG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZW5kU3RhdHMobGlzdDogUGVyZm9ybWFuY2VFbnRyeUxpc3QpIHtcbiAgICBtZXNzYWdpbmcubWVzc2FnZShcInBlcmZvcm1hbmNlX2JhY2tncm91bmRcIiwgXCJyZWNlaXZlU3RhdHNKc29uXCIsIFtcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkobGlzdCksXG4gICAgXSlcbn1cbiIsIi8qKiBUcmlkYWN0eWwgc2hhcmVkIHN0YXRlXG5cbiAgICBBbnkgY29udGV4dCB3aXRoIGFjY2VzcyB0byBicm93c2VyLnN0b3JhZ2UgY2FuIHNhZmVseSBpbXBvcnQgdGhpcyBmaWxlIGFuZFxuICAgIGdldCBhIHNlbGYtdXBkYXRpbmcgY29uc2lzdGVudCBjb3B5IG9mIHRoZSBzaGFyZWQgcHJvZ3JhbSBzdGF0ZS5cblxuICAgIEFueSBjb250ZXh0IG1heSBtb2RpZnkgdGhlaXIgY29weSBvZiB0aGUgc3RhdGUgYW5kIHRoYXQgbW9kaWZpY2F0aW9uIHdpbGxcbiAgICBiZSBwcm9wYWdhdGVkIHRvIHRoZSByZXN0IG9mIHRoZSBwcm9ncmFtLlxuXG4gICAgVGhpcyB3b3JrcyBieSBwcm94eWluZyB0aGUgc3RhdGUgb2JqZWN0IHN1Y2ggdGhhdCBzZXR0aW5nIGFueSBwcm9wZXJ0eVxuICAgIGNhdXNlcyB0aGUgZW50aXJlIHN0YXRlIHRvIGJlIHNhdmVkIHRvIHN0b3JhZ2UgYW5kIGFkZGluZyBhIGxpc3RlbmVyIHRoYXRcbiAgICBsaXN0ZW5zIGZvciBzdG9yYWdlIGV2ZW50cyBhbmQgdXBkYXRlcyB0aGUgcHJveGllZCBvYmplY3Qgb24gZWFjaCBzdG9yYWdlXG4gICAgZXZlbnQuXG5cbiAgICBJZiB0aGlzIHR1cm5zIG91dCB0byBiZSBleHBlbnNpdmUgdGhlcmUgYXJlIGltcHJvdmVtZW50cyBhdmFpbGFibGUuXG4qL1xuXG5pbXBvcnQgTG9nZ2VyIGZyb20gXCJAc3JjL2xpYi9sb2dnaW5nXCJcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoXCJzdGF0ZVwiKVxuXG5jbGFzcyBTdGF0ZSB7XG4gICAgbGFzdFNlYXJjaFF1ZXJ5OiBzdHJpbmcgPSB1bmRlZmluZWRcbiAgICBjbWRIaXN0b3J5OiBzdHJpbmdbXSA9IFtdXG4gICAgcHJldklucHV0czogQXJyYXk8eyBpbnB1dElkOiBzdHJpbmc7IHRhYjogbnVtYmVyOyBqdW1wcG9zPzogbnVtYmVyIH0+ID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICBpbnB1dElkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0YWI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGp1bXBwb3M6IHVuZGVmaW5lZCxcbiAgICAgICAgfSxcbiAgICBdXG59XG5cbi8vIERvbid0IGNoYW5nZSB0aGVzZSBmcm9tIGNvbnN0IG9yIHlvdSByaXNrIGJyZWFraW5nIHRoZSBQcm94eSBiZWxvdy5cbmNvbnN0IGRlZmF1bHRzID0gT2JqZWN0LmZyZWV6ZShuZXcgU3RhdGUoKSlcblxuY29uc3Qgb3ZlcmxheSA9IHt9IGFzIFN0YXRlXG5icm93c2VyLnN0b3JhZ2UubG9jYWxcbiAgICAuZ2V0KFwic3RhdGVcIilcbiAgICAudGhlbihyZXMgPT4ge1xuICAgICAgICBpZiAoXCJzdGF0ZVwiIGluIHJlcykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiTG9hZGVkIGluaXRpYWwgc3RhdGU6XCIsIHJlcy5zdGF0ZSlcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3ZlcmxheSwgcmVzLnN0YXRlKVxuICAgICAgICB9XG4gICAgfSlcbiAgICAuY2F0Y2goKC4uLmFyZ3MpID0+IGxvZ2dlci5lcnJvciguLi5hcmdzKSlcblxuY29uc3Qgc3RhdGUgPSAobmV3IFByb3h5KG92ZXJsYXksIHtcbiAgICAvKiogR2l2ZSBkZWZhdWx0cyBpZiBvdmVybGF5IGRvZXNuJ3QgaGF2ZSB0aGUga2V5ICovXG4gICAgZ2V0KHRhcmdldCwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5IGluIHRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0c1twcm9wZXJ0eV1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiogUGVyc2lzdCBzZXRzIHRvIHN0b3JhZ2UgaW1tZWRpYXRlbHkgKi9cbiAgICBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiU3RhdGUgY2hhbmdlZCFcIiwgcHJvcGVydHksIHZhbHVlKVxuICAgICAgICB0YXJnZXRbcHJvcGVydHldID0gdmFsdWVcbiAgICAgICAgYnJvd3Nlci5zdG9yYWdlLmxvY2FsLnNldCh7IHN0YXRlOiB0YXJnZXQgfSBhcyBhbnkpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfSxcbn0pKVxuXG5icm93c2VyLnN0b3JhZ2Uub25DaGFuZ2VkLmFkZExpc3RlbmVyKChjaGFuZ2VzLCBhcmVhbmFtZSkgPT4ge1xuICAgIGlmIChhcmVhbmFtZSA9PT0gXCJsb2NhbFwiICYmIFwic3RhdGVcIiBpbiBjaGFuZ2VzKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ob3ZlcmxheSwgY2hhbmdlcy5zdGF0ZS5uZXdWYWx1ZSlcbiAgICB9XG59KVxuXG5leHBvcnQgeyBzdGF0ZSBhcyBkZWZhdWx0IH1cbiJdLCJzb3VyY2VSb290IjoiIn0=